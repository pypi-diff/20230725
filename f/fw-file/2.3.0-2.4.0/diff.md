# Comparing `tmp/fw_file-2.3.0-py3-none-any.whl.zip` & `tmp/fw_file-2.4.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,33 +1,38 @@
-Zip file size: 211560 bytes, number of entries: 31
+Zip file size: 358219 bytes, number of entries: 36
 -rw-r--r--  2.0 unx      229 b- defN 80-Jan-01 00:00 fw_file/__init__.py
 -rw-r--r--  2.0 unx     8377 b- defN 80-Jan-01 00:00 fw_file/base.py
 -rw-r--r--  2.0 unx     3184 b- defN 80-Jan-01 00:00 fw_file/bruker.py
 -rw-r--r--  2.0 unx     1515 b- defN 80-Jan-01 00:00 fw_file/dicom/__init__.py
--rw-r--r--  2.0 unx     4912 b- defN 80-Jan-01 00:00 fw_file/dicom/config.py
+-rw-r--r--  2.0 unx     6011 b- defN 80-Jan-01 00:00 fw_file/dicom/config.py
 -rw-r--r--  2.0 unx    44285 b- defN 80-Jan-01 00:00 fw_file/dicom/dcmdict.py
--rw-r--r--  2.0 unx    17527 b- defN 80-Jan-01 00:00 fw_file/dicom/dicom.py
--rw-r--r--  2.0 unx    18392 b- defN 80-Jan-01 00:00 fw_file/dicom/fixers.py
--rw-r--r--  2.0 unx    17330 b- defN 80-Jan-01 00:00 fw_file/dicom/reader.py
--rw-r--r--  2.0 unx    27641 b- defN 80-Jan-01 00:00 fw_file/dicom/series.py
+-rw-r--r--  2.0 unx    17633 b- defN 80-Jan-01 00:00 fw_file/dicom/dicom.py
+-rw-r--r--  2.0 unx    18949 b- defN 80-Jan-01 00:00 fw_file/dicom/fixers.py
+-rw-r--r--  2.0 unx    17415 b- defN 80-Jan-01 00:00 fw_file/dicom/reader.py
+-rw-r--r--  2.0 unx    27658 b- defN 80-Jan-01 00:00 fw_file/dicom/series.py
 -rw-r--r--  2.0 unx   421033 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/2023b/json/dict_info.json
 -rw-r--r--  2.0 unx   188832 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/2023b/json/iod_info.json
 -rw-r--r--  2.0 unx   528709 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/2023b/json/module_info.json
 -rw-r--r--  2.0 unx    31221 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/2023b/json/uid_info.json
 -rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/2023b/json/version
--rw-r--r--  2.0 unx      345 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/editions.json
+-rw-r--r--  2.0 unx   422965 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/2023c/json/dict_info.json
+-rw-r--r--  2.0 unx   191779 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/2023c/json/iod_info.json
+-rw-r--r--  2.0 unx   531128 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/2023c/json/module_info.json
+-rw-r--r--  2.0 unx    31351 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/2023c/json/uid_info.json
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/2023c/json/version
+-rw-r--r--  2.0 unx      353 b- defN 80-Jan-01 00:00 fw_file/dicom/standard/editions.json
 -rw-r--r--  2.0 unx     9047 b- defN 80-Jan-01 00:00 fw_file/dicom/utils.py
--rw-r--r--  2.0 unx     6620 b- defN 80-Jan-01 00:00 fw_file/dicom/validation.py
+-rw-r--r--  2.0 unx     6880 b- defN 80-Jan-01 00:00 fw_file/dicom/validation.py
 -rw-r--r--  2.0 unx     3103 b- defN 80-Jan-01 00:00 fw_file/exif.py
 -rw-r--r--  2.0 unx    12581 b- defN 80-Jan-01 00:00 fw_file/ge.py
 -rw-r--r--  2.0 unx      778 b- defN 80-Jan-01 00:00 fw_file/jpg.py
 -rw-r--r--  2.0 unx     2186 b- defN 80-Jan-01 00:00 fw_file/json.py
 -rw-r--r--  2.0 unx     1440 b- defN 80-Jan-01 00:00 fw_file/nifti.py
 -rw-r--r--  2.0 unx     5265 b- defN 80-Jan-01 00:00 fw_file/philips.py
 -rw-r--r--  2.0 unx     8385 b- defN 80-Jan-01 00:00 fw_file/png.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 fw_file/py.typed
 -rw-r--r--  2.0 unx    10521 b- defN 80-Jan-01 00:00 fw_file/siemens.py
--rw-r--r--  2.0 unx     1078 b- defN 80-Jan-01 00:00 fw_file-2.3.0.dist-info/LICENSE
--rw-r--r--  2.0 unx     8486 b- defN 80-Jan-01 00:00 fw_file-2.3.0.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 fw_file-2.3.0.dist-info/WHEEL
-?rw-r--r--  2.0 unx     2509 b- defN 16-Jan-01 00:00 fw_file-2.3.0.dist-info/RECORD
-31 files, 1385624 bytes uncompressed, 207596 bytes compressed:  85.0%
+-rw-r--r--  2.0 unx     1078 b- defN 80-Jan-01 00:00 fw_file-2.4.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     9569 b- defN 80-Jan-01 00:00 fw_file-2.4.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 fw_file-2.4.0.dist-info/WHEEL
+?rw-r--r--  2.0 unx     3031 b- defN 16-Jan-01 00:00 fw_file-2.4.0.dist-info/RECORD
+36 files, 2566589 bytes uncompressed, 353409 bytes compressed:  86.3%
```

## zipnote {}

```diff
@@ -39,14 +39,29 @@
 
 Filename: fw_file/dicom/standard/2023b/json/uid_info.json
 Comment: 
 
 Filename: fw_file/dicom/standard/2023b/json/version
 Comment: 
 
+Filename: fw_file/dicom/standard/2023c/json/dict_info.json
+Comment: 
+
+Filename: fw_file/dicom/standard/2023c/json/iod_info.json
+Comment: 
+
+Filename: fw_file/dicom/standard/2023c/json/module_info.json
+Comment: 
+
+Filename: fw_file/dicom/standard/2023c/json/uid_info.json
+Comment: 
+
+Filename: fw_file/dicom/standard/2023c/json/version
+Comment: 
+
 Filename: fw_file/dicom/standard/editions.json
 Comment: 
 
 Filename: fw_file/dicom/utils.py
 Comment: 
 
 Filename: fw_file/dicom/validation.py
@@ -75,20 +90,20 @@
 
 Filename: fw_file/py.typed
 Comment: 
 
 Filename: fw_file/siemens.py
 Comment: 
 
-Filename: fw_file-2.3.0.dist-info/LICENSE
+Filename: fw_file-2.4.0.dist-info/LICENSE
 Comment: 
 
-Filename: fw_file-2.3.0.dist-info/METADATA
+Filename: fw_file-2.4.0.dist-info/METADATA
 Comment: 
 
-Filename: fw_file-2.3.0.dist-info/WHEEL
+Filename: fw_file-2.4.0.dist-info/WHEEL
 Comment: 
 
-Filename: fw_file-2.3.0.dist-info/RECORD
+Filename: fw_file-2.4.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## fw_file/dicom/config.py

```diff
@@ -2,14 +2,15 @@
 import functools
 import importlib
 import re
 import typing as t
 from pathlib import Path
 
 from pydantic import BaseSettings, validator
+from pydicom import config as pydicom_config
 
 from .. import __version__
 
 __all__ = [
     "get_config",
     "IMPLEMENTATION_CLASS_UID",
     "IMPLEMENTATION_VERSION_NAME",
@@ -58,17 +59,48 @@
         env_prefix = "FW_DCM_"
 
     # data element loader / fixer config
     fix_VR_mismatch: bool = False
     fix_VR_mismatch_with_VRs: t.List[str] = ["PN", "DS", "IS"]
     track: bool = False
 
+    # pydicom.config values
+    # 0==IGNORE, 1==WARN, 2==RAISE
+    reading_validation_mode: int = 1
+    writing_validation_mode: int = 1
+
+    @validator("reading_validation_mode")
+    def sync_rvm(cls, value) -> int:
+        """Syncs pydicom_config when config is changed."""
+        pydicom_config.settings.reading_validation_mode = value
+        return value
+
+    @validator("writing_validation_mode")
+    def sync_wvm(cls, value) -> int:
+        """Syncs pydicom_config when config is changed."""
+        pydicom_config.settings.writing_validation_mode = value
+        return value
+
+    # read-only mode
+    read_only: bool = False
+
     # dicom standard
     standard_path: Path = Path(__file__).parent / "standard"
-    standard_rev: str = "2023b"
+    standard_rev: str = "2023c"
+
+    # If standard_rev is changed after get_standard has been
+    # called, the cache needs to be cleared, otherwise it may
+    # try to use the previously cached standard.
+    @validator("standard_rev")
+    def clear_on_rev_change(cls, value) -> str:
+        """Clears get_standard cache on standard_rev change."""
+        from .validation import get_standard
+
+        get_standard.cache_clear()
+        return value
 
     # List of raw data element fixer functions
     raw_elem_fixers: t.List[t.Union[str, t.Callable]] = [
         "fw_file.dicom.fixers.tag_specific_fixer",
         "fw_file.dicom.fixers.apply_dictionary_VR",
         "fw_file.dicom.fixers.replace_backslash_in_VM1_str",
         "fw_file.dicom.fixers.convert_exception_fixer",
```

## fw_file/dicom/dicom.py

```diff
@@ -140,14 +140,16 @@
 
     def save(
         self,
         file: AnyFile = None,
         write_like_original: bool = True,
     ) -> None:
         """Save the dataset to the specified file (default to the original)."""
+        if get_config().read_only:
+            raise TypeError(f"{self.__class__.__name__} is read-only")
         bytesio = io.BytesIO()
         self.update_orig_attrs()
         self.dataset.save_as(bytesio, write_like_original=write_like_original)
         with self.open_dst(file) as wfile:
             wfile.write(bytesio.getvalue())
 
     def update_orig_attrs(self):
```

## fw_file/dicom/fixers.py

```diff
@@ -16,14 +16,15 @@
     MAX_VALUE_LEN,
     TEXT_VR_DELIMS,
     DSclass,
     format_number_as_ds,
 )
 from pydicom.values import convert_value, validate_value
 
+from .config import get_config
 from .utils import generate_uid
 
 log = logging.getLogger(__name__)
 
 
 private_vr_for_tag = pydicom_dataelem._private_vr_for_tag
 LUT_DESCRIPTOR_TAGS = pydicom_dataelem._LUT_DESCRIPTOR_TAGS
@@ -190,16 +191,21 @@
         # DA converter called in convert_value:
         # https://github.com/pydicom/pydicom/blob/v2.2.2/pydicom/values.py#L170
         #
         # DA VR class instantiated:
         # https://github.com/pydicom/pydicom/blob/v2.2.2/pydicom/dataelem.py#L543
 
         value = convert_value(VR, raw, encoding)
-        DataElement(raw.tag, VR, value, validation_mode=2)
-    except (ValueError, OverflowError):
+        DataElement(
+            raw.tag,
+            VR,
+            value,
+            validation_mode=pydicom_config.settings.reading_validation_mode,
+        )
+    except (ValueError, OverflowError, TypeError):
         # Only attempt to apply dictionary VR for a private tag if initial value
         # conversion didn't work. Private tag dictionary VRs don't seem to
         # always be accurate, and in fact there is nothing stopping
         # manufacturers from changing their internal "VR" for this field. So we
         # should only rely on the dictionary as a last resort to give us a hint
         # what the field should be if we can't decode it at first
         if raw.tag.is_private:
@@ -220,24 +226,35 @@
         # attempt to fix it.
         fixed_val = fix_invalid_VR_value(VR, raw, encoding=encoding, dataset=dataset)
         try:
             # Avoid calling TrackedRawDataElement._replace here since we
             # don't want this value change tracked
             fixed_raw_elem = RawDataElement._replace(raw, value=fixed_val)
             value = convert_value(VR, fixed_raw_elem, encoding)
-            DataElement(raw.tag, VR, fixed_val, validation_mode=2)
+            DataElement(
+                raw.tag,
+                VR,
+                fixed_val,
+                validation_mode=pydicom_config.settings.reading_validation_mode,
+            )
             # Replace value if fixed.
             if fixed_val != raw.value:
                 # NOTE: Can't think of a case where this wouldn't be true.
                 if len(fixed_val or b"") != len(raw.value or b""):
                     raw = raw._replace(length=len(fixed_val or b""))
                 raw = raw._replace(value=fixed_val)
         except ValueError:
-            # If we still get an error after using fixed value, bail.
-            return empty()
+            if get_config().read_only:
+                # In read-only mode, invalid values are saved with VR=OB
+                # as a last resort instead of removing the value.
+                raw = raw._replace(VR="OB")
+            else:
+                # In normal RW mode,
+                # If we still get an error after using fixed value, bail.
+                return empty()
         return convert_exception_fixer(raw, encoding, dataset)
     except Exception:
         log.exception("Unhandled exception.", exc_info=True)
         # Any other unforeseen exception in conversion
         return empty()
     return raw
```

## fw_file/dicom/reader.py

```diff
@@ -39,16 +39,14 @@
     This implementation separates the existing (as of pydicom 2.2.x)
     DataElement_from_raw into unit functions which are called in order.
 
     All these functions are accessible and configurable as user functions.
     FW File provides sensible defaults for these functions.
     """
     config = get_config()
-    orig_validation = pydicom_config.settings.reading_validation_mode
-    pydicom_config.settings.reading_validation_mode = 2
     # Hardcode tracker first since user still needs to opt in
     pd_callback_kwargs = pydicom_config.data_element_callback_kwargs
     read_ctx = pd_callback_kwargs.get(READER)
     if read_ctx:
         if read_ctx.encoding is None:
             read_ctx.encoding = encoding
         raw = read_ctx.track(raw)
@@ -70,15 +68,14 @@
         raw.tag,
         VR,
         value,
         raw.value_tell,
         raw.length == 0xFFFFFFFF,
         already_converted=True,
     )
-    pydicom_config.settings.reading_validation_mode = orig_validation
     return de
 
 
 @contextmanager
 def no_fixes():
     """Context manager that empties callbacks/fixers."""
     config = get_config()
@@ -365,15 +362,18 @@
             # write and if it fails, raise
             try:
                 # NOTE: Any intermediate fixing that happened here
                 # before we bailed out (removed the value) will be lost,
                 # only the original Value from the dicom will be written
                 # back if it can be
                 VR = t.cast(str, elem.VR)
-                out = DataElement(elem.tag, VR, elem.original.value)
+                # So that validation_mode is set to do as little validation as possible,
+                # it's set to 0 ("IGNORE") here, so that it won't raise if the value
+                # doesn't fit DICOM standards, only if it's unable to be parsed at all.
+                out = DataElement(elem.tag, VR, elem.original.value, validation_mode=0)
                 write_data_element(buffer, out)
                 dataset[out.tag] = out
             except Exception as exc:
                 # Writing will fail but we want to warn the user on all DEs that
                 # fall into this category
                 warnings.warn(
                     (
```

## fw_file/dicom/series.py

```diff
@@ -438,15 +438,15 @@
         """Remove any temp files (of from_zip) when the collection is GC'd."""
         self.cleanup()
 
 
 class DICOMSeries(DICOMCollection):
     """DICOMSeries represents a list of instances from the same series."""
 
-    def __init__(
+    def __init__(  # noqa: PLR0913
         self,
         *files: AnyDICOM,
         defer_parse: bool = True,
         write_cache_drop: bool = True,
         instance_name_fn: t.Callable[[DICOM], str] = get_instance_name,
         filter_fn: t.Optional[t.Callable[[DICOM], bool]] = None,
         series_name_fn: t.Callable[[DICOM], t.Optional[str]] = get_series_name,
```

## fw_file/dicom/standard/editions.json

### Pretty-printed

 * *Similarity: 0.9772727272727273%*

 * *Differences: {'insert': "[(43, '2023c')]"}*

```diff
@@ -37,9 +37,10 @@
     "2021e",
     "2022a",
     "2022b",
     "2022c",
     "2022d",
     "2022e",
     "2023a",
-    "2023b"
+    "2023b",
+    "2023c"
 ]
```

## fw_file/dicom/validation.py

```diff
@@ -34,27 +34,30 @@
     """Get the dicom standard.
 
     Returns:
         dicom standard representation.
     """
     config = get_config()
     standard_path = config.standard_path
-    revision_path = config.standard_path / config.standard_rev
+    standard_rev = config.standard_rev
+    if standard_rev == "current":
+        standard_rev = EditionReader(standard_path).get_edition("current")
+    revision_path = config.standard_path / standard_rev
     if not revision_path.exists():  # pragma: no cover
         # pull revs at runtime if not using the shipped default
         try:
             standard_path.mkdir(parents=True, exist_ok=True)
             standard_path.touch()
         except PermissionError:
             # fallback to /tmp if the default path is not writable
             standard_path = Path("/tmp/dicom_standard")  # noqa S108
             standard_path.mkdir(parents=True, exist_ok=True)
         # pull the dicom standard xml's and transform them to json
         edition_reader = EditionReader(standard_path)
-        edition_reader.get_revision(revision=config.standard_rev)
+        edition_reader.get_revision(revision=standard_rev)
         json_nl_re = re.compile(r'\},(?!"(cond|include|index|items|name|ref|title)")')
         for file in standard_path.rglob("*.*"):
             # minify the jsons while keeping them git and human-friendly
             if file.suffix == ".json":
                 data = json.loads(file.read_text())
                 data_str = json.dumps(data, sort_keys=True, separators=(",", ":"))
                 file.write_text(json_nl_re.sub("},\n", data_str))
@@ -106,41 +109,44 @@
         dcm: Input dicom
 
     Returns:
         Output tag dict, keys are tag ints, value is True if
             tags value can be removed, False otherwise.
             If output is None, tag_dict could not be generated
     """
+    if not isinstance(dcm, Dataset):
+        dcm = dcm.dataset.raw
     tag_dict: t.Dict[int, bool] = {}
     validator = IODValidator(
-        t.cast(Dataset, dcm),
+        dcm,
         standard.iod_info,
         standard.mod_info,
         standard.dict_info,
         log_level=logging.WARNING,
     )
     sop_class_uid = validator._dataset.get("SOPClassUID")
     curr_iod_info = validator._iod_info.get(sop_class_uid)
     if not curr_iod_info:
         log.warning(f"Could not find IOD info for SOPClassUID: {sop_class_uid}")
         return tag_dict
+    existing_mods = validator._get_maybe_existing_modules(curr_iod_info).keys()
     for name, module in curr_iod_info["modules"].items():
         # Modules can be mandatory or optional, or conditionally mandatory.
         # Here we don't care if they are mandatory or optional, we just want to
         # add its tags to the dictionary if it is present in the dataset.
         module_info = validator._get_module_info(module["ref"])
         usage = module["use"]
         condition = module.get("cond")
         if usage == "M":
             required = True
         elif usage == "U":
             required = False
         else:
             required, _ = validator._object_is_required_or_allowed(condition)
-        present = validator._has_module(module_info)
+        present = module["ref"] in existing_mods
         # Skip module if not required and not present
         if not required and not present:
             log.debug(f"Skipping module {name} as it was not found in dataset.")
             continue
         for tag_id_str, attribute in module_info.items():
             tag_id = validator._tag_id(tag_id_str)
             # Not adding any tags at PixelData or higher.
```

## Comparing `fw_file-2.3.0.dist-info/LICENSE` & `fw_file-2.4.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `fw_file-2.3.0.dist-info/METADATA` & `fw_file-2.4.0.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: fw-file
-Version: 2.3.0
+Version: 2.4.0
 Summary: Unified data-file interface
 Home-page: https://gitlab.com/flywheel-io/tools/lib/fw-file
 License: MIT
 Keywords: Flywheel,parse,medical,file,metadata,extract,DICOM,RAW,MR,CT,PET,NIfTI,JPG,JPEG,PNG,Bruker,ParaVision,GE,PFile,Philips,PARREC,Siemens,PTD
 Author: Flywheel
 Author-email: support@flywheel.io
 Requires-Python: >=3.8,<4.0
@@ -17,15 +17,15 @@
 Classifier: Topic :: Scientific/Engineering :: Medical Science Apps.
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Provides-Extra: all
 Provides-Extra: jpg
 Provides-Extra: json
 Provides-Extra: nifti
 Provides-Extra: png
-Requires-Dist: dicom-validator (>=0,<1)
+Requires-Dist: dicom-validator (>=0.3.5,<0.4.0)
 Requires-Dist: dotty-dict (>=1.3.1,<2.0.0) ; extra == "all" or extra == "json"
 Requires-Dist: fw-meta (>=3.1,<4.0)
 Requires-Dist: fw-utils (>=3,<5)
 Requires-Dist: importlib-metadata (>=4.8.2,<5.0.0) ; python_version < "3.8"
 Requires-Dist: memoization (>=0,<1)
 Requires-Dist: natsort (>=8.0.0,<9.0.0)
 Requires-Dist: nibabel (>=4.0.2,<5.0.0) ; extra == "all" or extra == "nifti"
@@ -200,14 +200,27 @@
 
 ```python
 from fw_file.dicom import DICOMSeries
 series = DICOMSeries("001.dcm", "002.dcm")
 filepath, metadata = series.to_upload()
 ```
 
+### DICOM Standard Editions
+
+As the DICOM Standard is typically revised multiple times throughout the year,
+`fw-file` provides the option to choose which edition is being utilized via
+environment variables. The default is `"2023c"`, which utilizes the locally-saved
+2023c edition. Additional options are `"current"` and any valid 5-character edition
+(i.e. `"2022d"`). Specifying `"current"` will fetch the most recent edition at runtime.
+
+```bash
+FW_DCM_STANDARD_REV=current
+FW_DCM_STANDARD_REV=2022d
+```
+
 ### Private dictionary
 
 In addition to the private tags included in
 [`pydicom`](https://github.com/pydicom/pydicom/blob/v2.1.2/pydicom/_private_dict.py),
 `fw-file` ships with an [extended dictionary](fw_file/dicom/dcmdict.py) to
 make accessing even more private tags that much simpler.
 
@@ -230,14 +243,31 @@
 
 ```bash
 FW_DCM_REPLACE_UN_WITH_KNOWN_VR=false
 FW_DCM_FIX_VM1_STRINGS=false
 FW_DCM_FIX_VR_MISMATCH=true
 ```
 
+To extract as much information from a DICOM as possible, `fw-file` can be run in
+read-only mode. When enabled, invalid values are retained and the VR is set to OB.
+As it is not safe to write the DICOM back in this state, saving is disabled. This
+mode can be enabled via an environment variable. (default: disabled)
+
+```bash
+FW_DCM_READ_ONLY=true
+```
+
+Additionally, validation mode can be set via environment variables. Default is
+1 (WARN), additional options are 2 (RAISE) and 0 (IGNORE).
+
+```bash
+FW_DCM_READING_VALIDATION_MODE=1
+FW_DCM_WRITING_VALIDATION_MODE=1
+```
+
 To track any changes like `VR` inferences on (raw) data elements DICOMs can be
 instantiated with `track=True`:
 
 ```python
 dcm = DICOM("dataset.dcm", decode=True, track=True)
 dcm.tracker.data_elements[0].events == ["Replace VR: UN -> CS"]
 ```
```

## Comparing `fw_file-2.3.0.dist-info/RECORD` & `fw_file-2.4.0.dist-info/RECORD`

 * *Files 11% similar despite different names*

```diff
@@ -1,31 +1,36 @@
 fw_file/__init__.py,sha256=T3Tnv5R3uXDGZ-lp03D4noosiBfs9Bu6GzvDUUltgTg,229
 fw_file/base.py,sha256=skak6Ex5bfSPwzN48F5dsJvfEz-vcg-Kn84SkfhhHzI,8377
 fw_file/bruker.py,sha256=yM_xq-cdgJ8zPKjhHBBQ8YrJRvj1U3JHmzMj8MR3oUA,3184
 fw_file/dicom/__init__.py,sha256=Dh7WgsG2PoelxuqtM5-_5C0dbAi_CG_TW35_N5aRBxY,1515
-fw_file/dicom/config.py,sha256=fbbVedvpRcyWl_ehcHmYQimNU-HozLEsBj4SyUfDFw4,4912
+fw_file/dicom/config.py,sha256=LDFuDZGl0Uk0RnIH9WJLR1RdwNZ-bXb-rtFjm5oziDc,6011
 fw_file/dicom/dcmdict.py,sha256=y_NpdECSc-klhPnf69qpYbjwy_TsI2ikXwLckZIDVcA,44285
-fw_file/dicom/dicom.py,sha256=FspnCMXey-etyz9QGla9_QjmrBACe6ChtMH15YEHjzU,17527
-fw_file/dicom/fixers.py,sha256=_cPToJhNej7QDmYMtBAwZaRlR7JPABIPzZXOIN02CRU,18392
-fw_file/dicom/reader.py,sha256=WOhltexJvpI3Aeh64wrIWMkqUXpScf5zSu9uo_duk3I,17330
-fw_file/dicom/series.py,sha256=VGp5rmCMwo7mFfq9Dc5P54z-H0FoZff0j-oNkpynQnM,27641
+fw_file/dicom/dicom.py,sha256=XavmLF1TWEQh4Py6_7v9WNpkF8UJU1iyzC23isVA5Yk,17633
+fw_file/dicom/fixers.py,sha256=SAr-XspzAgblkBMTNuexNQyqoy5QE7qz70hLmdXzjwU,18949
+fw_file/dicom/reader.py,sha256=pM2UMGdiO8xPC51G6Z0Kdx9lwbPCBDnpp7SLAlAPuVQ,17415
+fw_file/dicom/series.py,sha256=Fe6_OwInAp8ZU1INnkvRP7yf0BdIbuBNx32jCngY0hI,27658
 fw_file/dicom/standard/2023b/json/dict_info.json,sha256=G57E1IYRQssb6NVgA6hRA-qgrTAk-b_JgP7QUBjym1k,421033
 fw_file/dicom/standard/2023b/json/iod_info.json,sha256=kOR8UWIR7Gyut7WVGHmEXTJymjF8XYty6lqJWsoTwMs,188832
 fw_file/dicom/standard/2023b/json/module_info.json,sha256=juOJ1KQVVhL0J24fzGDl2joL6MtsBf223_PpkSvfwS8,528709
 fw_file/dicom/standard/2023b/json/uid_info.json,sha256=tkQbqwXGQO6_WsPxbNwf4eHQ8tdANM_PisWW8zqc864,31221
 fw_file/dicom/standard/2023b/json/version,sha256=uPt4p7NTFCveH-UkqLcBd1htCl0u6YAhWEHipHmPbBs,5
-fw_file/dicom/standard/editions.json,sha256=CG7x9qOOIXHL_oTrtgfKRa0UbFnaVjtXTMEROUgmWog,345
+fw_file/dicom/standard/2023c/json/dict_info.json,sha256=D9Ddu8tEEBaEGt3deC-UBirNO37E0Z7LCKvCz2Tux88,422965
+fw_file/dicom/standard/2023c/json/iod_info.json,sha256=W2Umw1578VfNoWNYI5PqtjyQGVgUMUYt1J4SqljLR-U,191779
+fw_file/dicom/standard/2023c/json/module_info.json,sha256=yDCIM3bOeC0F25P1H22HCNi4A0B07zz71ex_Neb3mqQ,531128
+fw_file/dicom/standard/2023c/json/uid_info.json,sha256=L-OpmphiqsvV1wTnPJJ1zPWrUaDruhn-7Fy1nOOhecw,31351
+fw_file/dicom/standard/2023c/json/version,sha256=chs29ukegsplmSIlFfRBz4srybz6fhCYDk5F04KGouQ,5
+fw_file/dicom/standard/editions.json,sha256=114U8pY1673mbEAP4J1FXuc_tgBjr4xKRyGgHfbp5J4,353
 fw_file/dicom/utils.py,sha256=ntJ5f94TJ1AkHku3lw_KtYzzyErZcyl1gGj1X1fAxAA,9047
-fw_file/dicom/validation.py,sha256=doVoPjuZuectYsuVhijTlG2XoMiFU2Awc17RFZhnCFw,6620
+fw_file/dicom/validation.py,sha256=kIa7jZ0gvV8vaLYSXocFjKI6H73zd_Lkai4x7C9x8wM,6880
 fw_file/exif.py,sha256=kPm3V9pByRzKMtMHRBljgAYA7g3Mk-kIKFLAD-bJMCA,3103
 fw_file/ge.py,sha256=jpd5_MTR5rf3lnX082pCSFYgbAXwDlO41-Xyp8QbrX4,12581
 fw_file/jpg.py,sha256=3qLSgZztivZ3so1CYD-CBC-x59kahOZO5Y5PIbVDX10,778
 fw_file/json.py,sha256=ufQ2YnNsyWocsB1yrTFEncHCKmIr7OeiwEUqOm3n3VY,2186
 fw_file/nifti.py,sha256=hKjKGhUUTrqIv6QsPe2qWJqteLbZPHZ52yWPf788iOQ,1440
 fw_file/philips.py,sha256=E9gyia6ZpyTg2RYktYFFDBNaI-plmYSVunhhWgfR_GA,5265
 fw_file/png.py,sha256=dqpSGSPg7Ox_B4JOFcSD2Uy5y0fXhM5O2tZgI-aZ4kU,8385
 fw_file/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 fw_file/siemens.py,sha256=IYUQkiEJs9_25hb50NgdoHM8cw-l5iATlI1V1EdQwpc,10521
-fw_file-2.3.0.dist-info/LICENSE,sha256=3QLwoJgDkLWRKwcyYzPn3vLqTHhbdltfjFYeBOZSlDY,1078
-fw_file-2.3.0.dist-info/METADATA,sha256=QWxNeeagcxvKUUj3JASrgvufqTVCrv8B--Mb_QaX7XA,8486
-fw_file-2.3.0.dist-info/WHEEL,sha256=7Z8_27uaHI_UZAc4Uox4PpBhQ9Y5_modZXWMxtUi4NU,88
-fw_file-2.3.0.dist-info/RECORD,,
+fw_file-2.4.0.dist-info/LICENSE,sha256=3QLwoJgDkLWRKwcyYzPn3vLqTHhbdltfjFYeBOZSlDY,1078
+fw_file-2.4.0.dist-info/METADATA,sha256=YQAzG13VLrfw-OhDrByAIopw0KR0R675OFkV4vZFT5U,9569
+fw_file-2.4.0.dist-info/WHEEL,sha256=Zb28QaM1gQi8f4VCBhsUklF61CTlNYfs9YAZn-TOGFk,88
+fw_file-2.4.0.dist-info/RECORD,,
```

