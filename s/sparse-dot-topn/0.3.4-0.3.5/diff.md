# Comparing `tmp/sparse_dot_topn-0.3.4-cp39-cp39-win_amd64.whl.zip` & `tmp/sparse_dot_topn-0.3.5-cp38-cp38-manylinux_2_17_aarch64.manylinux2014_aarch64.whl.zip`

## zipinfo {}

```diff
@@ -1,20 +1,21 @@
-Zip file size: 285638 bytes, number of entries: 18
--rw-rw-rw-  2.0 fat      195 b- defN 23-Feb-12 13:05 sparse_dot_topn/__init__.py
--rw-rw-rw-  2.0 fat    51200 b- defN 23-Feb-12 13:13 sparse_dot_topn/array_wrappers.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat      805 b- defN 23-Feb-12 13:05 sparse_dot_topn/array_wrappers.pxd
--rw-rw-rw-  2.0 fat     4469 b- defN 23-Feb-12 13:05 sparse_dot_topn/array_wrappers.pyx
--rw-rw-rw-  2.0 fat     5010 b- defN 23-Feb-12 13:05 sparse_dot_topn/awesome_cossim_topn.py
--rw-rw-rw-  2.0 fat   299520 b- defN 23-Feb-12 13:13 sparse_dot_topn/sparse_dot_topn.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     7683 b- defN 23-Feb-12 13:05 sparse_dot_topn/sparse_dot_topn.pyx
--rw-rw-rw-  2.0 fat    17882 b- defN 23-Feb-12 13:05 sparse_dot_topn/sparse_dot_topn_parallel.cpp
--rw-rw-rw-  2.0 fat     1809 b- defN 23-Feb-12 13:05 sparse_dot_topn/sparse_dot_topn_parallel.h
--rw-rw-rw-  2.0 fat    13036 b- defN 23-Feb-12 13:05 sparse_dot_topn/sparse_dot_topn_source.cpp
--rw-rw-rw-  2.0 fat     2034 b- defN 23-Feb-12 13:05 sparse_dot_topn/sparse_dot_topn_source.h
--rw-rw-rw-  2.0 fat   320000 b- defN 23-Feb-12 13:13 sparse_dot_topn/sparse_dot_topn_threaded.cp39-win_amd64.pyd
--rw-rw-rw-  2.0 fat     5169 b- defN 23-Feb-12 13:05 sparse_dot_topn/sparse_dot_topn_threaded.pyx
--rw-rw-rw-  2.0 fat    11575 b- defN 23-Feb-12 13:13 sparse_dot_topn-0.3.4.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     4730 b- defN 23-Feb-12 13:13 sparse_dot_topn-0.3.4.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Feb-12 13:13 sparse_dot_topn-0.3.4.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       16 b- defN 23-Feb-12 13:12 sparse_dot_topn-0.3.4.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     1712 b- defN 23-Feb-12 13:13 sparse_dot_topn-0.3.4.dist-info/RECORD
-18 files, 746945 bytes uncompressed, 282774 bytes compressed:  62.1%
+Zip file size: 2225318 bytes, number of entries: 19
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-24 22:07 sparse_dot_topn-0.3.5.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-24 22:07 sparse_dot_topn/
+drwxr-xr-x  2.0 unx        0 b- stor 23-Jul-24 22:07 sparse_dot_topn.libs/
+-rw-r--r--  2.0 unx       16 b- defN 23-Jul-24 22:07 sparse_dot_topn-0.3.5.dist-info/top_level.txt
+-rw-r--r--  2.0 unx    11375 b- defN 23-Jul-24 22:07 sparse_dot_topn-0.3.5.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     1568 b- defN 23-Jul-24 22:07 sparse_dot_topn-0.3.5.dist-info/RECORD
+-rw-r--r--  2.0 unx      150 b- defN 23-Jul-24 22:07 sparse_dot_topn-0.3.5.dist-info/WHEEL
+-rw-r--r--  2.0 unx     4614 b- defN 23-Jul-24 22:07 sparse_dot_topn-0.3.5.dist-info/METADATA
+-rw-r--r--  2.0 unx     4870 b- defN 23-Jul-24 22:07 sparse_dot_topn/awesome_cossim_topn.py
+-rwxr-xr-x  2.0 unx  4906048 b- defN 23-Jul-24 22:07 sparse_dot_topn/sparse_dot_topn_threaded.cpython-38-aarch64-linux-gnu.so
+-rwxr-xr-x  2.0 unx  3263720 b- defN 23-Jul-24 22:07 sparse_dot_topn/sparse_dot_topn.cpython-38-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx     4360 b- defN 23-Jul-24 22:07 sparse_dot_topn/array_wrappers.pyx
+-rw-r--r--  2.0 unx     4962 b- defN 23-Jul-24 22:07 sparse_dot_topn/sparse_dot_topn_threaded.pyx
+-rwxr-xr-x  2.0 unx   515000 b- defN 23-Jul-24 22:07 sparse_dot_topn/array_wrappers.cpython-38-aarch64-linux-gnu.so
+-rw-r--r--  2.0 unx      189 b- defN 23-Jul-24 22:07 sparse_dot_topn/__init__.py
+-rw-r--r--  2.0 unx     1728 b- defN 23-Jul-24 22:07 sparse_dot_topn/sparse_dot_topn_parallel.h
+-rw-r--r--  2.0 unx     7405 b- defN 23-Jul-24 22:07 sparse_dot_topn/sparse_dot_topn.pyx
+-rw-r--r--  2.0 unx     1944 b- defN 23-Jul-24 22:07 sparse_dot_topn/sparse_dot_topn_source.h
+-rw-r--r--  2.0 unx      782 b- defN 23-Jul-24 22:07 sparse_dot_topn/array_wrappers.pxd
+19 files, 8728731 bytes uncompressed, 2222334 bytes compressed:  74.5%
```

## zipnote {}

```diff
@@ -1,55 +1,58 @@
-Filename: sparse_dot_topn/__init__.py
+Filename: sparse_dot_topn-0.3.5.dist-info/
 Comment: 
 
-Filename: sparse_dot_topn/array_wrappers.cp39-win_amd64.pyd
+Filename: sparse_dot_topn/
 Comment: 
 
-Filename: sparse_dot_topn/array_wrappers.pxd
+Filename: sparse_dot_topn.libs/
 Comment: 
 
-Filename: sparse_dot_topn/array_wrappers.pyx
+Filename: sparse_dot_topn-0.3.5.dist-info/top_level.txt
 Comment: 
 
-Filename: sparse_dot_topn/awesome_cossim_topn.py
+Filename: sparse_dot_topn-0.3.5.dist-info/LICENSE
 Comment: 
 
-Filename: sparse_dot_topn/sparse_dot_topn.cp39-win_amd64.pyd
+Filename: sparse_dot_topn-0.3.5.dist-info/RECORD
 Comment: 
 
-Filename: sparse_dot_topn/sparse_dot_topn.pyx
+Filename: sparse_dot_topn-0.3.5.dist-info/WHEEL
 Comment: 
 
-Filename: sparse_dot_topn/sparse_dot_topn_parallel.cpp
+Filename: sparse_dot_topn-0.3.5.dist-info/METADATA
 Comment: 
 
-Filename: sparse_dot_topn/sparse_dot_topn_parallel.h
+Filename: sparse_dot_topn/awesome_cossim_topn.py
 Comment: 
 
-Filename: sparse_dot_topn/sparse_dot_topn_source.cpp
+Filename: sparse_dot_topn/sparse_dot_topn_threaded.cpython-38-aarch64-linux-gnu.so
 Comment: 
 
-Filename: sparse_dot_topn/sparse_dot_topn_source.h
+Filename: sparse_dot_topn/sparse_dot_topn.cpython-38-aarch64-linux-gnu.so
 Comment: 
 
-Filename: sparse_dot_topn/sparse_dot_topn_threaded.cp39-win_amd64.pyd
+Filename: sparse_dot_topn/array_wrappers.pyx
 Comment: 
 
 Filename: sparse_dot_topn/sparse_dot_topn_threaded.pyx
 Comment: 
 
-Filename: sparse_dot_topn-0.3.4.dist-info/LICENSE
+Filename: sparse_dot_topn/array_wrappers.cpython-38-aarch64-linux-gnu.so
+Comment: 
+
+Filename: sparse_dot_topn/__init__.py
 Comment: 
 
-Filename: sparse_dot_topn-0.3.4.dist-info/METADATA
+Filename: sparse_dot_topn/sparse_dot_topn_parallel.h
 Comment: 
 
-Filename: sparse_dot_topn-0.3.4.dist-info/WHEEL
+Filename: sparse_dot_topn/sparse_dot_topn.pyx
 Comment: 
 
-Filename: sparse_dot_topn-0.3.4.dist-info/top_level.txt
+Filename: sparse_dot_topn/sparse_dot_topn_source.h
 Comment: 
 
-Filename: sparse_dot_topn-0.3.4.dist-info/RECORD
+Filename: sparse_dot_topn/array_wrappers.pxd
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## sparse_dot_topn/__init__.py

 * *Ordering differences only*

```diff
@@ -1,7 +1,7 @@
-# flake8: noqa
-import sys
-
-if sys.version_info[0] >= 3:
-    from sparse_dot_topn.awesome_cossim_topn import awesome_cossim_topn
-else:
+# flake8: noqa
+import sys
+
+if sys.version_info[0] >= 3:
+    from sparse_dot_topn.awesome_cossim_topn import awesome_cossim_topn
+else:
     from awesome_cossim_topn import awesome_cossim_topn
```

## sparse_dot_topn/array_wrappers.pxd

 * *Ordering differences only*

```diff
@@ -1,23 +1,23 @@
-from libcpp.vector cimport vector
-
-# define a Cython array wrapper class to hold a C++ vector of ints, adhering to numpy's buffer protocol:
-cdef class ArrayWrapper_int:
-    cdef int view_count
-    cdef vector[int] vec
-    cdef Py_ssize_t shape[2]
-    cdef Py_ssize_t strides[2]
-
-
-# define a Cython array wrapper class to hold a C++ vector of doubles, adhering to numpy's buffer protocol:
-cdef class ArrayWrapper_double:
-    cdef int view_count
-    cdef vector[double] vec
-    cdef Py_ssize_t shape[2]
-    cdef Py_ssize_t strides[2]
-
-# define a Cython array wrapper class to hold a C++ vector of floats, adhering to numpy's buffer protocol:
-cdef class ArrayWrapper_float:
-    cdef int view_count
-    cdef vector[float] vec
-    cdef Py_ssize_t shape[2]
-    cdef Py_ssize_t strides[2]
+from libcpp.vector cimport vector
+
+# define a Cython array wrapper class to hold a C++ vector of ints, adhering to numpy's buffer protocol:
+cdef class ArrayWrapper_int:
+    cdef int view_count
+    cdef vector[int] vec
+    cdef Py_ssize_t shape[2]
+    cdef Py_ssize_t strides[2]
+
+
+# define a Cython array wrapper class to hold a C++ vector of doubles, adhering to numpy's buffer protocol:
+cdef class ArrayWrapper_double:
+    cdef int view_count
+    cdef vector[double] vec
+    cdef Py_ssize_t shape[2]
+    cdef Py_ssize_t strides[2]
+
+# define a Cython array wrapper class to hold a C++ vector of floats, adhering to numpy's buffer protocol:
+cdef class ArrayWrapper_float:
+    cdef int view_count
+    cdef vector[float] vec
+    cdef Py_ssize_t shape[2]
+    cdef Py_ssize_t strides[2]
```

## sparse_dot_topn/array_wrappers.pyx

 * *Ordering differences only*

```diff
@@ -1,109 +1,109 @@
-from cpython cimport Py_buffer
-from libcpp.vector cimport vector
-
-# define a Cython array wrapper class to hold a C++ vector of ints, adhering to numpy's buffer protocol:
-cdef class ArrayWrapper_int:
-    # constructor and destructor are fairly unimportant now since
-    # vec will be destroyed automatically.
-
-    def __cinit__(self, vector[int]& data):
-        self.vec.swap(data)
-        self.view_count = 0
-
-    # now implement the buffer protocol for the class
-    # which makes it generally useful to anything that expects an array
-    def __getbuffer__(self, Py_buffer *buffer, int flags):
-        # relevant documentation http://cython.readthedocs.io/en/latest/src/userguide/buffer.html#a-matrix-class
-        cdef Py_ssize_t itemsize = sizeof(self.vec[0])
-
-        self.shape[1] = self.vec.size()
-        self.shape[0] = 1
-        self.strides[1] = <Py_ssize_t>(  <char *>&(self.vec[1]) - <char *>&(self.vec[0]))
-        self.strides[0] = self.vec.size() * self.strides[1]
-        buffer.buf = <char *>&(self.vec[0])
-        buffer.format = 'i'
-        buffer.internal = NULL
-        buffer.itemsize = itemsize
-        buffer.len = self.vec.size() * itemsize   # product(shape) * itemsize
-        buffer.ndim = 2
-        buffer.obj = self
-        buffer.readonly = 0
-        buffer.shape = self.shape
-        buffer.strides = self.strides
-        buffer.suboffsets = NULL
-        self.view_count += 1
-
-    def __releasebuffer__(self, Py_buffer *buffer):
-        self.view_count -= 1
-
-
-# define a Cython array wrapper class to hold a C++ vector of doubles, adhering to numpy's buffer protocol:
-cdef class ArrayWrapper_double:
-    # constructor and destructor are fairly unimportant now since
-    # vec will be destroyed automatically.
-
-    def __cinit__(self, vector[double]& data):
-        self.vec.swap(data)
-        self.view_count = 0
-
-    # now implement the buffer protocol for the class
-    # which makes it generally useful to anything that expects an array
-    def __getbuffer__(self, Py_buffer *buffer, int flags):
-        # relevant documentation http://cython.readthedocs.io/en/latest/src/userguide/buffer.html#a-matrix-class
-        cdef Py_ssize_t itemsize = sizeof(self.vec[0])
-
-        self.shape[1] = self.vec.size()
-        self.shape[0] = 1
-        self.strides[1] = <Py_ssize_t>(  <char *>&(self.vec[1]) - <char *>&(self.vec[0]))
-        self.strides[0] = self.vec.size() * self.strides[1]
-        buffer.buf = <char *>&(self.vec[0])
-        buffer.format = 'd'
-        buffer.internal = NULL
-        buffer.itemsize = itemsize
-        buffer.len = self.vec.size() * itemsize   # product(shape) * itemsize
-        buffer.ndim = 2
-        buffer.obj = self
-        buffer.readonly = 0
-        buffer.shape = self.shape
-        buffer.strides = self.strides
-        buffer.suboffsets = NULL
-        self.view_count += 1
-
-    def __releasebuffer__(self, Py_buffer *buffer):
-        self.view_count -= 1
-
-
-# define a Cython array wrapper class to hold a C++ vector of floats, adhering to numpy's buffer protocol:
-cdef class ArrayWrapper_float:
-    # constructor and destructor are fairly unimportant now since
-    # vec will be destroyed automatically.
-
-    def __cinit__(self, vector[float]& data):
-        self.vec.swap(data)
-        self.view_count = 0
-
-    # now implement the buffer protocol for the class
-    # which makes it generally useful to anything that expects an array
-    def __getbuffer__(self, Py_buffer *buffer, int flags):
-        # relevant documentation http://cython.readthedocs.io/en/latest/src/userguide/buffer.html#a-matrix-class
-        cdef Py_ssize_t itemsize = sizeof(self.vec[0])
-
-        self.shape[1] = self.vec.size()
-        self.shape[0] = 1
-        self.strides[1] = <Py_ssize_t>(  <char *>&(self.vec[1]) - <char *>&(self.vec[0]))
-        self.strides[0] = self.vec.size() * self.strides[1]
-        buffer.buf = <char *>&(self.vec[0])
-        buffer.format = 'f'
-        buffer.internal = NULL
-        buffer.itemsize = itemsize
-        buffer.len = self.vec.size() * itemsize   # product(shape) * itemsize
-        buffer.ndim = 2
-        buffer.obj = self
-        buffer.readonly = 0
-        buffer.shape = self.shape
-        buffer.strides = self.strides
-        buffer.suboffsets = NULL
-        self.view_count += 1
-
-    def __releasebuffer__(self, Py_buffer *buffer):
-        self.view_count -= 1
+from cpython cimport Py_buffer
+from libcpp.vector cimport vector
+
+# define a Cython array wrapper class to hold a C++ vector of ints, adhering to numpy's buffer protocol:
+cdef class ArrayWrapper_int:
+    # constructor and destructor are fairly unimportant now since
+    # vec will be destroyed automatically.
+
+    def __cinit__(self, vector[int]& data):
+        self.vec.swap(data)
+        self.view_count = 0
+
+    # now implement the buffer protocol for the class
+    # which makes it generally useful to anything that expects an array
+    def __getbuffer__(self, Py_buffer *buffer, int flags):
+        # relevant documentation http://cython.readthedocs.io/en/latest/src/userguide/buffer.html#a-matrix-class
+        cdef Py_ssize_t itemsize = sizeof(self.vec[0])
+
+        self.shape[1] = self.vec.size()
+        self.shape[0] = 1
+        self.strides[1] = <Py_ssize_t>(  <char *>&(self.vec[1]) - <char *>&(self.vec[0]))
+        self.strides[0] = self.vec.size() * self.strides[1]
+        buffer.buf = <char *>&(self.vec[0])
+        buffer.format = 'i'
+        buffer.internal = NULL
+        buffer.itemsize = itemsize
+        buffer.len = self.vec.size() * itemsize   # product(shape) * itemsize
+        buffer.ndim = 2
+        buffer.obj = self
+        buffer.readonly = 0
+        buffer.shape = self.shape
+        buffer.strides = self.strides
+        buffer.suboffsets = NULL
+        self.view_count += 1
+
+    def __releasebuffer__(self, Py_buffer *buffer):
+        self.view_count -= 1
+
+
+# define a Cython array wrapper class to hold a C++ vector of doubles, adhering to numpy's buffer protocol:
+cdef class ArrayWrapper_double:
+    # constructor and destructor are fairly unimportant now since
+    # vec will be destroyed automatically.
+
+    def __cinit__(self, vector[double]& data):
+        self.vec.swap(data)
+        self.view_count = 0
+
+    # now implement the buffer protocol for the class
+    # which makes it generally useful to anything that expects an array
+    def __getbuffer__(self, Py_buffer *buffer, int flags):
+        # relevant documentation http://cython.readthedocs.io/en/latest/src/userguide/buffer.html#a-matrix-class
+        cdef Py_ssize_t itemsize = sizeof(self.vec[0])
+
+        self.shape[1] = self.vec.size()
+        self.shape[0] = 1
+        self.strides[1] = <Py_ssize_t>(  <char *>&(self.vec[1]) - <char *>&(self.vec[0]))
+        self.strides[0] = self.vec.size() * self.strides[1]
+        buffer.buf = <char *>&(self.vec[0])
+        buffer.format = 'd'
+        buffer.internal = NULL
+        buffer.itemsize = itemsize
+        buffer.len = self.vec.size() * itemsize   # product(shape) * itemsize
+        buffer.ndim = 2
+        buffer.obj = self
+        buffer.readonly = 0
+        buffer.shape = self.shape
+        buffer.strides = self.strides
+        buffer.suboffsets = NULL
+        self.view_count += 1
+
+    def __releasebuffer__(self, Py_buffer *buffer):
+        self.view_count -= 1
+
+
+# define a Cython array wrapper class to hold a C++ vector of floats, adhering to numpy's buffer protocol:
+cdef class ArrayWrapper_float:
+    # constructor and destructor are fairly unimportant now since
+    # vec will be destroyed automatically.
+
+    def __cinit__(self, vector[float]& data):
+        self.vec.swap(data)
+        self.view_count = 0
+
+    # now implement the buffer protocol for the class
+    # which makes it generally useful to anything that expects an array
+    def __getbuffer__(self, Py_buffer *buffer, int flags):
+        # relevant documentation http://cython.readthedocs.io/en/latest/src/userguide/buffer.html#a-matrix-class
+        cdef Py_ssize_t itemsize = sizeof(self.vec[0])
+
+        self.shape[1] = self.vec.size()
+        self.shape[0] = 1
+        self.strides[1] = <Py_ssize_t>(  <char *>&(self.vec[1]) - <char *>&(self.vec[0]))
+        self.strides[0] = self.vec.size() * self.strides[1]
+        buffer.buf = <char *>&(self.vec[0])
+        buffer.format = 'f'
+        buffer.internal = NULL
+        buffer.itemsize = itemsize
+        buffer.len = self.vec.size() * itemsize   # product(shape) * itemsize
+        buffer.ndim = 2
+        buffer.obj = self
+        buffer.readonly = 0
+        buffer.shape = self.shape
+        buffer.strides = self.strides
+        buffer.suboffsets = NULL
+        self.view_count += 1
+
+    def __releasebuffer__(self, Py_buffer *buffer):
+        self.view_count -= 1
```

## sparse_dot_topn/awesome_cossim_topn.py

 * *Ordering differences only*

```diff
@@ -1,140 +1,140 @@
-import sys
-import numpy as np
-from scipy.sparse import csr_matrix
-from scipy.sparse import isspmatrix_csr
-
-if sys.version_info[0] >= 3:
-    from sparse_dot_topn import sparse_dot_topn as ct
-    from sparse_dot_topn import sparse_dot_topn_threaded as ct_thread
-else:
-    import sparse_dot_topn as ct
-    import sparse_dot_topn_threaded as ct_thread
-
-
-def awesome_cossim_topn(
-        A, B, ntop, lower_bound=0, use_threads=False, n_jobs=1, return_best_ntop=False, test_nnz_max=-1):
-    """
-    This function will return a matrix C in CSR format, where
-    C = [sorted top n results > lower_bound for each row of A * B].
-    If return_best_ntop=True then best_ntop
-    (the true maximum number of elements > lower_bound per row of A * B)
-    will also be returned in a tuple together with C as (C, best_ntop).
-
-    Input:
-        A and B: two CSR matrices
-        ntop: top n results
-        lower_bound: a threshold that the element of A*B must be greater than
-        use_threads: use multi-thread or not
-        n_jobs: number of thread, must be >= 1
-        return_best_ntop: (default: False) if True, will return best_ntop together 
-                          with C as a tuple: (C, best_ntop)
-
-    Output:
-        C: result matrix (returned alone, if return_best_ntop=False)
-        best_ntop: The true maximum number of elements > lower_bound per row of 
-                   A * B returned together with C as a tuple: (C, best_ntop). It is 
-                   returned only if return_best_ntop=True.
-
-    N.B. if A and B are not in CSR format, they will be converted to CSR
-    """
-    def try_malloc(sz: int, idx_dtype, data_dtype) -> bool:
-        try:
-            ind_arr = np.empty(sz, dtype=idx_dtype)
-            dat_arr = np.empty(sz, dtype=data_dtype)
-            del ind_arr, dat_arr
-            return True
-        except MemoryError:
-            return False
-        
-    if not isspmatrix_csr(A):
-        A = A.tocsr()
-    if not isspmatrix_csr(B):
-        B = B.tocsr()
-
-    dtype = A.dtype
-    assert B.dtype == dtype
-    lower_bound = dtype.type(lower_bound)  # Casting this scalar to the same type
-
-    M, K1 = A.shape
-    K2, N = B.shape
-
-    if K1 != K2:
-        err_str = 'A matrix multiplication will be operated. A.shape[1] must be equal to B.shape[0]!'
-        raise ValueError(err_str)
-
-    idx_dtype = np.int32
-
-    nnz_max = M*ntop
-
-    # basic check. if A or B are all zeros matrix, return all zero matrix directly
-    if len(A.indices) == 0 or len(B.indices) == 0:
-        indptr = np.zeros(M + 1, dtype=idx_dtype)
-        indices = np.zeros(nnz_max, dtype=idx_dtype)
-        data = np.zeros(nnz_max, dtype=A.dtype)
-        output = csr_matrix((data, indices, indptr), shape=(M, N))
-        if return_best_ntop:
-            return output, 0
-        else:
-            return output
-
-    indptr = np.empty(M + 1, dtype=idx_dtype)
-
-    # reduce nnz_max if too large to fit in available memory:
-    nnz_max = 16*nnz_max
-    while (not try_malloc(nnz_max, idx_dtype, A.dtype)):
-        nnz_max = nnz_max//2
-
-    # take a chance on high matrix-sparsity and reduce further:
-    nnz_max = max(M, nnz_max//16)
-    
-    # this line is only for testing purposes, designed to enable the user to 
-    # force C/C++ to reallocate memory during the matrix multiplication
-    nnz_max = test_nnz_max if test_nnz_max > 0 else nnz_max
-    
-    # filled matrices from here on
-    indices = np.empty(nnz_max, dtype=idx_dtype)
-    data = np.empty(nnz_max, dtype=A.dtype)
-
-    best_ntop_arr = np.full(1, 0, dtype=idx_dtype)
-
-    if not use_threads:
-
-        alt_indices, alt_data = ct.sparse_dot_topn_extd(
-            M, N, np.asarray(A.indptr, dtype=idx_dtype),
-            np.asarray(A.indices, dtype=idx_dtype),
-            A.data,
-            np.asarray(B.indptr, dtype=idx_dtype),
-            np.asarray(B.indices, dtype=idx_dtype),
-            B.data,
-            ntop,
-            lower_bound,
-            indptr, indices, data, best_ntop_arr
-        )
-
-    else:
-        if n_jobs < 1:
-            err_str = 'Whenever you select the multi-thread mode, n_job must be greater than or equal to 1!'
-            raise ValueError(err_str)
-
-        alt_indices, alt_data = ct_thread.sparse_dot_topn_extd_threaded(
-            M, N, np.asarray(A.indptr, dtype=idx_dtype),
-            np.asarray(A.indices, dtype=idx_dtype),
-            A.data,
-            np.asarray(B.indptr, dtype=idx_dtype),
-            np.asarray(B.indices, dtype=idx_dtype),
-            B.data,
-            ntop,
-            lower_bound,
-            indptr, indices, data, best_ntop_arr, n_jobs
-        )
-
-    if alt_indices is not None:
-        indices = alt_indices
-        data = alt_data
-
-    # prepare and return the output:
-    output = csr_matrix((data, indices, indptr), shape=(M, N))
-    if return_best_ntop:
-        return output, best_ntop_arr[0]
-    else:
-        return output
+import sys
+import numpy as np
+from scipy.sparse import csr_matrix
+from scipy.sparse import isspmatrix_csr
+
+if sys.version_info[0] >= 3:
+    from sparse_dot_topn import sparse_dot_topn as ct
+    from sparse_dot_topn import sparse_dot_topn_threaded as ct_thread
+else:
+    import sparse_dot_topn as ct
+    import sparse_dot_topn_threaded as ct_thread
+
+
+def awesome_cossim_topn(
+        A, B, ntop, lower_bound=0, use_threads=False, n_jobs=1, return_best_ntop=False, test_nnz_max=-1):
+    """
+    This function will return a matrix C in CSR format, where
+    C = [sorted top n results > lower_bound for each row of A * B].
+    If return_best_ntop=True then best_ntop
+    (the true maximum number of elements > lower_bound per row of A * B)
+    will also be returned in a tuple together with C as (C, best_ntop).
+
+    Input:
+        A and B: two CSR matrices
+        ntop: top n results
+        lower_bound: a threshold that the element of A*B must be greater than
+        use_threads: use multi-thread or not
+        n_jobs: number of thread, must be >= 1
+        return_best_ntop: (default: False) if True, will return best_ntop together 
+                          with C as a tuple: (C, best_ntop)
+
+    Output:
+        C: result matrix (returned alone, if return_best_ntop=False)
+        best_ntop: The true maximum number of elements > lower_bound per row of 
+                   A * B returned together with C as a tuple: (C, best_ntop). It is 
+                   returned only if return_best_ntop=True.
+
+    N.B. if A and B are not in CSR format, they will be converted to CSR
+    """
+    def try_malloc(sz: int, idx_dtype, data_dtype) -> bool:
+        try:
+            ind_arr = np.empty(sz, dtype=idx_dtype)
+            dat_arr = np.empty(sz, dtype=data_dtype)
+            del ind_arr, dat_arr
+            return True
+        except MemoryError:
+            return False
+        
+    if not isspmatrix_csr(A):
+        A = A.tocsr()
+    if not isspmatrix_csr(B):
+        B = B.tocsr()
+
+    dtype = A.dtype
+    assert B.dtype == dtype
+    lower_bound = dtype.type(lower_bound)  # Casting this scalar to the same type
+
+    M, K1 = A.shape
+    K2, N = B.shape
+
+    if K1 != K2:
+        err_str = 'A matrix multiplication will be operated. A.shape[1] must be equal to B.shape[0]!'
+        raise ValueError(err_str)
+
+    idx_dtype = np.int32
+
+    nnz_max = M*ntop
+
+    # basic check. if A or B are all zeros matrix, return all zero matrix directly
+    if len(A.indices) == 0 or len(B.indices) == 0:
+        indptr = np.zeros(M + 1, dtype=idx_dtype)
+        indices = np.zeros(nnz_max, dtype=idx_dtype)
+        data = np.zeros(nnz_max, dtype=A.dtype)
+        output = csr_matrix((data, indices, indptr), shape=(M, N))
+        if return_best_ntop:
+            return output, 0
+        else:
+            return output
+
+    indptr = np.empty(M + 1, dtype=idx_dtype)
+
+    # reduce nnz_max if too large to fit in available memory:
+    nnz_max = 16*nnz_max
+    while (not try_malloc(nnz_max, idx_dtype, A.dtype)):
+        nnz_max = nnz_max//2
+
+    # take a chance on high matrix-sparsity and reduce further:
+    nnz_max = max(M, nnz_max//16)
+    
+    # this line is only for testing purposes, designed to enable the user to 
+    # force C/C++ to reallocate memory during the matrix multiplication
+    nnz_max = test_nnz_max if test_nnz_max > 0 else nnz_max
+    
+    # filled matrices from here on
+    indices = np.empty(nnz_max, dtype=idx_dtype)
+    data = np.empty(nnz_max, dtype=A.dtype)
+
+    best_ntop_arr = np.full(1, 0, dtype=idx_dtype)
+
+    if not use_threads:
+
+        alt_indices, alt_data = ct.sparse_dot_topn_extd(
+            M, N, np.asarray(A.indptr, dtype=idx_dtype),
+            np.asarray(A.indices, dtype=idx_dtype),
+            A.data,
+            np.asarray(B.indptr, dtype=idx_dtype),
+            np.asarray(B.indices, dtype=idx_dtype),
+            B.data,
+            ntop,
+            lower_bound,
+            indptr, indices, data, best_ntop_arr
+        )
+
+    else:
+        if n_jobs < 1:
+            err_str = 'Whenever you select the multi-thread mode, n_job must be greater than or equal to 1!'
+            raise ValueError(err_str)
+
+        alt_indices, alt_data = ct_thread.sparse_dot_topn_extd_threaded(
+            M, N, np.asarray(A.indptr, dtype=idx_dtype),
+            np.asarray(A.indices, dtype=idx_dtype),
+            A.data,
+            np.asarray(B.indptr, dtype=idx_dtype),
+            np.asarray(B.indices, dtype=idx_dtype),
+            B.data,
+            ntop,
+            lower_bound,
+            indptr, indices, data, best_ntop_arr, n_jobs
+        )
+
+    if alt_indices is not None:
+        indices = alt_indices
+        data = alt_data
+
+    # prepare and return the output:
+    output = csr_matrix((data, indices, indptr), shape=(M, N))
+    if return_best_ntop:
+        return output, best_ntop_arr[0]
+    else:
+        return output
```

## sparse_dot_topn/sparse_dot_topn.pyx

 * *Ordering differences only*

```diff
@@ -1,278 +1,278 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at#
-#	http://www.apache.org/licenses/LICENSE-2.0#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Author: Zhe Sun, Ahmet Erdem
-# April 20, 2017
-# Modified by: Particular Miner
-# April 14, 2021
-
-# distutils: language = c++
-
-from libcpp.vector cimport vector
-from array_wrappers cimport ArrayWrapper_int, ArrayWrapper_float, ArrayWrapper_double
-
-cimport cython
-cimport numpy as np
-import numpy as np
-
-np.import_array()
-
-
-ctypedef fused  float_ft:
-	cython.float
-	cython.double
-
-
-cdef extern from "sparse_dot_topn_source.h":
-
-	cdef void sparse_dot_topn_source[T](
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[],
-		int Bp[],
-		int Bj[],
-		T Bx[],
-		int topn,
-		T lower_bound,
-		int Cp[],
-		int Cj[],
-		T Cx[]
-	) except +;
-
-	cdef int sparse_dot_topn_extd_source[T](
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[],
-		int Bp[],
-		int Bj[],
-		T Bx[],
-		int topn,
-		T lower_bound,
-		int Cp[],
-		int Cj[],
-		T Cx[],
-		vector[int]* alt_Cj,
-		vector[T]* alt_Cx,
-		int nnz_max,
-		int* nminmax
-	) except +;
-
-	cdef int sparse_dot_only_nnz_source[T](
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[],
-		int Bp[],
-		int Bj[],
-		T Bx[],
-		int ntop,
-		T lower_bound
-	) except +;
-
-cpdef ArrayWrapper_template(vector[float_ft] vCx):
-	# raise Exception("In sparse_dot_topn.pyx")
-	if float_ft is float:
-		return ArrayWrapper_float(vCx)
-	elif float_ft is double:
-		return ArrayWrapper_double(vCx)
-	else:
-		raise Exception("Type not supported")
-
-cpdef sparse_dot_topn(
-	int n_row,
-	int n_col,
-	np.ndarray[int, ndim=1] a_indptr,
-	np.ndarray[int, ndim=1] a_indices,
-	np.ndarray[float_ft, ndim=1] a_data,
-	np.ndarray[int, ndim=1] b_indptr,
-	np.ndarray[int, ndim=1] b_indices,
-	np.ndarray[float_ft, ndim=1] b_data,
-	int ntop,
-	float_ft lower_bound,
-	np.ndarray[int, ndim=1] c_indptr,
-	np.ndarray[int, ndim=1] c_indices,
-	np.ndarray[float_ft, ndim=1] c_data
-):
-	"""
-	Cython glue function to call sparse_dot_topn C++ implementation
-	This function will return a matrix C in CSR format, where
-	C = [sorted top n results and results > lower_bound for each row of A * B]
-
-	Input:
-		n_row: number of rows of A matrix
-		n_col: number of columns of B matrix
-
-		a_indptr, a_indices, a_data: CSR expression of A matrix
-		b_indptr, b_indices, b_data: CSR expression of B matrix
-
-		ntop: n top results
-		lower_bound: a threshold that the element of A*B must greater than
-
-	Output by reference:
-		c_indptr, c_indices, c_data: CSR expression of C matrix
-
-	N.B. A and B must be CSR format!!!
-		 The type of input numpy array must be aligned with types of C++ function arguments!
-	"""
-
-	cdef int* Ap = &a_indptr[0]
-	cdef int* Aj = &a_indices[0]
-	cdef float_ft* Ax = &a_data[0]
-	cdef int* Bp = &b_indptr[0]
-	cdef int* Bj = &b_indices[0]
-	cdef float_ft* Bx = &b_data[0]
-	cdef int* Cp = &c_indptr[0]
-	cdef int* Cj = &c_indices[0]
-	cdef float_ft* Cx = &c_data[0]
-
-	sparse_dot_topn_source(
-		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound, Cp, Cj, Cx
-	)
-	return
-
-cpdef sparse_dot_topn_extd(
-	int n_row,
-	int n_col,
-	np.ndarray[int, ndim=1] a_indptr,
-	np.ndarray[int, ndim=1] a_indices,
-	np.ndarray[float_ft, ndim=1] a_data,
-	np.ndarray[int, ndim=1] b_indptr,
-	np.ndarray[int, ndim=1] b_indices,
-	np.ndarray[float_ft, ndim=1] b_data,
-	int ntop,
-	float_ft lower_bound,
-	np.ndarray[int, ndim=1] c_indptr,
-	np.ndarray[int, ndim=1] c_indices,
-	np.ndarray[float_ft, ndim=1] c_data,
-	np.ndarray[int, ndim=1] nminmax
-):
-	"""
-	Cython glue function to call sparse_dot_topn_extd C++
-	implementation.  This function will return a matrix C in CSR
-	format, where
-	C = [sorted top n results > lower_bound for each row of A * B]
-	The maximum number nminmax of elements per row of C (assuming 
-	n = number of columns of B) is also returned.
-
-	Input:
-		n_row: number of rows of A matrix
-		n_col: number of columns of B matrix
-
-		a_indptr, a_indices, a_data: CSR expression of A matrix
-		b_indptr, b_indices, b_data: CSR expression of B matrix
-
-		ntop: n, the number of topmost results > lower_bound for
-			  each row of C
-		lower_bound: a threshold that the element of A*B must
-					 greater than
-
-	Output by reference:
-		c_indptr, c_indices, c_data: CSR expression of matrix C
-		nminmax: The maximum number of elements per row of C 
-				 (assuming ntop = n_col)
-
-	Returned output:
-		c_indices, c_data: CSR expression of matrix C.  These will 
-						be returned instead of output by reference
-						if the preset sizes of c_indices and 
-						c_data are too small to hold all the 
-						results.
-
-	N.B. A and B must be CSR format!!!
-		 The type of input numpy array must be aligned with types
-		 of C++ function arguments!
-	"""
-
-	cdef int* Ap = &a_indptr[0]
-	cdef int* Aj = &a_indices[0]
-	cdef float_ft* Ax = &a_data[0]
-	cdef int* Bp = &b_indptr[0]
-	cdef int* Bj = &b_indices[0]
-	cdef float_ft* Bx = &b_data[0]
-	cdef int* Cp = &c_indptr[0]
-	cdef int* Cj = &c_indices[0]
-	cdef float_ft* Cx = &c_data[0]
-	cdef int* n_minmax = &nminmax[0]
-	
-	cdef nnz_max = len(c_indices)
-	
-	cdef vector[int] vCj;
-	cdef vector[float_ft] vCx;
-
-	cdef int nnz_max_is_too_small = sparse_dot_topn_extd_source(
-		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound, Cp, Cj, Cx, &vCj, &vCx, nnz_max, n_minmax
-	)
-	
-	if nnz_max_is_too_small:
-		
-		# raise Exception("In sparse_dot_topn.pyx")
-		
-		c_indices = np.asarray(ArrayWrapper_int(vCj)).squeeze(axis=0)
-		c_data = np.asarray(ArrayWrapper_template(vCx)).squeeze(axis=0)
-	
-		return c_indices, c_data		
-	
-	else:
-		
-		return None, None
-
-cpdef sparse_dot_only_nnz(
-	int n_row,
-	int n_col,
-	np.ndarray[int, ndim=1] a_indptr,
-	np.ndarray[int, ndim=1] a_indices,
-	np.ndarray[float_ft, ndim=1] a_data,
-	np.ndarray[int, ndim=1] b_indptr,
-	np.ndarray[int, ndim=1] b_indices,
-	np.ndarray[float_ft, ndim=1] b_data,
-	int ntop,
-	float_ft lower_bound
-):
-	"""
-	Cython glue function to call sparse_dot_nnz_only C++ implementation
-	This function will return nnz, the total number of nonzero
-	matrix-components of
-	C = [top n results > lower_bound for each row of A * B].
-
-	Input:
-		a_indptr, a_indices, a_data: CSR expression of A matrix
-		b_indptr, b_indices, b_data: CSR expression of B matrix
-
-		ntop: n, the number of topmost results > lower_bound for 
-			  each row of C
-		lower_bound: a threshold that the element of A*B must 
-					 greater than
-
-	Returned output:
-		nnz: the total number of nonzero matrix-components of C
-
-	N.B. A and B must be CSR format!!!
-		 The type of input numpy array must be aligned with types of C++ function arguments!
-	"""
-
-	cdef int* Ap = &a_indptr[0]
-	cdef int* Aj = &a_indices[0]
-	cdef float_ft* Ax = &a_data[0]
-	cdef int* Bp = &b_indptr[0]
-	cdef int* Bj = &b_indices[0]
-	cdef float_ft* Bx = &b_data[0]
-
-	return sparse_dot_only_nnz_source(
-		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound
-	)
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at#
+#	http://www.apache.org/licenses/LICENSE-2.0#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Author: Zhe Sun, Ahmet Erdem
+# April 20, 2017
+# Modified by: Particular Miner
+# April 14, 2021
+
+# distutils: language = c++
+
+from libcpp.vector cimport vector
+from array_wrappers cimport ArrayWrapper_int, ArrayWrapper_float, ArrayWrapper_double
+
+cimport cython
+cimport numpy as np
+import numpy as np
+
+np.import_array()
+
+
+ctypedef fused  float_ft:
+	cython.float
+	cython.double
+
+
+cdef extern from "sparse_dot_topn_source.h":
+
+	cdef void sparse_dot_topn_source[T](
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[],
+		int Bp[],
+		int Bj[],
+		T Bx[],
+		int topn,
+		T lower_bound,
+		int Cp[],
+		int Cj[],
+		T Cx[]
+	) except +;
+
+	cdef int sparse_dot_topn_extd_source[T](
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[],
+		int Bp[],
+		int Bj[],
+		T Bx[],
+		int topn,
+		T lower_bound,
+		int Cp[],
+		int Cj[],
+		T Cx[],
+		vector[int]* alt_Cj,
+		vector[T]* alt_Cx,
+		int nnz_max,
+		int* nminmax
+	) except +;
+
+	cdef int sparse_dot_only_nnz_source[T](
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[],
+		int Bp[],
+		int Bj[],
+		T Bx[],
+		int ntop,
+		T lower_bound
+	) except +;
+
+cpdef ArrayWrapper_template(vector[float_ft] vCx):
+	# raise Exception("In sparse_dot_topn.pyx")
+	if float_ft is float:
+		return ArrayWrapper_float(vCx)
+	elif float_ft is double:
+		return ArrayWrapper_double(vCx)
+	else:
+		raise Exception("Type not supported")
+
+cpdef sparse_dot_topn(
+	int n_row,
+	int n_col,
+	np.ndarray[int, ndim=1] a_indptr,
+	np.ndarray[int, ndim=1] a_indices,
+	np.ndarray[float_ft, ndim=1] a_data,
+	np.ndarray[int, ndim=1] b_indptr,
+	np.ndarray[int, ndim=1] b_indices,
+	np.ndarray[float_ft, ndim=1] b_data,
+	int ntop,
+	float_ft lower_bound,
+	np.ndarray[int, ndim=1] c_indptr,
+	np.ndarray[int, ndim=1] c_indices,
+	np.ndarray[float_ft, ndim=1] c_data
+):
+	"""
+	Cython glue function to call sparse_dot_topn C++ implementation
+	This function will return a matrix C in CSR format, where
+	C = [sorted top n results and results > lower_bound for each row of A * B]
+
+	Input:
+		n_row: number of rows of A matrix
+		n_col: number of columns of B matrix
+
+		a_indptr, a_indices, a_data: CSR expression of A matrix
+		b_indptr, b_indices, b_data: CSR expression of B matrix
+
+		ntop: n top results
+		lower_bound: a threshold that the element of A*B must greater than
+
+	Output by reference:
+		c_indptr, c_indices, c_data: CSR expression of C matrix
+
+	N.B. A and B must be CSR format!!!
+		 The type of input numpy array must be aligned with types of C++ function arguments!
+	"""
+
+	cdef int* Ap = &a_indptr[0]
+	cdef int* Aj = &a_indices[0]
+	cdef float_ft* Ax = &a_data[0]
+	cdef int* Bp = &b_indptr[0]
+	cdef int* Bj = &b_indices[0]
+	cdef float_ft* Bx = &b_data[0]
+	cdef int* Cp = &c_indptr[0]
+	cdef int* Cj = &c_indices[0]
+	cdef float_ft* Cx = &c_data[0]
+
+	sparse_dot_topn_source(
+		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound, Cp, Cj, Cx
+	)
+	return
+
+cpdef sparse_dot_topn_extd(
+	int n_row,
+	int n_col,
+	np.ndarray[int, ndim=1] a_indptr,
+	np.ndarray[int, ndim=1] a_indices,
+	np.ndarray[float_ft, ndim=1] a_data,
+	np.ndarray[int, ndim=1] b_indptr,
+	np.ndarray[int, ndim=1] b_indices,
+	np.ndarray[float_ft, ndim=1] b_data,
+	int ntop,
+	float_ft lower_bound,
+	np.ndarray[int, ndim=1] c_indptr,
+	np.ndarray[int, ndim=1] c_indices,
+	np.ndarray[float_ft, ndim=1] c_data,
+	np.ndarray[int, ndim=1] nminmax
+):
+	"""
+	Cython glue function to call sparse_dot_topn_extd C++
+	implementation.  This function will return a matrix C in CSR
+	format, where
+	C = [sorted top n results > lower_bound for each row of A * B]
+	The maximum number nminmax of elements per row of C (assuming 
+	n = number of columns of B) is also returned.
+
+	Input:
+		n_row: number of rows of A matrix
+		n_col: number of columns of B matrix
+
+		a_indptr, a_indices, a_data: CSR expression of A matrix
+		b_indptr, b_indices, b_data: CSR expression of B matrix
+
+		ntop: n, the number of topmost results > lower_bound for
+			  each row of C
+		lower_bound: a threshold that the element of A*B must
+					 greater than
+
+	Output by reference:
+		c_indptr, c_indices, c_data: CSR expression of matrix C
+		nminmax: The maximum number of elements per row of C 
+				 (assuming ntop = n_col)
+
+	Returned output:
+		c_indices, c_data: CSR expression of matrix C.  These will 
+						be returned instead of output by reference
+						if the preset sizes of c_indices and 
+						c_data are too small to hold all the 
+						results.
+
+	N.B. A and B must be CSR format!!!
+		 The type of input numpy array must be aligned with types
+		 of C++ function arguments!
+	"""
+
+	cdef int* Ap = &a_indptr[0]
+	cdef int* Aj = &a_indices[0]
+	cdef float_ft* Ax = &a_data[0]
+	cdef int* Bp = &b_indptr[0]
+	cdef int* Bj = &b_indices[0]
+	cdef float_ft* Bx = &b_data[0]
+	cdef int* Cp = &c_indptr[0]
+	cdef int* Cj = &c_indices[0]
+	cdef float_ft* Cx = &c_data[0]
+	cdef int* n_minmax = &nminmax[0]
+	
+	cdef nnz_max = len(c_indices)
+	
+	cdef vector[int] vCj;
+	cdef vector[float_ft] vCx;
+
+	cdef int nnz_max_is_too_small = sparse_dot_topn_extd_source(
+		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound, Cp, Cj, Cx, &vCj, &vCx, nnz_max, n_minmax
+	)
+	
+	if nnz_max_is_too_small:
+		
+		# raise Exception("In sparse_dot_topn.pyx")
+		
+		c_indices = np.asarray(ArrayWrapper_int(vCj)).squeeze(axis=0)
+		c_data = np.asarray(ArrayWrapper_template(vCx)).squeeze(axis=0)
+	
+		return c_indices, c_data		
+	
+	else:
+		
+		return None, None
+
+cpdef sparse_dot_only_nnz(
+	int n_row,
+	int n_col,
+	np.ndarray[int, ndim=1] a_indptr,
+	np.ndarray[int, ndim=1] a_indices,
+	np.ndarray[float_ft, ndim=1] a_data,
+	np.ndarray[int, ndim=1] b_indptr,
+	np.ndarray[int, ndim=1] b_indices,
+	np.ndarray[float_ft, ndim=1] b_data,
+	int ntop,
+	float_ft lower_bound
+):
+	"""
+	Cython glue function to call sparse_dot_nnz_only C++ implementation
+	This function will return nnz, the total number of nonzero
+	matrix-components of
+	C = [top n results > lower_bound for each row of A * B].
+
+	Input:
+		a_indptr, a_indices, a_data: CSR expression of A matrix
+		b_indptr, b_indices, b_data: CSR expression of B matrix
+
+		ntop: n, the number of topmost results > lower_bound for 
+			  each row of C
+		lower_bound: a threshold that the element of A*B must 
+					 greater than
+
+	Returned output:
+		nnz: the total number of nonzero matrix-components of C
+
+	N.B. A and B must be CSR format!!!
+		 The type of input numpy array must be aligned with types of C++ function arguments!
+	"""
+
+	cdef int* Ap = &a_indptr[0]
+	cdef int* Aj = &a_indices[0]
+	cdef float_ft* Ax = &a_data[0]
+	cdef int* Bp = &b_indptr[0]
+	cdef int* Bj = &b_indices[0]
+	cdef float_ft* Bx = &b_data[0]
+
+	return sparse_dot_only_nnz_source(
+		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound
+	)
```

## sparse_dot_topn/sparse_dot_topn_parallel.h

 * *Ordering differences only*

```diff
@@ -1,81 +1,81 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Author: Zhe Sun, Ahmet Erdem
-// April 20, 2017
-// Modified by: Particular Miner
-// April 14, 2021
-
-#ifndef UTILS_CPPCLASS_H
-#define UTILS_CPPCLASS_H
-
-template<typename T>
-extern void sparse_dot_topn_parallel(
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[],
-		int Bp[],
-		int Bj[],
-		T Bx[],
-		int ntop,
-		T lower_bound,
-		int Cp[],
-		int Cj[],
-		T Cx[],
-		int n_jobs
-);
-
-template<typename T>
-extern int sparse_dot_topn_extd_parallel(
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[],
-		int Bp[],
-		int Bj[],
-		T Bx[],
-		int ntop,
-		T lower_bound,
-		int Cp[],
-		int Cj[],
-		T Cx[],
-		std::vector<int>* alt_Cj,
-		std::vector<T>* alt_Cx,
-		int nnz_max,
-		int* n_minmax,
-		int n_jobs
-);
-
-template<typename T>
-extern int sparse_dot_only_nnz_parallel(
-	int n_row,
-	int n_col,
-	int Ap[],
-	int Aj[],
-	T Ax[],
-	int Bp[],
-	int Bj[],
-	T Bx[],
-	int ntop,
-	T lower_bound,
-	int n_jobs
-);
-
-#endif //UTILS_CPPCLASS_H
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Author: Zhe Sun, Ahmet Erdem
+// April 20, 2017
+// Modified by: Particular Miner
+// April 14, 2021
+
+#ifndef UTILS_CPPCLASS_H
+#define UTILS_CPPCLASS_H
+
+template<typename T>
+extern void sparse_dot_topn_parallel(
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[],
+		int Bp[],
+		int Bj[],
+		T Bx[],
+		int ntop,
+		T lower_bound,
+		int Cp[],
+		int Cj[],
+		T Cx[],
+		int n_jobs
+);
+
+template<typename T>
+extern int sparse_dot_topn_extd_parallel(
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[],
+		int Bp[],
+		int Bj[],
+		T Bx[],
+		int ntop,
+		T lower_bound,
+		int Cp[],
+		int Cj[],
+		T Cx[],
+		std::vector<int>* alt_Cj,
+		std::vector<T>* alt_Cx,
+		int nnz_max,
+		int* n_minmax,
+		int n_jobs
+);
+
+template<typename T>
+extern int sparse_dot_only_nnz_parallel(
+	int n_row,
+	int n_col,
+	int Ap[],
+	int Aj[],
+	T Ax[],
+	int Bp[],
+	int Bj[],
+	T Bx[],
+	int ntop,
+	T lower_bound,
+	int n_jobs
+);
+
+#endif //UTILS_CPPCLASS_H
```

## sparse_dot_topn/sparse_dot_topn_source.h

 * *Ordering differences only*

```diff
@@ -1,90 +1,90 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Author: Zhe Sun, Ahmet Erdem
-// April 20, 2017
-// Modified by: Particular Miner
-// April 14, 2021
-
-#ifndef UTILS_CPPCLASS_H
-#define UTILS_CPPCLASS_H
-
-template<typename T>
-struct Candidate {
-	int index;
-	T value;
-
-	bool operator<(const Candidate& a) const
-    {
-        return a.value < value;
-    }
-	
-};
-
-template<typename T>
-extern void sparse_dot_topn_source(
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[],	//data of A
-		int Bp[],
-		int Bj[],
-		T Bx[],	//data of B
-		int ntop,
-		T lower_bound,
-		int Cp[],
-		int Cj[],
-		T Cx[]		//data of C
-);
-
-template<typename T>
-extern int sparse_dot_topn_extd_source(
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[],	//data of A
-		int Bp[],
-		int Bj[],
-		T Bx[],	//data of B
-		int ntop,
-		T lower_bound,
-		int Cp[],
-		int Cj[],
-		T Cx[], 	//data of C
-		std::vector<int>* alt_Cj,
-		std::vector<T>* alt_Cx,
-		int nnz_max,
-		int* n_minmax
-);
-
-template<typename T>
-extern int sparse_dot_only_nnz_source(
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[], //data of A
-		int Bp[],
-		int Bj[],
-		T Bx[], //data of B
-		int ntop,
-		T lower_bound
-);
-
-#endif //UTILS_CPPCLASS_H
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Author: Zhe Sun, Ahmet Erdem
+// April 20, 2017
+// Modified by: Particular Miner
+// April 14, 2021
+
+#ifndef UTILS_CPPCLASS_H
+#define UTILS_CPPCLASS_H
+
+template<typename T>
+struct Candidate {
+	int index;
+	T value;
+
+	bool operator<(const Candidate& a) const
+    {
+        return a.value < value;
+    }
+	
+};
+
+template<typename T>
+extern void sparse_dot_topn_source(
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[],	//data of A
+		int Bp[],
+		int Bj[],
+		T Bx[],	//data of B
+		int ntop,
+		T lower_bound,
+		int Cp[],
+		int Cj[],
+		T Cx[]		//data of C
+);
+
+template<typename T>
+extern int sparse_dot_topn_extd_source(
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[],	//data of A
+		int Bp[],
+		int Bj[],
+		T Bx[],	//data of B
+		int ntop,
+		T lower_bound,
+		int Cp[],
+		int Cj[],
+		T Cx[], 	//data of C
+		std::vector<int>* alt_Cj,
+		std::vector<T>* alt_Cx,
+		int nnz_max,
+		int* n_minmax
+);
+
+template<typename T>
+extern int sparse_dot_only_nnz_source(
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[], //data of A
+		int Bp[],
+		int Bj[],
+		T Bx[], //data of B
+		int ntop,
+		T lower_bound
+);
+
+#endif //UTILS_CPPCLASS_H
```

## sparse_dot_topn/sparse_dot_topn_threaded.pyx

 * *Ordering differences only*

```diff
@@ -1,207 +1,207 @@
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.
-# The ASF licenses this file to You under the Apache License, Version 2.0
-# (the "License"); you may not use this file except in compliance with
-# the License.  You may obtain a copy of the License at#
-#	http://www.apache.org/licenses/LICENSE-2.0#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Author: Zhe Sun, Ahmet Erdem
-# April 20, 2017
-# Modified by: Particular Miner
-# April 14, 2021
-
-# distutils: language = c++
-
-from libcpp.vector cimport vector
-from array_wrappers cimport ArrayWrapper_int, ArrayWrapper_float, ArrayWrapper_double
-
-cimport cython
-cimport numpy as np
-import numpy as np
-
-
-np.import_array()
-
-
-ctypedef fused  float_ft:
-	cython.float
-	cython.double
-
-
-cdef extern from "sparse_dot_topn_parallel.h":
-
-	cdef void sparse_dot_topn_parallel[T](
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[],
-		int Bp[],
-		int Bj[],
-		T Bx[],
-		int topn,
-		T lower_bound,
-		int Cp[],
-		int Cj[],
-		T Cx[],
-		int n_jobs
-	) except +;
-
-	cdef int sparse_dot_topn_extd_parallel[T](
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[],
-		int Bp[],
-		int Bj[],
-		T Bx[],
-		int topn,
-		T lower_bound,
-		int Cp[],
-		int Cj[],
-		T Cx[],
-		vector[int]* alt_Cj,
-		vector[T]* alt_Cx,
-		int nnz_max,
-		int* n_minmax,
-		int n_jobs
-	) except +;
-
-	cdef int sparse_dot_only_nnz_parallel[T](
-		int n_row,
-		int n_col,
-		int Ap[],
-		int Aj[],
-		T Ax[],
-		int Bp[],
-		int Bj[],
-		T Bx[],
-		int ntop,
-		T lower_bound,
-		int n_jobs
-	) except +;
-
-cpdef sparse_dot_topn_threaded(
-	int n_row,
-	int n_col,
-	np.ndarray[int, ndim=1] a_indptr,
-	np.ndarray[int, ndim=1] a_indices,
-	np.ndarray[float_ft, ndim=1] a_data,
-	np.ndarray[int, ndim=1] b_indptr,
-	np.ndarray[int, ndim=1] b_indices,
-	np.ndarray[float_ft, ndim=1] b_data,
-	int ntop,
-	float_ft lower_bound,
-	np.ndarray[int, ndim=1] c_indptr,
-	np.ndarray[int, ndim=1] c_indices,
-	np.ndarray[float_ft, ndim=1] c_data,
-	int n_jobs
-):
-
-	cdef int* Ap = &a_indptr[0]
-	cdef int* Aj = &a_indices[0]
-	cdef float_ft* Ax = &a_data[0]
-	cdef int* Bp = &b_indptr[0]
-	cdef int* Bj = &b_indices[0]
-	cdef float_ft* Bx = &b_data[0]
-	cdef int* Cp = &c_indptr[0]
-	cdef int* Cj = &c_indices[0]
-	cdef float_ft* Cx = &c_data[0]
-
-	sparse_dot_topn_parallel(
-		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound, Cp, Cj, Cx, n_jobs
-	)
-	return
-
-cpdef ArrayWrapper_template(vector[float_ft] vCx):
-	# raise Exception("In sparse_dot_topn_threaded.pyx")
-	if float_ft is float:
-		return ArrayWrapper_float(vCx)
-	elif float_ft is double:
-		return ArrayWrapper_double(vCx)
-	else:
-		raise Exception("Type not supported")
-
-cpdef sparse_dot_topn_extd_threaded(
-	int n_row,
-	int n_col,
-	np.ndarray[int, ndim=1] a_indptr,
-	np.ndarray[int, ndim=1] a_indices,
-	np.ndarray[float_ft, ndim=1] a_data,
-	np.ndarray[int, ndim=1] b_indptr,
-	np.ndarray[int, ndim=1] b_indices,
-	np.ndarray[float_ft, ndim=1] b_data,
-	int ntop,
-	float_ft lower_bound,
-	np.ndarray[int, ndim=1] c_indptr,
-	np.ndarray[int, ndim=1] c_indices,
-	np.ndarray[float_ft, ndim=1] c_data,
-	np.ndarray[int, ndim=1] nminmax,
-	int n_jobs
-):
-
-	cdef int* Ap = &a_indptr[0]
-	cdef int* Aj = &a_indices[0]
-	cdef float_ft* Ax = &a_data[0]
-	cdef int* Bp = &b_indptr[0]
-	cdef int* Bj = &b_indices[0]
-	cdef float_ft* Bx = &b_data[0]
-	cdef int* Cp = &c_indptr[0]
-	cdef int* Cj = &c_indices[0]
-	cdef float_ft* Cx = &c_data[0]
-	cdef int* n_minmax = &nminmax[0]
-	
-	cdef nnz_max = len(c_indices)
-	
-	cdef vector[int] vCj;
-	cdef vector[float_ft] vCx;
-
-	cdef int nnz_max_is_too_small = sparse_dot_topn_extd_parallel(
-		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound, Cp, Cj, Cx, &vCj, &vCx, nnz_max, n_minmax, n_jobs
-	)
-	
-	if nnz_max_is_too_small:
-		
-		# raise Exception("In sparse_dot_topn_threaded.pyx")
-		
-		c_indices = np.asarray(ArrayWrapper_int(vCj)).squeeze(axis=0)
-		c_data = np.asarray(ArrayWrapper_template(vCx)).squeeze(axis=0)
-	
-		return c_indices, c_data
-	
-	else:
-		
-		return None, None
-
-cpdef sparse_dot_only_nnz_threaded(
-	int n_row,
-	int n_col,
-	np.ndarray[int, ndim=1] a_indptr,
-	np.ndarray[int, ndim=1] a_indices,
-	np.ndarray[float_ft, ndim=1] a_data,
-	np.ndarray[int, ndim=1] b_indptr,
-	np.ndarray[int, ndim=1] b_indices,
-	np.ndarray[float_ft, ndim=1] b_data,
-	int ntop,
-	float_ft lower_bound,
-	int n_jobs
-):
-
-	cdef int* Ap = &a_indptr[0]
-	cdef int* Aj = &a_indices[0]
-	cdef float_ft* Ax = &a_data[0]
-	cdef int* Bp = &b_indptr[0]
-	cdef int* Bj = &b_indices[0]
-	cdef float_ft* Bx = &b_data[0]
-
-	return sparse_dot_only_nnz_parallel(
-		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound, n_jobs
-	)
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at#
+#	http://www.apache.org/licenses/LICENSE-2.0#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Author: Zhe Sun, Ahmet Erdem
+# April 20, 2017
+# Modified by: Particular Miner
+# April 14, 2021
+
+# distutils: language = c++
+
+from libcpp.vector cimport vector
+from array_wrappers cimport ArrayWrapper_int, ArrayWrapper_float, ArrayWrapper_double
+
+cimport cython
+cimport numpy as np
+import numpy as np
+
+
+np.import_array()
+
+
+ctypedef fused  float_ft:
+	cython.float
+	cython.double
+
+
+cdef extern from "sparse_dot_topn_parallel.h":
+
+	cdef void sparse_dot_topn_parallel[T](
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[],
+		int Bp[],
+		int Bj[],
+		T Bx[],
+		int topn,
+		T lower_bound,
+		int Cp[],
+		int Cj[],
+		T Cx[],
+		int n_jobs
+	) except +;
+
+	cdef int sparse_dot_topn_extd_parallel[T](
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[],
+		int Bp[],
+		int Bj[],
+		T Bx[],
+		int topn,
+		T lower_bound,
+		int Cp[],
+		int Cj[],
+		T Cx[],
+		vector[int]* alt_Cj,
+		vector[T]* alt_Cx,
+		int nnz_max,
+		int* n_minmax,
+		int n_jobs
+	) except +;
+
+	cdef int sparse_dot_only_nnz_parallel[T](
+		int n_row,
+		int n_col,
+		int Ap[],
+		int Aj[],
+		T Ax[],
+		int Bp[],
+		int Bj[],
+		T Bx[],
+		int ntop,
+		T lower_bound,
+		int n_jobs
+	) except +;
+
+cpdef sparse_dot_topn_threaded(
+	int n_row,
+	int n_col,
+	np.ndarray[int, ndim=1] a_indptr,
+	np.ndarray[int, ndim=1] a_indices,
+	np.ndarray[float_ft, ndim=1] a_data,
+	np.ndarray[int, ndim=1] b_indptr,
+	np.ndarray[int, ndim=1] b_indices,
+	np.ndarray[float_ft, ndim=1] b_data,
+	int ntop,
+	float_ft lower_bound,
+	np.ndarray[int, ndim=1] c_indptr,
+	np.ndarray[int, ndim=1] c_indices,
+	np.ndarray[float_ft, ndim=1] c_data,
+	int n_jobs
+):
+
+	cdef int* Ap = &a_indptr[0]
+	cdef int* Aj = &a_indices[0]
+	cdef float_ft* Ax = &a_data[0]
+	cdef int* Bp = &b_indptr[0]
+	cdef int* Bj = &b_indices[0]
+	cdef float_ft* Bx = &b_data[0]
+	cdef int* Cp = &c_indptr[0]
+	cdef int* Cj = &c_indices[0]
+	cdef float_ft* Cx = &c_data[0]
+
+	sparse_dot_topn_parallel(
+		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound, Cp, Cj, Cx, n_jobs
+	)
+	return
+
+cpdef ArrayWrapper_template(vector[float_ft] vCx):
+	# raise Exception("In sparse_dot_topn_threaded.pyx")
+	if float_ft is float:
+		return ArrayWrapper_float(vCx)
+	elif float_ft is double:
+		return ArrayWrapper_double(vCx)
+	else:
+		raise Exception("Type not supported")
+
+cpdef sparse_dot_topn_extd_threaded(
+	int n_row,
+	int n_col,
+	np.ndarray[int, ndim=1] a_indptr,
+	np.ndarray[int, ndim=1] a_indices,
+	np.ndarray[float_ft, ndim=1] a_data,
+	np.ndarray[int, ndim=1] b_indptr,
+	np.ndarray[int, ndim=1] b_indices,
+	np.ndarray[float_ft, ndim=1] b_data,
+	int ntop,
+	float_ft lower_bound,
+	np.ndarray[int, ndim=1] c_indptr,
+	np.ndarray[int, ndim=1] c_indices,
+	np.ndarray[float_ft, ndim=1] c_data,
+	np.ndarray[int, ndim=1] nminmax,
+	int n_jobs
+):
+
+	cdef int* Ap = &a_indptr[0]
+	cdef int* Aj = &a_indices[0]
+	cdef float_ft* Ax = &a_data[0]
+	cdef int* Bp = &b_indptr[0]
+	cdef int* Bj = &b_indices[0]
+	cdef float_ft* Bx = &b_data[0]
+	cdef int* Cp = &c_indptr[0]
+	cdef int* Cj = &c_indices[0]
+	cdef float_ft* Cx = &c_data[0]
+	cdef int* n_minmax = &nminmax[0]
+	
+	cdef nnz_max = len(c_indices)
+	
+	cdef vector[int] vCj;
+	cdef vector[float_ft] vCx;
+
+	cdef int nnz_max_is_too_small = sparse_dot_topn_extd_parallel(
+		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound, Cp, Cj, Cx, &vCj, &vCx, nnz_max, n_minmax, n_jobs
+	)
+	
+	if nnz_max_is_too_small:
+		
+		# raise Exception("In sparse_dot_topn_threaded.pyx")
+		
+		c_indices = np.asarray(ArrayWrapper_int(vCj)).squeeze(axis=0)
+		c_data = np.asarray(ArrayWrapper_template(vCx)).squeeze(axis=0)
+	
+		return c_indices, c_data
+	
+	else:
+		
+		return None, None
+
+cpdef sparse_dot_only_nnz_threaded(
+	int n_row,
+	int n_col,
+	np.ndarray[int, ndim=1] a_indptr,
+	np.ndarray[int, ndim=1] a_indices,
+	np.ndarray[float_ft, ndim=1] a_data,
+	np.ndarray[int, ndim=1] b_indptr,
+	np.ndarray[int, ndim=1] b_indices,
+	np.ndarray[float_ft, ndim=1] b_data,
+	int ntop,
+	float_ft lower_bound,
+	int n_jobs
+):
+
+	cdef int* Ap = &a_indptr[0]
+	cdef int* Aj = &a_indices[0]
+	cdef float_ft* Ax = &a_data[0]
+	cdef int* Bp = &b_indptr[0]
+	cdef int* Bj = &b_indices[0]
+	cdef float_ft* Bx = &b_data[0]
+
+	return sparse_dot_only_nnz_parallel(
+		n_row, n_col, Ap, Aj, Ax, Bp, Bj, Bx, ntop, lower_bound, n_jobs
+	)
```

## Comparing `sparse_dot_topn-0.3.4.dist-info/LICENSE` & `sparse_dot_topn-0.3.5.dist-info/LICENSE`

 * *Ordering differences only*

 * *Files 9% similar despite different names*

```diff
@@ -1,201 +1,201 @@
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "{}"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright 2017, ING Wholesale Banking Advanced Analytics Team
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "{}"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright 2017, ING Wholesale Banking Advanced Analytics Team
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
    limitations under the License.
```

## Comparing `sparse_dot_topn-0.3.4.dist-info/METADATA` & `sparse_dot_topn-0.3.5.dist-info/METADATA`

 * *Files 13% similar despite different names*

```diff
@@ -1,98 +1,97 @@
-Metadata-Version: 2.1
-Name: sparse-dot-topn
-Version: 0.3.4
-Summary: This package boosts a sparse matrix multiplication followed by selecting the top-n multiplication
-Home-page: https://github.com/ing-bank/sparse_dot_topn
-Author: Zhe Sun
-Author-email: ymwdalex@gmail.com
-License: Apache 2.0
-Keywords: cosine-similarity sparse-matrix scipy cython
-Platform: UNKNOWN
-Description-Content-Type: text/markdown
-License-File: LICENSE
-Requires-Dist: numpy (>=1.14.5)
-Requires-Dist: scipy (>=1.2.3)
-
-# sparse\_dot\_topn: 
-
-**sparse\_dot\_topn** provides a fast way to performing a sparse matrix multiplication followed by top-n multiplication result selection.
-
-Comparing very large feature vectors and picking the best matches, in practice often results in performing a sparse matrix multiplication followed by selecting the top-n multiplication results. In this package, we implement a customized Cython function for this purpose. When comparing our Cythonic approach to doing the same use with SciPy and NumPy functions, **our approach improves the speed by about 40% and reduces memory consumption.**
-
-This package is made by ING Wholesale Banking Advanced Analytics team. This [blog](https://medium.com/@ingwbaa/https-medium-com-ingwbaa-boosting-selection-of-the-most-similar-entities-in-large-scale-datasets-450b3242e618) or this [blog](https://www.sun-analytics.nl/posts/2017-07-26-boosting-selection-of-most-similar-entities-in-large-scale-datasets/) explains how we implement it.
-
-## Example
-``` python
-import numpy as np
-from scipy.sparse import csr_matrix
-from scipy.sparse import rand
-from sparse_dot_topn import awesome_cossim_topn
-
-N = 10
-a = rand(100, 1000000, density=0.005, format='csr')
-b = rand(1000000, 200, density=0.005, format='csr')
-
-# Default precision type is np.float64, but you can down cast to have a small memory footprint and faster execution
-# Remark : These are the only 2 types supported now, since we assume that float16 will be difficult to implement and will be slower, because C doesn't support a 16-bit float type on most PCs
-a = a.astype(np.float32)
-b = b.astype(np.float32)
-
-# Use standard implementation
-c = awesome_cossim_topn(a, b, N, 0.01)
-
-# Use parallel implementation with 4 threads
-d = awesome_cossim_topn(a, b, N, 0.01, use_threads=True, n_jobs=4)
-
-# Use standard implementation with 4 threads and with the computation of best_ntop: the value of ntop needed to capture all results above lower_bound
-d, best_ntop = awesome_cossim_topn(a, b, N, 0.01, use_threads=True, n_jobs=4, return_best_ntop=True)
-```
-
-You can also find code which compares our boosting method with calling scipy+numpy function directly in example/comparison.py
-
-## Dependency and Install
-Install `numpy` and `cython` first before installing this package. Then,
-``` sh
-pip install sparse_dot_topn
-```
-
-From version >=0.3.0, we don't proactively support python 2.7. However, you should still be able to install this package in python 2.7.
-If you encounter gcc compiling issue, please refer these discussions and setup CFLAGS and CXXFLAGS variables
-- https://github.com/ing-bank/sparse_dot_topn/issues/7#issuecomment-695165663
-
-## Uninstall
-``` sh
-pip uninstall sparse_dot_topn
-```
-
-
-## Local development
-
-``` sh
-python setup.py clean --all
-python setup.py develop
-pytest
-```
-
-
-``` sh
-python -m build
-cd dist/
-pip install sparse_dot_topn-*.tar.gz
-```
-
-## Release strategy
-From version 0.3.2, we employ Github Actions to build wheels in different OS and Python environments with cibuildwheel, and release automatically. Hopefully this will solve many issues related to installation. The build and publish pipeline is configured in `./github/workflows/wheels.yml`. When a new release is neeeded, please follow these steps
-
-1. Create a test branch with branch name `test/x.x.x` from main branch.
-2. In `test/x.x.x` branch, update the version number such as `x.x.x.rcx` (e.g. 0.3.4.rc0) in setup.py, and update changelog in CHANGES.md file.
-3. Git push `test/x.x.x` branch, then build and publish pipeline will be triggered automatically. New release will be uploaded in PyPI test [https://test.pypi.org/project/sparse-dot-topn/](https://test.pypi.org/project/sparse-dot-topn/).
-4. Please do a sanity check on PyPI test release.
-5. Update the changelog in CHANGES.md
-6. Create a branch on top of the test branch.
-7. Modify the version number by remove the `rcx` suffix in setup.py.
-8. Git push, then build and publish pipeline will be triggered automatically. New release will be uploaded to PyPI [https://pypi.org/project/sparse-dot-topn](https://pypi.org/project/sparse-dot-topn/)
-9. Merge the release branch back to master
-
-
-
-
+Metadata-Version: 2.1
+Name: sparse-dot-topn
+Version: 0.3.5
+Summary: This package boosts a sparse matrix multiplication followed by selecting the top-n multiplication
+Home-page: https://github.com/ing-bank/sparse_dot_topn
+Author: Zhe Sun
+Author-email: ymwdalex@gmail.com
+License: Apache 2.0
+Keywords: cosine-similarity sparse-matrix scipy cython
+Description-Content-Type: text/markdown
+License-File: LICENSE
+Requires-Dist: numpy (>=1.14.5)
+Requires-Dist: scipy (>=1.2.3)
+
+# sparse\_dot\_topn: 
+
+**sparse\_dot\_topn** provides a fast way to performing a sparse matrix multiplication followed by top-n multiplication result selection.
+
+Comparing very large feature vectors and picking the best matches, in practice often results in performing a sparse matrix multiplication followed by selecting the top-n multiplication results. In this package, we implement a customized Cython function for this purpose. When comparing our Cythonic approach to doing the same use with SciPy and NumPy functions, **our approach improves the speed by about 40% and reduces memory consumption.**
+
+This package is made by ING Wholesale Banking Advanced Analytics team. This [blog](https://medium.com/@ingwbaa/https-medium-com-ingwbaa-boosting-selection-of-the-most-similar-entities-in-large-scale-datasets-450b3242e618) or this [blog](https://www.sun-analytics.nl/posts/2017-07-26-boosting-selection-of-most-similar-entities-in-large-scale-datasets/) explains how we implement it.
+
+## Example
+``` python
+import numpy as np
+from scipy.sparse import csr_matrix
+from scipy.sparse import rand
+from sparse_dot_topn import awesome_cossim_topn
+
+N = 10
+a = rand(100, 1000000, density=0.005, format='csr')
+b = rand(1000000, 200, density=0.005, format='csr')
+
+# Default precision type is np.float64, but you can down cast to have a small memory footprint and faster execution
+# Remark : These are the only 2 types supported now, since we assume that float16 will be difficult to implement and will be slower, because C doesn't support a 16-bit float type on most PCs
+a = a.astype(np.float32)
+b = b.astype(np.float32)
+
+# Use standard implementation
+c = awesome_cossim_topn(a, b, N, 0.01)
+
+# Use parallel implementation with 4 threads
+d = awesome_cossim_topn(a, b, N, 0.01, use_threads=True, n_jobs=4)
+
+# Use standard implementation with 4 threads and with the computation of best_ntop: the value of ntop needed to capture all results above lower_bound
+d, best_ntop = awesome_cossim_topn(a, b, N, 0.01, use_threads=True, n_jobs=4, return_best_ntop=True)
+```
+
+You can also find code which compares our boosting method with calling scipy+numpy function directly in example/comparison.py
+
+## Dependency and Install
+Install `numpy` and `cython` first before installing this package. Then,
+``` sh
+pip install sparse_dot_topn
+```
+
+From version >=0.3.0, we don't proactively support python 2.7. However, you should still be able to install this package in python 2.7.
+If you encounter gcc compiling issue, please refer these discussions and setup CFLAGS and CXXFLAGS variables
+- https://github.com/ing-bank/sparse_dot_topn/issues/7#issuecomment-695165663
+
+## Uninstall
+``` sh
+pip uninstall sparse_dot_topn
+```
+
+
+## Local development
+
+``` sh
+python setup.py clean --all
+python setup.py develop
+pytest
+```
+
+
+``` sh
+python -m build
+cd dist/
+pip install sparse_dot_topn-*.tar.gz
+```
+
+## Release strategy
+From version 0.3.2, we employ Github Actions to build wheels in different OS and Python environments with cibuildwheel, and release automatically. Hopefully this will solve many issues related to installation. The build and publish pipeline is configured in `./github/workflows/wheels.yml`. When a new release is neeeded, please follow these steps
+
+1. Create a test branch with branch name `test/x.x.x` from main branch.
+2. In `test/x.x.x` branch, update the version number such as `x.x.x.rcx` (e.g. 0.3.4.rc0) in setup.py, and update changelog in CHANGES.md file.
+3. Git push `test/x.x.x` branch, then build and publish pipeline will be triggered automatically. New release will be uploaded in PyPI test [https://test.pypi.org/project/sparse-dot-topn/](https://test.pypi.org/project/sparse-dot-topn/).
+4. Please do a sanity check on PyPI test release.
+5. Update the changelog in CHANGES.md
+6. Create a branch on top of the test branch.
+7. Modify the version number by remove the `rcx` suffix in setup.py.
+8. Git push, then build and publish pipeline will be triggered automatically. New release will be uploaded to PyPI [https://pypi.org/project/sparse-dot-topn](https://pypi.org/project/sparse-dot-topn/)
+9. Merge the release branch back to master
+
+
+
+
```

## Comparing `sparse_dot_topn-0.3.4.dist-info/RECORD` & `sparse_dot_topn-0.3.5.dist-info/RECORD`

 * *Files 25% similar despite different names*

```diff
@@ -1,18 +1,16 @@
-sparse_dot_topn/__init__.py,sha256=RJOA89-Zm5ZiG5gbk2GCVYSsX0B7cdBdqDXTPLoMBuw,195
-sparse_dot_topn/array_wrappers.cp39-win_amd64.pyd,sha256=8dsR6oi7mUmGnqVPOcDBjKnsXy74zpG-1WwiZd8Z0EE,51200
-sparse_dot_topn/array_wrappers.pxd,sha256=lhUbMlB-T0KCpRweYwovuF2rIcXBcFGahYGk43E-B0M,805
-sparse_dot_topn/array_wrappers.pyx,sha256=MIIlxNH1-G9L_vtm9x7sP3b8kfujE2tJPYrnLmyBxhs,4469
-sparse_dot_topn/awesome_cossim_topn.py,sha256=QCrxEUFmls00A9ci6B-I90IwS0GDblmpUxcepNsK_EM,5010
-sparse_dot_topn/sparse_dot_topn.cp39-win_amd64.pyd,sha256=uY_RyMyNcDPc9xrmKR9odBhw3wyLfHOGH11kmi0WLmc,299520
-sparse_dot_topn/sparse_dot_topn.pyx,sha256=C7kuRgEG38g1krUutA2u95zKUrmZBCwLJU0MtyZMDNk,7683
-sparse_dot_topn/sparse_dot_topn_parallel.cpp,sha256=ISrVrBvpgxsLJVOXa8sf8YwuR6OzeBSVVkByNQSDHp4,17882
-sparse_dot_topn/sparse_dot_topn_parallel.h,sha256=7GXBxrZC6LTeqAvmVQghibRCzAoFdgxQrzUNP0f68tg,1809
-sparse_dot_topn/sparse_dot_topn_source.cpp,sha256=6cvuUGPhN9e78Xt-uoX-ddYupvCwqORfKYze1_wDA-s,13036
-sparse_dot_topn/sparse_dot_topn_source.h,sha256=eTNQAsB3SNlwYlf-jWQxVQVeLKP32w7ue0OoYf68c-w,2034
-sparse_dot_topn/sparse_dot_topn_threaded.cp39-win_amd64.pyd,sha256=geI96W3BFsAinriQ9G2TMMDOAlwll3dUABiCzOwFt4Q,320000
-sparse_dot_topn/sparse_dot_topn_threaded.pyx,sha256=hjsXB8Pg40WEmXzS-9kTXf2kGTmgRuLnMK8s7rUPMzQ,5169
-sparse_dot_topn-0.3.4.dist-info/LICENSE,sha256=GL6evqYczhX6uh8-n6O-txHw4C6Bx1JP7l8ZEujjSCY,11575
-sparse_dot_topn-0.3.4.dist-info/METADATA,sha256=XeER58_dJ4sx_BLE9UQZTHz0l8CxG7UH073eazOG4Ig,4730
-sparse_dot_topn-0.3.4.dist-info/WHEEL,sha256=J_4V_gB-O6Y7Pn6lk91K27JaIhI-q07YM5J8Ufzqla4,100
-sparse_dot_topn-0.3.4.dist-info/top_level.txt,sha256=1Qjv4Rbm7ZEr6nv2x3sUpVNnWAjAPW_U7PNsQLaibWE,16
-sparse_dot_topn-0.3.4.dist-info/RECORD,,
+sparse_dot_topn-0.3.5.dist-info/top_level.txt,sha256=1Qjv4Rbm7ZEr6nv2x3sUpVNnWAjAPW_U7PNsQLaibWE,16
+sparse_dot_topn-0.3.5.dist-info/LICENSE,sha256=YjUMpko6gSoWuX5Q1VvRej9abh7IPmjoIjUa1cQcf-4,11375
+sparse_dot_topn-0.3.5.dist-info/RECORD,,
+sparse_dot_topn-0.3.5.dist-info/WHEEL,sha256=Tdbe_5alpWrQ1YlH4yHHovatN6Y3Is6tEg4PruwoJrc,150
+sparse_dot_topn-0.3.5.dist-info/METADATA,sha256=knrXFzEOYTKO2QYVGauqGkH9Y4JkPigntVsVMEIxTCc,4614
+sparse_dot_topn/awesome_cossim_topn.py,sha256=xDO07DJfnOSxfSVr4xMHy3aVLdVnBvYvQl0LZN49NW4,4870
+sparse_dot_topn/sparse_dot_topn_threaded.cpython-38-aarch64-linux-gnu.so,sha256=I7KBE8jQW9_86R5UKzKU4zXkZvJWGTLwMII3lFo4Opc,4906048
+sparse_dot_topn/sparse_dot_topn.cpython-38-aarch64-linux-gnu.so,sha256=lxosgqwdkkWP2cQ_TcD3vV7yv8DFNeGoWaiCpvud0fc,3263720
+sparse_dot_topn/array_wrappers.pyx,sha256=Tujh0i07r6TJdMNnVo8JUXLjgCSyWzmXYonXpfArDFQ,4360
+sparse_dot_topn/sparse_dot_topn_threaded.pyx,sha256=kTtIpOPt1td5gJFWQma1b0zAWQ4QJgKCp-3-5YPrB0o,4962
+sparse_dot_topn/array_wrappers.cpython-38-aarch64-linux-gnu.so,sha256=xPkh6TQMTNbgbnE8nlNHieE7DyUXhtMETCvKUIODYYs,515000
+sparse_dot_topn/__init__.py,sha256=NrYnwL3BWrW9NQMvkQit7hPiEkFfMbc9ETglbrGiwTA,189
+sparse_dot_topn/sparse_dot_topn_parallel.h,sha256=0Zy6_wZkaGc-s1bxhylKNv3JjtnZfQZO4rGswZSwyfM,1728
+sparse_dot_topn/sparse_dot_topn.pyx,sha256=MM2TuEjW2Iyhz_3PM9oTzo-rofJ1ayEpFS0cBDLY-4o,7405
+sparse_dot_topn/sparse_dot_topn_source.h,sha256=PFT6xpTMw9XPEV7yVl2AcAJ87nYLWz2LprnbZjnhhlI,1944
+sparse_dot_topn/array_wrappers.pxd,sha256=IuOXyYP7AiyRLPwk5flxEZy4zFePh6DlN5_vio8F1LI,782
```

