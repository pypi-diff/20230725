# Comparing `tmp/ark-analysis-0.6.3.tar.gz` & `tmp/ark-analysis-0.6.4.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "ark-analysis-0.6.3.tar", last modified: Fri Mar 24 21:03:08 2023, max compression
+gzip compressed data, was "ark-analysis-0.6.4.tar", last modified: Mon Jul 24 23:33:38 2023, max compression
```

## Comparing `ark-analysis-0.6.3.tar` & `ark-analysis-0.6.4.tar`

### file list

```diff
@@ -1,169 +1,175 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.784135 ark-analysis-0.6.3/
--rw-r--r--   0 runner    (1001) docker     (123)      941 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/.dockerignore
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.756134 ark-analysis-0.6.3/.github/
--rw-r--r--   0 runner    (1001) docker     (123)      416 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/.github/dependabot.yml
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.756134 ark-analysis-0.6.3/.github/workflows/
--rw-r--r--   0 runner    (1001) docker     (123)     1463 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/.github/workflows/build.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1295 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/.github/workflows/ci.yml
--rw-r--r--   0 runner    (1001) docker     (123)     2634 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/.github/workflows/docker.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1891 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/.github/workflows/pypi_publish.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/.github/workflows/release-drafter.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1160 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/.github/workflows/test.yml
--rw-r--r--   0 runner    (1001) docker     (123)      454 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/.gitignore
--rw-r--r--   0 runner    (1001) docker     (123)      157 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/.readthedocs.yml
--rw-r--r--   0 runner    (1001) docker     (123)     1456 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/Dockerfile
--rw-r--r--   0 runner    (1001) docker     (123)    11612 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/LICENSE
--rw-r--r--   0 runner    (1001) docker     (123)    19597 2023-03-24 21:03:08.784135 ark-analysis-0.6.3/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    18953 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/README.md
--rw-r--r--   0 runner    (1001) docker     (123)       53 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/conftest.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.760135 ark-analysis-0.6.3/docs/
--rw-r--r--   0 runner    (1001) docker     (123)      709 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/Makefile
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.760135 ark-analysis-0.6.3/docs/_images/
--rw-r--r--   0 runner    (1001) docker     (123)    77780 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_images/ark_processing.png
--rw-r--r--   0 runner    (1001) docker     (123)   366185 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_images/docker_preferences.png
--rw-r--r--   0 runner    (1001) docker     (123)    70517 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_images/mantis_feature_file.png
--rw-r--r--   0 runner    (1001) docker     (123)   561042 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_images/mantis_feature_view.png
--rw-r--r--   0 runner    (1001) docker     (123)    64589 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_images/mantis_loading.png
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.760135 ark-analysis-0.6.3/docs/_rtd/
--rw-r--r--   0 runner    (1001) docker     (123)     6746 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_rtd/contributing.md
--rw-r--r--   0 runner    (1001) docker     (123)     7204 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_rtd/data_types.md
--rw-r--r--   0 runner    (1001) docker     (123)     7298 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_rtd/development.md
--rw-r--r--   0 runner    (1001) docker     (123)     2316 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_rtd/faq.md
--rw-r--r--   0 runner    (1001) docker     (123)      484 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_rtd/landing.md
--rw-r--r--   0 runner    (1001) docker     (123)       86 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_rtd/pipeline.md
--rw-r--r--   0 runner    (1001) docker     (123)     5537 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_rtd/windows_setup.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.760135 ark-analysis-0.6.3/docs/_static/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_static/.gitkeep
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.760135 ark-analysis-0.6.3/docs/_templates/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/_templates/.gitkeep
--rw-r--r--   0 runner    (1001) docker     (123)    17145 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/conf.py
--rw-r--r--   0 runner    (1001) docker     (123)      597 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/index.rst
--rw-r--r--   0 runner    (1001) docker     (123)      795 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/make.bat
--rw-r--r--   0 runner    (1001) docker     (123)      201 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/docs/rtd-requirements.txt
--rw-r--r--   0 runner    (1001) docker     (123)     4737 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (123)       38 2023-03-24 21:03:08.784135 ark-analysis-0.6.3/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)      822 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.752134 ark-analysis-0.6.3/src/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.760135 ark-analysis-0.6.3/src/ark/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.764135 ark-analysis-0.6.3/src/ark/analysis/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/analysis/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     4999 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/analysis/dimensionality_reduction.py
--rw-r--r--   0 runner    (1001) docker     (123)    23286 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/analysis/neighborhood_analysis.py
--rw-r--r--   0 runner    (1001) docker     (123)    24694 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/analysis/spatial_analysis_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    19825 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/analysis/spatial_enrichment.py
--rw-r--r--   0 runner    (1001) docker     (123)    19221 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/analysis/visualize.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.764135 ark-analysis-0.6.3/src/ark/phenotyping/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    10311 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/cell_cluster_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    12240 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/cell_meta_clustering.py
--rw-r--r--   0 runner    (1001) docker     (123)     7062 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/cell_som_clustering.py
--rw-r--r--   0 runner    (1001) docker     (123)    24389 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/cluster_helpers.py
--rw-r--r--   0 runner    (1001) docker     (123)    17958 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/pixel_cluster_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    21292 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/pixel_meta_clustering.py
--rw-r--r--   0 runner    (1001) docker     (123)    12888 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/pixel_som_clustering.py
--rw-r--r--   0 runner    (1001) docker     (123)    14073 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/pixie_preprocessing.py
--rw-r--r--   0 runner    (1001) docker     (123)     5741 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/post_cluster_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    20336 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/phenotyping/weighted_channel_comp.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.764135 ark-analysis-0.6.3/src/ark/segmentation/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/segmentation/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    12398 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/segmentation/fiber_segmentation.py
--rw-r--r--   0 runner    (1001) docker     (123)    25408 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/segmentation/marker_quantification.py
--rw-r--r--   0 runner    (1001) docker     (123)     5538 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/segmentation/regionprops_extraction.py
--rw-r--r--   0 runner    (1001) docker     (123)     9584 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/segmentation/segmentation_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)     2643 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/segmentation/signal_extraction.py
--rw-r--r--   0 runner    (1001) docker     (123)     2479 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/settings.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.764135 ark-analysis-0.6.3/src/ark/spLDA/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/spLDA/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    15050 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/spLDA/processing.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.764135 ark-analysis-0.6.3/src/ark/utils/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)   922212 2023-03-24 21:03:07.000000 ark-analysis-0.6.3/src/ark/utils/_bootstrapping.c
--rw-r--r--   0 runner    (1001) docker     (123)    11326 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/_bootstrapping.pyx
--rw-r--r--   0 runner    (1001) docker     (123)    22522 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/data_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    15213 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/deepcell_service_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)     8666 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/example_dataset.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.768135 ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/
--rw-r--r--   0 runner    (1001) docker     (123)      213 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3894 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/colormap_helper.py
--rw-r--r--   0 runner    (1001) docker     (123)     2833 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/file_reader.py
--rw-r--r--   0 runner    (1001) docker     (123)     5790 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/metaclusterdata.py
--rw-r--r--   0 runner    (1001) docker     (123)    22311 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/metaclustergui.py
--rw-r--r--   0 runner    (1001) docker     (123)     1858 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/throttle.py
--rw-r--r--   0 runner    (1001) docker     (123)     1587 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/zscore_norm.py
--rw-r--r--   0 runner    (1001) docker     (123)    22247 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/plot_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    10076 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/src/ark/utils/spatial_lda_utils.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.768135 ark-analysis-0.6.3/src/ark_analysis.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)    19597 2023-03-24 21:03:08.000000 ark-analysis-0.6.3/src/ark_analysis.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)     4982 2023-03-24 21:03:08.000000 ark-analysis-0.6.3/src/ark_analysis.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-03-24 21:03:08.000000 ark-analysis-0.6.3/src/ark_analysis.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)      773 2023-03-24 21:03:08.000000 ark-analysis-0.6.3/src/ark_analysis.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)        4 2023-03-24 21:03:08.000000 ark-analysis-0.6.3/src/ark_analysis.egg-info/top_level.txt
--rwxr-xr-x   0 runner    (1001) docker     (123)     1915 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/start_docker.sh
--rw-r--r--   0 runner    (1001) docker     (123)      200 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/start_jupyter.sh
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.776135 ark-analysis-0.6.3/templates/
--rw-r--r--   0 runner    (1001) docker     (123)    12675 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/1_Segment_Image_Data.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    31170 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/2_Pixie_Cluster_Pixels.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    33351 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/3_Pixie_Cluster_Cells.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)   105384 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/4_Post_Clustering.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    94219 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/Calculate_Mixing_Scores.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)     5084 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/Image_Stitching.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)   357149 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/LDA_Preprocessing.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)   413377 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/LDA_Training_and_Inference.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)     6424 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/OME-TIFF_Conversion.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)  4977502 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/example_fiber_segmentation.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)   346976 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/example_neighborhood_analysis_script.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)   327304 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/example_visualization.ipynb
--rw-r--r--   0 runner    (1001) docker     (123)    23578 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/templates/generic_cell_clustering.ipynb
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.776135 ark-analysis-0.6.3/tests/
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.776135 ark-analysis-0.6.3/tests/analysis/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/analysis/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3485 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/analysis/dimensionality_reduction_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    13862 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/analysis/neighborhood_analysis_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    14854 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/analysis/spatial_analysis_utils_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    15424 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/analysis/spatial_enrichment_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    11868 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/analysis/visualize_test.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.780135 ark-analysis-0.6.3/tests/phenotyping/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    19278 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/cell_cluster_utils_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    17303 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/cell_meta_clustering_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    10751 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/cell_som_clustering_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    22071 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/cluster_helpers_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    23516 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/pixel_cluster_utils_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    33647 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/pixel_meta_clustering_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    16972 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/pixel_som_clustering_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    24159 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/pixie_preprocessing_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     3706 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/post_cluster_utils_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    22532 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/phenotyping/weighted_channel_comp_test.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.780135 ark-analysis-0.6.3/tests/segmentation/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/segmentation/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     3793 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/segmentation/fiber_segmentation_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    39057 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/segmentation/marker_quantification_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     4736 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/segmentation/regionprops_extraction_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    13467 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/segmentation/segmentation_utils_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     6607 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/segmentation/signal_extraction_test.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.780135 ark-analysis-0.6.3/tests/spLDA/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/spLDA/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     9264 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/spLDA/processing_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    19130 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/synthetic_spatial_datagen.py
--rw-r--r--   0 runner    (1001) docker     (123)    21991 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/test_utils.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.784135 ark-analysis-0.6.3/tests/utils/
--rw-r--r--   0 runner    (1001) docker     (123)        0 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    25633 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/data_utils_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    13816 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/deepcell_service_utils_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    19065 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/example_dataset_test.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-03-24 21:03:08.784135 ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/
--rw-r--r--   0 runner    (1001) docker     (123)     2930 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/colormap_helper_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     2275 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/conftest.py
--rw-r--r--   0 runner    (1001) docker     (123)     3162 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/file_reader_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     5962 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/metaclusterdata_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     4777 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/metaclustergui_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/throttle_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     4905 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/notebook_update_test.py
--rw-r--r--   0 runner    (1001) docker     (123)    23327 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/notebooks_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     2731 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/notebooks_test_utils.py
--rw-r--r--   0 runner    (1001) docker     (123)    16611 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/plot_utils_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     7070 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/spatial_lda_utils_test.py
--rw-r--r--   0 runner    (1001) docker     (123)     7150 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tests/utils/synthetic_spatial_datagen_test.py
--rw-r--r--   0 runner    (1001) docker     (123)       95 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/tox.ini
--rw-r--r--   0 runner    (1001) docker     (123)     1831 2023-03-24 21:02:55.000000 ark-analysis-0.6.3/update_notebooks.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.166144 ark-analysis-0.6.4/
+-rw-r--r--   0 runner    (1001) docker     (123)      960 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.dockerignore
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.142145 ark-analysis-0.6.4/.github/
+-rw-r--r--   0 runner    (1001) docker     (123)      416 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.github/dependabot.yml
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.142145 ark-analysis-0.6.4/.github/scripts/
+-rw-r--r--   0 runner    (1001) docker     (123)      792 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.github/scripts/get_example_dataset.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.146144 ark-analysis-0.6.4/.github/workflows/
+-rw-r--r--   0 runner    (1001) docker     (123)     1455 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.github/workflows/build.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     2081 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.github/workflows/ci.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     2634 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.github/workflows/docker.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     1891 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.github/workflows/pypi_publish.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.github/workflows/release-drafter.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     1428 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.github/workflows/test.yml
+-rw-r--r--   0 runner    (1001) docker     (123)      480 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.gitignore
+-rw-r--r--   0 runner    (1001) docker     (123)      157 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/.readthedocs.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     1542 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/Dockerfile
+-rw-r--r--   0 runner    (1001) docker     (123)    11612 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)    20297 2023-07-24 23:33:38.166144 ark-analysis-0.6.4/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)    19526 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)      769 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/conftest.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.146144 ark-analysis-0.6.4/docs/
+-rw-r--r--   0 runner    (1001) docker     (123)      709 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/Makefile
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.146144 ark-analysis-0.6.4/docs/_images/
+-rw-r--r--   0 runner    (1001) docker     (123)    77780 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_images/ark_processing.png
+-rw-r--r--   0 runner    (1001) docker     (123)   366185 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_images/docker_preferences.png
+-rw-r--r--   0 runner    (1001) docker     (123)    70517 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_images/mantis_feature_file.png
+-rw-r--r--   0 runner    (1001) docker     (123)   561042 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_images/mantis_feature_view.png
+-rw-r--r--   0 runner    (1001) docker     (123)    64589 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_images/mantis_loading.png
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.146144 ark-analysis-0.6.4/docs/_rtd/
+-rw-r--r--   0 runner    (1001) docker     (123)     6746 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_rtd/contributing.md
+-rw-r--r--   0 runner    (1001) docker     (123)     7191 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_rtd/data_types.md
+-rw-r--r--   0 runner    (1001) docker     (123)     7298 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_rtd/development.md
+-rw-r--r--   0 runner    (1001) docker     (123)     2316 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_rtd/faq.md
+-rw-r--r--   0 runner    (1001) docker     (123)      484 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_rtd/landing.md
+-rw-r--r--   0 runner    (1001) docker     (123)       86 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_rtd/pipeline.md
+-rw-r--r--   0 runner    (1001) docker     (123)     5606 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_rtd/windows_setup.md
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.146144 ark-analysis-0.6.4/docs/_static/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_static/.gitkeep
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.146144 ark-analysis-0.6.4/docs/_templates/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/_templates/.gitkeep
+-rw-r--r--   0 runner    (1001) docker     (123)    17161 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/conf.py
+-rw-r--r--   0 runner    (1001) docker     (123)      597 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/index.rst
+-rw-r--r--   0 runner    (1001) docker     (123)      795 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/make.bat
+-rw-r--r--   0 runner    (1001) docker     (123)      218 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/docs/rtd-requirements.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      113 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/environment.yml
+-rw-r--r--   0 runner    (1001) docker     (123)     4836 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-07-24 23:33:38.166144 ark-analysis-0.6.4/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)      946 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.142145 ark-analysis-0.6.4/src/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.146144 ark-analysis-0.6.4/src/ark/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.150144 ark-analysis-0.6.4/src/ark/analysis/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/analysis/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9008 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/analysis/cell_neighborhood_stats.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4999 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/analysis/dimensionality_reduction.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23863 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/analysis/neighborhood_analysis.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24707 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/analysis/spatial_analysis_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19779 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/analysis/spatial_enrichment.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19245 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/analysis/visualize.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.150144 ark-analysis-0.6.4/src/ark/phenotyping/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10371 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/cell_cluster_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13260 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/cell_meta_clustering.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7348 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/cell_som_clustering.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25950 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/cluster_helpers.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17905 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/pixel_cluster_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21819 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/pixel_meta_clustering.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13780 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/pixel_som_clustering.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15355 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/pixie_preprocessing.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6670 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/post_cluster_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    20457 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/phenotyping/weighted_channel_comp.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.150144 ark-analysis-0.6.4/src/ark/segmentation/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/segmentation/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24989 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/segmentation/fiber_segmentation.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25473 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/segmentation/marker_quantification.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5538 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/segmentation/regionprops_extraction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9584 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/segmentation/segmentation_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2643 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/segmentation/signal_extraction.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2465 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/settings.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.150144 ark-analysis-0.6.4/src/ark/spLDA/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/spLDA/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15050 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/spLDA/processing.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.154144 ark-analysis-0.6.4/src/ark/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)   977083 2023-07-24 23:33:37.000000 ark-analysis-0.6.4/src/ark/utils/_bootstrapping.c
+-rw-r--r--   0 runner    (1001) docker     (123)    11326 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/_bootstrapping.pyx
+-rw-r--r--   0 runner    (1001) docker     (123)    26505 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/data_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15208 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/deepcell_service_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8719 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/example_dataset.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.154144 ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/
+-rw-r--r--   0 runner    (1001) docker     (123)      213 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3894 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/colormap_helper.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2833 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/file_reader.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5790 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/metaclusterdata.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22311 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/metaclustergui.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1858 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/throttle.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1587 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/zscore_norm.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29217 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/plot_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10260 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/src/ark/utils/spatial_lda_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.154144 ark-analysis-0.6.4/src/ark_analysis.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)    20297 2023-07-24 23:33:38.000000 ark-analysis-0.6.4/src/ark_analysis.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     5166 2023-07-24 23:33:38.000000 ark-analysis-0.6.4/src/ark_analysis.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-07-24 23:33:38.000000 ark-analysis-0.6.4/src/ark_analysis.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)      839 2023-07-24 23:33:38.000000 ark-analysis-0.6.4/src/ark_analysis.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        4 2023-07-24 23:33:38.000000 ark-analysis-0.6.4/src/ark_analysis.egg-info/top_level.txt
+-rwxr-xr-x   0 runner    (1001) docker     (123)     1913 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/start_docker.sh
+-rw-r--r--   0 runner    (1001) docker     (123)      200 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/start_jupyter.sh
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.162145 ark-analysis-0.6.4/templates/
+-rw-r--r--   0 runner    (1001) docker     (123)    12599 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/1_Segment_Image_Data.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    33436 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/2_Pixie_Cluster_Pixels.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    36315 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/3_Pixie_Cluster_Cells.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)   105397 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/4_Post_Clustering.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    98589 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/Calculate_Mixing_Scores.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)     5171 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/Image_Stitching.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)   357182 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/LDA_Preprocessing.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)   413389 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/LDA_Training_and_Inference.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)     6486 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/OME-TIFF_Conversion.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)     9801 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/cell_neighbors_analysis.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)  3469571 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/example_fiber_segmentation.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)   348512 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/example_neighborhood_analysis_script.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)   327308 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/example_visualization.ipynb
+-rw-r--r--   0 runner    (1001) docker     (123)    24873 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/templates/generic_cell_clustering.ipynb
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.162145 ark-analysis-0.6.4/tests/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.162145 ark-analysis-0.6.4/tests/analysis/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/analysis/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6938 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/analysis/cell_neighborhood_stats_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3483 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/analysis/dimensionality_reduction_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13885 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/analysis/neighborhood_analysis_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14828 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/analysis/spatial_analysis_utils_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15371 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/analysis/spatial_enrichment_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11868 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/analysis/visualize_test.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.162145 ark-analysis-0.6.4/tests/phenotyping/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19226 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/cell_cluster_utils_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19757 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/cell_meta_clustering_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11910 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/cell_som_clustering_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22830 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/cluster_helpers_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    23438 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/pixel_cluster_utils_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    34677 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/pixel_meta_clustering_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    18046 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/pixel_som_clustering_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22835 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/pixie_preprocessing_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3625 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/post_cluster_utils_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    22376 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/phenotyping/weighted_channel_comp_test.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.162145 ark-analysis-0.6.4/tests/segmentation/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/segmentation/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12753 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/segmentation/fiber_segmentation_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    39057 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/segmentation/marker_quantification_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4736 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/segmentation/regionprops_extraction_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    13467 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/segmentation/segmentation_utils_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6607 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/segmentation/signal_extraction_test.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.162145 ark-analysis-0.6.4/tests/spLDA/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/spLDA/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9264 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/spLDA/processing_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19117 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/synthetic_spatial_datagen.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21991 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/test_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.166144 ark-analysis-0.6.4/tests/utils/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29651 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/data_utils_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    14097 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/deepcell_service_utils_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    19836 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/example_dataset_test.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-24 23:33:38.166144 ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/
+-rw-r--r--   0 runner    (1001) docker     (123)     2874 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/colormap_helper_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2275 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/conftest.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3162 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/file_reader_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5962 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/metaclusterdata_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4794 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/metaclustergui_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1002 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/throttle_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4905 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/notebook_update_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)    29117 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/notebooks_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4155 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/notebooks_test_utils.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25417 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/plot_utils_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7063 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/spatial_lda_utils_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7149 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tests/utils/synthetic_spatial_datagen_test.py
+-rw-r--r--   0 runner    (1001) docker     (123)       95 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/tox.ini
+-rw-r--r--   0 runner    (1001) docker     (123)     1831 2023-07-24 23:33:25.000000 ark-analysis-0.6.4/update_notebooks.sh
```

### Comparing `ark-analysis-0.6.3/.dockerignore` & `ark-analysis-0.6.4/.dockerignore`

 * *Files 12% similar despite different names*

```diff
@@ -87,7 +87,9 @@
 .env
 
 # virtualenv
 .venv/
 venv/
 ENV/
 env/
+
+.virtual_documents
```

### Comparing `ark-analysis-0.6.3/.github/workflows/build.yml` & `ark-analysis-0.6.4/.github/workflows/build.yml`

 * *Files 19% similar despite different names*

```diff
@@ -1,8 +1,8 @@
-name: Wheel Builder
+name: Build
 
 on:
   workflow_call:
 
 permissions:
   contents: read # to fetch code (actions/checkout)
 
@@ -25,15 +25,15 @@
       - name: Set up QEMU (For Linux ARM)
         if: runner.os == 'Linux'
         uses: docker/setup-qemu-action@v2
         with:
           platforms: arm64
 
       - name: Build Wheels
-        uses: pypa/cibuildwheel@v2.11.4
+        uses: pypa/cibuildwheel@v2.13.0
         with:
           package-dir: .
           output-dir: wheelhouse
           config-file: "{package}/pyproject.toml"
 
       - name: Store Wheel Artifacts
         uses: actions/upload-artifact@v3
```

### Comparing `ark-analysis-0.6.3/.github/workflows/docker.yml` & `ark-analysis-0.6.4/.github/workflows/docker.yml`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/.github/workflows/pypi_publish.yml` & `ark-analysis-0.6.4/.github/workflows/pypi_publish.yml`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/.github/workflows/release-drafter.yml` & `ark-analysis-0.6.4/.github/workflows/release-drafter.yml`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/.github/workflows/test.yml` & `ark-analysis-0.6.4/.github/workflows/test.yml`

 * *Files 25% similar despite different names*

```diff
@@ -3,46 +3,53 @@
 on:
   workflow_call:
 
 permissions:
   contents: read # to fetch code (actions/checkout)
 jobs:
   test:
-    name: ${{ github.repository }}
-    runs-on: ubuntu-latest
+    name: ${{ matrix.os }} - ${{ matrix.python-version }}
+    runs-on: ${{ matrix.os }}
+    strategy:
+      # Ensure that if any job fails, all jobs are cancelled.
+      fail-fast: false
+      matrix:
+        python-version: ["3.9", "3.10", "3.11"]
+        os: [ubuntu-latest, macos-latest, windows-latest]
 
     steps:
       - name: Checkout ${{ github.repository }}
         uses: actions/checkout@v3
         with:
           fetch-depth: 0
 
-      - name: Set up Python 3.8
+      - name: Download Example Dataset Cache
+        uses: actions/cache/restore@v3
+        id: dataset-cache
+        env:
+          cache-name: dataset
+        with:
+          path: ./data/cache/
+          key: huggingface-${{ env.cache-name }}
+          enableCrossOsArchive: true
+
+      - name: Set up Python ${{ matrix.python-version }}
         uses: actions/setup-python@v4
         with:
-          python-version: 3.8
+          python-version: ${{ matrix.python-version }}
           cache-dependency-path: "**/pyproject.toml"
           cache: "pip"
 
-      - name: Get Example Dataset Cache
-        uses: actions/cache@v3
-        with:
-          path: ~/.cache/huggingface/datasets
-          key: huggingface-${{ runner.os }}-${{ hashFiles('*.lock') }}
-          restore-keys: |
-            huggingface-${{ runner.os }}-${{ hashFiles('*.lock') }}
-            huggingface-${{ runner.os }}
-
       - name: Install Dependencies and ${{ github.repository }}
         run: |
           pip install .[test]
 
       - name: Run Tests
         run: |
           pytest
 
       - name: Archive Coverage
         uses: actions/upload-artifact@v3
         with:
-          name: coverage
+          name: coverage-${{ join(matrix.*, '-') }}
           path: |
             coverage.lcov
```

### Comparing `ark-analysis-0.6.3/Dockerfile` & `ark-analysis-0.6.4/Dockerfile`

 * *Files 7% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 # ANY CHANGES REQURIE A NEW RELEASE
 
-# Stage 1: Start from the official Python 3.8 Image: https://hub.docker.com/_/python
-FROM python:3.8 AS base
+# Stage 1: Start from the official Python 3.11 Image: https://hub.docker.com/_/python
+FROM python:3.11-slim-bullseye AS base
 
 # Set environment variable 
 ENV RUNNING_IN_DOCKER true
 
 # system maintenance
 RUN apt update && apt -y upgrade
 
@@ -32,21 +32,22 @@
 COPY .git /opt/ark-analysis/.git
 
 # Stage 3: Copy templates/ to scripts/
 FROM move_ark AS move_templates
 
 # copy the scripts over
 # this should catch changes to the scripts from updates
-COPY src /opt/ark-analysis/src
+COPY templates /opt/ark-analysis/templates
 
 # Stage 4: Install Ark Analysis
 FROM move_templates AS install_ark
 
-# Install the package via setup.py
-RUN cd /opt/ark-analysis && python -m pip install .
+# Install the package and the jupyter-lab extensions
+COPY src /opt/ark-analysis/src
+RUN cd /opt/ark-analysis && python -m pip install .[lab_ext]
 
 # Stage 5: Set the working directory, and open Jupyter Lab
 FROM install_ark AS open_for_user
 WORKDIR /opt/ark-analysis
 
 # jupyter lab
 CMD bash start_jupyter.sh
```

### Comparing `ark-analysis-0.6.3/LICENSE` & `ark-analysis-0.6.4/LICENSE`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/PKG-INFO` & `ark-analysis-0.6.4/README.md`

 * *Files 4% similar despite different names*

```diff
@@ -1,31 +1,19 @@
-Metadata-Version: 2.1
-Name: ark-analysis
-Version: 0.6.3
-Summary: Toolbox for analysis on segmented images from MIBI
-Author-email: Angelo Lab <theangelolab@gmail.com>
-License: Modified Apache License 2.0
-Project-URL: repository, https://github.com/angelolab/ark-analysis
-Classifier: Development Status :: 4 - Beta
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
-Classifier: License :: OSI Approved :: Apache Software License
-Classifier: Topic :: Scientific/Engineering :: Bio-Informatics
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Provides-Extra: test
-License-File: LICENSE
-
-[![CI](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml)
-[![Coverage Status](https://coveralls.io/repos/github/angelolab/ark-analysis/badge.svg?branch=main)](https://coveralls.io/github/angelolab/ark-analysis?branch=main)
-![Docker Image Version (latest by date)](https://img.shields.io/docker/v/angelolab/ark-analysis?arch=amd64&color=%23469ae5&label=Docker%20Version&sort=date)
-[![Read the Docs](https://readthedocs.org/projects/ark-analysis/badge/?version=latest)](https://ark-analysis.readthedocs.io/en/latest/)
-
 # ark-analysis
 
+<div align="center">
+
+| | | 
+| ---        |    ---  |
+| CI / CD | [![CI](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml/badge.svg)](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml) ![Read the Docs](https://img.shields.io/readthedocs/ark-analysis) [![Coverage Status](https://coveralls.io/repos/github/angelolab/ark-analysis/badge.svg?branch=main)](https://coveralls.io/github/angelolab/ark-analysis?branch=main) ![Docker Image Version (latest by date)](https://img.shields.io/docker/v/angelolab/ark-analysis?arch=amd64&color=%23469ae5&label=Docker%20Version&sort=date) |
+| Package | [![PyPI - Version](https://img.shields.io/pypi/v/ark-analysis.svg?logo=pypi&label=PyPI&logoColor=gold)](https://pypi.org/project/ark-analysis/) [![PyPI - Downloads](https://img.shields.io/pypi/dm/ark-analysis.svg?color=blue&label=Downloads&logo=pypi&logoColor=gold)](https://pypi.org/project/ark-analysis/) [![PyPI - Python Version](https://img.shields.io/pypi/pyversions/ark-analysis.svg?logo=python&label=Python&logoColor=gold)](https://pypi.org/project/ark-analysis/) |
+|Meta | [![PyPI - License](https://img.shields.io/pypi/l/ark-analysis?color=9400d3)](LICENSE) |
+
+</div>
+
 Toolbox for analyzing multiplexed imaging data.
 
 Full documentation for the project can be found [here](https://ark-analysis.readthedocs.io/en/latest/).
 
 ## Table of Contents
 - [Pipeline Flowchart](#pipeline-flowchart)
 - [Getting Started](#getting-started)
@@ -110,30 +98,30 @@
 However, the repository will still need to be cloned if you wish to use the Jupyter Notebooks.
 
 #### Download the Repo
 
 We recommend using the latest release of `ark`. You can find all the versions available in the [Releases Section](https://github.com/angelolab/ark-analysis/releases).
 Open terminal and navigate to where you want the code stored. 
 
-Currently, the latest release is `v0.6.3`.
-Then install the latest release with:
+
+If you would like to use the latest version of `ark` simply clone the project and create the Conda environment.
 
 ```sh
-git clone -b v0.6.3 https://github.com/angelolab/ark-analysis.git
+git clone -b v0.6.4 https://github.com/angelolab/ark-analysis.git
+cd ark-analysis
+conda env create -f environment.yml
 ```
 
-You may also install previous releases by simply changing the version after the `-b`.
-
 #### Setting up Docker
 
 There is a complementary [setup video](https://youtu.be/EXMGdi_Izdw).
 
 Next, you'll need to download Docker Desktop:
  - First, [download](https://hub.docker.com/?overlay=onboarding) Docker Desktop. 
- - Once it's sucessfully installed, make sure it is running by looking in toolbar for the Docker whale icon. 
+ - Once it's successfully installed, make sure it is running by looking in toolbar for the Docker whale icon. 
 
 
 #### Running on Windows
 
 Our repo runs best on Linux-based systems (including MacOS). If you need to run on Windows, please consult our [Windows guide](https://ark-analysis.readthedocs.io/en/latest/_rtd/windows_setup.html) for additional instructions.
 
 #### Using the Repository (Running the Docker)
```

### Comparing `ark-analysis-0.6.3/README.md` & `ark-analysis-0.6.4/PKG-INFO`

 * *Files 14% similar despite different names*

```diff
@@ -1,14 +1,39 @@
-[![CI](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml)
-[![Coverage Status](https://coveralls.io/repos/github/angelolab/ark-analysis/badge.svg?branch=main)](https://coveralls.io/github/angelolab/ark-analysis?branch=main)
-![Docker Image Version (latest by date)](https://img.shields.io/docker/v/angelolab/ark-analysis?arch=amd64&color=%23469ae5&label=Docker%20Version&sort=date)
-[![Read the Docs](https://readthedocs.org/projects/ark-analysis/badge/?version=latest)](https://ark-analysis.readthedocs.io/en/latest/)
+Metadata-Version: 2.1
+Name: ark-analysis
+Version: 0.6.4
+Summary: Toolbox for analysis on segmented images from MIBI.
+Author-email: Angelo Lab <theangelolab@gmail.com>
+License: Modified Apache License 2.0
+Project-URL: repository, https://github.com/angelolab/ark-analysis
+Classifier: Development Status :: 4 - Beta
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: License :: OSI Approved :: Apache Software License
+Classifier: Topic :: Scientific/Engineering :: Bio-Informatics
+Requires-Python: >=3.9
+Description-Content-Type: text/markdown
+Provides-Extra: test
+Provides-Extra: lab_ext
+License-File: LICENSE
 
 # ark-analysis
 
+<div align="center">
+
+| | | 
+| ---        |    ---  |
+| CI / CD | [![CI](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml/badge.svg)](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml) ![Read the Docs](https://img.shields.io/readthedocs/ark-analysis) [![Coverage Status](https://coveralls.io/repos/github/angelolab/ark-analysis/badge.svg?branch=main)](https://coveralls.io/github/angelolab/ark-analysis?branch=main) ![Docker Image Version (latest by date)](https://img.shields.io/docker/v/angelolab/ark-analysis?arch=amd64&color=%23469ae5&label=Docker%20Version&sort=date) |
+| Package | [![PyPI - Version](https://img.shields.io/pypi/v/ark-analysis.svg?logo=pypi&label=PyPI&logoColor=gold)](https://pypi.org/project/ark-analysis/) [![PyPI - Downloads](https://img.shields.io/pypi/dm/ark-analysis.svg?color=blue&label=Downloads&logo=pypi&logoColor=gold)](https://pypi.org/project/ark-analysis/) [![PyPI - Python Version](https://img.shields.io/pypi/pyversions/ark-analysis.svg?logo=python&label=Python&logoColor=gold)](https://pypi.org/project/ark-analysis/) |
+|Meta | [![PyPI - License](https://img.shields.io/pypi/l/ark-analysis?color=9400d3)](LICENSE) |
+
+</div>
+
 Toolbox for analyzing multiplexed imaging data.
 
 Full documentation for the project can be found [here](https://ark-analysis.readthedocs.io/en/latest/).
 
 ## Table of Contents
 - [Pipeline Flowchart](#pipeline-flowchart)
 - [Getting Started](#getting-started)
@@ -93,30 +118,30 @@
 However, the repository will still need to be cloned if you wish to use the Jupyter Notebooks.
 
 #### Download the Repo
 
 We recommend using the latest release of `ark`. You can find all the versions available in the [Releases Section](https://github.com/angelolab/ark-analysis/releases).
 Open terminal and navigate to where you want the code stored. 
 
-Currently, the latest release is `v0.6.3`.
-Then install the latest release with:
+
+If you would like to use the latest version of `ark` simply clone the project and create the Conda environment.
 
 ```sh
-git clone -b v0.6.3 https://github.com/angelolab/ark-analysis.git
+git clone -b v0.6.4 https://github.com/angelolab/ark-analysis.git
+cd ark-analysis
+conda env create -f environment.yml
 ```
 
-You may also install previous releases by simply changing the version after the `-b`.
-
 #### Setting up Docker
 
 There is a complementary [setup video](https://youtu.be/EXMGdi_Izdw).
 
 Next, you'll need to download Docker Desktop:
  - First, [download](https://hub.docker.com/?overlay=onboarding) Docker Desktop. 
- - Once it's sucessfully installed, make sure it is running by looking in toolbar for the Docker whale icon. 
+ - Once it's successfully installed, make sure it is running by looking in toolbar for the Docker whale icon. 
 
 
 #### Running on Windows
 
 Our repo runs best on Linux-based systems (including MacOS). If you need to run on Windows, please consult our [Windows guide](https://ark-analysis.readthedocs.io/en/latest/_rtd/windows_setup.html) for additional instructions.
 
 #### Using the Repository (Running the Docker)
```

### Comparing `ark-analysis-0.6.3/docs/Makefile` & `ark-analysis-0.6.4/docs/Makefile`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/docs/_images/ark_processing.png` & `ark-analysis-0.6.4/docs/_images/ark_processing.png`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/docs/_images/docker_preferences.png` & `ark-analysis-0.6.4/docs/_images/docker_preferences.png`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/docs/_images/mantis_feature_file.png` & `ark-analysis-0.6.4/docs/_images/mantis_feature_file.png`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/docs/_images/mantis_feature_view.png` & `ark-analysis-0.6.4/docs/_images/mantis_feature_view.png`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/docs/_images/mantis_loading.png` & `ark-analysis-0.6.4/docs/_images/mantis_loading.png`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/docs/_rtd/contributing.md` & `ark-analysis-0.6.4/docs/_rtd/contributing.md`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/docs/_rtd/data_types.md` & `ark-analysis-0.6.4/docs/_rtd/data_types.md`

 * *Files 0% similar despite different names*

```diff
@@ -84,9 +84,9 @@
 Shape: 2D matrix of num_cells x num_expression_columns  
 
 Description: users may want to run cell clustering on custom expression inputs outside of pixel cluster counts. The input data will need to be defined as a CSV to support DataFrame operations.
 
 The CSV should contain the following columns
 
 * `fov`: name of the FOV the cell comes from
-* `segmentation_label`: the name of the segmentation label
+* `label`: the name of the segmentation label
 * A set of expression columns defining the properties of each cell desired for clustering
```

### Comparing `ark-analysis-0.6.3/docs/_rtd/development.md` & `ark-analysis-0.6.4/docs/_rtd/development.md`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/docs/_rtd/faq.md` & `ark-analysis-0.6.4/docs/_rtd/faq.md`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/docs/_rtd/windows_setup.md` & `ark-analysis-0.6.4/docs/_rtd/windows_setup.md`

 * *Files 2% similar despite different names*

```diff
@@ -29,28 +29,33 @@
 
 After finishing the installer guidelines, go to your Command Prompt and type `git`. If you get a list of commands you can use with `git`, the installation was successful. 
 
 ### Docker Desktop
 
 Go to [Docker for Windows install](https://docs.docker.com/desktop/windows/install) to download `Docker Desktop`. 
 
-Open the shortcut (which should be added to your Desktop after installation) and open `Docker Desktop`. If the engine starts up successfully, Docker has been configured. Note that the engine may take a while to setup properly.
+Open the shortcut (which should be added to your Desktop after installation) and open `Docker Desktop`. If the engine starts up successfully, Docker has been configured. Note that the engine may take a while to set up properly.
 
 ### Setting up the repo
 
 In your Command Prompt, follow similar steps to clone the `ark-analysis` repo and build the Docker:
 
 * Run `git clone https://github.com/angelolab/ark-analysis.git` to clone the `ark-analysis` repo
 * Run `cd ark-analysis` to enter the cloned repo
 * Pull the latest Docker image by running `docker pull angelolab/ark-analysis:latest`
 
 To run the script, you have to use `bash start_docker.sh`. If you run into issues with invalid carriage returns (`\r`), please run the following before trying again:
 
 * Run `wsl sudo apt-get install dos2unix`
-* Run `wsl dos2unix start_docker.sh` and `wsl dos2unix update_notebooks.sh`
+* Run the following commands:
+  > `wsl dos2unix start_docker.sh`
+  
+  > `wsl dos2unix start_jupyter.sh`
+
+  > `wsl dos2unix update_notebooks.sh`
 
 ### Addressing `docker` not found
 
 If you run into this issue, or if you notice `wsl` commands are not displaying any output, it's likely that you will need to adjust the default Linux distribution WSL is pointing to.
 
 * Run `wsl -l -v`. You should be seeing 3 distros: `Ubuntu-20.04`, `docker-desktop`, and `docker-desktop-data`
 * Make sure `Ubuntu-20.04` is starred (`*` to the left) and running. If not, run `wsl --setdefault Ubuntu-20.04` to change the default version. Run `wsl -l -v` again to double check that the changes took effect.
```

### Comparing `ark-analysis-0.6.3/docs/conf.py` & `ark-analysis-0.6.4/docs/conf.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 import os
 import re  # for regex checking
 import subprocess  # to initiate sphinx-apidoc to build .md files
 import sys
 import warnings  # to throw warnings (not errors) for malformed docstrings
 
 import mock  # if we need to force mock import certain libraries autodoc_mock_imports fails ons
-from sphinx.builders.html import StandaloneHTMLBuilder
 
 # our project officially 'begins' in the parent aka root project directory
 # since we do not separate source from build we can simply go up one directory
 sys.path.insert(0, os.path.abspath('../src'))
 
 # if we ever have images, we'll be using the supported_image_types
 # argument to set the desired formats we wish to support
@@ -60,24 +59,26 @@
               'sphinx.ext.todo',  # support fo TODO
               'sphinx.ext.viewcode',  # support for adding links to highlighted source code, looks at Python object descriptions and tries to find source files where objects are contained
               'm2r2']  # allows you to include Markdown files in .rst, use mdinclude for this, choosing this over m2r because m2r is not supported anymore
 
 # set parameter to read Google docstring and not NumPy
 # redundant to add since it's default True but good to know
 napoleon_google_docstring = True
+napoleon_include_init_with_doc = True
 
 # contains list of modules to be marked up
 # will ensure 'clean' imports of all the following libraries
 autodoc_mock_imports = ['cryptography',
                         'datasets',
                         'feather',
                         'google',
                         'h5py',
                         'ipywidgets',
                         'natsort',
+                        'numba',
                         'numpy',
                         'matplotlib',
                         'natsort',
                         'palettable',
                         'pandas',
                         'pyarrow',
                         'pyFlowSOM',
```

### Comparing `ark-analysis-0.6.3/docs/index.rst` & `ark-analysis-0.6.4/docs/index.rst`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/docs/make.bat` & `ark-analysis-0.6.4/docs/make.bat`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/pyproject.toml` & `ark-analysis-0.6.4/pyproject.toml`

 * *Files 4% similar despite different names*

```diff
@@ -1,41 +1,37 @@
 [build-system]
 requires = [
     "setuptools",
-    "wheel",
-    "Cython>=0.29.24,<1",
-    "numpy>=1.16.3,<2",
+    "Cython>=0.29,<1",
+    "numpy>=1.20,<1.24",
     "setuptools_scm[toml]>=6.2",
 ]
 build-backend = "setuptools.build_meta"
 
 [project]
 dependencies = [
-    "alpineer>=0.1.5",
+    "alpineer>=0.1.8",
     "Cython>=0.29,<1",
     "datasets>=2.6,<3.0",
     "dill>=0.3.5,<0.4",
     "feather-format>=0.4.1,<1",
     "importlib-metadata>=5.0",
     "ipympl>=0.9.2,<1.0.0",
     "ipython>=8.4,<9",
-    "ipywidgets==8.0.0",
-    "jupyter_contrib_nbextensions>=0.5.1,<1",
-    "jupyter>=1.0.0",
     "jupyterlab>=3.4.3,<4",
-    "matplotlib>=3.6.2,<4",
+    "matplotlib>=3.7,<4",
     "multiprocess>=0.70.13",
     "natsort>=8,<9",
-    "numpy>=1.20,<2",
+    "numpy>=1.20,<1.24",
     "palettable>=3.3.0,<4",
-    "pandas>=1.3,<2",
+    "pandas>=2",
     "pillow>=9,<10",
-    "pyFlowSOM==0.1.14",
+    "pyFlowSOM>=0.1.15",
     "requests>=2.20,<3",
-    "scikit-image>=0.19,<0.20",
+    "scikit-image>=0.21",
     "scikit-learn>=1.1,<2",
     "scipy>=1.7,<2",
     "seaborn>=0.12,<1",
     "spatial-lda>=0.1.3,<1",
     "statsmodels>=0.13.2,<1",
     "tables>=3.7",
     "tifffile>=2022",
@@ -43,25 +39,26 @@
     "umap-learn>=0.5,<1.0",
     "xarray>=2022",
     "xmltodict>=0.13.0,<1",
     "zstandard>=0.19.0,<1",
 ]
 name = "ark-analysis"
 authors = [{ name = "Angelo Lab", email = "theangelolab@gmail.com" }]
-description = "Toolbox for analysis on segmented images from MIBI"
+description = "Toolbox for analysis on segmented images from MIBI."
 readme = "README.md"
-requires-python = ">=3.8"
+requires-python = ">=3.9"
 license = { text = "Modified Apache License 2.0" }
 classifiers = [
     "Development Status :: 4 - Beta",
     "Programming Language :: Python :: 3",
-    "Programming Language :: Python :: 3.8",
+    "Programming Language :: Python :: 3.9",
+    "Programming Language :: Python :: 3.10",
+    "Programming Language :: Python :: 3.11",
     "License :: OSI Approved :: Apache Software License",
     "Topic :: Scientific/Engineering :: Bio-Informatics",
-
 ]
 dynamic = ["version"]
 urls = { repository = "https://github.com/angelolab/ark-analysis" }
 
 [project.optional-dependencies]
 test = [
     "attrs",
@@ -71,40 +68,43 @@
     "pytest-cov",
     "pytest-mock",
     "pytest-pycodestyle",
     "pytest-randomly",
     "pytest-asyncio",
     "testbook",
 ]
+lab_ext = [
+    "jupyterlab-lsp",
+    "python-lsp-server[all]",
+    "jupyterlab-git",
+    "jupyterlab_execute_time",
+    "jupyterlab-skip-traceback",
+    "lckr-jupyterlab-variableinspector"
+]
 
 [tool.setuptools_scm]
 version_scheme = "release-branch-semver"
 local_scheme = "no-local-version"
 
 [tool.cibuildwheel]
-build = ["cp38-*"]
+build = ["cp39-*", "cp310-*", "cp311-*"]
 skip = [
-    "cp36-*",        # Python 3.6
-    "cp37-*",        # Python 3.7
-    "cp39-*",        # Python 3.9
-    "cp310-*",       # Python 3.10
-    "cp311-*",       # Python 3.11
-    "*-musllinux_*", # Musllinux
-    "pp*",           # PyPy wheels on all platforms
-    "*_i686",        # 32bit Linux Wheels
-    "*_s390x",       # IBM System/390, "mainframe"
-    "*-win32",       # 32bit Windows Wheels
-    "*_ppc64le",     # PowerPC
-]
-
-# Run tests
-# test-extras = ["test"]
-# test-command = "pytest {project}/tests"
+    "cp36-*",         # Python 3.6
+    "cp37-*",         # Python 3.7
+    "cp38-*",         # Python 3.8
+    "*-musllinux_*",  # Musllinux
+    "pp*",            # PyPy wheels on all platforms
+    "*_i686",         # 32bit Linux Wheels
+    "*_s390x",        # IBM System/390, "mainframe"
+    "*-win32",        # 32bit Windows Wheels
+    "*_ppc64le",      # PowerPC
+    "cp39-win_arm64", # Windows ARM64 Python 3.9 wheels do not build.
+]
+
 build-frontend = "build"
-build-verbosity = 3
 
 # Avoid testing on emulated architectures
 test-skip = [
     "*-win_arm64",               # Skip testing emulated arm64 biulds on Windows
     "*-*linux_aarch64",          # Skip testing emulated Linux builds
     "*-macosx_arm64",            # Skip testing emulated arm64 builds on Intel Macs
     "*-macosx_universal2:arm64", # Skip testing emulated arm64 portion of universal2 builds
@@ -133,15 +133,15 @@
 archs = ["AMD64", "ARM64"]
 # might not need to repair with delvewheel?
 # before-build = "pip install delvewheel"                          # Use delvewheel on windows
 # repair-wheel-command = "delvewheel repair -w {dest_dir} {wheel}"
 
 # Coverage
 [tool.coverage.paths]
-source = ["src", "*/site-packages"]
+source = ["src", "**/site-packages"]
 
 [tool.coverage.run]
 branch = true
 source = ["ark"]
 
 [tool.coverage.report]
 exclude_lines = [
```

### Comparing `ark-analysis-0.6.3/setup.py` & `ark-analysis-0.6.4/setup.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,31 +1,35 @@
-from os import pardir, path
+from pathlib import Path
+from typing import Tuple
 
 import numpy as np
 from Cython.Build import cythonize
+from Cython.Compiler.Options import get_directive_defaults
 from setuptools import Extension, setup
 
-CYTHON_DEBUG = False
+_compiler_directives = get_directive_defaults()
 
-if CYTHON_DEBUG:
-    from Cython.Compiler.Options import get_directive_defaults
+CYTHON_PROFILE_MODE = False
 
-    directive_defaults = get_directive_defaults()
-    directive_defaults["linetrace"] = True
-    directive_defaults["binding"] = True
+CYTHON_MACROS: Tuple[str,str] = None
 
-CYTHON_MACROS = [("CYTHON_TRACE", "1")] if CYTHON_DEBUG else None
+if CYTHON_PROFILE_MODE:
+    _compiler_directives["linetrace"] = True
+    _compiler_directives["profile"] = True
+    _compiler_directives["emit_code_comments"] = True
+    CYTHON_MACROS = [("CYTHON_TRACE", "1")]
 
-PKG_FOLDER = path.relpath(path.join(__file__, pardir))
+_compiler_directives["binding"] = True
+_compiler_directives["language_level"] = "3"
 
 extensions = [
     Extension(
         name="ark.utils._bootstrapping",
-        sources=[path.join(PKG_FOLDER, "src", "ark", "utils", "_bootstrapping.pyx")],
+        sources=[Path( "src", "ark", "utils", "_bootstrapping.pyx").as_posix()],
         include_dirs=[np.get_include()],
         define_macros=CYTHON_MACROS,
     )
 ]
 
 setup(
-    ext_modules=cythonize(extensions, compiler_directives={"language_level": "3"}),
+    ext_modules=cythonize(extensions, compiler_directives=_compiler_directives),
 )
```

### Comparing `ark-analysis-0.6.3/src/ark/analysis/dimensionality_reduction.py` & `ark-analysis-0.6.4/src/ark/analysis/dimensionality_reduction.py`

 * *Ordering differences only*

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 import matplotlib.pyplot as plt
 import seaborn as sns
 import umap
+from alpineer import misc_utils
 from sklearn.decomposition import PCA
 from sklearn.manifold import TSNE
 from sklearn.preprocessing import StandardScaler
-from alpineer import misc_utils
 
 
 def plot_dim_reduced_data(component_one, component_two, fig_id, hue, cell_data,
                           title, title_fontsize=24, palette="Spectral", alpha=0.3,
                           legend_type="full", bbox_to_anchor=(1.05, 1), legend_loc=2,
                           legend_borderaxespad=0., dpi=None, save_dir=None, save_file=None):
     """Helper function to visualize_dimensionality_reduction
```

### Comparing `ark-analysis-0.6.3/src/ark/analysis/neighborhood_analysis.py` & `ark-analysis-0.6.4/src/ark/analysis/neighborhood_analysis.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,25 +1,26 @@
 import os
 import warnings
-import seaborn as sns
-import matplotlib.pylab as plt
 
+import matplotlib.pylab as plt
 import numpy as np
 import pandas as pd
+import seaborn as sns
 import xarray as xr
+from tqdm.notebook import tqdm
 from alpineer import misc_utils
 
 import ark.settings as settings
 from ark.analysis import spatial_analysis_utils
 
 
 def create_neighborhood_matrix(all_data, dist_mat_dir, included_fovs=None, distlim=50,
                                self_neighbor=False, fov_col=settings.FOV_ID,
                                cell_label_col=settings.CELL_LABEL,
-                               cluster_name_col=settings.CELL_TYPE):
+                               cell_type_col=settings.CELL_TYPE):
     """Calculates the number of neighbor phenotypes for each cell.
 
     Args:
         all_data (pandas.DataFrame):
             data for all fovs. Includes the columns for fov, label, and cell phenotype.
         dist_mat_dir (str):
             directory containing the distance matrices
@@ -29,15 +30,15 @@
             cell proximity threshold. Default is 50.
         self_neighbor (bool):
             If true, cell counts itself as a neighbor in the analysis. Default is False.
         fov_col (str):
             column with the cell fovs.
         cell_label_col (str):
             column with the cell labels.
-        cluster_name_col (str):
+        cell_type_col (str):
             column with the cell types.
 
     Returns:
         pandas.DataFrame:
             DataFrame containing phenotype counts per cell tupled with DataFrame containing
             phenotype frequencies of counts per phenotype/total phenotypes for each cell
     """
@@ -48,22 +49,22 @@
 
     # Check if included fovs found in fov_col
     misc_utils.verify_in_list(fov_names=included_fovs,
                               unique_fovs=all_data[fov_col].unique())
 
     # Subset just the fov, label, and cell phenotype columns
     all_neighborhood_data = all_data[
-        [fov_col, cell_label_col, cluster_name_col]
+        [fov_col, cell_label_col, cell_type_col]
     ].reset_index(drop=True)
     # Extract the cell phenotypes
-    cluster_names = all_neighborhood_data[cluster_name_col].drop_duplicates()
+    cluster_names = all_neighborhood_data[cell_type_col].drop_duplicates()
     # Get the total number of phenotypes
     cluster_num = len(cluster_names)
 
-    included_columns = [fov_col, cell_label_col, cluster_name_col]
+    included_columns = [fov_col, cell_label_col, cell_type_col]
 
     # Initialize empty matrices for cell neighborhood data
     cell_neighbor_counts = pd.DataFrame(
         np.zeros((all_neighborhood_data.shape[0], cluster_num + len(included_columns)))
     )
     # Replace the first, second (possibly third) columns of cell_neighbor_counts
     cell_neighbor_counts[list(range(len(included_columns)))] = \
@@ -71,33 +72,40 @@
     cols = included_columns + list(cluster_names)
 
     # Rename the columns to match cell phenotypes
     cell_neighbor_counts.columns = cols
 
     cell_neighbor_freqs = cell_neighbor_counts.copy(deep=True)
 
-    for fov in included_fovs:
-        # Subsetting expression matrix to only include patients with correct fov label
-        current_fov_idx = all_neighborhood_data.loc[:, fov_col] == fov
-        current_fov_neighborhood_data = all_neighborhood_data[current_fov_idx]
-
-        # Get the subset of phenotypes included in the current fov
-        fov_cluster_names = current_fov_neighborhood_data[cluster_name_col].drop_duplicates()
-
-        # Retrieve fov-specific distance matrix from distance matrix dictionary
-        dist_matrix = xr.load_dataarray(os.path.join(dist_mat_dir, str(fov) + '_dist_mat.xr'))
-
-        # Get cell_neighbor_counts and cell_neighbor_freqs for fovs
-        counts, freqs = spatial_analysis_utils.compute_neighbor_counts(
-            current_fov_neighborhood_data, dist_matrix, distlim, self_neighbor,
-            cell_label_col=cell_label_col, cluster_name_col=cluster_name_col)
-
-        # Add to neighbor counts + freqs for only the matching phenos between fov and whole dataset
-        cell_neighbor_counts.loc[current_fov_neighborhood_data.index, fov_cluster_names] = counts
-        cell_neighbor_freqs.loc[current_fov_neighborhood_data.index, fov_cluster_names] = freqs
+    with tqdm(total=len(included_fovs), desc="Neighbors Matrix Generation") \
+            as neighbor_mat_progress:
+        for fov in included_fovs:
+            # Subsetting expression matrix to only include patients with correct fov label
+            current_fov_idx = all_neighborhood_data.loc[:, fov_col] == fov
+            current_fov_neighborhood_data = all_neighborhood_data[current_fov_idx]
+
+            # Get the subset of phenotypes included in the current fov
+            fov_cluster_names = current_fov_neighborhood_data[cell_type_col].drop_duplicates()
+
+            # Retrieve fov-specific distance matrix from distance matrix dictionary
+            dist_matrix = xr.load_dataarray(os.path.join(dist_mat_dir, str(fov) + '_dist_mat.xr'))
+
+            # Get cell_neighbor_counts and cell_neighbor_freqs for fovs
+            counts, freqs = spatial_analysis_utils.compute_neighbor_counts(
+                current_fov_neighborhood_data, dist_matrix, distlim, self_neighbor,
+                cell_label_col=cell_label_col, cluster_name_col=cell_type_col)
+
+            # Add to neighbor counts+freqs for only matching phenos between fov and whole dataset
+            cell_neighbor_counts.loc[current_fov_neighborhood_data.index, fov_cluster_names] \
+                = counts
+            cell_neighbor_freqs.loc[current_fov_neighborhood_data.index, fov_cluster_names]\
+                = freqs
+
+            neighbor_mat_progress.set_postfix(FOV=fov)
+            neighbor_mat_progress.update(1)
 
     # Remove cells that have no neighbors within the distlim
     total_cell_count = cell_neighbor_counts.shape[0]
     keep_cells = cell_neighbor_counts.drop(included_columns, axis=1).sum(axis=1) != 0
     cell_neighbor_counts = cell_neighbor_counts.loc[keep_cells].reset_index(drop=True)
     cell_neighbor_freqs = cell_neighbor_freqs.loc[keep_cells].reset_index(drop=True)
     # issue warning if more than 5% of cells are dropped
@@ -368,80 +376,82 @@
 
     Returns:
         tuple(list, list):
             - the target/reference ratios of each FOV
             - the reference/target ratios of each FOV
     """
 
-    targ_ref_ratio, ref_targ_ratio = [], []
+    targ_ref_ratio, ref_targ_ratio = np.empty(0), np.empty(0)
     for fov in fov_list:
         # subset neighbors mat by fov, drop fov name and labels
         neighbors_mat_fov = neighbors_mat[neighbors_mat[fov_col] == fov]
         misc_utils.verify_in_list(provided_column_names=[cell_col, fov_col, label_col],
                                   cell_neighbors_columns=neighbors_mat.columns)
         neighbors_mat_fov = neighbors_mat_fov.drop(columns=[fov_col, label_col])
 
         # get number of target and reference cells in sample
         target_total = neighbors_mat_fov[neighbors_mat_fov[cell_col].isin(target_cells)].shape[0]
         reference_total = neighbors_mat_fov[
             neighbors_mat_fov[cell_col].isin(reference_cells)].shape[0]
 
         if target_total == 0 or reference_total == 0:
-            targ_ref_ratio.append(np.nan)
-            ref_targ_ratio.append(np.nan)
+            targ_ref_ratio = np.append(targ_ref_ratio, np.nan)
+            ref_targ_ratio = np.append(ref_targ_ratio, np.nan)
         else:
-            targ_ref_ratio.append(target_total / reference_total)
-            ref_targ_ratio.append(reference_total / target_total)
+            targ_ref_ratio = np.append(targ_ref_ratio, target_total / reference_total)
+            ref_targ_ratio = np.append(ref_targ_ratio, reference_total / target_total)
 
     # remove nan values for plotting
-    targ_ref_remove_nan = [x for x in targ_ref_ratio if str(x) != 'nan']
-    ref_targ_remove_nan = [x for x in ref_targ_ratio if str(x) != 'nan']
+    targ_ref_remove_nan = targ_ref_ratio[~np.isnan(targ_ref_ratio)]
+    ref_targ_remove_nan = ref_targ_ratio[~np.isnan(ref_targ_ratio)]
+
+    # filter values
+    targ_ref_filter = targ_ref_remove_nan[targ_ref_remove_nan < 15]
+    ref_targ_filter = ref_targ_remove_nan[ref_targ_remove_nan < 15]
 
     # create ratio plots
     sns.set(rc={'figure.figsize': (16, 4)})
     fig, (ax1, ax2) = plt.subplots(1, 2)
     fig.suptitle("Population 1 / Population 2 Ratios")
-    ax1.boxplot(targ_ref_remove_nan, 0, 'c', vert=False)
+    ax1.boxplot(targ_ref_filter, 0, 'c', vert=False)
     ax1.set(xlabel='Ratio')
-    ax2.hist(targ_ref_remove_nan, bins=bin_number)
+    ax2.hist(targ_ref_filter, bins=bin_number)
     ax2.set(xlabel='Ratio', ylabel='Count')
     fig2, (ax3, ax4) = plt.subplots(1, 2)
     fig2.suptitle("Population 2 / Population 1 Ratios")
-    ax3.boxplot(ref_targ_remove_nan, 0, 'c', vert=False)
+    ax3.boxplot(ref_targ_filter, 0, 'c', vert=False)
     ax3.set(xlabel='Ratio')
-    ax4.hist(ref_targ_remove_nan, bins=bin_number)
+    ax4.hist(ref_targ_filter, bins=bin_number)
     ax4.set(xlabel='Ratio', ylabel='Count')
 
-    ratio_data = pd.DataFrame(list(zip(fov_list, targ_ref_ratio, ref_targ_ratio)),
-                              columns=['fov', 'pop1_pop2_ratio', 'pop2_pop1_ratio'])
+    ratio_data = pd.DataFrame(list(zip(fov_list, targ_ref_ratio)),
+                              columns=['fov', 'cell_ratio'])
     return ratio_data
 
 
-def compute_mixing_score(fov_neighbors_mat, fov, target_cells, reference_cells, mixing_type,
-                         ratio_threshold=5, cell_count_thresh=0,
+def compute_mixing_score(fov_neighbors_mat, target_cells, reference_cells, mixing_type,
+                         ratio_threshold=5, cell_count_thresh=200,
                          cell_col=settings.CELL_TYPE, fov_col=settings.FOV_ID,
                          label_col=settings.CELL_LABEL):
     """ Compute and return the mixing score for the specified target/reference cell types
 
     Args:
         fov_neighbors_mat (pandas.DataFrame):
             a neighborhood matrix, created from create_neighborhood_matrix and subsetted for 1 fov
-        fov (str):
-            single fov to compute mixing score for
         target_cells (list):
             invading cell phenotypes
         reference_cells (list):
             expected cell phenotypes
         mixing_type (str):
             "homogeneous" or "percent", homogeneous is a symmetrical calculation
         ratio_threshold (int):
             maximum ratio of cell_types required to calculate a mixing score,
             under this labeled "cold"
         cell_count_thresh (int):
-            minimum number of cells in each population to calculate a mixing score,
+            minimum number of total cells from both populations to calculate a mixing score,
             under this labeled "cold"
         cell_col (str):
             column with the cell phenotype
         fov_col (str):
             column with the fovs
         label_col (str):
             column with the cell labels
@@ -466,22 +476,24 @@
     # mixing_type validation
     if mixing_type not in ['percent', 'homogeneous']:
         raise ValueError(f'Please provide a valid mixing_type: "percent" or "homogeneous".')
 
     # get number of target and reference cells in sample
     target_total = fov_neighbors_mat[fov_neighbors_mat[cell_col].isin(target_cells)].shape[0]
     ref_total = fov_neighbors_mat[fov_neighbors_mat[cell_col].isin(reference_cells)].shape[0]
-    if ref_total < cell_count_thresh or target_total < cell_count_thresh:
-        return np.nan
+
+    # check cell count threshold
+    if (target_total + ref_total) < cell_count_thresh:
+        return np.nan, (target_total + ref_total)
     elif ref_total == 0 or target_total == 0:
-        return np.nan
+        return np.nan, (target_total + ref_total)
 
-    # check threshold
+    # check ratio threshold
     if ref_total/target_total > ratio_threshold or target_total/ref_total > ratio_threshold:
-        return np.nan
+        return np.nan, (target_total + ref_total)
 
     # condense to total number of cell type interactions
     fov_neighbors_mat[cell_col] = fov_neighbors_mat[cell_col].replace(target_cells, 'target')
     fov_neighbors_mat[cell_col] = fov_neighbors_mat[cell_col].replace(reference_cells, 'reference')
     interactions_mat = fov_neighbors_mat.groupby(by=[cell_col]).sum(numeric_only=True)
 
     # combine cell interactions by target and reference populations
@@ -504,8 +516,8 @@
     if mixing_type == 'percent':
         # percent mixing
         mixing_score = reference_target / (reference_target + target_target)
     elif mixing_type == 'homogeneous':
         # homogenous mixing
         mixing_score = reference_target / (target_target + reference_reference)
 
-    return mixing_score
+    return mixing_score, (target_total + ref_total)
```

### Comparing `ark-analysis-0.6.3/src/ark/analysis/spatial_analysis_utils.py` & `ark-analysis-0.6.4/src/ark/analysis/spatial_analysis_utils.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,32 +2,32 @@
 
 import numpy as np
 import pandas as pd
 import scipy
 import skimage.measure
 import sklearn.metrics
 import xarray as xr
+from alpineer import io_utils, load_utils, misc_utils
 from scipy.spatial.distance import cdist
 from sklearn.cluster import KMeans
 from statsmodels.stats.multitest import multipletests
-from alpineer import io_utils, load_utils, misc_utils
 from tqdm.notebook import tqdm
 
 import ark.settings as settings
 from ark.utils._bootstrapping import compute_close_num_rand
 
 
 def calc_dist_matrix(label_dir, save_path, prefix='_whole_cell'):
     """Generate matrix of distances between center of pairs of cells.
 
     Saves each one individually to `save_path`.
 
     Args:
         label_dir (str):
-            path to segmentation masks indexed by `(fov, cell_id, cell_id, segmentation_label)`
+            path to segmentation masks indexed by `(fov, cell_id, cell_id, label)`
         save_path (str):
             path to save the distance matrices
         prefix (str):
             the prefix used to identify label map files in `label_dir`
     """
 
     # check that both label_dir and save_path exist
@@ -41,19 +41,19 @@
         for fov_file in fov_files:
             # retrieve the fov name
             fov_name = fov_file.replace(prefix + '.tiff', '')
 
             # load in the data
             fov_data = load_utils.load_imgs_from_dir(
                 label_dir, [fov_file], match_substring=prefix,
-                trim_suffix=prefix, xr_channel_names=['segmentation_label']
+                trim_suffix=prefix, xr_channel_names=['label']
             )
 
             # keep just the middle two dimensions
-            fov_data = fov_data.loc[fov_name, :, :, 'segmentation_label'].values
+            fov_data = fov_data.loc[fov_name, :, :, 'label'].values
 
             # extract region properties of label map, then just get centroids
             props = skimage.measure.regionprops(fov_data)
             centroids = [prop.centroid for prop in props]
             centroid_labels = [prop.label for prop in props]
 
             # generate the distance matrix, then assign centroid_labels as coords
@@ -62,14 +62,15 @@
 
             # save the distance matrix to save_path
             dist_mat_xarr.to_netcdf(
                 os.path.join(save_path, fov_name + '_dist_mat.xr'),
                 format='NETCDF3_64BIT'
             )
 
+            dist_mat_progress.set_postfix(FOV=fov_name)
             dist_mat_progress.update(1)
 
 
 def append_distance_features_to_dataset(fov, dist_matrix, cell_table, distance_columns):
     """Appends selected distance features as 'cells' in distance matrix and cell table
 
     Args:
@@ -584,13 +585,13 @@
             the random seed to set for k-means clustering
 
     Returns:
         numpy.ndarray:
             the neighborhood cluster labels assigned to each cell in neighbor_mat_data
     """
 
-    cluster_fit = KMeans(n_clusters=cluster_num, random_state=seed, n_init='auto').\
+    cluster_fit = KMeans(n_clusters=cluster_num, random_state=seed, n_init=10).\
         fit(neighbor_mat_data)
     # Add 1 to avoid cluster number 0
     cluster_labels = cluster_fit.labels_ + 1
 
     return cluster_labels
```

### Comparing `ark-analysis-0.6.3/src/ark/analysis/spatial_enrichment.py` & `ark-analysis-0.6.4/src/ark/analysis/spatial_enrichment.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,23 +1,22 @@
 import os
 from itertools import combinations_with_replacement
 
 import numpy as np
-import pandas as pd
 import xarray as xr
-from tqdm.notebook import tqdm
 from alpineer import io_utils, load_utils, misc_utils
+from tqdm.notebook import tqdm
 
 import ark.settings as settings
 from ark.analysis import spatial_analysis_utils
 
 
 def generate_channel_spatial_enrichment_stats(label_dir, dist_mat_dir, marker_thresholds, all_data,
                                               suffix='_whole_cell',
-                                              xr_channel_name='segmentation_label', **kwargs):
+                                              xr_channel_name='label', **kwargs):
     """Wrapper function for batching calls to `calculate_channel_spatial_enrichment` over fovs
 
     Args:
         label_dir (str | Pathlike):
             directory containing labeled tiffs
         dist_mat_dir (str | Pathlike):
             directory containing the distance matrices
@@ -236,15 +235,15 @@
     stats.loc[fov, :, :] = stats_xr.values
 
     return values, stats
 
 
 def generate_cluster_spatial_enrichment_stats(label_dir, dist_mat_dir, all_data,
                                               suffix='_whole_cell',
-                                              xr_channel_name='segmentation_label', **kwargs):
+                                              xr_channel_name='label', **kwargs):
     """ Wrapper function for batching calls to `calculate_cluster_spatial_enrichment` over fovs
 
     Args:
         label_dir (str | Pathlike):
             directory containing labeled tiffs
         dist_mat_dir (str | Pathlike):
             directory containing the distance matrices
```

### Comparing `ark-analysis-0.6.3/src/ark/analysis/visualize.py` & `ark-analysis-0.6.4/src/ark/analysis/visualize.py`

 * *Files 0% similar despite different names*

```diff
@@ -143,14 +143,16 @@
     _ = heatmap.gs.update(
         left=left_start, right=right_start, wspace=w_spacing, hspace=h_spacing
     )
 
     # ensure the y-axis labels are horizontal, will be misaligned if vertical
     _ = plt.setp(heatmap.ax_heatmap.get_yticklabels(), rotation=0)
 
+    plt.tight_layout()
+
     if save_dir is not None:
         misc_utils.save_figure(save_dir, save_file, dpi=dpi)
 
 
 def get_sorted_data(cell_data, sort_by_first, sort_by_second, is_normalized=False):
     """Gets the cell data and generates a new Sorted DataFrame with each row representing a
     patient and column representing Population categories
```

### Comparing `ark-analysis-0.6.3/src/ark/phenotyping/cell_cluster_utils.py` & `ark-analysis-0.6.4/src/ark/phenotyping/cell_cluster_utils.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,15 @@
 import os
 import warnings
 
 import feather
+import numpy as np
 import pandas as pd
 from alpineer import io_utils, misc_utils
 
-from ark.phenotyping import cluster_helpers
-
 
 def compute_cell_som_cluster_cols_avg(cell_cluster_data, cell_som_cluster_cols,
                                       cell_cluster_col, keep_count=False):
     """For each cell SOM cluster, compute the average expression of all `cell_som_cluster_cols`
 
     Args:
         cell_cluster_data (pandas.DataFrame):
@@ -45,23 +44,23 @@
     # subset the data by columns used for SOM training, as well as the cell SOM assignments
     cell_cluster_data_subset = cell_cluster_data.loc[
         :, list(cell_som_cluster_cols) + [cell_cluster_col]
     ]
 
     # average each column grouped by the cell cluster column
     mean_count_totals = cell_cluster_data_subset.groupby(cell_cluster_col).mean().reset_index()
+    mean_count_totals[cell_cluster_col] = mean_count_totals[cell_cluster_col].astype(np.int64)
 
     # if keep_count is included, add the count column to the cell table
     if keep_count:
         cell_cluster_totals = cell_cluster_data_subset.groupby(
             cell_cluster_col
         ).size().to_frame('count')
         cell_cluster_totals = cell_cluster_totals.reset_index(drop=True)
         mean_count_totals['count'] = cell_cluster_totals['count']
-
     return mean_count_totals
 
 
 def create_c2pc_data(fovs, pixel_data_path, cell_table_path,
                      pixel_cluster_col='pixel_meta_cluster_rename'):
     """Create a matrix with each fov-cell label pair and their SOM pixel/meta cluster counts
 
@@ -101,64 +100,64 @@
 
     # subset on fov, label, and cell size
     cell_table = cell_table[['fov', 'label', 'cell_size']]
 
     # convert labels to int type
     cell_table['label'] = cell_table['label'].astype(int)
 
-    # rename cell_table label as segmentation_label for joining purposes
-    cell_table = cell_table.rename(columns={'label': 'segmentation_label'})
-
     # subset on only the fovs the user has specified
     cell_table = cell_table[cell_table['fov'].isin(fovs)]
 
     # define cell_table columns to subset on for merging
-    cell_table_cols = ['fov', 'segmentation_label', 'cell_size']
+    cell_table_cols = ['fov', 'label', 'cell_size']
 
     for fov in fovs:
         # read in the pixel dataset for the fov
         fov_pixel_data = feather.read_dataframe(
             os.path.join(pixel_data_path, fov + '.feather')
         )
 
-        # create a groupby object that aggregates the segmentation_label and the pixel_cluster_col
+        if "segmentation_label" in fov_pixel_data.columns:
+            fov_pixel_data.rename(columns={"segmentation_label": "label"}, inplace=True)
+
+        # create a groupby object that aggregates the label and the pixel_cluster_col
         # intermediate step for creating a pivot table, makes it easier
         group_by_cluster_col = fov_pixel_data.groupby(
-            ['segmentation_label', pixel_cluster_col]
+            ['label', pixel_cluster_col]
         ).size().reset_index(name='count')
 
         # if cluster labels end up as float (can happen with numeric types), convert to int
         if group_by_cluster_col[pixel_cluster_col].dtype == float:
             group_by_cluster_col[pixel_cluster_col] = group_by_cluster_col[
                 pixel_cluster_col
             ].astype(int)
 
         # counts number of pixel SOM/meta clusters per cell
         num_cluster_per_seg_label = group_by_cluster_col.pivot(
-            index='segmentation_label', columns=pixel_cluster_col, values='count'
+            index='label', columns=pixel_cluster_col, values='count'
         ).fillna(0).astype(int)
 
         # renames the columns to have 'pixel_som_cluster_' or 'pixel_meta_cluster_rename_' prefix
         new_columns = [
             '%s_' % pixel_cluster_col + str(c) for c in num_cluster_per_seg_label.columns
         ]
         num_cluster_per_seg_label.columns = new_columns
 
         # get intersection of the segmentation labels between cell_table_indices
         # and num_cluster_per_seg_label
-        cell_table_labels = list(cell_table[cell_table['fov'] == fov]['segmentation_label'])
+        cell_table_labels = list(cell_table[cell_table['fov'] == fov]['label'])
         cluster_labels = list(num_cluster_per_seg_label.index.values)
         label_intersection = list(set(cell_table_labels).intersection(cluster_labels))
 
         # subset on the label intersection
         num_cluster_per_seg_label = num_cluster_per_seg_label.loc[label_intersection]
         cell_table_indices = pd.Index(
             cell_table[
                 (cell_table['fov'] == fov) &
-                (cell_table['segmentation_label'].isin(label_intersection))
+                (cell_table['label'].isin(label_intersection))
             ].index.values
         )
 
         # combine the data of num_cluster_per_seg_label into cell_table_indices
         num_cluster_per_seg_label = num_cluster_per_seg_label.set_index(cell_table_indices)
         cell_table = cell_table.combine_first(num_cluster_per_seg_label)
 
@@ -206,22 +205,22 @@
 
     # file path validation
     io_utils.validate_paths([cell_table_path])
 
     # read in the data, ensure sorted by FOV column just in case
     cell_table = pd.read_csv(cell_table_path)
 
-    # for a simpler merge, rename segmentation_label to label in consensus_data
-    cell_som_results = cell_som_input_data.rename(
-        {'segmentation_label': 'label'}, axis=1
-    )
+    # for a simpler merge, rename label to label in consensus_data
+    # if it is `segmentation_label`
+    if "segmentation_label" in cell_som_input_data.columns:
+        cell_som_input_data.rename(columns={"segmentation_label": "label"}, inplace=True)
 
     # merge the cell table with the consensus data to retrieve the meta clusters
     cell_table_merged = cell_table.merge(
-        cell_som_results, how='left', on=['fov', 'label']
+        cell_som_input_data, how='left', on=['fov', 'label']
     )
 
     # adjust column names and drop consensus data-specific columns
     # NOTE: non-pixel cluster inputs will not have the cell size attribute for normalization
     if 'cell_size_y' in cell_table_merged.columns.values:
         cell_table_merged = cell_table_merged.drop(columns=['cell_size_y'])
         cell_table_merged = cell_table_merged.rename(
```

### Comparing `ark-analysis-0.6.3/src/ark/phenotyping/cell_meta_clustering.py` & `ark-analysis-0.6.4/src/ark/phenotyping/cell_meta_clustering.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,18 @@
 import os
 
 import numpy as np
 import pandas as pd
 from alpineer import io_utils, misc_utils
 
-from ark.phenotyping import cluster_helpers
-from ark.phenotyping import cell_cluster_utils
+from ark.phenotyping import cell_cluster_utils, cluster_helpers
 
 
 def cell_consensus_cluster(base_dir, cell_som_cluster_cols, cell_som_input_data,
-                           cell_som_expr_col_avg_name, max_k=20, cap=3, seed=42):
+                           cell_som_expr_col_avg_name, max_k=20, cap=3, seed=42, overwrite=False):
     """Run consensus clustering algorithm on cell-level data averaged across each cell SOM cluster.
 
     Saves data with consensus cluster labels to cell_consensus_name.
 
     Args:
         base_dir (str):
             The path to the data directory
@@ -26,21 +25,24 @@
             Used to run consensus clustering on.
         max_k (int):
             The number of consensus clusters
         cap (int):
             z-score cap to use when hierarchical clustering
         seed (int):
             The random seed to set for consensus clustering
+        overwrite (bool):
+            If set, overwrites the meta cluster assignments if they exist
 
     Returns:
         tuple:
             - cluster_helpers.PixieConsensusCluster: the consensus cluster object containing the
               SOM to meta mapping
             - pandas.DataFrame: the input data used for SOM training with meta labels attached
     """
+
     # define the paths to the data
     som_expr_col_avg_path = os.path.join(base_dir, cell_som_expr_col_avg_name)
 
     # check paths
     io_utils.validate_paths([som_expr_col_avg_path])
 
     # load in the cell SOM average expression data
@@ -53,14 +55,23 @@
     )
 
     # define the cell consensus cluster object
     cell_cc = cluster_helpers.PixieConsensusCluster(
         'cell', som_expr_col_avg_path, cell_som_cluster_cols, max_k=max_k, cap=cap
     )
 
+    if 'cell_meta_cluster' in cell_som_input_data:
+        # if cell_meta_cluster column exists and no overwrite set, return immediately
+        if not overwrite:
+            print("Meta clusters already assigned to each cell")
+            return cell_cc, cell_som_input_data
+
+        print("Overwrite flag set, reassigning meta cluster labels")
+        cell_som_input_data = cell_som_input_data.drop(columns='cell_meta_cluster')
+
     # z-score and cap the data
     print("z-score scaling and capping data")
     cell_cc.scale_data()
 
     # set random seed for consensus clustering
     np.random.seed(seed)
 
@@ -141,14 +152,20 @@
 
     print(
         "Mapping meta cluster values onto average expression values across cell SOM clusters"
     )
 
     # read in the average number of pixel/SOM clusters across all cell SOM clusters
     cell_som_cluster_avgs = pd.read_csv(som_expr_col_avg_path)
+    cell_som_cluster_avgs['cell_som_cluster'] = cell_som_cluster_avgs['cell_som_cluster'].astype(
+        int)
+
+    # this happens if the overwrite flag is set with previously generated data, need to overwrite
+    if 'cell_meta_cluster' in cell_som_cluster_avgs.columns.values:
+        cell_som_cluster_avgs = cell_som_cluster_avgs.drop(columns='cell_meta_cluster')
 
     # merge metacluster assignments in
     cell_som_cluster_avgs = pd.merge_asof(
         cell_som_cluster_avgs, cell_cc.mapping, on='cell_som_cluster'
     )
 
     # resave average number of pixel/SOM clusters across all cell SOM clusters
@@ -188,28 +205,29 @@
     # assert the correct columns are contained
     misc_utils.verify_same_elements(
         remapped_data_cols=cell_remapped_data.columns.values,
         required_cols=['cell_som_cluster', 'cell_meta_cluster', 'cell_meta_cluster_rename']
     )
 
     # create the mapping from cell SOM to cell meta cluster
-    # TODO: generating cell_remapped_dict and cell_renamed_meta_dict should be returned
+    # TODO: generated cell_remapped_dict and cell_renamed_meta_dict should be returned
     # to prevent repeat computation in summary file generation functions
     cell_remapped_dict = dict(
         cell_remapped_data[
             ['cell_som_cluster', 'cell_meta_cluster']
         ].values
     )
 
+    # ensure no duplicated renamed meta clusters make it in
+    cluster_helpers.verify_unique_meta_clusters(cell_remapped_data, meta_cluster_type="cell")
+
     # create the mapping from cell meta cluster to cell renamed meta cluster
-    cell_renamed_meta_dict = dict(
-        cell_remapped_data[
-            ['cell_meta_cluster', 'cell_meta_cluster_rename']
-        ].drop_duplicates().values
-    )
+    cell_renamed_meta_dict = dict(cell_remapped_data[
+        ['cell_meta_cluster', 'cell_meta_cluster_rename']
+    ].drop_duplicates().values)
 
     # load the cell consensus data in
     print("Using re-mapping scheme to re-label cell meta clusters")
     # ensure that no SOM clusters are missing from the mapping
     misc_utils.verify_in_list(
         fov_som_labels=cell_som_input_data['cell_som_cluster'],
         som_labels_in_mapping=list(cell_remapped_dict.keys())
```

### Comparing `ark-analysis-0.6.3/src/ark/phenotyping/cell_som_clustering.py` & `ark-analysis-0.6.4/src/ark/phenotyping/cell_som_clustering.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,13 +1,12 @@
 import os
 
 from alpineer import io_utils, misc_utils
 
-from ark.phenotyping import cluster_helpers
-from ark.phenotyping import cell_cluster_utils
+from ark.phenotyping import cell_cluster_utils, cluster_helpers
 
 
 def train_cell_som(fovs, base_dir, cell_table_path, cell_som_cluster_cols,
                    cell_som_input_data, som_weights_name='cell_som_weights.feather',
                    xdim=10, ydim=10, lr_start=0.05, lr_end=0.01, num_passes=1, seed=42,
                    overwrite=False):
     """Run the SOM training on the expression columns specified in `cell_som_cluster_cols`.
@@ -70,45 +69,53 @@
     # NOTE: seed has to be set in cyFlowSOM.pyx, done by passing flag in PixieSOMCluster
     print("Training SOM")
     cell_pysom.train_som(overwrite=overwrite)
 
     return cell_pysom
 
 
-def cluster_cells(base_dir, cell_pysom, cell_som_cluster_cols):
+def cluster_cells(base_dir, cell_pysom, cell_som_cluster_cols, overwrite=False):
     """Uses trained SOM weights to assign cluster labels on full cell data.
 
     Saves data with cluster labels to `cell_cluster_name`.
 
     Args:
         base_dir (str):
             The path to the data directory
         cell_pysom (cluster_helpers.CellSOMCluster):
             The SOM cluster object containing the cell SOM weights
         cell_som_cluster_cols (list):
             The list of columns used for SOM training
+        overwrite (bool):
+            If set, overwrites the SOM cluster assignments if they exist
 
     Returns:
         pandas.DataFrame:
             The cell data in `cell_pysom.cell_data` with SOM labels assigned
     """
 
     # raise error if weights haven't been assigned to cell_pysom
     if cell_pysom.weights is None:
         raise ValueError("Using untrained cell_pysom object, please invoke train_cell_som first")
 
+    if "segmentation_label" in cell_pysom.cell_data.columns:
+        cell_pysom.cell_data.rename(columns={"segmentation_label": "label"}, inplace=True)
+
     # non-pixel cluster inputs won't be cell size normalized
-    cols_to_drop = ['fov', 'segmentation_label']
+    cols_to_drop = ['fov', 'label']
     if 'cell_size' in cell_pysom.cell_data.columns.values:
         cols_to_drop.append('cell_size')
 
-    # ensure the weights columns are valid indexes, do so by ensuring
-    # the cluster_counts_norm and weights columns are the same
-    # minus the metadata columns (and possibly cluster col) that appear in cluster_counts_norm
     if 'cell_som_cluster' in cell_pysom.cell_data.columns.values:
+        # if cell_som_cluster column exists and no overwrite set, return immediately
+        if not overwrite:
+            print("SOM clusters already assigned to each cell")
+            return cell_pysom.cell_data
+
+        print("Overwrite flag set, reassigning SOM cluster labels")
         cols_to_drop.append('cell_som_cluster')
 
     # the cell_som_input_data and weights columns are the same
     # minus the metadata columns that appear in cluster_counts_norm
     cell_som_input_data = cell_pysom.cell_data.drop(
         columns=cols_to_drop
     )
@@ -172,8 +179,8 @@
         keep_count=True
     )
 
     # save the average expression values of cell_som_cluster_cols per cell SOM cluster
     cell_som_cluster_avgs.to_csv(
         som_expr_col_avg_path,
         index=False
-    )
+    )
```

### Comparing `ark-analysis-0.6.3/src/ark/phenotyping/cluster_helpers.py` & `ark-analysis-0.6.4/src/ark/phenotyping/cluster_helpers.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,23 +1,56 @@
 import bisect
 import os
 import pathlib
 import warnings
 from abc import ABC, abstractmethod
 from itertools import combinations
-from typing import List, Protocol, runtime_checkable
+from typing import List, Literal, Protocol, runtime_checkable
 
 import feather
 import numpy as np
 import pandas as pd
+from alpineer.io_utils import list_files, validate_paths
+from alpineer.misc_utils import verify_in_list
 from pyFlowSOM import map_data_to_nodes, som
 from scipy.stats import zscore
 from sklearn.cluster import AgglomerativeClustering
-from alpineer.io_utils import list_files, validate_paths
-from alpineer.misc_utils import verify_in_list
+
+
+def verify_unique_meta_clusters(pixie_remapped_data: pd.DataFrame,
+                                meta_cluster_type: Literal["pixel", "cell"]):
+    """Verifies that a mapping contains a unique renamed meta cluster for every base meta cluster
+
+    Args:
+        pixie_remapped_data (pandas.DataFrame):
+            Must have `{pixel/cell}_meta_cluster` and `{pixel/cell}_meta_cluster_rename` columns
+        meta_cluster_type (Literal["pixel", "cell"]):
+            Whether pixel or cell meta clusters are being validated
+
+    Raises:
+        ValueError:
+            If there are duplicate `{pixel/cell}_meta_cluster_rename` entries for multiple
+            `{pixel/cell}_meta_cluster` values
+    """
+    verify_in_list(
+        specified_meta_cluster=meta_cluster_type,
+        acceptable_meta_clusters=["pixel", "cell"]
+    )
+
+    meta_pairs = pixie_remapped_data[
+        [f"{meta_cluster_type}_meta_cluster", f"{meta_cluster_type}_meta_cluster_rename"]
+    ].drop_duplicates()
+    meta_dups = meta_pairs[
+        meta_pairs.duplicated(f"{meta_cluster_type}_meta_cluster_rename", keep=False)
+    ][f"{meta_cluster_type}_meta_cluster_rename"].unique().tolist()
+    if len(meta_dups) > 0:
+        raise ValueError(
+            f"Duplicate renamed {meta_cluster_type} meta cluster values found: %s, "
+            "please re-run remapping GUI to resolve naming conflicts" % str(meta_dups)
+        )
 
 
 class PixieSOMCluster(ABC):
     @abstractmethod
     def __init__(self, weights_path: pathlib.Path, columns: List[str], num_passes: int = 1,
                  xdim: int = 10, ydim: int = 10, lr_start: float = 0.05, lr_end: float = 0.01,
                  seed=42):
@@ -112,14 +145,17 @@
             cluster_labels.append(map_data_to_nodes(
                 self.weights.values.astype(np.float64),
                 external_data.loc[
                     i:min(i + 99, external_data.shape[0]), weights_cols
                 ].values.astype(np.float64)
             )[0])
 
+        # if no pixels in the image, return empty array
+        if not cluster_labels:
+            return np.empty(0)
         # concat all the results together and return
         return np.concatenate(cluster_labels)
 
 
 class PixelSOMCluster(PixieSOMCluster):
     def __init__(self, pixel_subset_folder: pathlib.Path, norm_vals_path: pathlib.Path,
                  weights_path: pathlib.Path, fovs: List[str], columns: List[str],
@@ -500,16 +536,15 @@
                 `(examples,attributes)` format
 
         Returns:
             pandas.DataFrame:
                 The data matrix prediction for `self.bestK`.
         """
         assert self.Mk is not None, "First run fit"
-        return self.cluster_(n_clusters=self.bestK).fit_predict(
-            data)
+        return self.cluster_(n_clusters=self.bestK).fit_predict(data)
 
 
 class PixieConsensusCluster:
     def __init__(self, cluster_type: str, input_file: pathlib.Path, columns: List[str],
                  max_k: int = 20, cap: float = 3):
         """Constructs a generic ConsensusCluster pipeline object that makes use of
         Sagovic's implementation of consensus clustering in Python.
@@ -583,14 +618,15 @@
         """Maps each `'{self.cluster_type}_som_cluster'` to the meta cluster
         generated by `ConsensusCluster`.
 
         Also assigns mapping to `self.mapping` for use in `assign_consensus_labels`.
         """
         self.input_data[self.meta_col] = self.cc.predict_data(self.input_data[self.columns])
         self.mapping = self.input_data[[self.som_col, self.meta_col]].copy()
+        self.mapping = self.mapping.astype(int)
 
         # we assume clusters are 1-indexed, so need to correct for Sagovic's 0-indexing
         self.mapping.loc[:, self.meta_col] += 1
 
     def save_som_to_meta_map(self, save_path: pathlib.Path):
         """Saves the mapping generated by `ConsensusCluster` to `save_path`.
```

### Comparing `ark-analysis-0.6.3/src/ark/phenotyping/pixel_cluster_utils.py` & `ark-analysis-0.6.4/src/ark/phenotyping/pixel_cluster_utils.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,19 +3,18 @@
 import warnings
 from typing import List
 
 import feather
 import numpy as np
 import pandas as pd
 import scipy.ndimage as ndimage
+from alpineer import image_utils, io_utils, load_utils, misc_utils
 from pyarrow.lib import ArrowInvalid
 from skimage.io import imread
 
-from alpineer import image_utils, io_utils, load_utils, misc_utils
-
 
 def calculate_channel_percentiles(tiff_dir, fovs, channels, img_sub_folder,
                                   percentile):
     """Calculates average percentile for each channel in the dataset
 
     Args:
         tiff_dir (str):
@@ -107,19 +106,19 @@
 
 def normalize_rows(pixel_data, channels, include_seg_label=True):
     """Normalizes the rows of a pixel matrix by their sum
 
     Args:
         pixel_data (pandas.DataFrame):
             The dataframe containing the pixel data for a given fov
-            Includes channel and meta (`fov`, `segmentation_label`, etc.) columns
+            Includes channel and meta (`fov`, `label`, etc.) columns
         channels (list):
             List of channels to subset over
         include_seg_label (bool):
-            Whether to include `'segmentation_label'` as a metadata column
+            Whether to include `'label'` as a metadata column
 
     Returns:
         pandas.DataFrame:
             The pixel data with rows normalized and 0-sum rows removed
     """
 
     # subset the fov data by the channels the user trained the pixel SOM on
@@ -127,17 +126,17 @@
 
     # divide each row by their sum
     pixel_data_sub = pixel_data_sub.div(pixel_data_sub.sum(axis=1), axis=0)
 
     # define the meta columns to add back
     meta_cols = ['fov', 'row_index', 'column_index']
 
-    # add the segmentation_label column if it should be kept
+    # add the label column if it should be kept
     if include_seg_label:
-        meta_cols.append('segmentation_label')
+        meta_cols.append('label')
 
     # add back meta columns, making sure to remove 0-row indices
     pixel_data_sub[meta_cols] = pixel_data.loc[pixel_data_sub.index.values, meta_cols]
 
     return pixel_data_sub
```

### Comparing `ark-analysis-0.6.3/src/ark/phenotyping/pixel_meta_clustering.py` & `ark-analysis-0.6.4/src/ark/phenotyping/pixel_meta_clustering.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,19 @@
 import multiprocessing
 import os
-import random
 from functools import partial
-from shutil import rmtree, move
+from shutil import move, rmtree
 
 import feather
 import numpy as np
 import pandas as pd
-from pyarrow.lib import ArrowInvalid
 from alpineer import io_utils, misc_utils
+from pyarrow.lib import ArrowInvalid
 
-from ark.phenotyping import cluster_helpers
-from ark.phenotyping import pixel_cluster_utils
+from ark.phenotyping import cluster_helpers, pixel_cluster_utils
 
 multiprocessing.set_start_method('spawn', force=True)
 
 
 def run_pixel_consensus_assignment(pixel_data_path, pixel_cc_obj, fov):
     """Helper function to assign pixel consensus clusters
 
@@ -256,16 +254,25 @@
         meta_cluster_avg_path,
         index=False
     )
 
     # merge metacluster assignments in
     print("Mapping meta cluster values onto average channel expression across pixel SOM clusters")
     pixel_channel_avg_som_cluster = pd.read_csv(som_cluster_avg_path)
+
+    # this happens if the overwrite flag is set with previously generated data, need to overwrite
+    if 'pixel_meta_cluster' in pixel_channel_avg_som_cluster.columns.values:
+        pixel_channel_avg_som_cluster = pixel_channel_avg_som_cluster.drop(
+            columns='pixel_meta_cluster'
+        )
+
+    pixel_channel_avg_som_cluster["pixel_som_cluster"] =\
+        pixel_channel_avg_som_cluster["pixel_som_cluster"].astype(int)
     pixel_channel_avg_som_cluster = pd.merge_asof(
-        pixel_channel_avg_som_cluster, pixel_cc.mapping, on='pixel_som_cluster'
+        pixel_channel_avg_som_cluster, pixel_cc.mapping, on="pixel_som_cluster"
     )
 
     # resave channel-averaged results across all pixel SOM clusters with metacluster assignments
     pixel_channel_avg_som_cluster.to_csv(
         som_cluster_avg_path,
         index=False
     )
@@ -367,20 +374,21 @@
     # create the mapping from pixel SOM to pixel meta cluster
     pixel_remapped_dict = dict(
         pixel_remapped_data[
             ['pixel_som_cluster', 'pixel_meta_cluster']
         ].values
     )
 
+    # ensure no duplicated renamed meta clusters make it in
+    cluster_helpers.verify_unique_meta_clusters(pixel_remapped_data, meta_cluster_type="pixel")
+
     # create the mapping from pixel meta cluster to renamed pixel meta cluster
-    pixel_renamed_meta_dict = dict(
-        pixel_remapped_data[
-            ['pixel_meta_cluster', 'pixel_meta_cluster_rename']
-        ].drop_duplicates().values
-    )
+    pixel_renamed_meta_dict = dict(pixel_remapped_data[
+        ['pixel_meta_cluster', 'pixel_meta_cluster_rename']
+    ].drop_duplicates().values)
 
     # define the partial function to iterate over
     fov_data_func = partial(
         update_pixel_meta_labels, pixel_data_path,
         pixel_remapped_dict, pixel_renamed_meta_dict
     )
```

### Comparing `ark-analysis-0.6.3/src/ark/phenotyping/pixel_som_clustering.py` & `ark-analysis-0.6.4/src/ark/phenotyping/pixel_som_clustering.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 import multiprocessing
 import os
 from functools import partial
-from shutil import rmtree, move
+from shutil import move, rmtree
+from typing import Any, Callable, Tuple
 
 import feather
-from pyarrow.lib import ArrowInvalid
 from alpineer import io_utils, misc_utils
+from pyarrow.lib import ArrowInvalid
 
-from ark.phenotyping import cluster_helpers
-from ark.phenotyping import pixel_cluster_utils
+from ark.phenotyping import cluster_helpers, pixel_cluster_utils
 
 multiprocessing.set_start_method('spawn', force=True)
 
 
 def train_pixel_som(fovs, channels, base_dir,
                     subset_dir='pixel_mat_subsetted',
                     norm_vals_name='post_rowsum_chan_norm.feather',
@@ -168,22 +168,27 @@
                               subsetted_fovs=io_utils.remove_file_extensions(data_files))
 
     # this will prevent reading in a corrupted sample_fov
     i = 0
     while i < len(data_files):
         try:
             sample_fov = feather.read_dataframe(os.path.join(base_dir, data_dir, data_files[i]))
+
+            if "segmentation_label" in sample_fov.columns:
+                sample_fov.rename(
+                    columns={"segmentation_label": "label"},
+                    inplace=True)
         except (ArrowInvalid, OSError, IOError):
             i += 1
             continue
         break
 
     # for verification purposes, drop the metadata columns
     cols_to_drop = ['fov', 'row_index', 'column_index']
-    for col in ['segmentation_label', 'pixel_som_cluster',
+    for col in ['label', 'pixel_som_cluster',
                 'pixel_meta_cluster', 'pixel_meta_cluster_rename']:
         if col in sample_fov.columns.values:
             cols_to_drop.append(col)
 
     sample_fov = sample_fov.drop(
         columns=cols_to_drop
     )
@@ -264,18 +269,34 @@
             fovs_processed += 1
 
             # update every 10 FOVs, or at the very end
             if fovs_processed % 10 == 0 or fovs_processed == len(fovs_list):
                 print("Processed %d fovs" % fovs_processed)
 
     # remove the data directory and rename the temp directory to the data directory
-    rmtree(data_path)
+    rmtree(data_path, onerror=_ignore_extended_attributes)
     move(data_path + '_temp', data_path)
 
 
+def _ignore_extended_attributes(func: Callable, filename: str, exc_info: Tuple[Any, Any, Any]):
+    """
+    Ignore the extended attribute files (prefixed with "._").
+    Read more here: https://tinyurl.com/extended-attributes
+
+    Args:
+        func (Callable): The function which raises the exception.
+        filename (str): The file where an extended attribute file fails to remove.
+        This originally gets passed into `func`.
+        exc_info (OptExcInfo): The exception information returned by `sys.exec_info()`.
+    """
+    is_meta_file: bool = os.path.basename(filename).startswith("._")
+    if not (func is os.unlink and is_meta_file):
+        raise
+
+
 def generate_som_avg_files(fovs, channels, base_dir, pixel_pysom, data_dir='pixel_data_dir',
                            pc_chan_avg_som_cluster_name='pixel_channel_avg_som_cluster.csv',
                            num_fovs_subset=100, seed=42, overwrite=False):
     """Computes and saves the average channel expression across pixel SOM clusters.
 
     Args:
         fovs (list):
```

### Comparing `ark-analysis-0.6.3/src/ark/phenotyping/pixie_preprocessing.py` & `ark-analysis-0.6.4/src/ark/phenotyping/pixie_preprocessing.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,17 @@
 import multiprocessing
 import os
-import random
-from shutil import rmtree
+from functools import partial
 
 import feather
-from functools import partial
 import numpy as np
 import pandas as pd
 import scipy.ndimage as ndimage
-from skimage.io import imread
 from alpineer import io_utils, load_utils, misc_utils
+from skimage.io import imread
 
 from ark.phenotyping import pixel_cluster_utils
 
 multiprocessing.set_start_method('spawn', force=True)
 
 
 def create_fov_pixel_data(fov, channels, img_data, seg_labels,
@@ -57,15 +55,15 @@
     pixel_mat['fov'] = fov
     pixel_mat['row_index'] = np.repeat(range(img_data.shape[0]), img_data.shape[1])
     pixel_mat['column_index'] = np.tile(range(img_data.shape[1]), img_data.shape[0])
 
     # assign segmentation labels if it is not None
     if seg_labels is not None:
         seg_labels_flat = seg_labels.flatten()
-        pixel_mat['segmentation_label'] = seg_labels_flat
+        pixel_mat['label'] = seg_labels_flat
 
     # remove any rows with channels that sum to zero prior to normalization
     pixel_mat = pixel_mat.loc[(pixel_mat[channels] != 0).any(axis=1), :].reset_index(drop=True)
 
     # normalize the row sums of pixel mat
     pixel_mat = pixel_cluster_utils.normalize_rows(pixel_mat, channels, seg_labels is not None)
 
@@ -128,20 +126,20 @@
 
     # ensure the provided channels will actually exist in img_xr
     misc_utils.verify_in_list(
         provided_chans=channels,
         pixel_mat_chans=img_xr.channels.values
     )
 
-    # if seg_dir is None, leave seg_labels as None
-    seg_labels = None
-
-    # otherwise, load segmentation labels in for fov
+    # if seg_dir is not None, load the segmentation labels in for the fov,
+    # otherwise leave seg_labels as None
     if seg_dir is not None:
         seg_labels = imread(os.path.join(seg_dir, fov + seg_suffix))
+    else:
+        seg_labels = None
 
     # subset for the channel data
     img_data = img_xr.loc[fov, :, :, channels].values.astype(np.float32)
 
     # set seed for subsetting
     np.random.seed(seed)
 
@@ -155,15 +153,15 @@
     # write complete dataset to feather, needed for cluster assignment
     feather.write_dataframe(pixel_mat,
                             os.path.join(base_dir,
                                          data_dir,
                                          fov + ".feather"),
                             compression='uncompressed')
 
-    # write subseted dataset to feather, needed for training
+    # write subsetted dataset to feather, needed for training
     feather.write_dataframe(pixel_mat_subset,
                             os.path.join(base_dir,
                                          subset_dir,
                                          fov + ".feather"),
                             compression='uncompressed')
 
     return pixel_mat
@@ -172,15 +170,15 @@
 def create_pixel_matrix(fovs, channels, base_dir, tiff_dir, seg_dir,
                         img_sub_folder="TIFs", seg_suffix='_whole_cell.tiff',
                         pixel_output_dir='pixel_output_dir',
                         data_dir='pixel_mat_data',
                         subset_dir='pixel_mat_subsetted',
                         norm_vals_name='channel_norm_post_rowsum.feather', is_mibitiff=False,
                         blur_factor=2, subset_proportion=0.1, seed=42,
-                        channel_percentile=0.99, multiprocess=False, batch_size=5):
+                        channel_percentile_postnorm=0.999, multiprocess=False, batch_size=5):
     """For each fov, add a Gaussian blur to each channel and normalize channel sums for each pixel
 
     Saves data to `data_dir` and subsetted data to `subset_dir`
 
     Args:
         fovs (list):
             List of fovs to subset over
@@ -214,16 +212,16 @@
             Whether to load the images from MIBITiff
         blur_factor (int):
             The sigma to set for the Gaussian blur
         subset_proportion (float):
             The proportion of pixels to take from each fov
         seed (int):
             The random seed to set for subsetting
-        channel_percentile (float):
-            Percentile used to normalize channels to same range
+        channel_percentile_postnorm (float):
+            Percentile used to normalize channels after pixel normalization
         multiprocess (bool):
             Whether to use multiprocessing or not
         batch_size (int):
             The number of FOVs to process in parallel, ignored if `multiprocess` is `False`
     """
 
     # if the subset_proportion specified is out of range
@@ -238,15 +236,15 @@
         os.mkdir(os.path.join(base_dir, data_dir))
 
     # create subset_dir if it doesn't already exist
     if not os.path.exists(os.path.join(base_dir, subset_dir)):
         os.mkdir(os.path.join(base_dir, subset_dir))
 
     # create variable for storing 99.9% values
-    quant_dat = pd.DataFrame()
+    quantile_path = os.path.join(base_dir, data_dir, "channel_norm_post_rowsum_perfov.csv")
 
     # find all the FOV files in the full data and subsetted directories
     # NOTE: this handles the case where the data file was written, but not the subset file
     fovs_sub = io_utils.list_files(os.path.join(base_dir, subset_dir), substrs='.feather')
     fovs_data = io_utils.list_files(os.path.join(base_dir, data_dir), substrs='.feather')
 
     # intersect the two fovs lists together (if a FOV appears in one but not the other, regenerate)
@@ -260,22 +258,29 @@
     fovs_list = list(set(fovs).difference(set(fovs_full)))
 
     # if there are no FOVs left to preprocess don't run function
     if len(fovs_list) == 0:
         print("There are no more FOVs to preprocess, skipping")
         return
 
+    # check for missing quant data and add to the list of FOVs for processing
+    quant_dat_all = pd.read_csv(quantile_path, index_col="channel") \
+        if os.path.exists(quantile_path) else pd.DataFrame()
+    quant_fov_list = quant_dat_all.columns
+    quant_missing = list(set(fovs).difference(set(quant_fov_list)))
+    fovs_list = list(set(fovs_list).union(set(quant_missing)))
+
     # if the process is only partially complete, inform the user of restart
     if len(fovs_list) < len(fovs):
         print("Restarting preprocessing from FOV %s, "
               "%d fovs left to process" % (fovs_list[0], len(fovs_list)))
 
     # check to make sure correct channels were specified
     pixel_cluster_utils.check_for_modified_channels(
-        tiff_dir=tiff_dir, 
+        tiff_dir=tiff_dir,
         test_fov=fovs[0],
         img_sub_folder=img_sub_folder,
         channels=channels
     )
 
     # define the partial function to iterate over
     fov_data_func = partial(
@@ -286,17 +291,17 @@
 
     # define variable to keep track of number of fovs processed
     fovs_processed = 0
 
     # define the columns to drop for 99.9% normalization
     cols_to_drop = ['fov', 'row_index', 'column_index']
 
-    # account for segmentation_label if seg_dir is set
+    # account for label if seg_dir is set
     if seg_dir:
-        cols_to_drop.append('segmentation_label')
+        cols_to_drop.append('label')
 
     if multiprocess:
         # define the multiprocessing context
         with multiprocessing.get_context('spawn').Pool(batch_size) as fov_data_pool:
             # asynchronously generate and save the pixel matrices per FOV
             # NOTE: fov_data_pool should NOT operate on quant_dat since that is a shared resource
             for fov_batch in [fovs_list[i:(i + batch_size)]
@@ -306,36 +311,51 @@
                 # compute the 99.9% quantile values for each FOV
                 for pixel_mat_data in fov_data_batch:
                     # retrieve the FOV name, note that there will only be one per FOV DataFrame
                     fov = pixel_mat_data['fov'].unique()[0]
 
                     # drop the metadata columns and generate the 99.9% quantile values for the FOV
                     fov_full_pixel_data = pixel_mat_data.drop(columns=cols_to_drop)
-                    quant_dat[fov] = fov_full_pixel_data.replace(
-                        0, np.nan
-                    ).quantile(q=0.999, axis=0)
+                    quant_dat_fov = fov_full_pixel_data.replace(0, np.nan).quantile(
+                        q=channel_percentile_postnorm, axis=0).rename(fov)
+                    quant_dat_fov.index.name = "channel"
+
+                    # update the file with the newly processed fov quantile value
+                    quant_dat_all = quant_dat_all.merge(quant_dat_fov, how="outer",
+                                                        left_index=True, right_index=True)
+                    quant_dat_all.to_csv(quantile_path)
 
                 # update number of fovs processed
                 fovs_processed += len(fov_batch)
                 print("Processed %d fovs" % fovs_processed)
     else:
         for fov in fovs_list:
             pixel_mat_data = fov_data_func(fov)
 
             # drop the metadata columns and generate the 99.9% quantile values for the FOV
             fov_full_pixel_data = pixel_mat_data.drop(columns=cols_to_drop)
-            quant_dat[fov] = fov_full_pixel_data.replace(0, np.nan).quantile(q=0.999, axis=0)
+            quant_dat_fov = fov_full_pixel_data.replace(0, np.nan).quantile(
+                q=channel_percentile_postnorm, axis=0).rename(fov)
+            quant_dat_fov.index.name = "channel"
+
+            # update the file with the newly processed fov quantile values
+            quant_dat_all = quant_dat_all.merge(quant_dat_fov, how="outer",
+                                                left_index=True, right_index=True)
+            quant_dat_all.to_csv(quantile_path)
 
             # update number of fovs processed
             fovs_processed += 1
 
             # update every 10 FOVs, or at the very end
             if fovs_processed % 10 == 0 or fovs_processed == len(fovs_list):
                 print("Processed %d fovs" % fovs_processed)
 
-    # get mean 99.9% across all fovs for all markers
-    mean_quant = pd.DataFrame(quant_dat.mean(axis=1))
+    # get mean 99.9% across all fovs for all markers, check that none are missing
+    mean_quant = pd.DataFrame(quant_dat_all.mean(axis=1))
 
     # save 99.9% normalization values
     feather.write_dataframe(mean_quant.T,
                             os.path.join(base_dir, norm_vals_name),
                             compression='uncompressed')
+
+    # delete quantile data file
+    os.remove(quantile_path)
```

### Comparing `ark-analysis-0.6.3/src/ark/phenotyping/post_cluster_utils.py` & `ark-analysis-0.6.4/src/ark/phenotyping/post_cluster_utils.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 import os
-from typing import List
+import pathlib
+from typing import List, Union
 
 import matplotlib.pyplot as plt
 import numpy as np
 import pandas as pd
 from alpineer import load_utils, misc_utils
 from alpineer.settings import EXTENSION_TYPES
+from ark import settings
 
 from ark.utils import data_utils, plot_utils
 
 
 def plot_hist_thresholds(cell_table, populations, marker, pop_col='cell_meta_cluster',
                          threshold=None, percentile=0.999):
     """Create histograms to compare marker distributions across cell populations
@@ -49,91 +51,127 @@
 
         if threshold:
             ax.axvline(x=threshold)
 
     plt.tight_layout()
 
 
-def create_mantis_project(cell_table, fovs, seg_dir, pop_col,
-                          mask_dir, image_dir, mantis_dir,
-                          seg_suffix_name: str = "_whole_cell.tiff",
-                          cluster_type='pixel') -> None:
-    """Create a complete Mantis project for viewing cell labels
+def create_mantis_project(
+    cell_table: pd.DataFrame,
+    fovs: List[str],
+    seg_dir: Union[pathlib.Path, str],
+    mask_dir: Union[pathlib.Path, str],
+    image_dir: Union[pathlib.Path, str],
+    mantis_dir: Union[pathlib.Path, str],
+    pop_col: str = settings.CELL_TYPE,
+    fov_col: str = settings.FOV_ID,
+    label_col: str = settings.CELL_LABEL,
+    seg_suffix_name: str = "_whole_cell.tiff",
+    cluster_type: str = "pixel",
+) -> None:
+    """Creates a complete Mantis Project for viewing cell labels.
 
     Args:
-        cell_table (pd.DataFrame): dataframe of extracted cell features and subtypes
-        fovs (list): list of FOVs to use for creating the project
-        seg_dir (path): path to the directory containing the segmentations
-        pop_col (str): the column containing the distinct cell populations
-        mask_dir (path): path to the directory where the masks will be stored
-        image_dir (path): path to the directory containing the raw image data
-        mantis_dir (path): path to the directory where the mantis project will be created
+        cell_table (pd.DataFrame):
+            DataFrame of extracted cell features and subtypes.
+        fovs (List[str]):
+            A list of FOVs to use for creating the project.
+        seg_dir (Union[pathlib.Path, str]):
+            The path to the directory containing the segmentation images.
+        mask_dir (Union[pathlib.Path, str]):
+            The path to the directory where the masks will be stored.
+        image_dir (Union[pathlib.Path, str]):
+            The path to the directory containing the raw image data.
+        mantis_dir (Union[pathlib.Path, str]):
+            The path to the directory where the mantis project will be created.
+        pop_col (str, optional):
+            The column name containing the distinct cell populations. Defaults to
+            `settings.CELL_TYPE` (`"cell_meta_cluster"`)
+        fov_col (str, optional):
+            The column name containing the FOV IDs. Defaults to `settings.FOV_ID` (`"fov"`).
+        label_col (str, optional):
+            The column name containing the cell label. Defaults to `settings.CELL_LABEL`
+            (`"label"`).
         seg_suffix_name (str, optional):
-            The suffix of the segmentation file and it's file extension.
-            Defaults to "_whole_cell.tiff".
-        cluster_type (str):
-            the type of clustering being done
+            The suffix of the segmentation file and it's file extension. Defaults to
+            `"_whole_cell.tiff"`.
+        cluster_type (str, optional):
+            The type of clustering being done. Defaults to `"pixel"`.
     """
 
     # verify the type of clustering provided is valid
     misc_utils.verify_in_list(
-        provided_cluster_type=[cluster_type],
-        valid_cluster_types=['pixel', 'cell']
+        provided_cluster_type=[cluster_type], valid_cluster_types=["pixel", "cell"]
     )
 
     # Validate image extension input.
     seg_suffix_ext: str = seg_suffix_name.split(".")[-1]
-    misc_utils.verify_in_list(seg_suffix_ext=seg_suffix_ext,
-                              supported_image_extensions=EXTENSION_TYPES["IMAGE"])
+    misc_utils.verify_in_list(
+        seg_suffix_ext=seg_suffix_ext,
+        supported_image_extensions=EXTENSION_TYPES["IMAGE"],
+    )
 
     # split the file extension from the suffix name
     seg_suffix_name_no_ext: str = seg_suffix_name.split(".")[0]
 
     if not os.path.exists(mask_dir):
         os.makedirs(mask_dir)
 
+    small_table: pd.DataFrame = cell_table.loc[:, [pop_col, "label", "fov"]]
     # create small df compatible with FOV function
-    small_table = cell_table.loc[:, [pop_col, 'label', 'fov']]
 
     # generate unique numeric value for each population
-    small_table['pop_vals'] = pd.factorize(small_table[pop_col].tolist())[0] + 1
+    small_table["pop_vals"] = pd.factorize(small_table[pop_col].tolist())[0] + 1
+
+    ccmd_pop = data_utils.CellClusterMaskData(
+        data=small_table,
+        fov_col=fov_col,
+        label_col=label_col,
+        cluster_col="pop_vals",
+    )
 
     # label and save the cell mask for each FOV
     for fov in fovs:
         whole_cell_files = [fov + seg_suffix_name]
 
         # load the segmentation labels in for the FOVs
         label_map = load_utils.load_imgs_from_dir(
-            data_dir=seg_dir, files=whole_cell_files, xr_dim_name='compartments',
-            xr_channel_names=[seg_suffix_name_no_ext], trim_suffix=seg_suffix_name_no_ext
+            data_dir=seg_dir,
+            files=whole_cell_files,
+            xr_dim_name="compartments",
+            xr_channel_names=[seg_suffix_name_no_ext],
+            trim_suffix=seg_suffix_name_no_ext,
         ).loc[fov, ...]
 
         # use label_cells_by_cluster to create cell masks
         mask_data = data_utils.label_cells_by_cluster(
-            fov, small_table, label_map, fov_col='fov',
-            cell_label_column='label', cluster_column='pop_vals'
+            fov=fov,
+            ccmd=ccmd_pop,
+            label_map=label_map,
         )
-
         # save the cell mask for each FOV -- (saves with ".tiff" extension)
         data_utils.save_fov_mask(
-            fov,
-            mask_dir,
-            mask_data,
-            sub_dir=None,
-            name_suffix='_cell_mask'
+            fov, mask_dir, mask_data, sub_dir=None, name_suffix="_cell_mask"
         )
 
     # rename the columns of small_table
-    mantis_df = small_table.rename(
+    mantis_df: pd.DataFrame = small_table.rename(
         {
-            'pop_vals': f'{cluster_type}_meta_cluster',
-            pop_col: f'{cluster_type}_meta_cluster_rename'
+            "pop_vals": f"{cluster_type}_meta_cluster",
+            pop_col: f"{cluster_type}_meta_cluster_rename",
         },
-        axis=1
+        axis=1,
     )
 
     # create the mantis project
-    plot_utils.create_mantis_dir(fovs=fovs, mantis_project_path=mantis_dir,
-                                 img_data_path=image_dir, mask_output_dir=mask_dir,
-                                 mask_suffix='_cell_mask', mapping=mantis_df,
-                                 seg_dir=seg_dir, cluster_type=cluster_type,
-                                 img_sub_folder='', seg_suffix_name=seg_suffix_name)
+    plot_utils.create_mantis_dir(
+        fovs=fovs,
+        mantis_project_path=mantis_dir,
+        img_data_path=image_dir,
+        mask_output_dir=mask_dir,
+        mask_suffix="_cell_mask",
+        mapping=mantis_df,
+        seg_dir=seg_dir,
+        cluster_type=cluster_type,
+        img_sub_folder="",
+        seg_suffix_name=seg_suffix_name,
+    )
```

### Comparing `ark-analysis-0.6.3/src/ark/phenotyping/weighted_channel_comp.py` & `ark-analysis-0.6.4/src/ark/phenotyping/weighted_channel_comp.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,15 +5,14 @@
 import matplotlib.pyplot as plt
 import numpy as np
 import pandas as pd
 import scipy.stats as stats
 from alpineer import io_utils, misc_utils
 
 from ark.analysis import visualize
-from ark.phenotyping import cluster_helpers
 
 
 def compute_p2c_weighted_channel_avg(pixel_channel_avg, channels, cell_counts,
                                      fovs=None, pixel_cluster_col='pixel_meta_cluster_rename'):
     """Compute the average marker expression for each cell weighted by pixel cluster
 
     This expression is weighted by the pixel SOM/meta cluster counts. So for each cell,
@@ -120,17 +119,19 @@
         cell_counts_clusters.values, pixel_channel_avg_sub.values
     )
 
     # convert back to dataframe
     weighted_cell_channel = pd.DataFrame(
         weighted_cell_channel, columns=channels
     )
+    if "segmentation_label" in weighted_cell_channel.columns:
+        weighted_cell_channel.rename({"segmentation_label": "label"}, inplace=True)
 
     # add columns back
-    meta_cols = ['cell_size', 'fov', 'segmentation_label']
+    meta_cols = ['cell_size', 'fov', 'label']
     weighted_cell_channel[meta_cols] = cell_counts_sub.reset_index(drop=True)[meta_cols]
 
     # normalize the channel columns by the cell size
     weighted_cell_channel[channels] = weighted_cell_channel[channels].div(
         weighted_cell_channel['cell_size'],
         axis=0
     )
@@ -178,42 +179,43 @@
     # read the weighted cell channel table in
     cell_table = feather.read_dataframe(weighted_cell_channel_name_path)
 
     # subset on only the fovs the user has specified
     cell_table = cell_table[cell_table['fov'].isin(fovs)]
 
     # need to ensure that both cell_table and cluster_data have FOVs and segmentation_labels sorted
-    # in the same order, this can be done by simply sorting by fov and segmentation_label for both
+    # in the same order, this can be done by simply sorting by fov and label for both
     cell_table = cell_table.sort_values(
-        by=['fov', 'segmentation_label']
+        by=['fov', 'label']
     ).reset_index(drop=True)
     cell_cluster_data = cell_cluster_data.sort_values(
-        by=['fov', 'segmentation_label']
+        by=['fov', 'label']
     ).reset_index(drop=True)
 
     # add an extra check to ensure that the FOVs and segmentation labels are in the same order
     misc_utils.verify_same_elements(
         enforce_order=True,
         cell_table_fovs=list(cell_table['fov']),
         cluster_data_fovs=list(cell_cluster_data['fov'])
     )
     misc_utils.verify_same_elements(
         enforce_order=True,
-        cell_table_labels=list(cell_table['segmentation_label']),
-        cluster_data_labels=list(cell_cluster_data['segmentation_label'])
+        cell_table_labels=list(cell_table['label']),
+        cluster_data_labels=list(cell_cluster_data['label'])
     )
 
     # assign the cluster labels to cell_table
     cell_table[cell_cluster_col] = cell_cluster_data[cell_cluster_col]
 
     # subset the cell table by just the desired channels and the cell_cluster_col
     cell_table = cell_table[channels + [cell_cluster_col]]
 
     # compute the mean channel expression across each cell cluster
     channel_avgs = cell_table.groupby(cell_cluster_col).mean().reset_index()
+    channel_avgs[cell_cluster_col] = channel_avgs[cell_cluster_col].astype(dtype=int)
 
     return channel_avgs
 
 
 def generate_wc_avg_files(fovs, channels, base_dir, cell_cc, cell_som_input_data,
                           weighted_cell_channel_name='weighted_cell_channel.feather',
                           cell_som_cluster_channel_avg_name='cell_som_cluster_channel_avg.csv',
@@ -278,16 +280,17 @@
 
     # merge metacluster assignments into cell_som_cluster_channel_avg
     print(
         "Mapping meta cluster values onto average weighted channel expression"
         "across cell SOM clusters"
     )
     cell_som_cluster_channel_avg = pd.merge_asof(
-        cell_som_cluster_channel_avg, cell_cc.mapping, on='cell_som_cluster'
-    )
+        cell_som_cluster_channel_avg,
+        cell_cc.mapping,
+        on='cell_som_cluster')
 
     # save the weighted channel average expression per cell cluster
     cell_som_cluster_channel_avg.to_csv(
         som_cluster_channel_avg_path,
         index=False
     )
```

### Comparing `ark-analysis-0.6.3/src/ark/segmentation/marker_quantification.py` & `ark-analysis-0.6.4/src/ark/segmentation/marker_quantification.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 import copy
 import warnings
 
 import numpy as np
 import pandas as pd
 import xarray as xr
-from skimage.measure import regionprops, regionprops_table
 from alpineer import io_utils, load_utils, misc_utils
+from skimage.measure import regionprops, regionprops_table
 
 import ark.settings as settings
+from ark.segmentation import segmentation_utils
 from ark.segmentation.regionprops_extraction import REGIONPROPS_FUNCTION
 from ark.segmentation.signal_extraction import EXTRACTION_FUNCTION
-from ark.segmentation import segmentation_utils
 
 
 def get_single_compartment_props(segmentation_labels, regionprops_base,
                                  regionprops_single_comp, **kwargs):
     """Gets regionprops features from the provided segmentation labels for a fov
 
     Based on segmentation labels from a single compartment
@@ -398,18 +398,18 @@
                                     img_data_fovs=image_data.fovs.values)
 
     # define the FOV associated with this segmentation label
     fov = segmentation_labels.fovs.values[0]
     print("extracting data from {}".format(fov))
 
     # current mask
-    segmentation_label = segmentation_labels.loc[fov, :, :, :]
+    label = segmentation_labels.loc[fov, :, :, :]
 
     # extract the counts per cell for each marker
-    marker_counts = compute_marker_counts(image_data.loc[fov, :, :, :], segmentation_label,
+    marker_counts = compute_marker_counts(image_data.loc[fov, :, :, :], label,
                                           nuclear_counts=nuclear_counts,
                                           split_large_nuclei=split_large_nuclei,
                                           extraction=extraction,
                                           fast_extraction=fast_extraction, **kwargs)
 
     # normalize counts by cell size
     marker_counts_norm = segmentation_utils.transform_expression_matrix(marker_counts,
@@ -422,14 +422,17 @@
     # add data from each fov to array
     normalized = pd.DataFrame(data=marker_counts_norm.loc['whole_cell', :, :].values,
                               columns=marker_counts_norm.features)
 
     arcsinh = pd.DataFrame(data=marker_counts_arcsinh.values[0, :, :],
                            columns=marker_counts_arcsinh.features)
 
+    normalized[settings.CELL_LABEL] = normalized[settings.CELL_LABEL].astype(np.int32)
+    arcsinh[settings.CELL_LABEL] = arcsinh[settings.CELL_LABEL].astype(np.int32)
+
     if nuclear_counts:
         # append nuclear counts pandas array with modified column name
         nuc_column_names = [feature + '_nuclear' for feature in marker_counts.features.values]
 
         # add nuclear counts to size normalized data
         normalized_nuc = pd.DataFrame(data=marker_counts_norm.loc['nuclear', :, :].values,
                                       columns=nuc_column_names)
@@ -444,15 +447,15 @@
     normalized['fov'] = fov
     arcsinh['fov'] = fov
 
     return normalized, arcsinh
 
 
 def generate_cell_table(segmentation_dir, tiff_dir, img_sub_folder="TIFs",
-                        is_mibitiff=False, fovs=None, dtype="int16",
+                        is_mibitiff=False, fovs=None,
                         extraction='total_intensity', nuclear_counts=False,
                         fast_extraction=False, **kwargs):
     """This function takes the segmented data and computes the expression matrices batch-wise
     while also validating inputs
 
     Args:
         segmentation_dir (str):
@@ -462,16 +465,14 @@
         img_sub_folder (str):
             the name of the folder where the TIF images are located
             ignored if is_mibitiff is True
         fovs (list):
             a list of fovs we wish to analyze, if None will default to all fovs
         is_mibitiff (bool):
             a flag to indicate whether or not the base images are MIBItiffs
-        dtype (str/type):
-            data type of base images
         extraction (str):
             extraction function used to compute marker counts
         nuclear_counts (bool):
             boolean flag to determine whether nuclear counts are returned, note that if
             set to True, the compartments coordinate in segmentation_labels must contain 'nuclear'
         fast_extraction (bool):
             if set, skips the custom regionprops and expensive base regionprops extraction steps
```

### Comparing `ark-analysis-0.6.3/src/ark/segmentation/regionprops_extraction.py` & `ark-analysis-0.6.4/src/ark/segmentation/regionprops_extraction.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/src/ark/segmentation/segmentation_utils.py` & `ark-analysis-0.6.4/src/ark/segmentation/segmentation_utils.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import copy
 import os
 
 import numpy as np
 import pandas as pd
+from alpineer import image_utils, io_utils, load_utils, misc_utils
 from skimage.measure import regionprops_table
 from skimage.morphology import remove_small_objects
 from skimage.segmentation import find_boundaries
-from alpineer import image_utils, io_utils, load_utils, misc_utils
 
 import ark.settings as settings
 from ark.utils import plot_utils
 
 
 def find_nuclear_label_id(nuc_segmentation_labels, cell_coords):
     """Get the ID of the nuclear mask which has the greatest amount of overlap with a given cell
```

### Comparing `ark-analysis-0.6.3/src/ark/segmentation/signal_extraction.py` & `ark-analysis-0.6.4/src/ark/segmentation/signal_extraction.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/src/ark/settings.py` & `ark-analysis-0.6.4/src/ark/settings.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,13 @@
-from typing import Dict, List
 
 # hope u like capital letters
 
 # default cell table column names
 CELL_SIZE = 'cell_size'  # cell size (number of pixels in the cell)
-CELL_LABEL = 'label'  # cell label number (regionprops)
+CELL_LABEL = 'label'  # cell label number for segmentation
 FOV_ID = 'fov'  # cell's fov name
 CELL_TYPE = 'cell_meta_cluster'  # cell cluster name
 CELL_TYPE_NUM = 'cell_num'   # int cell cluster identifier
 PATIENT_ID = 'PatientID'  # cell's patient id
 KMEANS_CLUSTER = 'kmeans_neighborhood'  # neighborhood which cells belong to
 CENTROID_0 = 'centroid-0'  # cell centroid x-coordinate
 CENTROID_1 = 'centroid-1'  # cell centroid y-coordinate
@@ -36,21 +35,22 @@
 REGIONPROPS_SINGLE_COMP = ['major_minor_axis_ratio', 'perim_square_over_area',
                            'major_axis_equiv_diam_ratio', 'convex_hull_resid',
                            'centroid_dif', 'num_concavities']
 REGIONPROPS_MULTI_COMP = ['nc_ratio']
 
 # fiber segmentation regionprops extraction
 FIBER_OBJECT_PROPS = (
+    'label',
+    'centroid',
     'major_axis_length',
     'minor_axis_length',
     'orientation',
-    'centroid',
-    'label',
+    'area',
     'eccentricity',
-    'euler_number'
+    'euler_number',
 )
 
 # spatial-LDA minimum required columns
 BASE_COLS = [FOV_ID, CELL_LABEL, CELL_SIZE, CENTROID_0, CENTROID_1, CELL_TYPE]
 
 # spatial_lda topic EDA key names
 EDA_KEYS = ['inertia', 'silhouette', 'gap_stat', 'gap_sds', 'cell_counts', "featurization"]
```

### Comparing `ark-analysis-0.6.3/src/ark/spLDA/processing.py` & `ark-analysis-0.6.4/src/ark/spLDA/processing.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/src/ark/utils/_bootstrapping.c` & `ark-analysis-0.6.4/src/ark/utils/_bootstrapping.c`

 * *Files 2% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-/* Generated by Cython 0.29.33 */
+/* Generated by Cython 0.29.36 */
 
 /* BEGIN: Cython Metadata
 {
     "distutils": {
         "depends": [
-            "/tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h",
-            "/tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/core/include/numpy/arrayscalars.h",
-            "/tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h",
-            "/tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h",
-            "/tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/core/include/numpy/ufuncobject.h"
+            "/tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h",
+            "/tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/core/include/numpy/arrayscalars.h",
+            "/tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h",
+            "/tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h",
+            "/tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/core/include/numpy/ufuncobject.h"
         ],
         "include_dirs": [
-            "/tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/core/include"
+            "/tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/core/include"
         ],
         "name": "ark.utils._bootstrapping",
         "sources": [
-            "./src/ark/utils/_bootstrapping.pyx"
+            "src/ark/utils/_bootstrapping.pyx"
         ]
     },
     "module_name": "ark.utils._bootstrapping"
 }
 END: Cython Metadata */
 
 #ifndef PY_SSIZE_T_CLEAN
@@ -27,16 +27,16 @@
 #endif /* PY_SSIZE_T_CLEAN */
 #include "Python.h"
 #ifndef Py_PYTHON_H
     #error Python headers needed to compile C extensions, please install development version of Python.
 #elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03030000)
     #error Cython requires Python 2.6+ or Python 3.3+.
 #else
-#define CYTHON_ABI "0_29_33"
-#define CYTHON_HEX_VERSION 0x001D21F0
+#define CYTHON_ABI "0_29_36"
+#define CYTHON_HEX_VERSION 0x001D24F0
 #define CYTHON_FUTURE_DIVISION 1
 #include <stddef.h>
 #ifndef offsetof
   #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
 #endif
 #if !defined(WIN32) && !defined(MS_WINDOWS)
   #ifndef __stdcall
@@ -96,18 +96,22 @@
   #define CYTHON_ASSUME_SAFE_MACROS 0
   #undef CYTHON_UNPACK_METHODS
   #define CYTHON_UNPACK_METHODS 0
   #undef CYTHON_FAST_THREAD_STATE
   #define CYTHON_FAST_THREAD_STATE 0
   #undef CYTHON_FAST_PYCALL
   #define CYTHON_FAST_PYCALL 0
-  #undef CYTHON_PEP489_MULTI_PHASE_INIT
-  #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #if PY_VERSION_HEX < 0x03090000
+    #undef CYTHON_PEP489_MULTI_PHASE_INIT
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 0
+  #elif !defined(CYTHON_PEP489_MULTI_PHASE_INIT)
+    #define CYTHON_PEP489_MULTI_PHASE_INIT 1
+  #endif
   #undef CYTHON_USE_TP_FINALIZE
-  #define CYTHON_USE_TP_FINALIZE 0
+  #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1 && PYPY_VERSION_NUM >= 0x07030C00)
   #undef CYTHON_USE_DICT_VERSIONS
   #define CYTHON_USE_DICT_VERSIONS 0
   #undef CYTHON_USE_EXC_INFO_STACK
   #define CYTHON_USE_EXC_INFO_STACK 0
   #ifndef CYTHON_UPDATE_DESCRIPTOR_DOC
     #define CYTHON_UPDATE_DESCRIPTOR_DOC 0
   #endif
@@ -221,15 +225,15 @@
   #elif !defined(CYTHON_USE_ASYNC_SLOTS)
     #define CYTHON_USE_ASYNC_SLOTS 1
   #endif
   #if PY_VERSION_HEX < 0x02070000
     #undef CYTHON_USE_PYLONG_INTERNALS
     #define CYTHON_USE_PYLONG_INTERNALS 0
   #elif !defined(CYTHON_USE_PYLONG_INTERNALS)
-    #define CYTHON_USE_PYLONG_INTERNALS 1
+    #define CYTHON_USE_PYLONG_INTERNALS (PY_VERSION_HEX < 0x030C00A5)
   #endif
   #ifndef CYTHON_USE_PYLIST_INTERNALS
     #define CYTHON_USE_PYLIST_INTERNALS 1
   #endif
   #ifndef CYTHON_USE_UNICODE_INTERNALS
     #define CYTHON_USE_UNICODE_INTERNALS 1
   #endif
@@ -260,15 +264,15 @@
   #ifndef CYTHON_PEP489_MULTI_PHASE_INIT
     #define CYTHON_PEP489_MULTI_PHASE_INIT (PY_VERSION_HEX >= 0x03050000)
   #endif
   #ifndef CYTHON_USE_TP_FINALIZE
     #define CYTHON_USE_TP_FINALIZE (PY_VERSION_HEX >= 0x030400a1)
   #endif
   #ifndef CYTHON_USE_DICT_VERSIONS
-    #define CYTHON_USE_DICT_VERSIONS (PY_VERSION_HEX >= 0x030600B1)
+    #define CYTHON_USE_DICT_VERSIONS ((PY_VERSION_HEX >= 0x030600B1) && (PY_VERSION_HEX < 0x030C00A5))
   #endif
   #if PY_VERSION_HEX >= 0x030B00A4
     #undef CYTHON_USE_EXC_INFO_STACK
     #define CYTHON_USE_EXC_INFO_STACK 0
   #elif !defined(CYTHON_USE_EXC_INFO_STACK)
     #define CYTHON_USE_EXC_INFO_STACK (PY_VERSION_HEX >= 0x030700A3)
   #endif
@@ -383,17 +387,14 @@
   #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
     #define CYTHON_INLINE inline
   #else
     #define CYTHON_INLINE
   #endif
 #endif
 
-#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
-  #define Py_OptimizeFlag 0
-#endif
 #define __PYX_BUILD_PY_SSIZE_T "n"
 #define CYTHON_FORMAT_SSIZE_T "z"
 #if PY_MAJOR_VERSION < 3
   #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
   #define __Pyx_DefaultClassType PyClass_Type
@@ -463,14 +464,19 @@
     }
 #else
   #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
           PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
 #endif
   #define __Pyx_DefaultClassType PyType_Type
 #endif
+#if PY_VERSION_HEX >= 0x030900F0 && !CYTHON_COMPILING_IN_PYPY
+  #define __Pyx_PyObject_GC_IsFinalized(o) PyObject_GC_IsFinalized(o)
+#else
+  #define __Pyx_PyObject_GC_IsFinalized(o) _PyGC_FINALIZED(o)
+#endif
 #ifndef Py_TPFLAGS_CHECKTYPES
   #define Py_TPFLAGS_CHECKTYPES 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_INDEX
   #define Py_TPFLAGS_HAVE_INDEX 0
 #endif
 #ifndef Py_TPFLAGS_HAVE_NEWBUFFER
@@ -1113,195 +1119,195 @@
   char enc_type;
   char new_packmode;
   char enc_packmode;
   char is_valid_array;
 } __Pyx_BufFmt_Context;
 
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":689
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":689
  * # in Cython to enable them only on the right systems.
  * 
  * ctypedef npy_int8       int8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  */
 typedef npy_int8 __pyx_t_5numpy_int8_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":690
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":690
  * 
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t
  */
 typedef npy_int16 __pyx_t_5numpy_int16_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":691
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":691
  * ctypedef npy_int8       int8_t
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_int64      int64_t
  * #ctypedef npy_int96      int96_t
  */
 typedef npy_int32 __pyx_t_5numpy_int32_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":692
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":692
  * ctypedef npy_int16      int16_t
  * ctypedef npy_int32      int32_t
  * ctypedef npy_int64      int64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_int96      int96_t
  * #ctypedef npy_int128     int128_t
  */
 typedef npy_int64 __pyx_t_5numpy_int64_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":696
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":696
  * #ctypedef npy_int128     int128_t
  * 
  * ctypedef npy_uint8      uint8_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  */
 typedef npy_uint8 __pyx_t_5numpy_uint8_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":697
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":697
  * 
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t
  */
 typedef npy_uint16 __pyx_t_5numpy_uint16_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":698
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":698
  * ctypedef npy_uint8      uint8_t
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uint64     uint64_t
  * #ctypedef npy_uint96     uint96_t
  */
 typedef npy_uint32 __pyx_t_5numpy_uint32_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":699
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":699
  * ctypedef npy_uint16     uint16_t
  * ctypedef npy_uint32     uint32_t
  * ctypedef npy_uint64     uint64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_uint96     uint96_t
  * #ctypedef npy_uint128    uint128_t
  */
 typedef npy_uint64 __pyx_t_5numpy_uint64_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":703
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":703
  * #ctypedef npy_uint128    uint128_t
  * 
  * ctypedef npy_float32    float32_t             # <<<<<<<<<<<<<<
  * ctypedef npy_float64    float64_t
  * #ctypedef npy_float80    float80_t
  */
 typedef npy_float32 __pyx_t_5numpy_float32_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":704
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":704
  * 
  * ctypedef npy_float32    float32_t
  * ctypedef npy_float64    float64_t             # <<<<<<<<<<<<<<
  * #ctypedef npy_float80    float80_t
  * #ctypedef npy_float128   float128_t
  */
 typedef npy_float64 __pyx_t_5numpy_float64_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":713
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":713
  * # The int types are mapped a bit surprising --
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t
  */
 typedef npy_long __pyx_t_5numpy_int_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":714
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":714
  * # numpy.int corresponds to 'l' and numpy.long to 'q'
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longlong   longlong_t
  * 
  */
 typedef npy_longlong __pyx_t_5numpy_long_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":715
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":715
  * ctypedef npy_long       int_t
  * ctypedef npy_longlong   long_t
  * ctypedef npy_longlong   longlong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_ulong      uint_t
  */
 typedef npy_longlong __pyx_t_5numpy_longlong_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":717
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":717
  * ctypedef npy_longlong   longlong_t
  * 
  * ctypedef npy_ulong      uint_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t
  */
 typedef npy_ulong __pyx_t_5numpy_uint_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":718
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":718
  * 
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t             # <<<<<<<<<<<<<<
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulong_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":719
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":719
  * ctypedef npy_ulong      uint_t
  * ctypedef npy_ulonglong  ulong_t
  * ctypedef npy_ulonglong  ulonglong_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_intp       intp_t
  */
 typedef npy_ulonglong __pyx_t_5numpy_ulonglong_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":721
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":721
  * ctypedef npy_ulonglong  ulonglong_t
  * 
  * ctypedef npy_intp       intp_t             # <<<<<<<<<<<<<<
  * ctypedef npy_uintp      uintp_t
  * 
  */
 typedef npy_intp __pyx_t_5numpy_intp_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":722
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":722
  * 
  * ctypedef npy_intp       intp_t
  * ctypedef npy_uintp      uintp_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_double     float_t
  */
 typedef npy_uintp __pyx_t_5numpy_uintp_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":724
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":724
  * ctypedef npy_uintp      uintp_t
  * 
  * ctypedef npy_double     float_t             # <<<<<<<<<<<<<<
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t
  */
 typedef npy_double __pyx_t_5numpy_float_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":725
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":725
  * 
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t             # <<<<<<<<<<<<<<
  * ctypedef npy_longdouble longdouble_t
  * 
  */
 typedef npy_double __pyx_t_5numpy_double_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":726
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":726
  * ctypedef npy_double     float_t
  * ctypedef npy_double     double_t
  * ctypedef npy_longdouble longdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cfloat      cfloat_t
  */
 typedef npy_longdouble __pyx_t_5numpy_longdouble_t;
@@ -1359,42 +1365,42 @@
 
 /*--- Type declarations ---*/
 struct __pyx_array_obj;
 struct __pyx_MemviewEnum_obj;
 struct __pyx_memoryview_obj;
 struct __pyx_memoryviewslice_obj;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":728
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":728
  * ctypedef npy_longdouble longdouble_t
  * 
  * ctypedef npy_cfloat      cfloat_t             # <<<<<<<<<<<<<<
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t
  */
 typedef npy_cfloat __pyx_t_5numpy_cfloat_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":729
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":729
  * 
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t             # <<<<<<<<<<<<<<
  * ctypedef npy_clongdouble clongdouble_t
  * 
  */
 typedef npy_cdouble __pyx_t_5numpy_cdouble_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":730
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":730
  * ctypedef npy_cfloat      cfloat_t
  * ctypedef npy_cdouble     cdouble_t
  * ctypedef npy_clongdouble clongdouble_t             # <<<<<<<<<<<<<<
  * 
  * ctypedef npy_cdouble     complex_t
  */
 typedef npy_clongdouble __pyx_t_5numpy_clongdouble_t;
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":732
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":732
  * ctypedef npy_clongdouble clongdouble_t
  * 
  * ctypedef npy_cdouble     complex_t             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  */
 typedef npy_cdouble __pyx_t_5numpy_complex_t;
@@ -2000,14 +2006,31 @@
     }
     return PyList_Append(list, x);
 }
 #else
 #define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
 #endif
 
+/* AssertionsEnabled.proto */
+#define __Pyx_init_assertions_enabled()
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
+  #define __pyx_assertions_enabled() (1)
+#elif PY_VERSION_HEX < 0x03080000  ||  CYTHON_COMPILING_IN_PYPY  ||  defined(Py_LIMITED_API)
+  #define __pyx_assertions_enabled() (!Py_OptimizeFlag)
+#elif CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x030900A6
+  static int __pyx_assertions_enabled_flag;
+  #define __pyx_assertions_enabled() (__pyx_assertions_enabled_flag)
+  #undef __Pyx_init_assertions_enabled
+  static void __Pyx_init_assertions_enabled(void) {
+    __pyx_assertions_enabled_flag = ! _PyInterpreterState_GetConfig(__Pyx_PyThreadState_Current->interp)->optimization_level;
+  }
+#else
+  #define __pyx_assertions_enabled() (!Py_OptimizeFlag)
+#endif
+
 /* None.proto */
 static CYTHON_INLINE void __Pyx_RaiseUnboundLocalError(const char *varname);
 
 /* DivInt[long].proto */
 static CYTHON_INLINE long __Pyx_div_long(long, long);
 
 /* PySequenceContains.proto */
@@ -2042,24 +2065,95 @@
 /* PyObjectGetAttrStrNoError.proto */
 static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStrNoError(PyObject* obj, PyObject* attr_name);
 
 /* SetupReduce.proto */
 static int __Pyx_setup_reduce(PyObject* type_obj);
 
 /* TypeImport.proto */
-#ifndef __PYX_HAVE_RT_ImportType_proto
-#define __PYX_HAVE_RT_ImportType_proto
-enum __Pyx_ImportType_CheckSize {
-   __Pyx_ImportType_CheckSize_Error = 0,
-   __Pyx_ImportType_CheckSize_Warn = 1,
-   __Pyx_ImportType_CheckSize_Ignore = 2
+#ifndef __PYX_HAVE_RT_ImportType_proto_0_29_36
+#define __PYX_HAVE_RT_ImportType_proto_0_29_36
+#if __STDC_VERSION__ >= 201112L
+#include <stdalign.h>
+#endif
+#if __STDC_VERSION__ >= 201112L || __cplusplus >= 201103L
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_36(s) alignof(s)
+#else
+#define __PYX_GET_STRUCT_ALIGNMENT_0_29_36(s) sizeof(void*)
+#endif
+enum __Pyx_ImportType_CheckSize_0_29_36 {
+   __Pyx_ImportType_CheckSize_Error_0_29_36 = 0,
+   __Pyx_ImportType_CheckSize_Warn_0_29_36 = 1,
+   __Pyx_ImportType_CheckSize_Ignore_0_29_36 = 2
 };
-static PyTypeObject *__Pyx_ImportType(PyObject* module, const char *module_name, const char *class_name, size_t size, enum __Pyx_ImportType_CheckSize check_size);
+static PyTypeObject *__Pyx_ImportType_0_29_36(PyObject* module, const char *module_name, const char *class_name, size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_36 check_size);
 #endif
 
+/* FetchCommonType.proto */
+static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type);
+
+/* CythonFunctionShared.proto */
+#define __Pyx_CyFunction_USED 1
+#define __Pyx_CYFUNCTION_STATICMETHOD  0x01
+#define __Pyx_CYFUNCTION_CLASSMETHOD   0x02
+#define __Pyx_CYFUNCTION_CCLASS        0x04
+#define __Pyx_CyFunction_GetClosure(f)\
+    (((__pyx_CyFunctionObject *) (f))->func_closure)
+#define __Pyx_CyFunction_GetClassObj(f)\
+    (((__pyx_CyFunctionObject *) (f))->func_classobj)
+#define __Pyx_CyFunction_Defaults(type, f)\
+    ((type *)(((__pyx_CyFunctionObject *) (f))->defaults))
+#define __Pyx_CyFunction_SetDefaultsGetter(f, g)\
+    ((__pyx_CyFunctionObject *) (f))->defaults_getter = (g)
+typedef struct {
+    PyCFunctionObject func;
+#if PY_VERSION_HEX < 0x030500A0
+    PyObject *func_weakreflist;
+#endif
+    PyObject *func_dict;
+    PyObject *func_name;
+    PyObject *func_qualname;
+    PyObject *func_doc;
+    PyObject *func_globals;
+    PyObject *func_code;
+    PyObject *func_closure;
+    PyObject *func_classobj;
+    void *defaults;
+    int defaults_pyobjects;
+    size_t defaults_size;  // used by FusedFunction for copying defaults
+    int flags;
+    PyObject *defaults_tuple;
+    PyObject *defaults_kwdict;
+    PyObject *(*defaults_getter)(PyObject *);
+    PyObject *func_annotations;
+} __pyx_CyFunctionObject;
+static PyTypeObject *__pyx_CyFunctionType = 0;
+#define __Pyx_CyFunction_Check(obj)  (__Pyx_TypeCheck(obj, __pyx_CyFunctionType))
+static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject* op, PyMethodDef *ml,
+                                      int flags, PyObject* qualname,
+                                      PyObject *self,
+                                      PyObject *module, PyObject *globals,
+                                      PyObject* code);
+static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *m,
+                                                         size_t size,
+                                                         int pyobjects);
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *m,
+                                                            PyObject *tuple);
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *m,
+                                                             PyObject *dict);
+static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *m,
+                                                              PyObject *dict);
+static int __pyx_CyFunction_init(void);
+
+/* CythonFunction.proto */
+static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml,
+                                      int flags, PyObject* qualname,
+                                      PyObject *closure,
+                                      PyObject *module, PyObject *globals,
+                                      PyObject* code);
+
 /* CLineInTraceback.proto */
 #ifdef CYTHON_CLINE_IN_TRACEBACK
 #define __Pyx_CLineForTraceback(tstate, c_line)  (((CYTHON_CLINE_IN_TRACEBACK)) ? c_line : 0)
 #else
 static int __Pyx_CLineForTraceback(PyThreadState *tstate, int c_line);
 #endif
 
@@ -2416,40 +2510,48 @@
 static PyObject *__pyx_builtin_Ellipsis;
 static PyObject *__pyx_builtin_id;
 static PyObject *__pyx_builtin_IndexError;
 static const char __pyx_k_O[] = "O";
 static const char __pyx_k_c[] = "c";
 static const char __pyx_k_id[] = "id";
 static const char __pyx_k_np[] = "np";
+static const char __pyx_k_dst[] = "dst";
 static const char __pyx_k_new[] = "__new__";
 static const char __pyx_k_obj[] = "obj";
+static const char __pyx_k_src[] = "src";
+static const char __pyx_k_tmp[] = "tmp";
 static const char __pyx_k_base[] = "base";
+static const char __pyx_k_copy[] = "copy";
 static const char __pyx_k_dict[] = "__dict__";
 static const char __pyx_k_main[] = "__main__";
 static const char __pyx_k_mode[] = "mode";
 static const char __pyx_k_name[] = "name";
 static const char __pyx_k_ndim[] = "ndim";
 static const char __pyx_k_pack[] = "pack";
+static const char __pyx_k_self[] = "self";
 static const char __pyx_k_size[] = "size";
 static const char __pyx_k_step[] = "step";
 static const char __pyx_k_stop[] = "stop";
 static const char __pyx_k_test[] = "__test__";
 static const char __pyx_k_ASCII[] = "ASCII";
 static const char __pyx_k_class[] = "__class__";
 static const char __pyx_k_dtype[] = "dtype";
 static const char __pyx_k_error[] = "error";
 static const char __pyx_k_flags[] = "flags";
 static const char __pyx_k_numpy[] = "numpy";
 static const char __pyx_k_range[] = "range";
 static const char __pyx_k_shape[] = "shape";
 static const char __pyx_k_start[] = "start";
+static const char __pyx_k_state[] = "state";
 static const char __pyx_k_zeros[] = "zeros";
+static const char __pyx_k_dict_2[] = "_dict";
 static const char __pyx_k_encode[] = "encode";
 static const char __pyx_k_format[] = "format";
 static const char __pyx_k_import[] = "__import__";
+static const char __pyx_k_mslice[] = "mslice";
 static const char __pyx_k_name_2[] = "__name__";
 static const char __pyx_k_pickle[] = "pickle";
 static const char __pyx_k_reduce[] = "__reduce__";
 static const char __pyx_k_struct[] = "struct";
 static const char __pyx_k_uint16[] = "uint16";
 static const char __pyx_k_unpack[] = "unpack";
 static const char __pyx_k_update[] = "update";
@@ -2468,43 +2570,59 @@
 static const char __pyx_k_ValueError[] = "ValueError";
 static const char __pyx_k_pos_labels[] = "pos_labels";
 static const char __pyx_k_pyx_result[] = "__pyx_result";
 static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
 static const char __pyx_k_ImportError[] = "ImportError";
 static const char __pyx_k_MemoryError[] = "MemoryError";
 static const char __pyx_k_PickleError[] = "PickleError";
+static const char __pyx_k_is_c_contig[] = "is_c_contig";
+static const char __pyx_k_is_f_contig[] = "is_f_contig";
 static const char __pyx_k_marker_nums[] = "marker_nums";
+static const char __pyx_k_copy_fortran[] = "copy_fortran";
 static const char __pyx_k_dist_mat_bin[] = "dist_mat_bin";
 static const char __pyx_k_pyx_checksum[] = "__pyx_checksum";
 static const char __pyx_k_row_indicies[] = "row_indicies";
 static const char __pyx_k_stringsource[] = "stringsource";
+static const char __pyx_k_use_setstate[] = "use_setstate";
 static const char __pyx_k_bootstrap_num[] = "bootstrap_num";
 static const char __pyx_k_pyx_getbuffer[] = "__pyx_getbuffer";
 static const char __pyx_k_reduce_cython[] = "__reduce_cython__";
 static const char __pyx_k_View_MemoryView[] = "View.MemoryView";
 static const char __pyx_k_allocate_buffer[] = "allocate_buffer";
 static const char __pyx_k_dtype_is_object[] = "dtype_is_object";
+static const char __pyx_k_memoryview_copy[] = "memoryview.copy";
 static const char __pyx_k_pyx_PickleError[] = "__pyx_PickleError";
 static const char __pyx_k_setstate_cython[] = "__setstate_cython__";
 static const char __pyx_k_cols_in_row_flat[] = "cols_in_row_flat";
 static const char __pyx_k_pyx_unpickle_Enum[] = "__pyx_unpickle_Enum";
 static const char __pyx_k_cline_in_traceback[] = "cline_in_traceback";
 static const char __pyx_k_strided_and_direct[] = "<strided and direct>";
+static const char __pyx_k_Enum___reduce_cython[] = "Enum.__reduce_cython__";
 static const char __pyx_k_strided_and_indirect[] = "<strided and indirect>";
+static const char __pyx_k_array___reduce_cython[] = "array.__reduce_cython__";
 static const char __pyx_k_contiguous_and_direct[] = "<contiguous and direct>";
+static const char __pyx_k_Enum___setstate_cython[] = "Enum.__setstate_cython__";
 static const char __pyx_k_MemoryView_of_r_object[] = "<MemoryView of %r object>";
 static const char __pyx_k_compute_close_num_rand[] = "compute_close_num_rand";
+static const char __pyx_k_memoryview_is_c_contig[] = "memoryview.is_c_contig";
+static const char __pyx_k_memoryview_is_f_contig[] = "memoryview.is_f_contig";
 static const char __pyx_k_MemoryView_of_r_at_0x_x[] = "<MemoryView of %r at 0x%x>";
+static const char __pyx_k_array___setstate_cython[] = "array.__setstate_cython__";
 static const char __pyx_k_contiguous_and_indirect[] = "<contiguous and indirect>";
+static const char __pyx_k_memoryview_copy_fortran[] = "memoryview.copy_fortran";
 static const char __pyx_k_Cannot_index_with_type_s[] = "Cannot index with type '%s'";
 static const char __pyx_k_ark_utils__bootstrapping[] = "ark.utils._bootstrapping";
 static const char __pyx_k_Invalid_shape_in_axis_d_d[] = "Invalid shape in axis %d: %d.";
+static const char __pyx_k_memoryview___reduce_cython[] = "memoryview.__reduce_cython__";
 static const char __pyx_k_itemsize_0_for_cython_array[] = "itemsize <= 0 for cython.array";
+static const char __pyx_k_memoryview___setstate_cython[] = "memoryview.__setstate_cython__";
 static const char __pyx_k_unable_to_allocate_array_data[] = "unable to allocate array data.";
 static const char __pyx_k_strided_and_direct_or_indirect[] = "<strided and direct or indirect>";
+static const char __pyx_k_memoryviewslice___reduce_cython[] = "_memoryviewslice.__reduce_cython__";
+static const char __pyx_k_memoryviewslice___setstate_cyth[] = "_memoryviewslice.__setstate_cython__";
 static const char __pyx_k_numpy_core_multiarray_failed_to[] = "numpy.core.multiarray failed to import";
 static const char __pyx_k_Buffer_view_does_not_expose_stri[] = "Buffer view does not expose strides";
 static const char __pyx_k_Can_only_create_a_buffer_that_is[] = "Can only create a buffer that is contiguous in memory.";
 static const char __pyx_k_Cannot_assign_to_read_only_memor[] = "Cannot assign to read-only memoryview";
 static const char __pyx_k_Cannot_create_writable_memory_vi[] = "Cannot create writable memory view from read-only memoryview";
 static const char __pyx_k_Empty_shape_tuple_for_cython_arr[] = "Empty shape tuple for cython.array";
 static const char __pyx_k_Incompatible_checksums_0x_x_vs_0[] = "Incompatible checksums (0x%x vs (0xb068931, 0x82a3537, 0x6ae9995) = (name))";
@@ -2521,14 +2639,16 @@
 static PyObject *__pyx_kp_s_Buffer_view_does_not_expose_stri;
 static PyObject *__pyx_kp_s_Can_only_create_a_buffer_that_is;
 static PyObject *__pyx_kp_s_Cannot_assign_to_read_only_memor;
 static PyObject *__pyx_kp_s_Cannot_create_writable_memory_vi;
 static PyObject *__pyx_kp_s_Cannot_index_with_type_s;
 static PyObject *__pyx_n_s_Ellipsis;
 static PyObject *__pyx_kp_s_Empty_shape_tuple_for_cython_arr;
+static PyObject *__pyx_n_s_Enum___reduce_cython;
+static PyObject *__pyx_n_s_Enum___setstate_cython;
 static PyObject *__pyx_n_s_ImportError;
 static PyObject *__pyx_kp_s_Incompatible_checksums_0x_x_vs_0;
 static PyObject *__pyx_n_s_IndexError;
 static PyObject *__pyx_kp_s_Indirect_dimensions_not_supporte;
 static PyObject *__pyx_kp_s_Invalid_mode_expected_c_or_fortr;
 static PyObject *__pyx_kp_s_Invalid_shape_in_axis_d_d;
 static PyObject *__pyx_n_s_MemoryError;
@@ -2539,45 +2659,62 @@
 static PyObject *__pyx_n_s_PickleError;
 static PyObject *__pyx_n_s_TypeError;
 static PyObject *__pyx_kp_s_Unable_to_convert_item_to_object;
 static PyObject *__pyx_n_s_ValueError;
 static PyObject *__pyx_n_s_View_MemoryView;
 static PyObject *__pyx_n_s_allocate_buffer;
 static PyObject *__pyx_n_s_ark_utils__bootstrapping;
+static PyObject *__pyx_n_s_array___reduce_cython;
+static PyObject *__pyx_n_s_array___setstate_cython;
 static PyObject *__pyx_n_s_base;
 static PyObject *__pyx_n_s_bootstrap_num;
 static PyObject *__pyx_n_s_c;
 static PyObject *__pyx_n_u_c;
 static PyObject *__pyx_n_s_class;
 static PyObject *__pyx_n_s_cline_in_traceback;
 static PyObject *__pyx_n_s_cols_in_row_flat;
 static PyObject *__pyx_n_s_compute_close_num_rand;
 static PyObject *__pyx_kp_s_contiguous_and_direct;
 static PyObject *__pyx_kp_s_contiguous_and_indirect;
+static PyObject *__pyx_n_s_copy;
+static PyObject *__pyx_n_s_copy_fortran;
 static PyObject *__pyx_n_s_dict;
+static PyObject *__pyx_n_s_dict_2;
 static PyObject *__pyx_n_s_dist_mat_bin;
+static PyObject *__pyx_n_s_dst;
 static PyObject *__pyx_n_s_dtype;
 static PyObject *__pyx_n_s_dtype_is_object;
 static PyObject *__pyx_n_s_encode;
 static PyObject *__pyx_n_s_enumerate;
 static PyObject *__pyx_n_s_error;
 static PyObject *__pyx_n_s_flags;
 static PyObject *__pyx_n_s_format;
 static PyObject *__pyx_n_s_fortran;
 static PyObject *__pyx_n_u_fortran;
 static PyObject *__pyx_n_s_getstate;
 static PyObject *__pyx_kp_s_got_differing_extents_in_dimensi;
 static PyObject *__pyx_n_s_id;
 static PyObject *__pyx_n_s_import;
+static PyObject *__pyx_n_s_is_c_contig;
+static PyObject *__pyx_n_s_is_f_contig;
 static PyObject *__pyx_n_s_itemsize;
 static PyObject *__pyx_kp_s_itemsize_0_for_cython_array;
 static PyObject *__pyx_n_s_main;
 static PyObject *__pyx_n_s_marker_nums;
+static PyObject *__pyx_n_s_memoryview___reduce_cython;
+static PyObject *__pyx_n_s_memoryview___setstate_cython;
+static PyObject *__pyx_n_s_memoryview_copy;
+static PyObject *__pyx_n_s_memoryview_copy_fortran;
+static PyObject *__pyx_n_s_memoryview_is_c_contig;
+static PyObject *__pyx_n_s_memoryview_is_f_contig;
+static PyObject *__pyx_n_s_memoryviewslice___reduce_cython;
+static PyObject *__pyx_n_s_memoryviewslice___setstate_cyth;
 static PyObject *__pyx_n_s_memview;
 static PyObject *__pyx_n_s_mode;
+static PyObject *__pyx_n_s_mslice;
 static PyObject *__pyx_n_s_name;
 static PyObject *__pyx_n_s_name_2;
 static PyObject *__pyx_n_s_ndim;
 static PyObject *__pyx_n_s_new;
 static PyObject *__pyx_kp_s_no_default___reduce___due_to_non;
 static PyObject *__pyx_n_s_np;
 static PyObject *__pyx_n_s_numpy;
@@ -2596,33 +2733,38 @@
 static PyObject *__pyx_n_s_pyx_unpickle_Enum;
 static PyObject *__pyx_n_s_pyx_vtable;
 static PyObject *__pyx_n_s_range;
 static PyObject *__pyx_n_s_reduce;
 static PyObject *__pyx_n_s_reduce_cython;
 static PyObject *__pyx_n_s_reduce_ex;
 static PyObject *__pyx_n_s_row_indicies;
+static PyObject *__pyx_n_s_self;
 static PyObject *__pyx_n_s_setstate;
 static PyObject *__pyx_n_s_setstate_cython;
 static PyObject *__pyx_n_s_shape;
 static PyObject *__pyx_n_s_size;
+static PyObject *__pyx_n_s_src;
 static PyObject *__pyx_kp_s_src_ark_utils__bootstrapping_pyx;
 static PyObject *__pyx_n_s_start;
+static PyObject *__pyx_n_s_state;
 static PyObject *__pyx_n_s_step;
 static PyObject *__pyx_n_s_stop;
 static PyObject *__pyx_kp_s_strided_and_direct;
 static PyObject *__pyx_kp_s_strided_and_direct_or_indirect;
 static PyObject *__pyx_kp_s_strided_and_indirect;
 static PyObject *__pyx_kp_s_stringsource;
 static PyObject *__pyx_n_s_struct;
 static PyObject *__pyx_n_s_test;
+static PyObject *__pyx_n_s_tmp;
 static PyObject *__pyx_n_s_uint16;
 static PyObject *__pyx_kp_s_unable_to_allocate_array_data;
 static PyObject *__pyx_kp_s_unable_to_allocate_shape_and_str;
 static PyObject *__pyx_n_s_unpack;
 static PyObject *__pyx_n_s_update;
+static PyObject *__pyx_n_s_use_setstate;
 static PyObject *__pyx_n_s_zeros;
 static PyObject *__pyx_pf_3ark_5utils_14_bootstrapping_compute_close_num_rand(CYTHON_UNUSED PyObject *__pyx_self, __Pyx_memviewslice __pyx_v_dist_mat_bin, __Pyx_memviewslice __pyx_v_cols_in_row_flat, __Pyx_memviewslice __pyx_v_row_indicies, __Pyx_memviewslice __pyx_v_marker_nums, PyObject *__pyx_v_pos_labels, int __pyx_v_bootstrap_num); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array___cinit__(struct __pyx_array_obj *__pyx_v_self, PyObject *__pyx_v_shape, Py_ssize_t __pyx_v_itemsize, PyObject *__pyx_v_format, PyObject *__pyx_v_mode, int __pyx_v_allocate_buffer); /* proto */
 static int __pyx_array___pyx_pf_15View_dot_MemoryView_5array_2__getbuffer__(struct __pyx_array_obj *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /* proto */
 static void __pyx_array___pyx_pf_15View_dot_MemoryView_5array_4__dealloc__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static PyObject *__pyx_pf_15View_dot_MemoryView_5array_7memview___get__(struct __pyx_array_obj *__pyx_v_self); /* proto */
 static Py_ssize_t __pyx_array___pyx_pf_15View_dot_MemoryView_5array_6__len__(struct __pyx_array_obj *__pyx_v_self); /* proto */
@@ -2692,21 +2834,45 @@
 static PyObject *__pyx_tuple__16;
 static PyObject *__pyx_tuple__18;
 static PyObject *__pyx_tuple__19;
 static PyObject *__pyx_tuple__20;
 static PyObject *__pyx_tuple__21;
 static PyObject *__pyx_tuple__22;
 static PyObject *__pyx_tuple__24;
-static PyObject *__pyx_tuple__25;
 static PyObject *__pyx_tuple__26;
-static PyObject *__pyx_tuple__27;
 static PyObject *__pyx_tuple__28;
-static PyObject *__pyx_tuple__29;
+static PyObject *__pyx_tuple__30;
+static PyObject *__pyx_tuple__32;
+static PyObject *__pyx_tuple__33;
+static PyObject *__pyx_tuple__34;
+static PyObject *__pyx_tuple__35;
+static PyObject *__pyx_tuple__36;
+static PyObject *__pyx_tuple__37;
+static PyObject *__pyx_tuple__39;
+static PyObject *__pyx_tuple__41;
+static PyObject *__pyx_tuple__43;
+static PyObject *__pyx_tuple__45;
+static PyObject *__pyx_tuple__47;
+static PyObject *__pyx_tuple__49;
+static PyObject *__pyx_tuple__51;
+static PyObject *__pyx_tuple__53;
 static PyObject *__pyx_codeobj__23;
-static PyObject *__pyx_codeobj__30;
+static PyObject *__pyx_codeobj__25;
+static PyObject *__pyx_codeobj__27;
+static PyObject *__pyx_codeobj__29;
+static PyObject *__pyx_codeobj__31;
+static PyObject *__pyx_codeobj__38;
+static PyObject *__pyx_codeobj__40;
+static PyObject *__pyx_codeobj__42;
+static PyObject *__pyx_codeobj__44;
+static PyObject *__pyx_codeobj__46;
+static PyObject *__pyx_codeobj__48;
+static PyObject *__pyx_codeobj__50;
+static PyObject *__pyx_codeobj__52;
+static PyObject *__pyx_codeobj__54;
 /* Late includes */
 
 /* "ark/utils/_bootstrapping.pyx":15
  * 
  * @cdivision(True) # Ignore modulo/divide by zero warning
  * cdef inline void _c_permutation(Py_ssize_t* arr, const Py_ssize_t size) nogil:             # <<<<<<<<<<<<<<
  *     """ Randomly permutes the provided arr
@@ -3991,15 +4157,15 @@
   __PYX_XDEC_MEMVIEW(&__pyx_v_row_indicies, 1);
   __PYX_XDEC_MEMVIEW(&__pyx_v_marker_nums, 1);
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":734
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":734
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
@@ -4008,29 +4174,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew1", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":735
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":735
  * 
  * cdef inline object PyArray_MultiIterNew1(a):
  *     return PyArray_MultiIterNew(1, <void*>a)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(1, ((void *)__pyx_v_a)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 735, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":734
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":734
  * ctypedef npy_cdouble     complex_t
  * 
  * cdef inline object PyArray_MultiIterNew1(a):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  */
 
@@ -4041,15 +4207,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":737
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":737
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
@@ -4058,29 +4224,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew2", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":738
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":738
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(2, ((void *)__pyx_v_a), ((void *)__pyx_v_b)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 738, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":737
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":737
  *     return PyArray_MultiIterNew(1, <void*>a)
  * 
  * cdef inline object PyArray_MultiIterNew2(a, b):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  */
 
@@ -4091,15 +4257,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":740
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":740
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
@@ -4108,29 +4274,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew3", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":741
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":741
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(3, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 741, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":740
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":740
  *     return PyArray_MultiIterNew(2, <void*>a, <void*>b)
  * 
  * cdef inline object PyArray_MultiIterNew3(a, b, c):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  */
 
@@ -4141,15 +4307,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":743
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":743
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
@@ -4158,29 +4324,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew4", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":744
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":744
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(4, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 744, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":743
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":743
  *     return PyArray_MultiIterNew(3, <void*>a, <void*>b, <void*> c)
  * 
  * cdef inline object PyArray_MultiIterNew4(a, b, c, d):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  */
 
@@ -4191,15 +4357,15 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":746
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":746
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
@@ -4208,29 +4374,29 @@
   __Pyx_RefNannyDeclarations
   PyObject *__pyx_t_1 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("PyArray_MultiIterNew5", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":747
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":747
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)             # <<<<<<<<<<<<<<
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  */
   __Pyx_XDECREF(__pyx_r);
   __pyx_t_1 = PyArray_MultiIterNew(5, ((void *)__pyx_v_a), ((void *)__pyx_v_b), ((void *)__pyx_v_c), ((void *)__pyx_v_d), ((void *)__pyx_v_e)); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 747, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __pyx_r = __pyx_t_1;
   __pyx_t_1 = 0;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":746
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":746
  *     return PyArray_MultiIterNew(4, <void*>a, <void*>b, <void*>c, <void*> d)
  * 
  * cdef inline object PyArray_MultiIterNew5(a, b, c, d, e):             # <<<<<<<<<<<<<<
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  */
 
@@ -4241,212 +4407,212 @@
   __pyx_r = 0;
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":749
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":749
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_PyDataType_SHAPE(PyArray_Descr *__pyx_v_d) {
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("PyDataType_SHAPE", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":750
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":750
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   __pyx_t_1 = (PyDataType_HASSUBARRAY(__pyx_v_d) != 0);
   if (__pyx_t_1) {
 
-    /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":751
+    /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":751
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape             # <<<<<<<<<<<<<<
  *     else:
  *         return ()
  */
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(((PyObject*)__pyx_v_d->subarray->shape));
     __pyx_r = ((PyObject*)__pyx_v_d->subarray->shape);
     goto __pyx_L0;
 
-    /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":750
+    /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":750
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):
  *     if PyDataType_HASSUBARRAY(d):             # <<<<<<<<<<<<<<
  *         return <tuple>d.subarray.shape
  *     else:
  */
   }
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":753
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":753
  *         return <tuple>d.subarray.shape
  *     else:
  *         return ()             # <<<<<<<<<<<<<<
  * 
  * 
  */
   /*else*/ {
     __Pyx_XDECREF(__pyx_r);
     __Pyx_INCREF(__pyx_empty_tuple);
     __pyx_r = __pyx_empty_tuple;
     goto __pyx_L0;
   }
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":749
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":749
  *     return PyArray_MultiIterNew(5, <void*>a, <void*>b, <void*>c, <void*> d, <void*> e)
  * 
  * cdef inline tuple PyDataType_SHAPE(dtype d):             # <<<<<<<<<<<<<<
  *     if PyDataType_HASSUBARRAY(d):
  *         return <tuple>d.subarray.shape
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":928
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":928
  *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
 static CYTHON_INLINE void __pyx_f_5numpy_set_array_base(PyArrayObject *__pyx_v_arr, PyObject *__pyx_v_base) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("set_array_base", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":929
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":929
  * 
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!             # <<<<<<<<<<<<<<
  *     PyArray_SetBaseObject(arr, base)
  * 
  */
   Py_INCREF(__pyx_v_base);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":930
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":930
  * cdef inline void set_array_base(ndarray arr, object base):
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)             # <<<<<<<<<<<<<<
  * 
  * cdef inline object get_array_base(ndarray arr):
  */
   (void)(PyArray_SetBaseObject(__pyx_v_arr, __pyx_v_base));
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":928
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":928
  *     int _import_umath() except -1
  * 
  * cdef inline void set_array_base(ndarray arr, object base):             # <<<<<<<<<<<<<<
  *     Py_INCREF(base) # important to do this before stealing the reference below!
  *     PyArray_SetBaseObject(arr, base)
  */
 
   /* function exit code */
   __Pyx_RefNannyFinishContext();
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":932
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":932
  *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
 static CYTHON_INLINE PyObject *__pyx_f_5numpy_get_array_base(PyArrayObject *__pyx_v_arr) {
   PyObject *__pyx_v_base;
   PyObject *__pyx_r = NULL;
   __Pyx_RefNannyDeclarations
   int __pyx_t_1;
   __Pyx_RefNannySetupContext("get_array_base", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":933
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":933
  * 
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)             # <<<<<<<<<<<<<<
  *     if base is NULL:
  *         return None
  */
   __pyx_v_base = PyArray_BASE(__pyx_v_arr);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":934
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":934
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   __pyx_t_1 = ((__pyx_v_base == NULL) != 0);
   if (__pyx_t_1) {
 
-    /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":935
+    /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":935
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  *         return None             # <<<<<<<<<<<<<<
  *     return <object>base
  * 
  */
     __Pyx_XDECREF(__pyx_r);
     __pyx_r = Py_None; __Pyx_INCREF(Py_None);
     goto __pyx_L0;
 
-    /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":934
+    /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":934
  * cdef inline object get_array_base(ndarray arr):
  *     base = PyArray_BASE(arr)
  *     if base is NULL:             # <<<<<<<<<<<<<<
  *         return None
  *     return <object>base
  */
   }
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":936
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":936
  *     if base is NULL:
  *         return None
  *     return <object>base             # <<<<<<<<<<<<<<
  * 
  * # Versions of the import_* functions which are more suitable for
  */
   __Pyx_XDECREF(__pyx_r);
   __Pyx_INCREF(((PyObject *)__pyx_v_base));
   __pyx_r = ((PyObject *)__pyx_v_base);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":932
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":932
  *     PyArray_SetBaseObject(arr, base)
  * 
  * cdef inline object get_array_base(ndarray arr):             # <<<<<<<<<<<<<<
  *     base = PyArray_BASE(arr)
  *     if base is NULL:
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_XGIVEREF(__pyx_r);
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":940
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":940
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -4462,15 +4628,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_array", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":941
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
   {
@@ -4478,53 +4644,53 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":942
+      /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":942
  * cdef inline int import_array() except -1:
  *     try:
  *         __pyx_import_array()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")
  */
       __pyx_t_4 = _import_array(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 942, __pyx_L3_error)
 
-      /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":941
+      /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":943
+    /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":943
  *     try:
  *         __pyx_import_array()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 943, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":944
+      /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":944
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple_, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 944, __pyx_L5_except_error)
@@ -4532,30 +4698,30 @@
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(1, 944, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":941
+    /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":941
  * # Cython code.
  * cdef inline int import_array() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         __pyx_import_array()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":940
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":940
  * # Versions of the import_* functions which are more suitable for
  * # Cython code.
  * cdef inline int import_array() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         __pyx_import_array()
  */
 
@@ -4570,15 +4736,15 @@
   __Pyx_AddTraceback("numpy.import_array", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":946
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":946
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -4594,15 +4760,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_umath", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":947
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":947
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -4610,53 +4776,53 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":948
+      /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":948
  * cdef inline int import_umath() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
       __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 948, __pyx_L3_error)
 
-      /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":947
+      /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":947
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":949
+    /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":949
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 949, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":950
+      /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":950
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 950, __pyx_L5_except_error)
@@ -4664,30 +4830,30 @@
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(1, 950, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":947
+    /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":947
  * 
  * cdef inline int import_umath() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":946
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":946
  *         raise ImportError("numpy.core.multiarray failed to import")
  * 
  * cdef inline int import_umath() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -4702,15 +4868,15 @@
   __Pyx_AddTraceback("numpy.import_umath", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":952
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":952
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -4726,15 +4892,15 @@
   PyObject *__pyx_t_7 = NULL;
   PyObject *__pyx_t_8 = NULL;
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("import_ufunc", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":953
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":953
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
   {
@@ -4742,53 +4908,53 @@
     __Pyx_PyThreadState_assign
     __Pyx_ExceptionSave(&__pyx_t_1, &__pyx_t_2, &__pyx_t_3);
     __Pyx_XGOTREF(__pyx_t_1);
     __Pyx_XGOTREF(__pyx_t_2);
     __Pyx_XGOTREF(__pyx_t_3);
     /*try:*/ {
 
-      /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":954
+      /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":954
  * cdef inline int import_ufunc() except -1:
  *     try:
  *         _import_umath()             # <<<<<<<<<<<<<<
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")
  */
       __pyx_t_4 = _import_umath(); if (unlikely(__pyx_t_4 == ((int)-1))) __PYX_ERR(1, 954, __pyx_L3_error)
 
-      /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":953
+      /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":953
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     }
     __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
     __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
     __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
     goto __pyx_L8_try_end;
     __pyx_L3_error:;
 
-    /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":955
+    /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":955
  *     try:
  *         _import_umath()
  *     except Exception:             # <<<<<<<<<<<<<<
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  */
     __pyx_t_4 = __Pyx_PyErr_ExceptionMatches(((PyObject *)(&((PyTypeObject*)PyExc_Exception)[0])));
     if (__pyx_t_4) {
       __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
       if (__Pyx_GetException(&__pyx_t_5, &__pyx_t_6, &__pyx_t_7) < 0) __PYX_ERR(1, 955, __pyx_L5_except_error)
       __Pyx_GOTREF(__pyx_t_5);
       __Pyx_GOTREF(__pyx_t_6);
       __Pyx_GOTREF(__pyx_t_7);
 
-      /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":956
+      /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":956
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef extern from *:
  */
       __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ImportError, __pyx_tuple__2, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(1, 956, __pyx_L5_except_error)
@@ -4796,30 +4962,30 @@
       __Pyx_Raise(__pyx_t_8, 0, 0, 0);
       __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
       __PYX_ERR(1, 956, __pyx_L5_except_error)
     }
     goto __pyx_L5_except_error;
     __pyx_L5_except_error:;
 
-    /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":953
+    /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":953
  * 
  * cdef inline int import_ufunc() except -1:
  *     try:             # <<<<<<<<<<<<<<
  *         _import_umath()
  *     except Exception:
  */
     __Pyx_XGIVEREF(__pyx_t_1);
     __Pyx_XGIVEREF(__pyx_t_2);
     __Pyx_XGIVEREF(__pyx_t_3);
     __Pyx_ExceptionReset(__pyx_t_1, __pyx_t_2, __pyx_t_3);
     goto __pyx_L1_error;
     __pyx_L8_try_end:;
   }
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":952
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":952
  *         raise ImportError("numpy.core.umath failed to import")
  * 
  * cdef inline int import_ufunc() except -1:             # <<<<<<<<<<<<<<
  *     try:
  *         _import_umath()
  */
 
@@ -4834,176 +5000,176 @@
   __Pyx_AddTraceback("numpy.import_ufunc", __pyx_clineno, __pyx_lineno, __pyx_filename);
   __pyx_r = -1;
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":966
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":966
  * 
  * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_timedelta64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_timedelta64_object", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":978
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":978
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyTimedeltaArrType_Type)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyTimedeltaArrType_Type));
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":966
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":966
  * 
  * 
  * cdef inline bint is_timedelta64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.timedelta64)`
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":981
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":981
  * 
  * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
 static CYTHON_INLINE int __pyx_f_5numpy_is_datetime64_object(PyObject *__pyx_v_obj) {
   int __pyx_r;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_datetime64_object", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":993
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":993
  *     bool
  *     """
  *     return PyObject_TypeCheck(obj, &PyDatetimeArrType_Type)             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = PyObject_TypeCheck(__pyx_v_obj, (&PyDatetimeArrType_Type));
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":981
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":981
  * 
  * 
  * cdef inline bint is_datetime64_object(object obj):             # <<<<<<<<<<<<<<
  *     """
  *     Cython equivalent of `isinstance(obj, np.datetime64)`
  */
 
   /* function exit code */
   __pyx_L0:;
   __Pyx_RefNannyFinishContext();
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":996
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":996
  * 
  * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
 static CYTHON_INLINE npy_datetime __pyx_f_5numpy_get_datetime64_value(PyObject *__pyx_v_obj) {
   npy_datetime __pyx_r;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":1003
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":1003
  *     also needed.  That can be found using `get_datetime64_unit`.
  *     """
  *     return (<PyDatetimeScalarObject*>obj).obval             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((PyDatetimeScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":996
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":996
  * 
  * 
  * cdef inline npy_datetime get_datetime64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy datetime64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":1006
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":1006
  * 
  * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
 static CYTHON_INLINE npy_timedelta __pyx_f_5numpy_get_timedelta64_value(PyObject *__pyx_v_obj) {
   npy_timedelta __pyx_r;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":1010
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":1010
  *     returns the int64 value underlying scalar numpy timedelta64 object
  *     """
  *     return (<PyTimedeltaScalarObject*>obj).obval             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_r = ((PyTimedeltaScalarObject *)__pyx_v_obj)->obval;
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":1006
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":1006
  * 
  * 
  * cdef inline npy_timedelta get_timedelta64_value(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the int64 value underlying scalar numpy timedelta64 object
  */
 
   /* function exit code */
   __pyx_L0:;
   return __pyx_r;
 }
 
-/* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":1013
+/* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":1013
  * 
  * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
 static CYTHON_INLINE NPY_DATETIMEUNIT __pyx_f_5numpy_get_datetime64_unit(PyObject *__pyx_v_obj) {
   NPY_DATETIMEUNIT __pyx_r;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":1017
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":1017
  *     returns the unit part of the dtype for a numpy datetime64 object.
  *     """
  *     return <NPY_DATETIMEUNIT>(<PyDatetimeScalarObject*>obj).obmeta.base             # <<<<<<<<<<<<<<
  */
   __pyx_r = ((NPY_DATETIMEUNIT)((PyDatetimeScalarObject *)__pyx_v_obj)->obmeta.base);
   goto __pyx_L0;
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":1013
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":1013
  * 
  * 
  * cdef inline NPY_DATETIMEUNIT get_datetime64_unit(object obj) nogil:             # <<<<<<<<<<<<<<
  *     """
  *     returns the unit part of the dtype for a numpy datetime64 object.
  */
 
@@ -6596,14 +6762,15 @@
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw___pyx_array_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyMethodDef __pyx_mdef___pyx_array_1__reduce_cython__ = {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_array_1__reduce_cython__, METH_NOARGS, 0};
 static PyObject *__pyx_pw___pyx_array_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
   __pyx_r = __pyx_pf___pyx_array___reduce_cython__(((struct __pyx_array_obj *)__pyx_v_self));
 
   /* function exit code */
@@ -6653,14 +6820,15 @@
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw___pyx_array_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyMethodDef __pyx_mdef___pyx_array_3__setstate_cython__ = {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_array_3__setstate_cython__, METH_O, 0};
 static PyObject *__pyx_pw___pyx_array_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
   __pyx_r = __pyx_pf___pyx_array_2__setstate_cython__(((struct __pyx_array_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
@@ -7030,14 +7198,15 @@
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     cdef tuple state
  *     cdef object _dict
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyMethodDef __pyx_mdef___pyx_MemviewEnum_1__reduce_cython__ = {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_1__reduce_cython__, METH_NOARGS, 0};
 static PyObject *__pyx_pw___pyx_MemviewEnum_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
   __pyx_r = __pyx_pf___pyx_MemviewEnum___reduce_cython__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self));
 
   /* function exit code */
@@ -7265,14 +7434,15 @@
  *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw___pyx_MemviewEnum_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyMethodDef __pyx_mdef___pyx_MemviewEnum_3__setstate_cython__ = {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_MemviewEnum_3__setstate_cython__, METH_O, 0};
 static PyObject *__pyx_pw___pyx_MemviewEnum_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
   __pyx_r = __pyx_pf___pyx_MemviewEnum_2__setstate_cython__(((struct __pyx_MemviewEnum_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
@@ -11156,14 +11326,15 @@
  *     def is_c_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyMethodDef __pyx_mdef_15View_dot_MemoryView_10memoryview_17is_c_contig = {"is_c_contig", (PyCFunction)__pyx_memoryview_is_c_contig, METH_NOARGS, 0};
 static PyObject *__pyx_memoryview_is_c_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_c_contig (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_16is_c_contig(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
@@ -11232,14 +11403,15 @@
  *     def is_f_contig(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice *mslice
  *         cdef __Pyx_memviewslice tmp
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyMethodDef __pyx_mdef_15View_dot_MemoryView_10memoryview_19is_f_contig = {"is_f_contig", (PyCFunction)__pyx_memoryview_is_f_contig, METH_NOARGS, 0};
 static PyObject *__pyx_memoryview_is_f_contig(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("is_f_contig (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_18is_f_contig(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
@@ -11308,14 +11480,15 @@
  *     def copy(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice mslice
  *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyMethodDef __pyx_mdef_15View_dot_MemoryView_10memoryview_21copy = {"copy", (PyCFunction)__pyx_memoryview_copy, METH_NOARGS, 0};
 static PyObject *__pyx_memoryview_copy(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("copy (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_20copy(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
@@ -11402,14 +11575,15 @@
  *     def copy_fortran(self):             # <<<<<<<<<<<<<<
  *         cdef __Pyx_memviewslice src, dst
  *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
  */
 
 /* Python wrapper */
 static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyMethodDef __pyx_mdef_15View_dot_MemoryView_10memoryview_23copy_fortran = {"copy_fortran", (PyCFunction)__pyx_memoryview_copy_fortran, METH_NOARGS, 0};
 static PyObject *__pyx_memoryview_copy_fortran(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("copy_fortran (wrapper)", 0);
   __pyx_r = __pyx_memoryview___pyx_pf_15View_dot_MemoryView_10memoryview_22copy_fortran(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
@@ -11495,14 +11669,15 @@
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw___pyx_memoryview_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyMethodDef __pyx_mdef___pyx_memoryview_1__reduce_cython__ = {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_memoryview_1__reduce_cython__, METH_NOARGS, 0};
 static PyObject *__pyx_pw___pyx_memoryview_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
   __pyx_r = __pyx_pf___pyx_memoryview___reduce_cython__(((struct __pyx_memoryview_obj *)__pyx_v_self));
 
   /* function exit code */
@@ -11552,14 +11727,15 @@
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw___pyx_memoryview_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyMethodDef __pyx_mdef___pyx_memoryview_3__setstate_cython__ = {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_memoryview_3__setstate_cython__, METH_O, 0};
 static PyObject *__pyx_pw___pyx_memoryview_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
   __pyx_r = __pyx_pf___pyx_memoryview_2__setstate_cython__(((struct __pyx_memoryview_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
@@ -12346,15 +12522,15 @@
  *     cdef _memoryviewslice memviewsliceobj
  * 
  *     assert memview.view.ndim > 0             # <<<<<<<<<<<<<<
  * 
  *     if isinstance(memview, _memoryviewslice):
  */
   #ifndef CYTHON_WITHOUT_ASSERTIONS
-  if (unlikely(!Py_OptimizeFlag)) {
+  if (unlikely(__pyx_assertions_enabled())) {
     if (unlikely(!((__pyx_v_memview->view.ndim > 0) != 0))) {
       PyErr_SetNone(PyExc_AssertionError);
       __PYX_ERR(2, 724, __pyx_L1_error)
     }
   }
   #endif
 
@@ -14396,14 +14572,15 @@
  * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw___pyx_memoryviewslice_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
+static PyMethodDef __pyx_mdef___pyx_memoryviewslice_1__reduce_cython__ = {"__reduce_cython__", (PyCFunction)__pyx_pw___pyx_memoryviewslice_1__reduce_cython__, METH_NOARGS, 0};
 static PyObject *__pyx_pw___pyx_memoryviewslice_1__reduce_cython__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__reduce_cython__ (wrapper)", 0);
   __pyx_r = __pyx_pf___pyx_memoryviewslice___reduce_cython__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self));
 
   /* function exit code */
@@ -14453,14 +14630,15 @@
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
  *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
  */
 
 /* Python wrapper */
 static PyObject *__pyx_pw___pyx_memoryviewslice_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state); /*proto*/
+static PyMethodDef __pyx_mdef___pyx_memoryviewslice_3__setstate_cython__ = {"__setstate_cython__", (PyCFunction)__pyx_pw___pyx_memoryviewslice_3__setstate_cython__, METH_O, 0};
 static PyObject *__pyx_pw___pyx_memoryviewslice_3__setstate_cython__(PyObject *__pyx_v_self, PyObject *__pyx_v___pyx_state) {
   PyObject *__pyx_r = 0;
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__setstate_cython__ (wrapper)", 0);
   __pyx_r = __pyx_pf___pyx_memoryviewslice_2__setstate_cython__(((struct __pyx_memoryviewslice_obj *)__pyx_v_self), ((PyObject *)__pyx_v___pyx_state));
 
   /* function exit code */
@@ -18073,15 +18251,15 @@
   Py_DECREF(o); o = 0;
   return NULL;
 }
 
 static void __pyx_tp_dealloc_array(PyObject *o) {
   struct __pyx_array_obj *p = (struct __pyx_array_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !__Pyx_PyObject_GC_IsFinalized(o))) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
     __Pyx_SET_REFCNT(o, Py_REFCNT(o) + 1);
@@ -18236,15 +18414,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyObject *__pyx_tp_new_Enum(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
   struct __pyx_MemviewEnum_obj *p;
   PyObject *o;
@@ -18258,15 +18436,15 @@
   p->name = Py_None; Py_INCREF(Py_None);
   return o;
 }
 
 static void __pyx_tp_dealloc_Enum(PyObject *o) {
   struct __pyx_MemviewEnum_obj *p = (struct __pyx_MemviewEnum_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !__Pyx_PyObject_GC_IsFinalized(o)) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   Py_CLEAR(p->name);
   (*Py_TYPE(o)->tp_free)(o);
 }
@@ -18358,15 +18536,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct_memoryview __pyx_vtable_memoryview;
 
 static PyObject *__pyx_tp_new_memoryview(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryview_obj *p;
@@ -18389,15 +18567,15 @@
   Py_DECREF(o); o = 0;
   return NULL;
 }
 
 static void __pyx_tp_dealloc_memoryview(PyObject *o) {
   struct __pyx_memoryview_obj *p = (struct __pyx_memoryview_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !__Pyx_PyObject_GC_IsFinalized(o)) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
@@ -18622,15 +18800,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 static struct __pyx_vtabstruct__memoryviewslice __pyx_vtable__memoryviewslice;
 
 static PyObject *__pyx_tp_new__memoryviewslice(PyTypeObject *t, PyObject *a, PyObject *k) {
   struct __pyx_memoryviewslice_obj *p;
@@ -18642,15 +18820,15 @@
   p->from_slice.memview = NULL;
   return o;
 }
 
 static void __pyx_tp_dealloc__memoryviewslice(PyObject *o) {
   struct __pyx_memoryviewslice_obj *p = (struct __pyx_memoryviewslice_obj *)o;
   #if CYTHON_USE_TP_FINALIZE
-  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
+  if (unlikely(PyType_HasFeature(Py_TYPE(o), Py_TPFLAGS_HAVE_FINALIZE) && Py_TYPE(o)->tp_finalize) && !__Pyx_PyObject_GC_IsFinalized(o)) {
     if (PyObject_CallFinalizerFromDealloc(o)) return;
   }
   #endif
   PyObject_GC_UnTrack(o);
   {
     PyObject *etype, *eval, *etb;
     PyErr_Fetch(&etype, &eval, &etb);
@@ -18771,15 +18949,15 @@
   #endif
   #if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
   0, /*tp_vectorcall*/
   #endif
   #if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
   0, /*tp_print*/
   #endif
-  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000
+  #if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
   0, /*tp_pypy_flags*/
   #endif
 };
 
 static PyMethodDef __pyx_methods[] = {
   {0, 0, 0, 0}
 };
@@ -18830,14 +19008,16 @@
   {&__pyx_kp_s_Buffer_view_does_not_expose_stri, __pyx_k_Buffer_view_does_not_expose_stri, sizeof(__pyx_k_Buffer_view_does_not_expose_stri), 0, 0, 1, 0},
   {&__pyx_kp_s_Can_only_create_a_buffer_that_is, __pyx_k_Can_only_create_a_buffer_that_is, sizeof(__pyx_k_Can_only_create_a_buffer_that_is), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_assign_to_read_only_memor, __pyx_k_Cannot_assign_to_read_only_memor, sizeof(__pyx_k_Cannot_assign_to_read_only_memor), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_create_writable_memory_vi, __pyx_k_Cannot_create_writable_memory_vi, sizeof(__pyx_k_Cannot_create_writable_memory_vi), 0, 0, 1, 0},
   {&__pyx_kp_s_Cannot_index_with_type_s, __pyx_k_Cannot_index_with_type_s, sizeof(__pyx_k_Cannot_index_with_type_s), 0, 0, 1, 0},
   {&__pyx_n_s_Ellipsis, __pyx_k_Ellipsis, sizeof(__pyx_k_Ellipsis), 0, 0, 1, 1},
   {&__pyx_kp_s_Empty_shape_tuple_for_cython_arr, __pyx_k_Empty_shape_tuple_for_cython_arr, sizeof(__pyx_k_Empty_shape_tuple_for_cython_arr), 0, 0, 1, 0},
+  {&__pyx_n_s_Enum___reduce_cython, __pyx_k_Enum___reduce_cython, sizeof(__pyx_k_Enum___reduce_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_Enum___setstate_cython, __pyx_k_Enum___setstate_cython, sizeof(__pyx_k_Enum___setstate_cython), 0, 0, 1, 1},
   {&__pyx_n_s_ImportError, __pyx_k_ImportError, sizeof(__pyx_k_ImportError), 0, 0, 1, 1},
   {&__pyx_kp_s_Incompatible_checksums_0x_x_vs_0, __pyx_k_Incompatible_checksums_0x_x_vs_0, sizeof(__pyx_k_Incompatible_checksums_0x_x_vs_0), 0, 0, 1, 0},
   {&__pyx_n_s_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 0, 0, 1, 1},
   {&__pyx_kp_s_Indirect_dimensions_not_supporte, __pyx_k_Indirect_dimensions_not_supporte, sizeof(__pyx_k_Indirect_dimensions_not_supporte), 0, 0, 1, 0},
   {&__pyx_kp_s_Invalid_mode_expected_c_or_fortr, __pyx_k_Invalid_mode_expected_c_or_fortr, sizeof(__pyx_k_Invalid_mode_expected_c_or_fortr), 0, 0, 1, 0},
   {&__pyx_kp_s_Invalid_shape_in_axis_d_d, __pyx_k_Invalid_shape_in_axis_d_d, sizeof(__pyx_k_Invalid_shape_in_axis_d_d), 0, 0, 1, 0},
   {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
@@ -18848,45 +19028,62 @@
   {&__pyx_n_s_PickleError, __pyx_k_PickleError, sizeof(__pyx_k_PickleError), 0, 0, 1, 1},
   {&__pyx_n_s_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 0, 0, 1, 1},
   {&__pyx_kp_s_Unable_to_convert_item_to_object, __pyx_k_Unable_to_convert_item_to_object, sizeof(__pyx_k_Unable_to_convert_item_to_object), 0, 0, 1, 0},
   {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
   {&__pyx_n_s_View_MemoryView, __pyx_k_View_MemoryView, sizeof(__pyx_k_View_MemoryView), 0, 0, 1, 1},
   {&__pyx_n_s_allocate_buffer, __pyx_k_allocate_buffer, sizeof(__pyx_k_allocate_buffer), 0, 0, 1, 1},
   {&__pyx_n_s_ark_utils__bootstrapping, __pyx_k_ark_utils__bootstrapping, sizeof(__pyx_k_ark_utils__bootstrapping), 0, 0, 1, 1},
+  {&__pyx_n_s_array___reduce_cython, __pyx_k_array___reduce_cython, sizeof(__pyx_k_array___reduce_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_array___setstate_cython, __pyx_k_array___setstate_cython, sizeof(__pyx_k_array___setstate_cython), 0, 0, 1, 1},
   {&__pyx_n_s_base, __pyx_k_base, sizeof(__pyx_k_base), 0, 0, 1, 1},
   {&__pyx_n_s_bootstrap_num, __pyx_k_bootstrap_num, sizeof(__pyx_k_bootstrap_num), 0, 0, 1, 1},
   {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
   {&__pyx_n_u_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 1, 0, 1},
   {&__pyx_n_s_class, __pyx_k_class, sizeof(__pyx_k_class), 0, 0, 1, 1},
   {&__pyx_n_s_cline_in_traceback, __pyx_k_cline_in_traceback, sizeof(__pyx_k_cline_in_traceback), 0, 0, 1, 1},
   {&__pyx_n_s_cols_in_row_flat, __pyx_k_cols_in_row_flat, sizeof(__pyx_k_cols_in_row_flat), 0, 0, 1, 1},
   {&__pyx_n_s_compute_close_num_rand, __pyx_k_compute_close_num_rand, sizeof(__pyx_k_compute_close_num_rand), 0, 0, 1, 1},
   {&__pyx_kp_s_contiguous_and_direct, __pyx_k_contiguous_and_direct, sizeof(__pyx_k_contiguous_and_direct), 0, 0, 1, 0},
   {&__pyx_kp_s_contiguous_and_indirect, __pyx_k_contiguous_and_indirect, sizeof(__pyx_k_contiguous_and_indirect), 0, 0, 1, 0},
+  {&__pyx_n_s_copy, __pyx_k_copy, sizeof(__pyx_k_copy), 0, 0, 1, 1},
+  {&__pyx_n_s_copy_fortran, __pyx_k_copy_fortran, sizeof(__pyx_k_copy_fortran), 0, 0, 1, 1},
   {&__pyx_n_s_dict, __pyx_k_dict, sizeof(__pyx_k_dict), 0, 0, 1, 1},
+  {&__pyx_n_s_dict_2, __pyx_k_dict_2, sizeof(__pyx_k_dict_2), 0, 0, 1, 1},
   {&__pyx_n_s_dist_mat_bin, __pyx_k_dist_mat_bin, sizeof(__pyx_k_dist_mat_bin), 0, 0, 1, 1},
+  {&__pyx_n_s_dst, __pyx_k_dst, sizeof(__pyx_k_dst), 0, 0, 1, 1},
   {&__pyx_n_s_dtype, __pyx_k_dtype, sizeof(__pyx_k_dtype), 0, 0, 1, 1},
   {&__pyx_n_s_dtype_is_object, __pyx_k_dtype_is_object, sizeof(__pyx_k_dtype_is_object), 0, 0, 1, 1},
   {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
   {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
   {&__pyx_n_s_error, __pyx_k_error, sizeof(__pyx_k_error), 0, 0, 1, 1},
   {&__pyx_n_s_flags, __pyx_k_flags, sizeof(__pyx_k_flags), 0, 0, 1, 1},
   {&__pyx_n_s_format, __pyx_k_format, sizeof(__pyx_k_format), 0, 0, 1, 1},
   {&__pyx_n_s_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 0, 1, 1},
   {&__pyx_n_u_fortran, __pyx_k_fortran, sizeof(__pyx_k_fortran), 0, 1, 0, 1},
   {&__pyx_n_s_getstate, __pyx_k_getstate, sizeof(__pyx_k_getstate), 0, 0, 1, 1},
   {&__pyx_kp_s_got_differing_extents_in_dimensi, __pyx_k_got_differing_extents_in_dimensi, sizeof(__pyx_k_got_differing_extents_in_dimensi), 0, 0, 1, 0},
   {&__pyx_n_s_id, __pyx_k_id, sizeof(__pyx_k_id), 0, 0, 1, 1},
   {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
+  {&__pyx_n_s_is_c_contig, __pyx_k_is_c_contig, sizeof(__pyx_k_is_c_contig), 0, 0, 1, 1},
+  {&__pyx_n_s_is_f_contig, __pyx_k_is_f_contig, sizeof(__pyx_k_is_f_contig), 0, 0, 1, 1},
   {&__pyx_n_s_itemsize, __pyx_k_itemsize, sizeof(__pyx_k_itemsize), 0, 0, 1, 1},
   {&__pyx_kp_s_itemsize_0_for_cython_array, __pyx_k_itemsize_0_for_cython_array, sizeof(__pyx_k_itemsize_0_for_cython_array), 0, 0, 1, 0},
   {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
   {&__pyx_n_s_marker_nums, __pyx_k_marker_nums, sizeof(__pyx_k_marker_nums), 0, 0, 1, 1},
+  {&__pyx_n_s_memoryview___reduce_cython, __pyx_k_memoryview___reduce_cython, sizeof(__pyx_k_memoryview___reduce_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_memoryview___setstate_cython, __pyx_k_memoryview___setstate_cython, sizeof(__pyx_k_memoryview___setstate_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_memoryview_copy, __pyx_k_memoryview_copy, sizeof(__pyx_k_memoryview_copy), 0, 0, 1, 1},
+  {&__pyx_n_s_memoryview_copy_fortran, __pyx_k_memoryview_copy_fortran, sizeof(__pyx_k_memoryview_copy_fortran), 0, 0, 1, 1},
+  {&__pyx_n_s_memoryview_is_c_contig, __pyx_k_memoryview_is_c_contig, sizeof(__pyx_k_memoryview_is_c_contig), 0, 0, 1, 1},
+  {&__pyx_n_s_memoryview_is_f_contig, __pyx_k_memoryview_is_f_contig, sizeof(__pyx_k_memoryview_is_f_contig), 0, 0, 1, 1},
+  {&__pyx_n_s_memoryviewslice___reduce_cython, __pyx_k_memoryviewslice___reduce_cython, sizeof(__pyx_k_memoryviewslice___reduce_cython), 0, 0, 1, 1},
+  {&__pyx_n_s_memoryviewslice___setstate_cyth, __pyx_k_memoryviewslice___setstate_cyth, sizeof(__pyx_k_memoryviewslice___setstate_cyth), 0, 0, 1, 1},
   {&__pyx_n_s_memview, __pyx_k_memview, sizeof(__pyx_k_memview), 0, 0, 1, 1},
   {&__pyx_n_s_mode, __pyx_k_mode, sizeof(__pyx_k_mode), 0, 0, 1, 1},
+  {&__pyx_n_s_mslice, __pyx_k_mslice, sizeof(__pyx_k_mslice), 0, 0, 1, 1},
   {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
   {&__pyx_n_s_name_2, __pyx_k_name_2, sizeof(__pyx_k_name_2), 0, 0, 1, 1},
   {&__pyx_n_s_ndim, __pyx_k_ndim, sizeof(__pyx_k_ndim), 0, 0, 1, 1},
   {&__pyx_n_s_new, __pyx_k_new, sizeof(__pyx_k_new), 0, 0, 1, 1},
   {&__pyx_kp_s_no_default___reduce___due_to_non, __pyx_k_no_default___reduce___due_to_non, sizeof(__pyx_k_no_default___reduce___due_to_non), 0, 0, 1, 0},
   {&__pyx_n_s_np, __pyx_k_np, sizeof(__pyx_k_np), 0, 0, 1, 1},
   {&__pyx_n_s_numpy, __pyx_k_numpy, sizeof(__pyx_k_numpy), 0, 0, 1, 1},
@@ -18905,33 +19102,38 @@
   {&__pyx_n_s_pyx_unpickle_Enum, __pyx_k_pyx_unpickle_Enum, sizeof(__pyx_k_pyx_unpickle_Enum), 0, 0, 1, 1},
   {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
   {&__pyx_n_s_range, __pyx_k_range, sizeof(__pyx_k_range), 0, 0, 1, 1},
   {&__pyx_n_s_reduce, __pyx_k_reduce, sizeof(__pyx_k_reduce), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_cython, __pyx_k_reduce_cython, sizeof(__pyx_k_reduce_cython), 0, 0, 1, 1},
   {&__pyx_n_s_reduce_ex, __pyx_k_reduce_ex, sizeof(__pyx_k_reduce_ex), 0, 0, 1, 1},
   {&__pyx_n_s_row_indicies, __pyx_k_row_indicies, sizeof(__pyx_k_row_indicies), 0, 0, 1, 1},
+  {&__pyx_n_s_self, __pyx_k_self, sizeof(__pyx_k_self), 0, 0, 1, 1},
   {&__pyx_n_s_setstate, __pyx_k_setstate, sizeof(__pyx_k_setstate), 0, 0, 1, 1},
   {&__pyx_n_s_setstate_cython, __pyx_k_setstate_cython, sizeof(__pyx_k_setstate_cython), 0, 0, 1, 1},
   {&__pyx_n_s_shape, __pyx_k_shape, sizeof(__pyx_k_shape), 0, 0, 1, 1},
   {&__pyx_n_s_size, __pyx_k_size, sizeof(__pyx_k_size), 0, 0, 1, 1},
+  {&__pyx_n_s_src, __pyx_k_src, sizeof(__pyx_k_src), 0, 0, 1, 1},
   {&__pyx_kp_s_src_ark_utils__bootstrapping_pyx, __pyx_k_src_ark_utils__bootstrapping_pyx, sizeof(__pyx_k_src_ark_utils__bootstrapping_pyx), 0, 0, 1, 0},
   {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
+  {&__pyx_n_s_state, __pyx_k_state, sizeof(__pyx_k_state), 0, 0, 1, 1},
   {&__pyx_n_s_step, __pyx_k_step, sizeof(__pyx_k_step), 0, 0, 1, 1},
   {&__pyx_n_s_stop, __pyx_k_stop, sizeof(__pyx_k_stop), 0, 0, 1, 1},
   {&__pyx_kp_s_strided_and_direct, __pyx_k_strided_and_direct, sizeof(__pyx_k_strided_and_direct), 0, 0, 1, 0},
   {&__pyx_kp_s_strided_and_direct_or_indirect, __pyx_k_strided_and_direct_or_indirect, sizeof(__pyx_k_strided_and_direct_or_indirect), 0, 0, 1, 0},
   {&__pyx_kp_s_strided_and_indirect, __pyx_k_strided_and_indirect, sizeof(__pyx_k_strided_and_indirect), 0, 0, 1, 0},
   {&__pyx_kp_s_stringsource, __pyx_k_stringsource, sizeof(__pyx_k_stringsource), 0, 0, 1, 0},
   {&__pyx_n_s_struct, __pyx_k_struct, sizeof(__pyx_k_struct), 0, 0, 1, 1},
   {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
+  {&__pyx_n_s_tmp, __pyx_k_tmp, sizeof(__pyx_k_tmp), 0, 0, 1, 1},
   {&__pyx_n_s_uint16, __pyx_k_uint16, sizeof(__pyx_k_uint16), 0, 0, 1, 1},
   {&__pyx_kp_s_unable_to_allocate_array_data, __pyx_k_unable_to_allocate_array_data, sizeof(__pyx_k_unable_to_allocate_array_data), 0, 0, 1, 0},
   {&__pyx_kp_s_unable_to_allocate_shape_and_str, __pyx_k_unable_to_allocate_shape_and_str, sizeof(__pyx_k_unable_to_allocate_shape_and_str), 0, 0, 1, 0},
   {&__pyx_n_s_unpack, __pyx_k_unpack, sizeof(__pyx_k_unpack), 0, 0, 1, 1},
   {&__pyx_n_s_update, __pyx_k_update, sizeof(__pyx_k_update), 0, 0, 1, 1},
+  {&__pyx_n_s_use_setstate, __pyx_k_use_setstate, sizeof(__pyx_k_use_setstate), 0, 0, 1, 1},
   {&__pyx_n_s_zeros, __pyx_k_zeros, sizeof(__pyx_k_zeros), 0, 0, 1, 1},
   {0, 0, 0, 0, 0, 0, 0}
 };
 static CYTHON_SMALL_CODE int __Pyx_InitCachedBuiltins(void) {
   __pyx_builtin_range = __Pyx_GetBuiltinName(__pyx_n_s_range); if (!__pyx_builtin_range) __PYX_ERR(0, 28, __pyx_L1_error)
   __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(0, 206, __pyx_L1_error)
   __pyx_builtin_ImportError = __Pyx_GetBuiltinName(__pyx_n_s_ImportError); if (!__pyx_builtin_ImportError) __PYX_ERR(1, 944, __pyx_L1_error)
@@ -18946,26 +19148,26 @@
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitCachedConstants(void) {
   __Pyx_RefNannyDeclarations
   __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":944
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":944
  *         __pyx_import_array()
  *     except Exception:
  *         raise ImportError("numpy.core.multiarray failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_umath() except -1:
  */
   __pyx_tuple_ = PyTuple_Pack(1, __pyx_kp_u_numpy_core_multiarray_failed_to); if (unlikely(!__pyx_tuple_)) __PYX_ERR(1, 944, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple_);
   __Pyx_GIVEREF(__pyx_tuple_);
 
-  /* "../../../../../tmp/build-env-5sz0mggh/lib/python3.10/site-packages/numpy/__init__.pxd":950
+  /* "../../../../../tmp/build-env-b17xcgbu/lib/python3.10/site-packages/numpy/__init__.pxd":950
  *         _import_umath()
  *     except Exception:
  *         raise ImportError("numpy.core.umath failed to import")             # <<<<<<<<<<<<<<
  * 
  * cdef inline int import_ufunc() except -1:
  */
   __pyx_tuple__2 = PyTuple_Pack(1, __pyx_kp_u_numpy_core_umath_failed_to_impor); if (unlikely(!__pyx_tuple__2)) __PYX_ERR(1, 950, __pyx_L1_error)
@@ -19175,86 +19377,223 @@
  *                            dict pos_labels, int bootstrap_num):
  */
   __pyx_tuple__22 = PyTuple_Pack(6, __pyx_n_s_dist_mat_bin, __pyx_n_s_cols_in_row_flat, __pyx_n_s_row_indicies, __pyx_n_s_marker_nums, __pyx_n_s_pos_labels, __pyx_n_s_bootstrap_num); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 248, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_tuple__22);
   __Pyx_GIVEREF(__pyx_tuple__22);
   __pyx_codeobj__23 = (PyObject*)__Pyx_PyCode_New(6, 0, 6, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__22, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_src_ark_utils__bootstrapping_pyx, __pyx_n_s_compute_close_num_rand, 248, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__23)) __PYX_ERR(0, 248, __pyx_L1_error)
 
+  /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__24);
+  __Pyx_GIVEREF(__pyx_tuple__24);
+  __pyx_codeobj__25 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__24, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__25)) __PYX_ERR(2, 1, __pyx_L1_error)
+
+  /* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_tuple__26 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_pyx_state); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(2, 3, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__26);
+  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_codeobj__27 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__26, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 3, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__27)) __PYX_ERR(2, 3, __pyx_L1_error)
+
+  /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     cdef tuple state
+ *     cdef object _dict
+ */
+  __pyx_tuple__28 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_state, __pyx_n_s_dict_2, __pyx_n_s_use_setstate); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__28);
+  __Pyx_GIVEREF(__pyx_tuple__28);
+  __pyx_codeobj__29 = (PyObject*)__Pyx_PyCode_New(1, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__28, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__29)) __PYX_ERR(2, 1, __pyx_L1_error)
+
+  /* "(tree fragment)":16
+ *     else:
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
+ */
+  __pyx_tuple__30 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_pyx_state); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(2, 16, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__30);
+  __Pyx_GIVEREF(__pyx_tuple__30);
+  __pyx_codeobj__31 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__30, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 16, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__31)) __PYX_ERR(2, 16, __pyx_L1_error)
+
   /* "View.MemoryView":287
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_tuple__24 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(2, 287, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__24);
-  __Pyx_GIVEREF(__pyx_tuple__24);
+  __pyx_tuple__32 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct_or_indirect); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(2, 287, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__32);
+  __Pyx_GIVEREF(__pyx_tuple__32);
 
   /* "View.MemoryView":288
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(2, 288, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__25);
-  __Pyx_GIVEREF(__pyx_tuple__25);
+  __pyx_tuple__33 = PyTuple_Pack(1, __pyx_kp_s_strided_and_direct); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(2, 288, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__33);
+  __Pyx_GIVEREF(__pyx_tuple__33);
 
   /* "View.MemoryView":289
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(2, 289, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__26);
-  __Pyx_GIVEREF(__pyx_tuple__26);
+  __pyx_tuple__34 = PyTuple_Pack(1, __pyx_kp_s_strided_and_indirect); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(2, 289, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__34);
+  __Pyx_GIVEREF(__pyx_tuple__34);
 
   /* "View.MemoryView":292
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(2, 292, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__27);
-  __Pyx_GIVEREF(__pyx_tuple__27);
+  __pyx_tuple__35 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_direct); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(2, 292, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__35);
+  __Pyx_GIVEREF(__pyx_tuple__35);
 
   /* "View.MemoryView":293
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(2, 293, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__28);
-  __Pyx_GIVEREF(__pyx_tuple__28);
+  __pyx_tuple__36 = PyTuple_Pack(1, __pyx_kp_s_contiguous_and_indirect); if (unlikely(!__pyx_tuple__36)) __PYX_ERR(2, 293, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__36);
+  __Pyx_GIVEREF(__pyx_tuple__36);
+
+  /* "View.MemoryView":621
+ * 
+ * 
+ *     def is_c_contig(self):             # <<<<<<<<<<<<<<
+ *         cdef __Pyx_memviewslice *mslice
+ *         cdef __Pyx_memviewslice tmp
+ */
+  __pyx_tuple__37 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_mslice, __pyx_n_s_tmp); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(2, 621, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__37);
+  __Pyx_GIVEREF(__pyx_tuple__37);
+  __pyx_codeobj__38 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__37, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_is_c_contig, 621, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__38)) __PYX_ERR(2, 621, __pyx_L1_error)
+
+  /* "View.MemoryView":627
+ *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
+ * 
+ *     def is_f_contig(self):             # <<<<<<<<<<<<<<
+ *         cdef __Pyx_memviewslice *mslice
+ *         cdef __Pyx_memviewslice tmp
+ */
+  __pyx_tuple__39 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_mslice, __pyx_n_s_tmp); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(2, 627, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__39);
+  __Pyx_GIVEREF(__pyx_tuple__39);
+  __pyx_codeobj__40 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__39, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_is_f_contig, 627, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__40)) __PYX_ERR(2, 627, __pyx_L1_error)
+
+  /* "View.MemoryView":633
+ *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
+ * 
+ *     def copy(self):             # <<<<<<<<<<<<<<
+ *         cdef __Pyx_memviewslice mslice
+ *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
+ */
+  __pyx_tuple__41 = PyTuple_Pack(3, __pyx_n_s_self, __pyx_n_s_mslice, __pyx_n_s_flags); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(2, 633, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__41);
+  __Pyx_GIVEREF(__pyx_tuple__41);
+  __pyx_codeobj__42 = (PyObject*)__Pyx_PyCode_New(1, 0, 3, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__41, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_copy, 633, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__42)) __PYX_ERR(2, 633, __pyx_L1_error)
+
+  /* "View.MemoryView":645
+ *         return memoryview_copy_from_slice(self, &mslice)
+ * 
+ *     def copy_fortran(self):             # <<<<<<<<<<<<<<
+ *         cdef __Pyx_memviewslice src, dst
+ *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
+ */
+  __pyx_tuple__43 = PyTuple_Pack(4, __pyx_n_s_self, __pyx_n_s_src, __pyx_n_s_dst, __pyx_n_s_flags); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(2, 645, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__43);
+  __Pyx_GIVEREF(__pyx_tuple__43);
+  __pyx_codeobj__44 = (PyObject*)__Pyx_PyCode_New(1, 0, 4, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__43, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_copy_fortran, 645, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__44)) __PYX_ERR(2, 645, __pyx_L1_error)
+
+  /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+  __pyx_tuple__45 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__45);
+  __Pyx_GIVEREF(__pyx_tuple__45);
+  __pyx_codeobj__46 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__45, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__46)) __PYX_ERR(2, 1, __pyx_L1_error)
+
+  /* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_tuple__47 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_pyx_state); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(2, 3, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__47);
+  __Pyx_GIVEREF(__pyx_tuple__47);
+  __pyx_codeobj__48 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__47, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 3, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__48)) __PYX_ERR(2, 3, __pyx_L1_error)
+
+  /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+  __pyx_tuple__49 = PyTuple_Pack(1, __pyx_n_s_self); if (unlikely(!__pyx_tuple__49)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__49);
+  __Pyx_GIVEREF(__pyx_tuple__49);
+  __pyx_codeobj__50 = (PyObject*)__Pyx_PyCode_New(1, 0, 1, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__49, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_reduce_cython, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__50)) __PYX_ERR(2, 1, __pyx_L1_error)
+
+  /* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_tuple__51 = PyTuple_Pack(2, __pyx_n_s_self, __pyx_n_s_pyx_state); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(2, 3, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__51);
+  __Pyx_GIVEREF(__pyx_tuple__51);
+  __pyx_codeobj__52 = (PyObject*)__Pyx_PyCode_New(2, 0, 2, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__51, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_setstate_cython, 3, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__52)) __PYX_ERR(2, 3, __pyx_L1_error)
 
   /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_tuple__29 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(2, 1, __pyx_L1_error)
-  __Pyx_GOTREF(__pyx_tuple__29);
-  __Pyx_GIVEREF(__pyx_tuple__29);
-  __pyx_codeobj__30 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__29, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__30)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __pyx_tuple__53 = PyTuple_Pack(5, __pyx_n_s_pyx_type, __pyx_n_s_pyx_checksum, __pyx_n_s_pyx_state, __pyx_n_s_pyx_PickleError, __pyx_n_s_pyx_result); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_tuple__53);
+  __Pyx_GIVEREF(__pyx_tuple__53);
+  __pyx_codeobj__54 = (PyObject*)__Pyx_PyCode_New(3, 0, 5, 0, CO_OPTIMIZED|CO_NEWLOCALS, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__53, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_stringsource, __pyx_n_s_pyx_unpickle_Enum, 1, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj__54)) __PYX_ERR(2, 1, __pyx_L1_error)
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_RefNannyFinishContext();
   return -1;
 }
 
 static CYTHON_SMALL_CODE int __Pyx_InitGlobals(void) {
+  /* AssertionsEnabled.init */
+  __Pyx_init_assertions_enabled();
+
+if (unlikely(PyErr_Occurred())) __PYX_ERR(0, 1, __pyx_L1_error)
+
   if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_112105877 = PyInt_FromLong(112105877L); if (unlikely(!__pyx_int_112105877)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_136983863 = PyInt_FromLong(136983863L); if (unlikely(!__pyx_int_136983863)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_184977713 = PyInt_FromLong(184977713L); if (unlikely(!__pyx_int_184977713)) __PYX_ERR(0, 1, __pyx_L1_error)
   __pyx_int_neg_1 = PyInt_FromLong(-1); if (unlikely(!__pyx_int_neg_1)) __PYX_ERR(0, 1, __pyx_L1_error)
@@ -19371,55 +19710,39 @@
   int __pyx_lineno = 0;
   const char *__pyx_filename = NULL;
   int __pyx_clineno = 0;
   __Pyx_RefNannySetupContext("__Pyx_modinit_type_import_code", 0);
   /*--- Type import code ---*/
   __pyx_t_1 = PyImport_ImportModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_t_1)) __PYX_ERR(3, 9, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
+  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType_0_29_36(__pyx_t_1, __Pyx_BUILTIN_MODULE_NAME, "type", 
   #if defined(PYPY_VERSION_NUM) && PYPY_VERSION_NUM < 0x050B0000
-  sizeof(PyTypeObject),
+  sizeof(PyTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyTypeObject),
   #else
-  sizeof(PyHeapTypeObject),
+  sizeof(PyHeapTypeObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyHeapTypeObject),
   #endif
-  __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(3, 9, __pyx_L1_error)
+  __Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_7cpython_4type_type) __PYX_ERR(3, 9, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __pyx_t_1 = PyImport_ImportModule("numpy"); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 199, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
-  __pyx_ptype_5numpy_dtype = __Pyx_ImportType(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(1, 199, __pyx_L1_error)
-  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(1, 222, __pyx_L1_error)
-  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(1, 226, __pyx_L1_error)
-  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(1, 238, __pyx_L1_error)
-  __pyx_ptype_5numpy_generic = __Pyx_ImportType(__pyx_t_1, "numpy", "generic", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_generic) __PYX_ERR(1, 770, __pyx_L1_error)
-  __pyx_ptype_5numpy_number = __Pyx_ImportType(__pyx_t_1, "numpy", "number", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_number) __PYX_ERR(1, 772, __pyx_L1_error)
-  __pyx_ptype_5numpy_integer = __Pyx_ImportType(__pyx_t_1, "numpy", "integer", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_integer) __PYX_ERR(1, 774, __pyx_L1_error)
-  __pyx_ptype_5numpy_signedinteger = __Pyx_ImportType(__pyx_t_1, "numpy", "signedinteger", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_signedinteger) __PYX_ERR(1, 776, __pyx_L1_error)
-  __pyx_ptype_5numpy_unsignedinteger = __Pyx_ImportType(__pyx_t_1, "numpy", "unsignedinteger", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_unsignedinteger) __PYX_ERR(1, 778, __pyx_L1_error)
-  __pyx_ptype_5numpy_inexact = __Pyx_ImportType(__pyx_t_1, "numpy", "inexact", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_inexact) __PYX_ERR(1, 780, __pyx_L1_error)
-  __pyx_ptype_5numpy_floating = __Pyx_ImportType(__pyx_t_1, "numpy", "floating", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_floating) __PYX_ERR(1, 782, __pyx_L1_error)
-  __pyx_ptype_5numpy_complexfloating = __Pyx_ImportType(__pyx_t_1, "numpy", "complexfloating", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_complexfloating) __PYX_ERR(1, 784, __pyx_L1_error)
-  __pyx_ptype_5numpy_flexible = __Pyx_ImportType(__pyx_t_1, "numpy", "flexible", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_flexible) __PYX_ERR(1, 786, __pyx_L1_error)
-  __pyx_ptype_5numpy_character = __Pyx_ImportType(__pyx_t_1, "numpy", "character", sizeof(PyObject), __Pyx_ImportType_CheckSize_Warn);
-   if (!__pyx_ptype_5numpy_character) __PYX_ERR(1, 788, __pyx_L1_error)
-  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __Pyx_ImportType_CheckSize_Ignore);
-   if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(1, 826, __pyx_L1_error)
+  __pyx_ptype_5numpy_dtype = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "dtype", sizeof(PyArray_Descr), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyArray_Descr),__Pyx_ImportType_CheckSize_Ignore_0_29_36); if (!__pyx_ptype_5numpy_dtype) __PYX_ERR(1, 199, __pyx_L1_error)
+  __pyx_ptype_5numpy_flatiter = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "flatiter", sizeof(PyArrayIterObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyArrayIterObject),__Pyx_ImportType_CheckSize_Ignore_0_29_36); if (!__pyx_ptype_5numpy_flatiter) __PYX_ERR(1, 222, __pyx_L1_error)
+  __pyx_ptype_5numpy_broadcast = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "broadcast", sizeof(PyArrayMultiIterObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyArrayMultiIterObject),__Pyx_ImportType_CheckSize_Ignore_0_29_36); if (!__pyx_ptype_5numpy_broadcast) __PYX_ERR(1, 226, __pyx_L1_error)
+  __pyx_ptype_5numpy_ndarray = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "ndarray", sizeof(PyArrayObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyArrayObject),__Pyx_ImportType_CheckSize_Ignore_0_29_36); if (!__pyx_ptype_5numpy_ndarray) __PYX_ERR(1, 238, __pyx_L1_error)
+  __pyx_ptype_5numpy_generic = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "generic", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_5numpy_generic) __PYX_ERR(1, 770, __pyx_L1_error)
+  __pyx_ptype_5numpy_number = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "number", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_5numpy_number) __PYX_ERR(1, 772, __pyx_L1_error)
+  __pyx_ptype_5numpy_integer = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "integer", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_5numpy_integer) __PYX_ERR(1, 774, __pyx_L1_error)
+  __pyx_ptype_5numpy_signedinteger = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "signedinteger", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_5numpy_signedinteger) __PYX_ERR(1, 776, __pyx_L1_error)
+  __pyx_ptype_5numpy_unsignedinteger = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "unsignedinteger", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_5numpy_unsignedinteger) __PYX_ERR(1, 778, __pyx_L1_error)
+  __pyx_ptype_5numpy_inexact = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "inexact", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_5numpy_inexact) __PYX_ERR(1, 780, __pyx_L1_error)
+  __pyx_ptype_5numpy_floating = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "floating", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_5numpy_floating) __PYX_ERR(1, 782, __pyx_L1_error)
+  __pyx_ptype_5numpy_complexfloating = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "complexfloating", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_5numpy_complexfloating) __PYX_ERR(1, 784, __pyx_L1_error)
+  __pyx_ptype_5numpy_flexible = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "flexible", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_5numpy_flexible) __PYX_ERR(1, 786, __pyx_L1_error)
+  __pyx_ptype_5numpy_character = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "character", sizeof(PyObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyObject),__Pyx_ImportType_CheckSize_Warn_0_29_36); if (!__pyx_ptype_5numpy_character) __PYX_ERR(1, 788, __pyx_L1_error)
+  __pyx_ptype_5numpy_ufunc = __Pyx_ImportType_0_29_36(__pyx_t_1, "numpy", "ufunc", sizeof(PyUFuncObject), __PYX_GET_STRUCT_ALIGNMENT_0_29_36(PyUFuncObject),__Pyx_ImportType_CheckSize_Ignore_0_29_36); if (!__pyx_ptype_5numpy_ufunc) __PYX_ERR(1, 826, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   __Pyx_RefNannyFinishContext();
   return 0;
   __pyx_L1_error:;
   __Pyx_XDECREF(__pyx_t_1);
   __Pyx_RefNannyFinishContext();
   return -1;
@@ -19657,15 +19980,15 @@
   /* "ark/utils/_bootstrapping.pyx":248
  *     return close_num_rand
  * 
  * def compute_close_num_rand(DTYPE_t[:, :] dist_mat_bin, DTYPE_t[:] cols_in_row_flat,             # <<<<<<<<<<<<<<
  *                            MAXINDEX_t[:] row_indicies, DTYPE_t[:] marker_nums,
  *                            dict pos_labels, int bootstrap_num):
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_3ark_5utils_14_bootstrapping_1compute_close_num_rand, NULL, __pyx_n_s_ark_utils__bootstrapping); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 248, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_3ark_5utils_14_bootstrapping_1compute_close_num_rand, 0, __pyx_n_s_compute_close_num_rand, NULL, __pyx_n_s_ark_utils__bootstrapping, __pyx_d, ((PyObject *)__pyx_codeobj__23)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 248, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_compute_close_num_rand, __pyx_t_1) < 0) __PYX_ERR(0, 248, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "ark/utils/_bootstrapping.pyx":1
  * from cpython.mem cimport PyMem_Free, PyMem_Malloc             # <<<<<<<<<<<<<<
  * from cython cimport boundscheck, cdivision, wraparound
@@ -19685,78 +20008,122 @@
  */
   __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_array_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 210, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem((PyObject *)__pyx_array_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 210, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_array_type);
 
+  /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef___pyx_array_1__reduce_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_array___reduce_cython, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__25)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reduce_cython, __pyx_t_1) < 0) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef___pyx_array_3__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_array___setstate_cython, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__27)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 3, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_1) < 0) __PYX_ERR(2, 3, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     cdef tuple state
+ *     cdef object _dict
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef___pyx_MemviewEnum_1__reduce_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Enum___reduce_cython, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__29)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_MemviewEnum_type->tp_dict, __pyx_n_s_reduce_cython, __pyx_t_1) < 0) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_MemviewEnum_type);
+
+  /* "(tree fragment)":16
+ *     else:
+ *         return __pyx_unpickle_Enum, (type(self), 0xb068931, state)
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     __pyx_unpickle_Enum__set_state(self, __pyx_state)
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef___pyx_MemviewEnum_3__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_Enum___setstate_cython, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__31)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 16, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_MemviewEnum_type->tp_dict, __pyx_n_s_setstate_cython, __pyx_t_1) < 0) __PYX_ERR(2, 16, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_MemviewEnum_type);
+
   /* "View.MemoryView":287
  *         return self.name
  * 
  * cdef generic = Enum("<strided and direct or indirect>")             # <<<<<<<<<<<<<<
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__24, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 287, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__32, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 287, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(generic);
   __Pyx_DECREF_SET(generic, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":288
  * 
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default             # <<<<<<<<<<<<<<
  * cdef indirect = Enum("<strided and indirect>")
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 288, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__33, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 288, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(strided);
   __Pyx_DECREF_SET(strided, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":289
  * cdef generic = Enum("<strided and direct or indirect>")
  * cdef strided = Enum("<strided and direct>") # default
  * cdef indirect = Enum("<strided and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 289, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__34, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 289, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect);
   __Pyx_DECREF_SET(indirect, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":292
  * 
  * 
  * cdef contiguous = Enum("<contiguous and direct>")             # <<<<<<<<<<<<<<
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 292, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__35, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 292, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(contiguous);
   __Pyx_DECREF_SET(contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":293
  * 
  * cdef contiguous = Enum("<contiguous and direct>")
  * cdef indirect_contiguous = Enum("<contiguous and indirect>")             # <<<<<<<<<<<<<<
  * 
  * 
  */
-  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 293, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_MemviewEnum_type), __pyx_tuple__36, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 293, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   __Pyx_XGOTREF(indirect_contiguous);
   __Pyx_DECREF_SET(indirect_contiguous, __pyx_t_1);
   __Pyx_GIVEREF(__pyx_t_1);
   __pyx_t_1 = 0;
 
   /* "View.MemoryView":317
@@ -19794,33 +20161,127 @@
  */
   __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 551, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 551, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_memoryview_type);
 
+  /* "View.MemoryView":621
+ * 
+ * 
+ *     def is_c_contig(self):             # <<<<<<<<<<<<<<
+ *         cdef __Pyx_memviewslice *mslice
+ *         cdef __Pyx_memviewslice tmp
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_15View_dot_MemoryView_10memoryview_17is_c_contig, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_memoryview_is_c_contig, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__38)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 621, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_is_c_contig, __pyx_t_1) < 0) __PYX_ERR(2, 621, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_memoryview_type);
+
+  /* "View.MemoryView":627
+ *         return slice_is_contig(mslice[0], 'C', self.view.ndim)
+ * 
+ *     def is_f_contig(self):             # <<<<<<<<<<<<<<
+ *         cdef __Pyx_memviewslice *mslice
+ *         cdef __Pyx_memviewslice tmp
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_15View_dot_MemoryView_10memoryview_19is_f_contig, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_memoryview_is_f_contig, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__40)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 627, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_is_f_contig, __pyx_t_1) < 0) __PYX_ERR(2, 627, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_memoryview_type);
+
+  /* "View.MemoryView":633
+ *         return slice_is_contig(mslice[0], 'F', self.view.ndim)
+ * 
+ *     def copy(self):             # <<<<<<<<<<<<<<
+ *         cdef __Pyx_memviewslice mslice
+ *         cdef int flags = self.flags & ~PyBUF_F_CONTIGUOUS
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_15View_dot_MemoryView_10memoryview_21copy, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_memoryview_copy, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__42)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 633, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_copy, __pyx_t_1) < 0) __PYX_ERR(2, 633, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_memoryview_type);
+
+  /* "View.MemoryView":645
+ *         return memoryview_copy_from_slice(self, &mslice)
+ * 
+ *     def copy_fortran(self):             # <<<<<<<<<<<<<<
+ *         cdef __Pyx_memviewslice src, dst
+ *         cdef int flags = self.flags & ~PyBUF_C_CONTIGUOUS
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_15View_dot_MemoryView_10memoryview_23copy_fortran, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_memoryview_copy_fortran, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__44)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 645, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem((PyObject *)__pyx_memoryview_type->tp_dict, __pyx_n_s_copy_fortran, __pyx_t_1) < 0) __PYX_ERR(2, 645, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+  PyType_Modified(__pyx_memoryview_type);
+
+  /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef___pyx_memoryview_1__reduce_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_memoryview___reduce_cython, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__46)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reduce_cython, __pyx_t_1) < 0) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef___pyx_memoryview_3__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_memoryview___setstate_cython, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__48)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 3, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_1) < 0) __PYX_ERR(2, 3, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
   /* "View.MemoryView":997
  *         return self.from_object
  * 
  *     __pyx_getbuffer = capsule(<void *> &__pyx_memoryview_getbuffer, "getbuffer(obj, view, flags)")             # <<<<<<<<<<<<<<
  * 
  * 
  */
   __pyx_t_1 = __pyx_capsule_create(((void *)(&__pyx_memoryview_getbuffer)), ((char *)"getbuffer(obj, view, flags)")); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 997, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem((PyObject *)__pyx_memoryviewslice_type->tp_dict, __pyx_n_s_pyx_getbuffer, __pyx_t_1) < 0) __PYX_ERR(2, 997, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
   PyType_Modified(__pyx_memoryviewslice_type);
 
   /* "(tree fragment)":1
+ * def __reduce_cython__(self):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef___pyx_memoryviewslice_1__reduce_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_memoryviewslice___reduce_cython, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__50)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_reduce_cython, __pyx_t_1) < 0) __PYX_ERR(2, 1, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "(tree fragment)":3
+ * def __reduce_cython__(self):
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ * def __setstate_cython__(self, __pyx_state):             # <<<<<<<<<<<<<<
+ *     raise TypeError("no default __reduce__ due to non-trivial __cinit__")
+ */
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef___pyx_memoryviewslice_3__setstate_cython__, __Pyx_CYFUNCTION_CCLASS, __pyx_n_s_memoryviewslice___setstate_cyth, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__52)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 3, __pyx_L1_error)
+  __Pyx_GOTREF(__pyx_t_1);
+  if (PyDict_SetItem(__pyx_d, __pyx_n_s_setstate_cython, __pyx_t_1) < 0) __PYX_ERR(2, 3, __pyx_L1_error)
+  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
+
+  /* "(tree fragment)":1
  * def __pyx_unpickle_Enum(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<
  *     cdef object __pyx_PickleError
  *     cdef object __pyx_result
  */
-  __pyx_t_1 = PyCFunction_NewEx(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1, __pyx_L1_error)
+  __pyx_t_1 = __Pyx_CyFunction_New(&__pyx_mdef_15View_dot_MemoryView_1__pyx_unpickle_Enum, 0, __pyx_n_s_pyx_unpickle_Enum, NULL, __pyx_n_s_View_MemoryView, __pyx_d, ((PyObject *)__pyx_codeobj__54)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 1, __pyx_L1_error)
   __Pyx_GOTREF(__pyx_t_1);
   if (PyDict_SetItem(__pyx_d, __pyx_n_s_pyx_unpickle_Enum, __pyx_t_1) < 0) __PYX_ERR(2, 1, __pyx_L1_error)
   __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
 
   /* "(tree fragment)":11
  *         __pyx_unpickle_Enum__set_state(<Enum> __pyx_result, __pyx_state)
  *     return __pyx_result
@@ -20651,28 +21112,28 @@
                             "BaseException");
             goto bad;
         }
         PyException_SetCause(value, fixed_cause);
     }
     PyErr_SetObject(type, value);
     if (tb) {
-#if CYTHON_COMPILING_IN_PYPY
-        PyObject *tmp_type, *tmp_value, *tmp_tb;
-        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
-        Py_INCREF(tb);
-        PyErr_Restore(tmp_type, tmp_value, tb);
-        Py_XDECREF(tmp_tb);
-#else
+#if CYTHON_FAST_THREAD_STATE
         PyThreadState *tstate = __Pyx_PyThreadState_Current;
         PyObject* tmp_tb = tstate->curexc_traceback;
         if (tb != tmp_tb) {
             Py_INCREF(tb);
             tstate->curexc_traceback = tb;
             Py_XDECREF(tmp_tb);
         }
+#else
+        PyObject *tmp_type, *tmp_value, *tmp_tb;
+        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
+        Py_INCREF(tb);
+        PyErr_Restore(tmp_type, tmp_value, tb);
+        Py_XDECREF(tmp_tb);
 #endif
     }
 bad:
     Py_XDECREF(owned_instance);
     return;
 }
 #endif
@@ -21833,74 +22294,763 @@
     Py_XDECREF(reduce_cython);
     Py_XDECREF(setstate);
     Py_XDECREF(setstate_cython);
     return ret;
 }
 
 /* TypeImport */
-#ifndef __PYX_HAVE_RT_ImportType
-#define __PYX_HAVE_RT_ImportType
-static PyTypeObject *__Pyx_ImportType(PyObject *module, const char *module_name, const char *class_name,
-    size_t size, enum __Pyx_ImportType_CheckSize check_size)
+#ifndef __PYX_HAVE_RT_ImportType_0_29_36
+#define __PYX_HAVE_RT_ImportType_0_29_36
+static PyTypeObject *__Pyx_ImportType_0_29_36(PyObject *module, const char *module_name, const char *class_name,
+    size_t size, size_t alignment, enum __Pyx_ImportType_CheckSize_0_29_36 check_size)
 {
     PyObject *result = 0;
     char warning[200];
     Py_ssize_t basicsize;
+    Py_ssize_t itemsize;
 #ifdef Py_LIMITED_API
     PyObject *py_basicsize;
+    PyObject *py_itemsize;
 #endif
     result = PyObject_GetAttrString(module, class_name);
     if (!result)
         goto bad;
     if (!PyType_Check(result)) {
         PyErr_Format(PyExc_TypeError,
             "%.200s.%.200s is not a type object",
             module_name, class_name);
         goto bad;
     }
 #ifndef Py_LIMITED_API
     basicsize = ((PyTypeObject *)result)->tp_basicsize;
+    itemsize = ((PyTypeObject *)result)->tp_itemsize;
 #else
     py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
     if (!py_basicsize)
         goto bad;
     basicsize = PyLong_AsSsize_t(py_basicsize);
     Py_DECREF(py_basicsize);
     py_basicsize = 0;
     if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
         goto bad;
+    py_itemsize = PyObject_GetAttrString(result, "__itemsize__");
+    if (!py_itemsize)
+        goto bad;
+    itemsize = PyLong_AsSsize_t(py_itemsize);
+    Py_DECREF(py_itemsize);
+    py_itemsize = 0;
+    if (itemsize == (Py_ssize_t)-1 && PyErr_Occurred())
+        goto bad;
 #endif
-    if ((size_t)basicsize < size) {
+    if (itemsize) {
+        if (size % alignment) {
+            alignment = size % alignment;
+        }
+        if (itemsize < (Py_ssize_t)alignment)
+            itemsize = (Py_ssize_t)alignment;
+    }
+    if ((size_t)(basicsize + itemsize) < size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    if (check_size == __Pyx_ImportType_CheckSize_Error && (size_t)basicsize != size) {
+    if (check_size == __Pyx_ImportType_CheckSize_Error_0_29_36 && (size_t)basicsize != size) {
         PyErr_Format(PyExc_ValueError,
             "%.200s.%.200s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         goto bad;
     }
-    else if (check_size == __Pyx_ImportType_CheckSize_Warn && (size_t)basicsize > size) {
+    else if (check_size == __Pyx_ImportType_CheckSize_Warn_0_29_36 && (size_t)basicsize > size) {
         PyOS_snprintf(warning, sizeof(warning),
             "%s.%s size changed, may indicate binary incompatibility. "
             "Expected %zd from C header, got %zd from PyObject",
             module_name, class_name, size, basicsize);
         if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
     }
     return (PyTypeObject *)result;
 bad:
     Py_XDECREF(result);
     return NULL;
 }
 #endif
 
+/* FetchCommonType */
+static PyTypeObject* __Pyx_FetchCommonType(PyTypeObject* type) {
+    PyObject* fake_module;
+    PyTypeObject* cached_type = NULL;
+    fake_module = PyImport_AddModule((char*) "_cython_" CYTHON_ABI);
+    if (!fake_module) return NULL;
+    Py_INCREF(fake_module);
+    cached_type = (PyTypeObject*) PyObject_GetAttrString(fake_module, type->tp_name);
+    if (cached_type) {
+        if (!PyType_Check((PyObject*)cached_type)) {
+            PyErr_Format(PyExc_TypeError,
+                "Shared Cython type %.200s is not a type object",
+                type->tp_name);
+            goto bad;
+        }
+        if (cached_type->tp_basicsize != type->tp_basicsize) {
+            PyErr_Format(PyExc_TypeError,
+                "Shared Cython type %.200s has the wrong size, try recompiling",
+                type->tp_name);
+            goto bad;
+        }
+    } else {
+        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
+        PyErr_Clear();
+        if (PyType_Ready(type) < 0) goto bad;
+        if (PyObject_SetAttrString(fake_module, type->tp_name, (PyObject*) type) < 0)
+            goto bad;
+        Py_INCREF(type);
+        cached_type = type;
+    }
+done:
+    Py_DECREF(fake_module);
+    return cached_type;
+bad:
+    Py_XDECREF(cached_type);
+    cached_type = NULL;
+    goto done;
+}
+
+/* CythonFunctionShared */
+#include <structmember.h>
+static PyObject *
+__Pyx_CyFunction_get_doc(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *closure)
+{
+    if (unlikely(op->func_doc == NULL)) {
+        if (op->func.m_ml->ml_doc) {
+#if PY_MAJOR_VERSION >= 3
+            op->func_doc = PyUnicode_FromString(op->func.m_ml->ml_doc);
+#else
+            op->func_doc = PyString_FromString(op->func.m_ml->ml_doc);
+#endif
+            if (unlikely(op->func_doc == NULL))
+                return NULL;
+        } else {
+            Py_INCREF(Py_None);
+            return Py_None;
+        }
+    }
+    Py_INCREF(op->func_doc);
+    return op->func_doc;
+}
+static int
+__Pyx_CyFunction_set_doc(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
+{
+    PyObject *tmp = op->func_doc;
+    if (value == NULL) {
+        value = Py_None;
+    }
+    Py_INCREF(value);
+    op->func_doc = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_name(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    if (unlikely(op->func_name == NULL)) {
+#if PY_MAJOR_VERSION >= 3
+        op->func_name = PyUnicode_InternFromString(op->func.m_ml->ml_name);
+#else
+        op->func_name = PyString_InternFromString(op->func.m_ml->ml_name);
+#endif
+        if (unlikely(op->func_name == NULL))
+            return NULL;
+    }
+    Py_INCREF(op->func_name);
+    return op->func_name;
+}
+static int
+__Pyx_CyFunction_set_name(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
+{
+    PyObject *tmp;
+#if PY_MAJOR_VERSION >= 3
+    if (unlikely(value == NULL || !PyUnicode_Check(value)))
+#else
+    if (unlikely(value == NULL || !PyString_Check(value)))
+#endif
+    {
+        PyErr_SetString(PyExc_TypeError,
+                        "__name__ must be set to a string object");
+        return -1;
+    }
+    tmp = op->func_name;
+    Py_INCREF(value);
+    op->func_name = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_qualname(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    Py_INCREF(op->func_qualname);
+    return op->func_qualname;
+}
+static int
+__Pyx_CyFunction_set_qualname(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
+{
+    PyObject *tmp;
+#if PY_MAJOR_VERSION >= 3
+    if (unlikely(value == NULL || !PyUnicode_Check(value)))
+#else
+    if (unlikely(value == NULL || !PyString_Check(value)))
+#endif
+    {
+        PyErr_SetString(PyExc_TypeError,
+                        "__qualname__ must be set to a string object");
+        return -1;
+    }
+    tmp = op->func_qualname;
+    Py_INCREF(value);
+    op->func_qualname = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_self(__pyx_CyFunctionObject *m, CYTHON_UNUSED void *closure)
+{
+    PyObject *self;
+    self = m->func_closure;
+    if (self == NULL)
+        self = Py_None;
+    Py_INCREF(self);
+    return self;
+}
+static PyObject *
+__Pyx_CyFunction_get_dict(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    if (unlikely(op->func_dict == NULL)) {
+        op->func_dict = PyDict_New();
+        if (unlikely(op->func_dict == NULL))
+            return NULL;
+    }
+    Py_INCREF(op->func_dict);
+    return op->func_dict;
+}
+static int
+__Pyx_CyFunction_set_dict(__pyx_CyFunctionObject *op, PyObject *value, CYTHON_UNUSED void *context)
+{
+    PyObject *tmp;
+    if (unlikely(value == NULL)) {
+        PyErr_SetString(PyExc_TypeError,
+               "function's dictionary may not be deleted");
+        return -1;
+    }
+    if (unlikely(!PyDict_Check(value))) {
+        PyErr_SetString(PyExc_TypeError,
+               "setting function's dictionary to a non-dict");
+        return -1;
+    }
+    tmp = op->func_dict;
+    Py_INCREF(value);
+    op->func_dict = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_globals(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    Py_INCREF(op->func_globals);
+    return op->func_globals;
+}
+static PyObject *
+__Pyx_CyFunction_get_closure(CYTHON_UNUSED __pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+static PyObject *
+__Pyx_CyFunction_get_code(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context)
+{
+    PyObject* result = (op->func_code) ? op->func_code : Py_None;
+    Py_INCREF(result);
+    return result;
+}
+static int
+__Pyx_CyFunction_init_defaults(__pyx_CyFunctionObject *op) {
+    int result = 0;
+    PyObject *res = op->defaults_getter((PyObject *) op);
+    if (unlikely(!res))
+        return -1;
+    #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+    op->defaults_tuple = PyTuple_GET_ITEM(res, 0);
+    Py_INCREF(op->defaults_tuple);
+    op->defaults_kwdict = PyTuple_GET_ITEM(res, 1);
+    Py_INCREF(op->defaults_kwdict);
+    #else
+    op->defaults_tuple = PySequence_ITEM(res, 0);
+    if (unlikely(!op->defaults_tuple)) result = -1;
+    else {
+        op->defaults_kwdict = PySequence_ITEM(res, 1);
+        if (unlikely(!op->defaults_kwdict)) result = -1;
+    }
+    #endif
+    Py_DECREF(res);
+    return result;
+}
+static int
+__Pyx_CyFunction_set_defaults(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
+    PyObject* tmp;
+    if (!value) {
+        value = Py_None;
+    } else if (value != Py_None && !PyTuple_Check(value)) {
+        PyErr_SetString(PyExc_TypeError,
+                        "__defaults__ must be set to a tuple object");
+        return -1;
+    }
+    Py_INCREF(value);
+    tmp = op->defaults_tuple;
+    op->defaults_tuple = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_defaults(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
+    PyObject* result = op->defaults_tuple;
+    if (unlikely(!result)) {
+        if (op->defaults_getter) {
+            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
+            result = op->defaults_tuple;
+        } else {
+            result = Py_None;
+        }
+    }
+    Py_INCREF(result);
+    return result;
+}
+static int
+__Pyx_CyFunction_set_kwdefaults(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
+    PyObject* tmp;
+    if (!value) {
+        value = Py_None;
+    } else if (value != Py_None && !PyDict_Check(value)) {
+        PyErr_SetString(PyExc_TypeError,
+                        "__kwdefaults__ must be set to a dict object");
+        return -1;
+    }
+    Py_INCREF(value);
+    tmp = op->defaults_kwdict;
+    op->defaults_kwdict = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_kwdefaults(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
+    PyObject* result = op->defaults_kwdict;
+    if (unlikely(!result)) {
+        if (op->defaults_getter) {
+            if (__Pyx_CyFunction_init_defaults(op) < 0) return NULL;
+            result = op->defaults_kwdict;
+        } else {
+            result = Py_None;
+        }
+    }
+    Py_INCREF(result);
+    return result;
+}
+static int
+__Pyx_CyFunction_set_annotations(__pyx_CyFunctionObject *op, PyObject* value, CYTHON_UNUSED void *context) {
+    PyObject* tmp;
+    if (!value || value == Py_None) {
+        value = NULL;
+    } else if (!PyDict_Check(value)) {
+        PyErr_SetString(PyExc_TypeError,
+                        "__annotations__ must be set to a dict object");
+        return -1;
+    }
+    Py_XINCREF(value);
+    tmp = op->func_annotations;
+    op->func_annotations = value;
+    Py_XDECREF(tmp);
+    return 0;
+}
+static PyObject *
+__Pyx_CyFunction_get_annotations(__pyx_CyFunctionObject *op, CYTHON_UNUSED void *context) {
+    PyObject* result = op->func_annotations;
+    if (unlikely(!result)) {
+        result = PyDict_New();
+        if (unlikely(!result)) return NULL;
+        op->func_annotations = result;
+    }
+    Py_INCREF(result);
+    return result;
+}
+static PyGetSetDef __pyx_CyFunction_getsets[] = {
+    {(char *) "func_doc", (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
+    {(char *) "__doc__",  (getter)__Pyx_CyFunction_get_doc, (setter)__Pyx_CyFunction_set_doc, 0, 0},
+    {(char *) "func_name", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
+    {(char *) "__name__", (getter)__Pyx_CyFunction_get_name, (setter)__Pyx_CyFunction_set_name, 0, 0},
+    {(char *) "__qualname__", (getter)__Pyx_CyFunction_get_qualname, (setter)__Pyx_CyFunction_set_qualname, 0, 0},
+    {(char *) "__self__", (getter)__Pyx_CyFunction_get_self, 0, 0, 0},
+    {(char *) "func_dict", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
+    {(char *) "__dict__", (getter)__Pyx_CyFunction_get_dict, (setter)__Pyx_CyFunction_set_dict, 0, 0},
+    {(char *) "func_globals", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
+    {(char *) "__globals__", (getter)__Pyx_CyFunction_get_globals, 0, 0, 0},
+    {(char *) "func_closure", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
+    {(char *) "__closure__", (getter)__Pyx_CyFunction_get_closure, 0, 0, 0},
+    {(char *) "func_code", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
+    {(char *) "__code__", (getter)__Pyx_CyFunction_get_code, 0, 0, 0},
+    {(char *) "func_defaults", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
+    {(char *) "__defaults__", (getter)__Pyx_CyFunction_get_defaults, (setter)__Pyx_CyFunction_set_defaults, 0, 0},
+    {(char *) "__kwdefaults__", (getter)__Pyx_CyFunction_get_kwdefaults, (setter)__Pyx_CyFunction_set_kwdefaults, 0, 0},
+    {(char *) "__annotations__", (getter)__Pyx_CyFunction_get_annotations, (setter)__Pyx_CyFunction_set_annotations, 0, 0},
+    {0, 0, 0, 0, 0}
+};
+static PyMemberDef __pyx_CyFunction_members[] = {
+    {(char *) "__module__", T_OBJECT, offsetof(PyCFunctionObject, m_module), PY_WRITE_RESTRICTED, 0},
+    {0, 0, 0,  0, 0}
+};
+static PyObject *
+__Pyx_CyFunction_reduce(__pyx_CyFunctionObject *m, CYTHON_UNUSED PyObject *args)
+{
+#if PY_MAJOR_VERSION >= 3
+    Py_INCREF(m->func_qualname);
+    return m->func_qualname;
+#else
+    return PyString_FromString(m->func.m_ml->ml_name);
+#endif
+}
+static PyMethodDef __pyx_CyFunction_methods[] = {
+    {"__reduce__", (PyCFunction)__Pyx_CyFunction_reduce, METH_VARARGS, 0},
+    {0, 0, 0, 0}
+};
+#if PY_VERSION_HEX < 0x030500A0
+#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func_weakreflist)
+#else
+#define __Pyx_CyFunction_weakreflist(cyfunc) ((cyfunc)->func.m_weakreflist)
+#endif
+static PyObject *__Pyx_CyFunction_Init(__pyx_CyFunctionObject *op, PyMethodDef *ml, int flags, PyObject* qualname,
+                                       PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
+    if (unlikely(op == NULL))
+        return NULL;
+    op->flags = flags;
+    __Pyx_CyFunction_weakreflist(op) = NULL;
+    op->func.m_ml = ml;
+    op->func.m_self = (PyObject *) op;
+    Py_XINCREF(closure);
+    op->func_closure = closure;
+    Py_XINCREF(module);
+    op->func.m_module = module;
+    op->func_dict = NULL;
+    op->func_name = NULL;
+    Py_INCREF(qualname);
+    op->func_qualname = qualname;
+    op->func_doc = NULL;
+    op->func_classobj = NULL;
+    op->func_globals = globals;
+    Py_INCREF(op->func_globals);
+    Py_XINCREF(code);
+    op->func_code = code;
+    op->defaults_pyobjects = 0;
+    op->defaults_size = 0;
+    op->defaults = NULL;
+    op->defaults_tuple = NULL;
+    op->defaults_kwdict = NULL;
+    op->defaults_getter = NULL;
+    op->func_annotations = NULL;
+    return (PyObject *) op;
+}
+static int
+__Pyx_CyFunction_clear(__pyx_CyFunctionObject *m)
+{
+    Py_CLEAR(m->func_closure);
+    Py_CLEAR(m->func.m_module);
+    Py_CLEAR(m->func_dict);
+    Py_CLEAR(m->func_name);
+    Py_CLEAR(m->func_qualname);
+    Py_CLEAR(m->func_doc);
+    Py_CLEAR(m->func_globals);
+    Py_CLEAR(m->func_code);
+    Py_CLEAR(m->func_classobj);
+    Py_CLEAR(m->defaults_tuple);
+    Py_CLEAR(m->defaults_kwdict);
+    Py_CLEAR(m->func_annotations);
+    if (m->defaults) {
+        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
+        int i;
+        for (i = 0; i < m->defaults_pyobjects; i++)
+            Py_XDECREF(pydefaults[i]);
+        PyObject_Free(m->defaults);
+        m->defaults = NULL;
+    }
+    return 0;
+}
+static void __Pyx__CyFunction_dealloc(__pyx_CyFunctionObject *m)
+{
+    if (__Pyx_CyFunction_weakreflist(m) != NULL)
+        PyObject_ClearWeakRefs((PyObject *) m);
+    __Pyx_CyFunction_clear(m);
+    PyObject_GC_Del(m);
+}
+static void __Pyx_CyFunction_dealloc(__pyx_CyFunctionObject *m)
+{
+    PyObject_GC_UnTrack(m);
+    __Pyx__CyFunction_dealloc(m);
+}
+static int __Pyx_CyFunction_traverse(__pyx_CyFunctionObject *m, visitproc visit, void *arg)
+{
+    Py_VISIT(m->func_closure);
+    Py_VISIT(m->func.m_module);
+    Py_VISIT(m->func_dict);
+    Py_VISIT(m->func_name);
+    Py_VISIT(m->func_qualname);
+    Py_VISIT(m->func_doc);
+    Py_VISIT(m->func_globals);
+    Py_VISIT(m->func_code);
+    Py_VISIT(m->func_classobj);
+    Py_VISIT(m->defaults_tuple);
+    Py_VISIT(m->defaults_kwdict);
+    if (m->defaults) {
+        PyObject **pydefaults = __Pyx_CyFunction_Defaults(PyObject *, m);
+        int i;
+        for (i = 0; i < m->defaults_pyobjects; i++)
+            Py_VISIT(pydefaults[i]);
+    }
+    return 0;
+}
+static PyObject *__Pyx_CyFunction_descr_get(PyObject *func, PyObject *obj, PyObject *type)
+{
+#if PY_MAJOR_VERSION < 3
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    if (m->flags & __Pyx_CYFUNCTION_STATICMETHOD) {
+        Py_INCREF(func);
+        return func;
+    }
+    if (m->flags & __Pyx_CYFUNCTION_CLASSMETHOD) {
+        if (type == NULL)
+            type = (PyObject *)(Py_TYPE(obj));
+        return __Pyx_PyMethod_New(func, type, (PyObject *)(Py_TYPE(type)));
+    }
+    if (obj == Py_None)
+        obj = NULL;
+#endif
+    return __Pyx_PyMethod_New(func, obj, type);
+}
+static PyObject*
+__Pyx_CyFunction_repr(__pyx_CyFunctionObject *op)
+{
+#if PY_MAJOR_VERSION >= 3
+    return PyUnicode_FromFormat("<cyfunction %U at %p>",
+                                op->func_qualname, (void *)op);
+#else
+    return PyString_FromFormat("<cyfunction %s at %p>",
+                               PyString_AsString(op->func_qualname), (void *)op);
+#endif
+}
+static PyObject * __Pyx_CyFunction_CallMethod(PyObject *func, PyObject *self, PyObject *arg, PyObject *kw) {
+    PyCFunctionObject* f = (PyCFunctionObject*)func;
+    PyCFunction meth = f->m_ml->ml_meth;
+    Py_ssize_t size;
+    switch (f->m_ml->ml_flags & (METH_VARARGS | METH_KEYWORDS | METH_NOARGS | METH_O)) {
+    case METH_VARARGS:
+        if (likely(kw == NULL || PyDict_Size(kw) == 0))
+            return (*meth)(self, arg);
+        break;
+    case METH_VARARGS | METH_KEYWORDS:
+        return (*(PyCFunctionWithKeywords)(void*)meth)(self, arg, kw);
+    case METH_NOARGS:
+        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
+            size = PyTuple_GET_SIZE(arg);
+            if (likely(size == 0))
+                return (*meth)(self, NULL);
+            PyErr_Format(PyExc_TypeError,
+                "%.200s() takes no arguments (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                f->m_ml->ml_name, size);
+            return NULL;
+        }
+        break;
+    case METH_O:
+        if (likely(kw == NULL || PyDict_Size(kw) == 0)) {
+            size = PyTuple_GET_SIZE(arg);
+            if (likely(size == 1)) {
+                PyObject *result, *arg0;
+                #if CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS
+                arg0 = PyTuple_GET_ITEM(arg, 0);
+                #else
+                arg0 = PySequence_ITEM(arg, 0); if (unlikely(!arg0)) return NULL;
+                #endif
+                result = (*meth)(self, arg0);
+                #if !(CYTHON_ASSUME_SAFE_MACROS && !CYTHON_AVOID_BORROWED_REFS)
+                Py_DECREF(arg0);
+                #endif
+                return result;
+            }
+            PyErr_Format(PyExc_TypeError,
+                "%.200s() takes exactly one argument (%" CYTHON_FORMAT_SSIZE_T "d given)",
+                f->m_ml->ml_name, size);
+            return NULL;
+        }
+        break;
+    default:
+        PyErr_SetString(PyExc_SystemError, "Bad call flags in "
+                        "__Pyx_CyFunction_Call. METH_OLDARGS is no "
+                        "longer supported!");
+        return NULL;
+    }
+    PyErr_Format(PyExc_TypeError, "%.200s() takes no keyword arguments",
+                 f->m_ml->ml_name);
+    return NULL;
+}
+static CYTHON_INLINE PyObject *__Pyx_CyFunction_Call(PyObject *func, PyObject *arg, PyObject *kw) {
+    return __Pyx_CyFunction_CallMethod(func, ((PyCFunctionObject*)func)->m_self, arg, kw);
+}
+static PyObject *__Pyx_CyFunction_CallAsMethod(PyObject *func, PyObject *args, PyObject *kw) {
+    PyObject *result;
+    __pyx_CyFunctionObject *cyfunc = (__pyx_CyFunctionObject *) func;
+    if ((cyfunc->flags & __Pyx_CYFUNCTION_CCLASS) && !(cyfunc->flags & __Pyx_CYFUNCTION_STATICMETHOD)) {
+        Py_ssize_t argc;
+        PyObject *new_args;
+        PyObject *self;
+        argc = PyTuple_GET_SIZE(args);
+        new_args = PyTuple_GetSlice(args, 1, argc);
+        if (unlikely(!new_args))
+            return NULL;
+        self = PyTuple_GetItem(args, 0);
+        if (unlikely(!self)) {
+            Py_DECREF(new_args);
+#if PY_MAJOR_VERSION > 2
+            PyErr_Format(PyExc_TypeError,
+                         "unbound method %.200S() needs an argument",
+                         cyfunc->func_qualname);
+#else
+            PyErr_SetString(PyExc_TypeError,
+                            "unbound method needs an argument");
+#endif
+            return NULL;
+        }
+        result = __Pyx_CyFunction_CallMethod(func, self, new_args, kw);
+        Py_DECREF(new_args);
+    } else {
+        result = __Pyx_CyFunction_Call(func, args, kw);
+    }
+    return result;
+}
+static PyTypeObject __pyx_CyFunctionType_type = {
+    PyVarObject_HEAD_INIT(0, 0)
+    "cython_function_or_method",
+    sizeof(__pyx_CyFunctionObject),
+    0,
+    (destructor) __Pyx_CyFunction_dealloc,
+    0,
+    0,
+    0,
+#if PY_MAJOR_VERSION < 3
+    0,
+#else
+    0,
+#endif
+    (reprfunc) __Pyx_CyFunction_repr,
+    0,
+    0,
+    0,
+    0,
+    __Pyx_CyFunction_CallAsMethod,
+    0,
+    0,
+    0,
+    0,
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
+    0,
+    (traverseproc) __Pyx_CyFunction_traverse,
+    (inquiry) __Pyx_CyFunction_clear,
+    0,
+#if PY_VERSION_HEX < 0x030500A0
+    offsetof(__pyx_CyFunctionObject, func_weakreflist),
+#else
+    offsetof(PyCFunctionObject, m_weakreflist),
+#endif
+    0,
+    0,
+    __pyx_CyFunction_methods,
+    __pyx_CyFunction_members,
+    __pyx_CyFunction_getsets,
+    0,
+    0,
+    __Pyx_CyFunction_descr_get,
+    0,
+    offsetof(__pyx_CyFunctionObject, func_dict),
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+    0,
+#if PY_VERSION_HEX >= 0x030400a1
+    0,
+#endif
+#if PY_VERSION_HEX >= 0x030800b1 && (!CYTHON_COMPILING_IN_PYPY || PYPY_VERSION_NUM >= 0x07030800)
+    0,
+#endif
+#if PY_VERSION_HEX >= 0x030800b4 && PY_VERSION_HEX < 0x03090000
+    0,
+#endif
+#if PY_VERSION_HEX >= 0x030C0000
+    0,
+#endif
+#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX >= 0x03090000 && PY_VERSION_HEX < 0x030a0000
+    0,
+#endif
+};
+static int __pyx_CyFunction_init(void) {
+    __pyx_CyFunctionType = __Pyx_FetchCommonType(&__pyx_CyFunctionType_type);
+    if (unlikely(__pyx_CyFunctionType == NULL)) {
+        return -1;
+    }
+    return 0;
+}
+static CYTHON_INLINE void *__Pyx_CyFunction_InitDefaults(PyObject *func, size_t size, int pyobjects) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->defaults = PyObject_Malloc(size);
+    if (unlikely(!m->defaults))
+        return PyErr_NoMemory();
+    memset(m->defaults, 0, size);
+    m->defaults_pyobjects = pyobjects;
+    m->defaults_size = size;
+    return m->defaults;
+}
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsTuple(PyObject *func, PyObject *tuple) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->defaults_tuple = tuple;
+    Py_INCREF(tuple);
+}
+static CYTHON_INLINE void __Pyx_CyFunction_SetDefaultsKwDict(PyObject *func, PyObject *dict) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->defaults_kwdict = dict;
+    Py_INCREF(dict);
+}
+static CYTHON_INLINE void __Pyx_CyFunction_SetAnnotationsDict(PyObject *func, PyObject *dict) {
+    __pyx_CyFunctionObject *m = (__pyx_CyFunctionObject *) func;
+    m->func_annotations = dict;
+    Py_INCREF(dict);
+}
+
+/* CythonFunction */
+static PyObject *__Pyx_CyFunction_New(PyMethodDef *ml, int flags, PyObject* qualname,
+                                      PyObject *closure, PyObject *module, PyObject* globals, PyObject* code) {
+    PyObject *op = __Pyx_CyFunction_Init(
+        PyObject_GC_New(__pyx_CyFunctionObject, __pyx_CyFunctionType),
+        ml, flags, qualname, closure, module, globals, code
+    );
+    if (likely(op)) {
+        PyObject_GC_Track(op);
+    }
+    return op;
+}
+
 /* CLineInTraceback */
 #ifndef CYTHON_CLINE_IN_TRACEBACK
 static int __Pyx_CLineForTraceback(CYTHON_UNUSED PyThreadState *tstate, int c_line) {
     PyObject *use_cline;
     PyObject *ptype, *pvalue, *ptraceback;
 #if CYTHON_COMPILING_IN_CPYTHON
     PyObject **cython_runtime_dict;
@@ -23539,15 +24689,15 @@
                         } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                             return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -23811,15 +24961,15 @@
                         } else if (8 * sizeof(npy_uint64) >= 4 * PyLong_SHIFT) {
                             return (npy_uint64) (((((((((npy_uint64)digits[3]) << PyLong_SHIFT) | (npy_uint64)digits[2]) << PyLong_SHIFT) | (npy_uint64)digits[1]) << PyLong_SHIFT) | (npy_uint64)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -24007,15 +25157,15 @@
                         } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                             return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
@@ -24241,15 +25391,15 @@
                         } else if (8 * sizeof(char) >= 4 * PyLong_SHIFT) {
                             return (char) (((((((((char)digits[3]) << PyLong_SHIFT) | (char)digits[2]) << PyLong_SHIFT) | (char)digits[1]) << PyLong_SHIFT) | (char)digits[0]));
                         }
                     }
                     break;
             }
 #endif
-#if CYTHON_COMPILING_IN_CPYTHON
+#if CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX < 0x030C00A7
             if (unlikely(Py_SIZE(x) < 0)) {
                 goto raise_neg_overflow;
             }
 #else
             {
                 int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                 if (unlikely(result < 0))
```

### Comparing `ark-analysis-0.6.3/src/ark/utils/_bootstrapping.pyx` & `ark-analysis-0.6.4/src/ark/utils/_bootstrapping.pyx`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/src/ark/utils/data_utils.py` & `ark-analysis-0.6.4/src/ark/utils/data_utils.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,21 +1,25 @@
+import numba as nb
+import itertools
 import os
 import pathlib
 import re
 from typing import List, Union
 
 import feather
 import natsort as ns
 import numpy as np
 import pandas as pd
 import skimage.io as io
 from alpineer import data_utils, image_utils, io_utils, load_utils, misc_utils
+from alpineer.settings import EXTENSION_TYPES
 from tqdm.notebook import tqdm_notebook as tqdm
-
+import xarray as xr
 from ark import settings
+from pandas.core.groupby import DataFrameGroupBy
 
 
 def save_fov_mask(fov, data_dir, mask_data, sub_dir=None, name_suffix=''):
     """Saves a provided cluster label mask overlay for a FOV.
 
     Args:
         fov (str):
@@ -48,195 +52,304 @@
     # define the file name as the fov name with the name suffix appended
     fov_file = fov + name_suffix + '.tiff'
 
     # save the image to data_dir
     image_utils.save_image(os.path.join(save_dir, fov_file), mask_data)
 
 
-def relabel_segmentation(labeled_image, labels_dict):
-    """Takes a labeled image and translates its labels according to a dictionary.
-
-    Returns the relabeled array (according to the dictionary).
-
-    Args:
-        labeled_image (numpy.ndarray):
-            2D numpy array of labeled cell objects.
-        labels_dict (dict):
-            a mapping between labeled cells and their clusters.
-
-    Returns:
-        numpy.ndarray:
-            The relabeled array.
+class CellClusterMaskData:
+    """
+    A class containing the cell labels, cluster labels, and segmentation labels for the
+    whole cohort. Also contains the mapping from the segmentation label to the cluster
+    label for each FOV.
     """
 
-    img = np.copy(labeled_image)
-    unique_cell_ids = np.unique(labeled_image)
-    unique_cell_ids = unique_cell_ids[np.nonzero(unique_cell_ids)]
-
-    default_label = max(labels_dict.values()) + 1
-
-    # cast to int16 to allow for Photoshop loading
-    relabeled_img = np.vectorize(
-        lambda x: labels_dict.get(x, default_label) if x != 0 else 0
-    )(img).astype('int16')
-
-    return relabeled_img
-
-
-def label_cells_by_cluster(fov, all_data, label_map, fov_col=settings.FOV_ID,
-                           cell_label_column=settings.CELL_LABEL,
-                           cluster_column=settings.KMEANS_CLUSTER):
-    """Translates cell-ID labeled images according to the clustering assignment.
+    fov_column: str
+    label_column: str
+    cluster_column: str
+    unique_fovs: List[str]
+    unassigned_id: int
+    mapping: DataFrameGroupBy
+
+    def __init__(
+        self, data: pd.DataFrame, fov_col: str, label_col: str, cluster_col: str
+    ) -> None:
+        """
+        A class containing the cell data, cell label column, cluster column and the mapping from a
+        cell label to a cluster.
+
+        Args:
+            data (pd.DataFrame):
+                A cell table with the cell label column and the cluster column.
+            fov_col (str):
+                The name of the column in the cell table that contains the FOV ID.
+            label_col (str):
+                The name of the column in the cell table that contains the cell label.
+            cluster_col (str):
+                The name of the column in the cell table that contains the cluster label.
+        """
+        self.fov_column: str = fov_col
+        self.label_column: str = label_col
+        self.cluster_column: str = cluster_col
+
+        # Extract only the necessary columns: fov ID, segmentation label, cluster label
+        mapping_data: pd.DataFrame = data[
+            [self.fov_column, self.label_column, self.cluster_column]
+        ].copy()
+
+        mapping_data = mapping_data.astype(
+            {
+                self.fov_column: str,
+                self.label_column: np.int32,
+                self.cluster_column: np.int32,
+            }
+        )
+
+        self.unique_fovs: List[str] = ns.natsorted(
+            mapping_data[self.fov_column].unique().tolist()
+        )
+
+        self.unassigned_id: np.int32 = np.int32(
+            mapping_data[self.cluster_column].max() + 1
+        )
+
+        # For each FOV map the segmentation label 0 to the cluster label 0
+        cluster0_mapping: pd.DataFrame = pd.DataFrame(
+            data={
+                self.fov_column: self.unique_fovs,
+                self.label_column: np.repeat(0, repeats=len(self.unique_fovs)),
+                self.cluster_column: np.repeat(0, repeats=len(self.unique_fovs)),
+            }
+        ).astype(
+            {
+                self.fov_column: str,
+                self.label_column: np.int32,
+                self.cluster_column: np.int32,
+            }
+        )
+
+        mapping_data = pd.concat(objs=[mapping_data, cluster0_mapping])
+
+        # Sort by FOV first, then by segmentation label
+        # Then Group by FOV
+        self.mapping: DataFrameGroupBy = mapping_data.sort_values(
+            by=[self.fov_column, self.label_column]
+        ).groupby(by=self.fov_column)
+
+    def fov_mapping(self, fov: str) -> pd.DataFrame:
+        """Returns the mapping for a specific FOV.
+        Args:
+            fov (str):
+                The FOV to get the mapping for.
+        Returns:
+            pd.DataFrame:
+                The mapping for the FOV.
+        """
+        misc_utils.verify_in_list(requested_fov=[fov], all_fovs=self.unique_fovs)
+        group = self.mapping.get_group(fov).reset_index(drop=True, inplace=False)
+
+        return self.mapping.get_group(fov).reset_index(drop=True, inplace=False)
+
+
+def label_cells_by_cluster(
+        fov: str,
+        ccmd: CellClusterMaskData,
+        label_map: xr.DataArray,
+) -> np.ndarray:
+    """Translates cell-ID labeled images according to the clustering assignment
+    found in cell_cluster_mask_data.
 
-    Takes a single FOV, and relabels the image according to the assignment
-    of cell IDs to cluster label.
 
     Args:
         fov (str):
             The FOV to relabel
-        all_data (pandas.DataFrame):
-            data including fovs, cell labels, and cell expression matrix for all markers.
+        ccmd (CellClusterMaskData):
+            A dataclass containing the cell data, cell label column, cluster column and the
+            mapping from the segmentation label to the cluster label for a given FOV.
         label_map (xarray.DataArray):
-            label map for a single FOV
-        fov_col (str):
-            column with the fovs names in `all_data`.
-        cell_label_column (str):
-            column with the cell labels in `all_data`.
-        cluster_column (str):
-            column with the cluster labels in `all_data`.
+            label map for a single FOV.
 
     Returns:
         numpy.ndarray:
             The image with new designated label assignments
     """
 
     # verify that fov found in all_data
-    # NOTE: label_map fov validation happens in loading function
-    misc_utils.verify_in_list(fov_name=[fov], all_data_fovs=all_data[fov_col].unique())
+    misc_utils.verify_in_list(
+        fov_name=[fov],
+        all_data_fovs=ccmd.unique_fovs)
 
-    # subset all_data on the FOV
-    df = all_data[all_data[fov_col] == fov]
+    # condense extraneous axes
+    labeled_image: np.ndarray = label_map.squeeze().values.astype(np.int32)
 
-    # generate the labels to use
-    labels_dict = dict(zip(df[cell_label_column], df[cluster_column]))
+    fov_clusters: pd.DataFrame = ccmd.fov_mapping(fov=fov)
 
-    # condense extraneous axes
-    labeled_img_array = label_map.squeeze().values
+    mapping: nb.typed.typeddict = nb.typed.Dict.empty(
+        key_type=nb.types.int32,
+        value_type=nb.types.int32,
+    )
 
-    # relabel the array
-    relabeled_img_array = relabel_segmentation(labeled_img_array, labels_dict)
+    for label, cluster in fov_clusters[[ccmd.label_column, ccmd.cluster_column]].itertuples(
+            index=False):
+        mapping[label] = cluster
+
+    relabeled_image: np.ndarray = relabel_segmentation(
+        mapping=mapping,
+        unassigned_id=ccmd.unassigned_id,
+        labeled_image=labeled_image,)
+
+    return relabeled_image.astype(np.int16)
+
+
+@nb.njit(parallel=True)
+def relabel_segmentation(
+    mapping: nb.typed.typeddict,
+    unassigned_id: np.int32,
+    labeled_image: np.ndarray,
+) -> np.ndarray:
+    """
+    Relabels a labled segmentation image according to the provided cluster labels.
 
-    return relabeled_img_array
+    Args:
+        mapping (nb.typed.typeddict):
+            A Numba typed dictionary mapping segmentation labels to cluster labels.
+        unassigned_id (np.int32):
+            The label given to a pixel with no associated cluster.
+        labeled_image (np.ndarray):
+            The labeled segmentation image.
 
+    Returns:
+        np.ndarray: The relabeled segmentation image.
+    """
+    relabeled_image: np.ndarray = np.empty(shape=labeled_image.shape, dtype=np.int16)
+    for i in nb.prange(labeled_image.shape[0]):
+        for j in nb.prange(labeled_image.shape[1]):
+            relabeled_image[i, j] = mapping.get(labeled_image[i, j], unassigned_id)
+    return relabeled_image
 
-def generate_cell_cluster_mask(fov, base_dir, seg_dir, cell_data,
-                               cell_cluster_col='cell_meta_cluster',
-                               seg_suffix='_whole_cell.tiff'):
+
+def generate_cell_cluster_mask(
+        fov: str,
+        seg_dir: Union[str, pathlib.Path],
+        ccmd: CellClusterMaskData,
+        seg_suffix: str = "_whole_cell.tiff") -> np.ndarray:
     """For a fov, create a mask labeling each cell with their SOM or meta cluster label
 
     Args:
-        fov (list):
+        fov (str):
             The fov to relabel
-        base_dir (str):
-            The path to the data directory
         seg_dir (str):
             The path to the segmentation data
-        cell_data (pandas.DataFrame):
-            The cell data with both cell SOM and meta cluster assignments
-        cell_cluster_col (str):
-            Whether to assign SOM or meta clusters.
-            Needs to be `'cell_som_cluster'` or `'cell_meta_cluster'`
+        ccmd (CellClusterMaskData):
+            A dataclass containing the cell data, cell label column, cluster column and the
+            mapping from the segmentation label to the cluster label for a given FOV.
         seg_suffix (str):
             The suffix that the segmentation images use. Defaults to `'_whole_cell.tiff'`.
 
     Returns:
         numpy.ndarray:
-            The image overlaid with cell cluster labels
+            The image where values represent cell cluster labels.
     """
 
     # path checking
     io_utils.validate_paths([seg_dir])
 
     # verify the cluster_col provided is valid
     misc_utils.verify_in_list(
-        provided_cluster_col=cell_cluster_col,
+        provided_cluster_col=[ccmd.cluster_column],
         valid_cluster_cols=['cell_som_cluster', 'cell_meta_cluster']
     )
 
-    # ensure the cluster col will be displayed as an integer and not a float
-    cell_data[cell_cluster_col] = cell_data[cell_cluster_col].astype(int)
-
     # define the file for whole cell
     whole_cell_files = [fov + seg_suffix]
 
     # load the segmentation labels in for the FOV
     label_map = load_utils.load_imgs_from_dir(
         data_dir=seg_dir, files=whole_cell_files, xr_dim_name='compartments',
         xr_channel_names=['whole_cell'], trim_suffix=seg_suffix.split('.')[0]
     ).loc[fov, ...]
 
     # use label_cells_by_cluster to create cell masks
-    img_data = label_cells_by_cluster(
-        fov, cell_data, label_map, fov_col='fov',
-        cell_label_column='segmentation_label', cluster_column=cell_cluster_col
+    img_data: np.ndarray = label_cells_by_cluster(
+        fov=fov,
+        ccmd=ccmd,
+        label_map=label_map
     )
 
     return img_data
 
 
-def generate_and_save_cell_cluster_masks(fovs: List[str],
-                                         base_dir: Union[pathlib.Path, str],
-                                         save_dir: Union[pathlib.Path, str],
-                                         seg_dir: Union[pathlib.Path, str],
-                                         cell_data: pd.DataFrame,
-                                         cell_cluster_col: str = 'cell_meta_cluster',
-                                         seg_suffix: str = '_whole_cell.tiff',
-                                         sub_dir: str = None,
-                                         name_suffix: str = ''):
+def generate_and_save_cell_cluster_masks(
+    fovs: List[str],
+    save_dir: Union[pathlib.Path, str],
+    seg_dir: Union[pathlib.Path, str],
+    cell_data: pd.DataFrame,
+    fov_col: str = settings.FOV_ID,
+    label_col: str = settings.CELL_LABEL,
+    cell_cluster_col: str = settings.CELL_TYPE,
+    seg_suffix: str = "_whole_cell.tiff",
+    sub_dir: str = None,
+    name_suffix: str = "",
+):
     """Generates cell cluster masks and saves them for downstream analysis.
 
     Args:
         fovs (List[str]):
             A list of fovs to generate and save pixel masks for.
-        base_dir (Union[pathlib.Path, str]):
-            The path to the data directory.
         save_dir (Union[pathlib.Path, str]):
             The directory to save the generated cell cluster masks.
         seg_dir (Union[pathlib.Path, str]):
             The path to the segmentation data.
-        cell_data (pandas.DataFrame):
-            The cell data with both cell SOM and meta cluster assignments
+        cell_data (pd.DataFrame):
+            The cell data with both cell SOM and meta cluster assignments.
+        fov_col (str, optional):
+            The column name containing the FOV IDs . Defaults to `settings.FOV_ID` (`"fov"`).
+        label_col (str, optional):
+            The column name containing the cell label. Defaults to
+            `settings.CELL_LABEL` (`"label"`).
         cell_cluster_col (str, optional):
-            Whether to assign SOM or meta clusters. Needs to be `'cell_som_cluster'` or
-            `'cell_meta_cluster'`. Defaults to `'cell_meta_cluster'`.
+            Whether to assign SOM or meta clusters. Needs to be `"cell_som_cluster"` or
+            `"cell_meta_cluster"`. Defaults to `settings.CELL_TYPE` (`"cell_meta_cluster"`).
         seg_suffix (str, optional):
-            The suffix that the segmentation images use. Defaults to `'_whole_cell.tiff'`.
+            The suffix that the segmentation images use. Defaults to `"_whole_cell.tiff"`.
         sub_dir (str, optional):
             The subdirectory to save the images in. If specified images are saved to
             `"data_dir/sub_dir"`. If `sub_dir = None` the images are saved to `"data_dir"`.
             Defaults to `None`.
         name_suffix (str, optional):
-            Specify what to append at the end of every cell mask. Defaults to `''`.
+            Specify what to append at the end of every cell mask. Defaults to `""`.
     """
 
+    ccmd = CellClusterMaskData(
+        data=cell_data,
+        fov_col=fov_col,
+        label_col=label_col,
+        cluster_col=cell_cluster_col,
+    )
+
     # create the pixel cluster masks across each fov
-    with tqdm(total=len(fovs), desc="Cell Cluster Mask Generation") as cell_mask_progress:
+    with tqdm(
+        total=len(fovs), desc="Cell Cluster Mask Generation", unit="FOVs"
+    ) as pbar:
         for fov in fovs:
             # generate the cell mask for the FOV
-            cell_mask: np.ndarray =\
-                generate_cell_cluster_mask(fov=fov, base_dir=base_dir, seg_dir=seg_dir,
-                                           cell_data=cell_data,
-                                           cell_cluster_col=cell_cluster_col,
-                                           seg_suffix=seg_suffix)
+            cell_mask: np.ndarray = generate_cell_cluster_mask(
+                fov=fov, seg_dir=seg_dir, ccmd=ccmd, seg_suffix=seg_suffix
+            )
 
             # save the cell mask generated
-            save_fov_mask(fov, data_dir=save_dir, mask_data=cell_mask, sub_dir=sub_dir,
-                          name_suffix=name_suffix)
+            save_fov_mask(
+                fov,
+                data_dir=save_dir,
+                mask_data=cell_mask,
+                sub_dir=sub_dir,
+                name_suffix=name_suffix,
+            )
 
-            cell_mask_progress.update(1)
+            pbar.update(1)
 
 
 def generate_pixel_cluster_mask(fov, base_dir, tiff_dir, chan_file_path,
                                 pixel_data_dir, pixel_cluster_col='pixel_meta_cluster'):
     """For a fov, create a mask labeling each pixel with their SOM or meta cluster label
 
     Args:
@@ -292,15 +405,15 @@
     fov_data[pixel_cluster_col] = fov_data[pixel_cluster_col].astype(int)
 
     # get the pixel coordinates
     x_coords = fov_data['row_index'].values
     y_coords = fov_data['column_index'].values
 
     # convert to 1D indexing
-    coordinates = x_coords * img_data.shape[0] + y_coords
+    coordinates = x_coords * img_data.shape[1] + y_coords
 
     # get the cooresponding cluster labels for each pixel
     cluster_labels = list(fov_data[pixel_cluster_col])
 
     # assign each coordinate in pixel_cluster_mask to its respective cluster label
     img_subset = img_data.ravel()
     img_subset[coordinates] = cluster_labels
@@ -363,64 +476,90 @@
             # save the pixel mask generated
             save_fov_mask(fov, data_dir=save_dir, mask_data=pixel_mask, sub_dir=sub_dir,
                           name_suffix=name_suffix)
 
             pixel_mask_progress.update(1)
 
 
-def generate_and_save_neighborhood_cluster_masks(fovs: List[str],
-                                                 save_dir: Union[pathlib.Path, str],
-                                                 neighborhood_data: pd.DataFrame,
-                                                 seg_dir: str,
-                                                 seg_suffix: str = '_whole_cell.tiff',
-                                                 xr_channel_name='segmentation_label',
-                                                 sub_dir: str = None,
-                                                 name_suffix: str = ''):
-    """Generates neighborhood cluster masks and saves them for downstream analysis
+def generate_and_save_neighborhood_cluster_masks(
+    fovs: List[str],
+    save_dir: Union[pathlib.Path, str],
+    seg_dir: Union[pathlib.Path, str],
+    neighborhood_data: pd.DataFrame,
+    fov_col: str = settings.FOV_ID,
+    label_col: str = settings.CELL_LABEL,
+    cluster_col: str = settings.KMEANS_CLUSTER,
+    seg_suffix: str = "_whole_cell.tiff",
+    xr_channel_name="label",
+    sub_dir: Union[pathlib.Path, str] = None,
+    name_suffix: str = "",
+):
+    """Generates neighborhood cluster masks and saves them for downstream analysis.
 
     Args:
         fovs (List[str]):
             A list of fovs to generate and save neighborhood masks for.
         save_dir (Union[pathlib.Path, str]):
             The directory to save the generated pixel cluster masks.
-        neighborhood_data (pandas.DataFrame):
-            Contains the neighborhood cluster assignments for each cell.
-        seg_dir (str):
+        seg_dir (Union[pathlib.Path, str]):
             The path to the segmentation data.
-        seg_suffix (str):
-            The suffix that the segmentation images use. Defaults to `'_whole_cell.tiff'`.
+        neighborhood_data (pd.DataFrame):
+            Contains the neighborhood cluster assignments for each cell.
+        fov_col (str, optional):
+            The column name containing the FOV IDs . Defaults to `settings.FOV_ID` (`"fov"`).
+        label_col (str, optional):
+            The column name containing the cell label. Defaults to `settings.CELL_LABEL`
+            (`"label"`).
+        cluster_col (str, optional):
+            The column name containing the cluster label. Defaults to `settings.KMEANS_CLUSTER`
+            (`"kmeans_neighborhood"`).
+        seg_suffix (str, optional):
+            The suffix that the segmentation images use. Defaults to `'_whole_cell.tiff'`
         xr_channel_name (str):
             Channel name for segmented data array.
         sub_dir (str, optional):
             The subdirectory to save the images in. If specified images are saved to
             `"data_dir/sub_dir"`. If `sub_dir = None` the images are saved to `"data_dir"`.
             Defaults to `None`.
         name_suffix (str, optional):
             Specify what to append at the end of every pixel mask. Defaults to `''`.
     """
 
+    ccmd = CellClusterMaskData(
+        data=neighborhood_data,
+        fov_col=fov_col,
+        label_col=label_col,
+        cluster_col=cluster_col,
+    )
+
     # create the neighborhood cluster masks across each fov
-    with tqdm(total=len(fovs), desc="Neighborhood Cluster Mask Generation") as neigh_mask_progress:
+    with tqdm(
+        total=len(fovs), desc="Neighborhood Cluster Mask Generation"
+    ) as neigh_mask_progress:
         # generate the mask for each FOV
         for fov in fovs:
             # load in the label map for the FOV
             label_map = load_utils.load_imgs_from_dir(
-                seg_dir, files=[fov + seg_suffix], xr_channel_names=[xr_channel_name],
-                trim_suffix=seg_suffix.split('.')[0]
+                seg_dir,
+                files=[fov + seg_suffix],
+                xr_channel_names=[xr_channel_name],
+                trim_suffix=seg_suffix.split(".")[0],
             ).loc[fov, ..., :]
 
             # generate the neighborhood mask for the FOV
-            neighborhood_mask: np.ndarray =\
-                label_cells_by_cluster(
-                    fov, neighborhood_data, label_map
-                )
+            neighborhood_mask: np.ndarray = label_cells_by_cluster(fov, ccmd, label_map)
 
             # save the neighborhood mask generated
-            save_fov_mask(fov, data_dir=save_dir, mask_data=neighborhood_mask, sub_dir=sub_dir,
-                          name_suffix=name_suffix)
+            save_fov_mask(
+                fov,
+                data_dir=save_dir,
+                mask_data=neighborhood_mask,
+                sub_dir=sub_dir,
+                name_suffix=name_suffix,
+            )
 
             neigh_mask_progress.update(1)
 
 
 def split_img_stack(stack_dir, output_dir, stack_list, indices, names, channels_first=True):
     """Splits the channels in a given directory of images into separate files
 
@@ -474,15 +613,15 @@
         clustering (bool or str):
             if stitching images from the single pixel or cell mask dir, specify 'pixel' / 'cell'
     """
 
     io_utils.validate_paths(data_dir)
 
     # no img_sub_folder, change to empty string to read directly from base folder
-    if img_sub_folder is None:
+    if img_sub_folder in [None, '', ""]:
         img_sub_folder = ""
 
     if clustering and clustering not in ['pixel', 'cell']:
         raise ValueError('If stitching images from the pixie pipeline, the clustering arg must be '
                          'set to either \"pixel\" or \"cell\".')
 
     # retrieve valid fov names
@@ -501,46 +640,53 @@
     if len(fovs) == 0:
         raise ValueError(f"No FOVs found in directory, {data_dir}.")
 
     # check previous stitching
     if os.path.exists(stitched_dir):
         raise ValueError(f"The {stitched_dir} directory already exists.")
 
+    search_term: str = re.compile(r"(R\+?\d+)(C\+?\d+)")
+
     bad_fov_names = []
     for fov in fovs:
-        r = re.compile('.*R.*C.*')
-        if r.match(fov) is None:
+        res = re.search(search_term, fov)
+        if res is None:
             bad_fov_names.append(fov)
+
     if len(bad_fov_names) > 0:
         raise ValueError(f"Invalid FOVs found in directory, {data_dir}. FOV names "
                          f"{bad_fov_names} should have the form RnCm.")
 
     # retrieve all extracted channel names and verify list if provided
     if not segmentation and not clustering:
         channel_imgs = io_utils.list_files(
             dir_name=os.path.join(data_dir, fovs[0], img_sub_folder),
-            substrs=['.tiff', '.jpg', '.png'])
+            substrs=EXTENSION_TYPES["IMAGE"])
     else:
-        channel_imgs = io_utils.list_files(data_dir, substrs=fovs[0])
+        channel_imgs = io_utils.list_files(data_dir, substrs=fovs[0]+'_')
         channel_imgs = [chan.split(fovs[0] + '_')[1] for chan in channel_imgs]
 
     if channels is None:
         channels = io_utils.remove_file_extensions(channel_imgs)
     else:
         misc_utils.verify_in_list(channel_inputs=channels,
                                   valid_channels=io_utils.remove_file_extensions(channel_imgs))
 
-    os.makedirs(stitched_dir)
-
-    file_ext = channel_imgs[0].split('.')[1]
-    expected_fovs, num_rows, num_cols = load_utils.get_tiled_fov_names(fovs, return_dims=True)
+    file_ext = os.path.splitext(channel_imgs[0])[1]
+    expected_tiles = load_utils.get_tiled_fov_names(fovs, return_dims=True)
 
     # save new images to the stitched_images, one channel at a time
-    for chan in channels:
+    for chan, tile in itertools.product(channels, expected_tiles):
+        prefix, expected_fovs, num_rows, num_cols = tile
+        if prefix == "":
+            prefix = "unnamed_tile"
+        stitched_subdir = os.path.join(stitched_dir, prefix)
+        if not os.path.exists(stitched_subdir):
+            os.makedirs(stitched_subdir)
         image_data = load_utils.load_tiled_img_data(data_dir, fovs, expected_fovs, chan,
                                                     single_dir=any([segmentation, clustering]),
-                                                    file_ext=file_ext,
+                                                    file_ext=file_ext[1:],
                                                     img_sub_folder=img_sub_folder)
         stitched_data = data_utils.stitch_images(image_data, num_cols)
         current_img = stitched_data.loc['stitched_image', :, :, chan].values
-        image_utils.save_image(os.path.join(stitched_dir, chan + '_stitched.' + file_ext),
+        image_utils.save_image(os.path.join(stitched_subdir, chan + '_stitched' + file_ext),
                                current_img)
```

### Comparing `ark-analysis-0.6.3/src/ark/utils/deepcell_service_utils.py` & `ark-analysis-0.6.4/src/ark/utils/deepcell_service_utils.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,20 +6,20 @@
 from json import JSONDecodeError
 from pathlib import Path
 from urllib.parse import unquote_plus
 from zipfile import ZIP_DEFLATED, ZipFile
 
 import numpy as np
 import requests
+from alpineer import image_utils, io_utils, load_utils, misc_utils
 from requests.adapters import HTTPAdapter
 from requests.exceptions import RetryError
-from requests.packages.urllib3.util import Retry
 from tifffile import imread
-from alpineer import image_utils, io_utils, misc_utils, load_utils
 from tqdm.notebook import tqdm
+from urllib3 import Retry
 
 
 def create_deepcell_output(deepcell_input_dir, deepcell_output_dir, fovs=None,
                            wc_suffix='_whole_cell', nuc_suffix='_nuclear',
                            host='https://deepcell.org', job_type='mesmer',
                            scale=1.0, timeout=3600, zip_size=5, parallel=False):
     """Handles all of the necessary data manipulation for running deepcell tasks.
@@ -153,15 +153,15 @@
                 mask_path = os.path.join(deepcell_output_dir, resuffixed_name)
 
                 # DeepCell uses .tif extension, append extra f to account for .tiff standard
                 mask_path += 'f'
 
                 # read the file from the .zip file and save as segmentation mask
                 byte_repr = zipObj.read(name)
-                ranked_segmentation_mask = _convert_deepcell_seg_masks(byte_repr)
+                ranked_segmentation_mask = (_convert_deepcell_seg_masks(byte_repr)).squeeze()
                 image_utils.save_image(mask_path, ranked_segmentation_mask)
 
             # verify that all the files were extracted
             for fov in fov_group:
                 if fov + '_feature_0.tif' not in zipObj.namelist():
                     warnings.warn(f'Deep Cell whole cell output file was not found for {fov}.')
                 if fov + '_feature_1.tif' not in zipObj.namelist():
@@ -210,15 +210,15 @@
         }
         f.seek(0)
 
     # define and mount a retry instance to call the Deepcell API again if needed
     retry_strategy = Retry(
         total=num_retries,
         status_forcelist=[404, 500, 502, 503, 504],
-        method_whitelist=['HEAD', 'GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'TRACE']
+        allowed_methods=['HEAD', 'GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'TRACE']
     )
     adapter = HTTPAdapter(max_retries=retry_strategy)
 
     http = requests.Session()
     http.mount('https://', adapter)
     http.mount('http://', adapter)
 
@@ -254,15 +254,15 @@
 
     # call prediction
     predict_url = host + '/api/predict'
 
     predict_response = requests.post(
         predict_url,
         json={
-            'dataRescale': scale,
+            'jobForm': {"scale": scale},
             'imageName': filename,
             'imageUrl': upload_response['imageURL'],
             'jobType': job_type,
             'uploadedName': upload_response['uploadedName']
         }
     ).json()
```

### Comparing `ark-analysis-0.6.3/src/ark/utils/example_dataset.py` & `ark-analysis-0.6.4/src/ark/utils/example_dataset.py`

 * *Files 2% similar despite different names*

```diff
@@ -103,27 +103,27 @@
         """
         if type(move_dir) is not pathlib.Path:
             move_dir = pathlib.Path(move_dir)
 
         dataset_names = list(self.dataset_paths[self.dataset].features.keys())
 
         for ds_n in dataset_names:
-            ds_n_suffix = self.path_suffixes[ds_n]
+            ds_n_suffix: str = pathlib.Path(self.path_suffixes[ds_n])
 
             # The path where the dataset is saved in the Hugging Face Cache post-download,
             # Necessary to copy + move the data from the cache to the user specified `move_dir`.
             dataset_cache_path = pathlib.Path(self.dataset_paths[self.dataset][ds_n][0])
-            src_path = dataset_cache_path / ds_n
-            dst_path = move_dir / ds_n_suffix
+            src_path: pathlib.Path = dataset_cache_path / ds_n
+            dst_path: pathlib.Path = move_dir / ds_n_suffix
 
             # Overwrite the existing dataset when `overwrite_existing` == `True`
             # and when the `dst_path` is empty.
 
             # `True` if `dst_path` is empty, `False` if data exists in `dst_path`
-            empty_dst_path = self.check_empty_dst(dst_path=dst_path)
+            empty_dst_path: bool = self.check_empty_dst(dst_path=dst_path)
 
             if self.overwrite_existing:
                 if not empty_dst_path:
                     warnings.warn(UserWarning(f"Files exist in {dst_path}. \
                         They will be overwritten by the downloaded example dataset."))
 
                 # Remove files in the destination path
```

### Comparing `ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/colormap_helper.py` & `ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/colormap_helper.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/file_reader.py` & `ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/file_reader.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/metaclusterdata.py` & `ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/metaclusterdata.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/metaclustergui.py` & `ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/metaclustergui.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/throttle.py` & `ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/throttle.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/src/ark/utils/metacluster_remap_gui/zscore_norm.py` & `ark-analysis-0.6.4/src/ark/utils/metacluster_remap_gui/zscore_norm.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/src/ark/utils/plot_utils.py` & `ark-analysis-0.6.4/src/ark/utils/plot_utils.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,25 +1,177 @@
 import os
 import pathlib
 import shutil
+from dataclasses import dataclass, field
 from operator import contains
-from typing import List, Union
+from typing import Dict, List, Literal, Optional, Tuple, Union
 
 import matplotlib.cm as cm
 import matplotlib.colors as colors
 import matplotlib.pyplot as plt
 import natsort
 import numpy as np
 import pandas as pd
 import xarray as xr
+from alpineer import image_utils, io_utils, load_utils, misc_utils
+from alpineer.settings import EXTENSION_TYPES
 from mpl_toolkits.axes_grid1 import make_axes_locatable
 from skimage.exposure import rescale_intensity
 from skimage.segmentation import find_boundaries
-from alpineer import io_utils, load_utils, misc_utils
-from alpineer.settings import EXTENSION_TYPES
+from tqdm import tqdm
+
+
+@dataclass
+class MetaclusterColormap:
+    """
+    A dataclass which contains the colormap-related information for the metaclusters.
+
+    """
+    cluster_type: str
+    cluster_id_to_name_path: Union[str, pathlib.Path]
+    metacluster_colors: Dict
+
+    # Fields initialized after `__post_init__`
+    unassigned_color: Tuple[float, ...] = field(init=False)
+    unassigned_id: int = field(init=False)
+    no_cluster_color: Tuple[float, ...] = field(init=False)
+    metacluster_id_to_name: pd.DataFrame = field(init=False)
+    mc_colors: np.ndarray = field(init=False)
+    metacluster_to_index: Dict = field(init=False)
+    cmap: colors.ListedColormap = field(init=False)
+    norm: colors.BoundaryNorm = field(init=False)
+
+    def __post_init__(self) -> None:
+        """
+        Initializes the fields of the dataclass after the object is instantiated.
+        """
+
+        # A pixel with no associated metacluster (gray, #5A5A5A)
+        self.unassigned_color: Tuple[float, ...] = (0.9, 0.9, 0.9, 1.0)
+
+        # A pixel assigned to no cluster (black, #000000)
+        self.no_cluster_color: Tuple[float, ...] = (0.0, 0.0, 0.0, 1.0)
+
+        self._metacluster_cmap_generator()
+
+    def _metacluster_cmap_generator(self) -> None:
+        """
+        A helper function which generates a colormap for the metaclusters with a given cluster ID
+        to name mapping.
+
+        Args:
+            cluster_id_to_name_path (Union[str, pathlib.Path]):
+                a path to a CSV identifying the pixel/cell cluster to manually-defined name mapping
+                this is output by the remapping visualization found in `metacluster_remap_gui`
+            metacluster_colors (Dict):
+                maps each metacluster id to a color
+            cluster_type (Literal["cell", "pixel"]):
+                the type of clustering being done
+
+
+        Returns:
+            MetaclusterColormap: The Dataclass containing the colormap-related information
+        """
+
+        cluster_id_to_name: pd.DataFrame = pd.read_csv(self.cluster_id_to_name_path)
+
+        # The mapping file needs to contain the following columns:
+        # 'cluster', 'metacluster', and 'mc_name'
+        misc_utils.verify_same_elements(
+            cluster_mapping_cols=cluster_id_to_name.columns.values,
+            required_cols=[
+                f"{self.cluster_type}_som_cluster",
+                f"{self.cluster_type}_meta_cluster",
+                f"{self.cluster_type}_meta_cluster_rename",
+            ],
+        )
+
+        # subset on just metacluster and mc_name
+        metacluster_id_to_name = cluster_id_to_name[
+            [f"{self.cluster_type}_meta_cluster", f"{self.cluster_type}_meta_cluster_rename"]
+        ].copy()
+
+        unassigned_id: int = int(
+            metacluster_id_to_name[f"{self.cluster_type}_meta_cluster"].max() + 1)
+
+        # Extract unique pairs of (metacluster-ID,  name)
+        # Set the unassigned cluster ID to be the max ID + 1
+        # Set 0 as the Empty value
+        metacluster_id_to_name: pd.DataFrame = pd.concat(
+            [
+                metacluster_id_to_name.drop_duplicates(),
+                pd.DataFrame(
+                    data={
+                        f"{self.cluster_type}_meta_cluster": [unassigned_id, 0],
+                        f"{self.cluster_type}_meta_cluster_rename": ["Unassigned", "Empty"]
+                    }
+                )
+            ]
+        )
+
+        # sort by metacluster id ascending, this will help when making the colormap
+        metacluster_id_to_name.sort_values(by=f'{self.cluster_type}_meta_cluster', inplace=True)
+
+        # add the unassigned color to the metacluster_colors dict
+        self.metacluster_colors.update({unassigned_id: self.unassigned_color})
+
+        # add the no cluster color to the metacluster_colors dict
+        self.metacluster_colors.update({0: self.no_cluster_color})
+
+        # assert the metacluster index in colors matches with the ids in metacluster_id_to_name
+        misc_utils.verify_same_elements(
+            metacluster_colors_ids=list(
+                self.metacluster_colors.keys()),
+            metacluster_mapping_ids=metacluster_id_to_name
+            [f'{self.cluster_type}_meta_cluster'].values)
+
+        # use metacluster_colors to add the colors to metacluster_id_to_name
+        metacluster_id_to_name["color"] = metacluster_id_to_name[
+            f"{self.cluster_type}_meta_cluster"
+        ].map(self.metacluster_colors)
+
+        # Convert the list of tuples to a numpy array, each index is a color
+
+        mc_colors: np.ndarray = np.array(metacluster_id_to_name['color'].to_list())
+
+        metacluster_to_index = {}
+        metacluster_id_to_name.reset_index(drop=True, inplace=True)
+        for index, row in metacluster_id_to_name.reset_index(drop=True).iterrows():
+            metacluster_to_index[row[f'{self.cluster_type}_meta_cluster']] = index
+
+        # generate the colormap
+        cmap = colors.ListedColormap(mc_colors)
+        norm = colors.BoundaryNorm(
+            np.linspace(0, len(mc_colors), len(mc_colors) + 1) - 0.5,
+            len(mc_colors)
+        )
+
+        # Assign created values to dataclass attributes
+        self.metacluster_id_to_name = metacluster_id_to_name
+        self.mc_colors = mc_colors
+        self.metacluster_to_index = metacluster_to_index
+        self.cmap = cmap
+        self.norm = norm
+
+    def assign_metacluster_cmap(self, fov_img: np.ndarray) -> np.ndarray:
+        """Assigns the metacluster colormap to the provided image.
+
+        Args:
+            fov_img (np.ndarray): The metacluster image to assign the colormap index to.
+
+        Returns:
+            np.ndarray: The image with the colormap index assigned.
+        """
+        # explicitly relabel each value in fov_img with its index in mc_colors
+        # to ensure proper indexing into colormap
+        relabeled_fov = np.copy(fov_img)
+        for mc, mc_color_idx in self.metacluster_to_index.items():
+            relabeled_fov[fov_img == mc] = mc_color_idx
+
+        return relabeled_fov
 
 
 def plot_neighborhood_cluster_result(img_xr, fovs, k, save_dir=None, cmap_name='tab20',
                                      fov_col='fovs', figsize=(10, 10)):
     """Takes an xarray containing labeled images and displays them.
     Args:
         img_xr (xarray.DataArray):
@@ -56,15 +208,15 @@
         ax = plt.gca()
 
         # make the title
         plt.title(fov)
 
         # show the image on the figure
         im = plt.imshow(img_xr[img_xr[fov_col] == fov].values.squeeze(),
-                        cmap=cmap, norm=norm)
+                        cmap=cmap, norm=norm, interpolation='none')
 
         # remove the axes
         plt.axis('off')
 
         # remove the gridlines
         plt.grid(visible=None)
 
@@ -118,120 +270,62 @@
 
     # verify the fovs are valid
     misc_utils.verify_in_list(fov_names=fovs, unique_fovs=img_xr.fovs.values)
 
     # verify cluster_id_to_name_path exists
     io_utils.validate_paths(cluster_id_to_name_path)
 
-    # read the cluster to name mapping
-    cluster_id_to_name = pd.read_csv(cluster_id_to_name_path)
-
-    # this mapping file needs to contain the following columns:
-    # 'cluster', 'metacluster', and 'mc_name'
-    # NOTE: check for 'cluster' ensures this file was generated by the interactive visualization
-    misc_utils.verify_same_elements(
-        cluster_mapping_cols=cluster_id_to_name.columns.values,
-        required_cols=[
-            f'{cluster_type}_som_cluster',
-            f'{cluster_type}_meta_cluster',
-            f'{cluster_type}_meta_cluster_rename']
-    )
-
-    # subset on just metacluster and mc_name
-    metacluster_id_to_name = cluster_id_to_name[
-        [f'{cluster_type}_meta_cluster', f'{cluster_type}_meta_cluster_rename']
-    ].copy()
-
-    # take only the unique pairs
-    metacluster_id_to_name = metacluster_id_to_name.drop_duplicates()
-
-    # sort by metacluster id ascending, this will help when making the colormap
-    metacluster_id_to_name = metacluster_id_to_name.sort_values(by=f'{cluster_type}_meta_cluster')
-
-    # assert the metacluster index in colors matches with the ids in metacluster_id_to_name
-    misc_utils.verify_same_elements(
-        metacluster_colors_ids=list(metacluster_colors.keys()),
-        metacluster_mapping_ids=metacluster_id_to_name[f'{cluster_type}_meta_cluster'].values
-    )
-
-    # use metacluster_colors to add the colors to metacluster_id_to_name
-    metacluster_id_to_name['color'] = metacluster_id_to_name[f'{cluster_type}_meta_cluster'].map(
-        metacluster_colors
-    )
-
-    # need to add black to denote a pixel with no clusters
-    mc_colors = [(0.0, 0.0, 0.0)] + list(metacluster_id_to_name['color'].values)
-
-    # map each metacluster_id_to_name to its index + 1
-    # NOTE: explicitly needed to ensure correct colormap colors are drawn and colorbar
-    # is indexed correctly when plotted
-    metacluster_to_index = {}
-    for index, row in metacluster_id_to_name.reset_index(drop=True).iterrows():
-        metacluster_to_index[row[f'{cluster_type}_meta_cluster']] = index + 1
-
-    # generate the colormap
-    cmap = colors.ListedColormap(mc_colors)
-    norm = colors.BoundaryNorm(
-        np.linspace(0, len(mc_colors), len(mc_colors) + 1) - 0.5,
-        len(mc_colors)
-    )
-
+    # read the cluster to name mapping with the helper function
+    mcc = MetaclusterColormap(cluster_type=cluster_type,
+                              cluster_id_to_name_path=cluster_id_to_name_path,
+                              metacluster_colors=metacluster_colors)
     for fov in fovs:
         # retrieve the image associated with the FOV
         fov_img = img_xr[img_xr[fov_col] == fov].values
 
-        # assign any metacluster id not in metacluster_id_to_name to 0 (not including 0 itself)
-        # done as a precaution, should not usually happen
-        acceptable_cluster_ids = [0] + list(metacluster_id_to_name[f'{cluster_type}_meta_cluster'])
-        fov_img[~np.isin(fov_img, acceptable_cluster_ids)] = 0
-
-        # explicitly relabel each value in fov_img with its index in mc_colors
-        # to ensure proper indexing into colormap
-        for mc, mc_index in metacluster_to_index.items():
-            fov_img[fov_img == mc] = mc_index
+        fov_img: np.ndarray = mcc.assign_metacluster_cmap(fov_img)
 
         # define the figure
         fig = plt.figure(figsize=figsize)
 
         # make the title
         plt.title(fov)
 
         # display the image
         overlay = plt.imshow(
             fov_img.squeeze(),
-            cmap=cmap,
-            norm=norm,
+            cmap=mcc.cmap,
+            norm=mcc.norm,
             origin='upper'
         )
 
         # remove the axes
         plt.axis('off')
 
         # remove the gridlines
         plt.grid(visible=False)
 
         # define the colorbar with annotations
         cax = fig.add_axes([0.9, 0.1, 0.01, 0.8])
         cbar = plt.colorbar(
             overlay,
-            ticks=np.arange(len(mc_colors)),
+            ticks=np.arange(len(mcc.mc_colors)),
             cax=cax,
             orientation='vertical'
         )
-        cbar.ax.set_yticklabels(['Empty'] + list(
-            metacluster_id_to_name[f'{cluster_type}_meta_cluster_rename'].values)
-        )
+        cbar.ax.set_yticklabels(
+            mcc.metacluster_id_to_name[f'{cluster_type}_meta_cluster_rename'].values)
 
         # explicitly turn off intermediate minor ticks
         for mt in cbar.ax.yaxis.get_minor_ticks():
             mt.set_visible(False)
 
         # save if specified
         if save_dir:
-            misc_utils.save_figure(save_dir, f'{fov}.png')
+            misc_utils.save_figure(save_dir, f"{fov}.png")
 
 
 def tif_overlay_preprocess(segmentation_labels, plotting_tif):
     """Validates plotting_tif and preprocesses it accordingly
     Args:
         segmentation_labels (numpy.ndarray):
             2D numpy array of labeled cell objects
@@ -407,18 +501,18 @@
     return colors.ListedColormap(corrected)
 
 
 def create_mantis_dir(fovs: List[str], mantis_project_path: Union[str, pathlib.Path],
                       img_data_path: Union[str, pathlib.Path],
                       mask_output_dir: Union[str, pathlib.Path],
                       mapping: Union[str, pathlib.Path, pd.DataFrame],
-                      seg_dir: Union[str, pathlib.Path],
+                      seg_dir: Optional[Union[str, pathlib.Path]],
                       cluster_type='pixel',
                       mask_suffix: str = "_mask",
-                      seg_suffix_name: str = "_whole_cell.tiff",
+                      seg_suffix_name: Optional[str] = "_whole_cell.tiff",
                       img_sub_folder: str = ""):
     """Creates a mantis project directory so that it can be opened by the mantis viewer.
     Copies fovs, segmentation files, masks, and mapping csv's into a new directory structure.
     Here is how the contents of the mantis project folder will look like.
 
     ```{code-block} sh
     mantis_project
@@ -448,22 +542,24 @@
             The folder where the mantis project will be created.
         img_data_path (Union[str, pathlib.Path]):
             The location of the all the fovs you wish to create a project from.
         mask_output_dir (Union[str, pathlib.Path]):
             The folder containing all the masks of the fovs.
         mapping (Union[str, pathlib.Path, pd.DataFrame]):
             The location of the mapping file, or the mapping Pandas DataFrame itself.
-        seg_dir (Union[str, pathlib.Path]):
-            The location of the segmentation directory for the fovs.
+        seg_dir (Union[str, pathlib.Path], optional):
+            The location of the segmentation directory for the fovs. If None, then
+            the segmentation file will not be copied over.
         cluster_type (str):
             the type of clustering being done
         mask_suffix (str, optional):
             The suffix used to find the mask tiffs. Defaults to "_mask".
         seg_suffix_name (str, optional):
-            The suffix of the segmentation file and it's file extension.
+            The suffix of the segmentation file and it's file extension. If None, then
+            the segmentation file will not be copied over.
             Defaults to "_whole_cell.tiff".
         img_sub_folder (str, optional):
             The subfolder where the channels exist within the `img_data_path`.
             Defaults to "normalized".
     """
 
     # verify the type of clustering provided is valid
@@ -472,22 +568,25 @@
         valid_cluster_types=['pixel', 'cell']
     )
 
     if not os.path.exists(mantis_project_path):
         os.makedirs(mantis_project_path)
 
     # create key from cluster number to cluster name
-    if type(mapping) in {pathlib.Path, str}:
+    if isinstance(mapping, (pathlib.Path, str)):
         map_df = pd.read_csv(mapping)
-    elif type(mapping) is pd.DataFrame:
+    elif isinstance(mapping, pd.DataFrame):
         map_df = mapping
     else:
         ValueError("Mapping must either be a path to an already saved mapping csv, \
                    or a DataFrame that is already loaded in.")
 
+    # Save the segmentation tiff or not
+    save_seg_tiff: bool = all(v is not None for v in [seg_dir, seg_suffix_name])
+
     map_df = map_df.loc[:, [f'{cluster_type}_meta_cluster', f'{cluster_type}_meta_cluster_rename']]
     # remove duplicates from df
     map_df = map_df.drop_duplicates()
     map_df = map_df.sort_values(by=[f'{cluster_type}_meta_cluster'])
 
     # rename for mantis names
     map_df = map_df.rename(
@@ -529,14 +628,82 @@
 
         # copy mask into new folder
         mask_name: str = mn + mask_suffix + ".tiff"
         shutil.copy(os.path.join(mask_output_dir, mask_name),
                     os.path.join(output_dir, 'population{}.tiff'.format(mask_suffix)))
 
         # copy the segmentation files into the output directory
-        seg_name: str = fov + seg_suffix_name
-        shutil.copy(os.path.join(seg_dir, seg_name),
-                    os.path.join(output_dir, 'cell_segmentation.tiff'))
+        # if `seg_dir` or `seg_name` is none, then skip copying
+        if save_seg_tiff:
+            seg_name: str = fov + seg_suffix_name
+            shutil.copy(os.path.join(seg_dir, seg_name),
+                        os.path.join(output_dir, 'cell_segmentation.tiff'))
 
         # copy mapping into directory
         map_df.to_csv(os.path.join(output_dir, 'population{}.csv'.format(mask_suffix)),
                       index=False)
+
+
+def save_colored_masks(
+        fovs: List[str],
+        mask_dir: Union[str, pathlib.Path],
+        save_dir: Union[str, pathlib.Path],
+        cluster_id_to_name_path: Union[str, pathlib.Path],
+        metacluster_colors: Dict,
+        cluster_type: Literal["cell", "pixel"],
+) -> None:
+    """
+    Converts the pixie TIFF masks into colored TIFF masks using the provided colormap and saves
+    them in the `save_dir`. Mainly used for visualization purposes.
+
+    Args:
+        fovs (List[str]): A list of FOVs to save their associated color masks for.
+        mask_dir (Union[str, pathlib.Path]): The directory where the pixie masks are stored.
+        save_dir (Union[str, pathlib.Path]): The directory where the colored masks will be saved.
+        cluster_id_to_name_path (Union[str, pathlib.Path]): A path to a CSV identifying the
+            pixel/cell cluster to manually-defined name mapping this is output by the remapping
+            visualization found in `metacluster_remap_gui`.
+        metacluster_colors (Dict): Maps each metacluster id to a color.
+        cluster_type (Literal["cell", "pixel"]): The type of clustering being done.
+    """
+
+    # Input validation
+    misc_utils.verify_in_list(
+        provided_cluster_type=[cluster_type],
+        valid_cluster_types=["pixel", "cell"])
+
+    # Create the save directory if it does not exist, convert mask and save dirs to Path objects
+    if isinstance(mask_dir, str):
+        mask_dir = pathlib.Path(mask_dir)
+    if isinstance(save_dir, str):
+        save_dir = pathlib.Path(save_dir)
+    save_dir.mkdir(parents=True, exist_ok=True)
+
+    io_utils.validate_paths([mask_dir, save_dir])
+
+    mcc = MetaclusterColormap(cluster_type=cluster_type,
+                              cluster_id_to_name_path=cluster_id_to_name_path,
+                              metacluster_colors=metacluster_colors)
+
+    with tqdm(total=len(fovs), desc="Saving colored masks", unit="FOVs") as pbar:
+        for fov in fovs:
+            mask: xr.DataArray = load_utils.load_imgs_from_dir(
+                data_dir=mask_dir,
+                files=[f"{fov}_{cluster_type}_mask.tiff"],
+                trim_suffix=f"{cluster_type}_mask",
+                match_substring=f"{cluster_type}_mask",
+                xr_dim_name="pixel_mask",
+                xr_channel_names=None,
+            )
+
+            # The values in the colored_mask are the indices of the colors in mcc.mc_colors
+            # Make a new array with the actual colors, multiply by uint8 max to get 0-255 range
+
+            colored_mask: np.ndarray = (mcc.mc_colors[mcc.assign_metacluster_cmap(
+                mask.values.squeeze())] * 255.999).astype(np.uint8)
+
+            image_utils.save_image(
+                fname=save_dir / f"{fov}_{cluster_type}_mask_colored.tiff",
+                data=colored_mask,)
+
+            pbar.set_postfix(FOV=fov, refresh=False)
+            pbar.update(1)
```

### Comparing `ark-analysis-0.6.3/src/ark/utils/spatial_lda_utils.py` & `ark-analysis-0.6.4/src/ark/utils/spatial_lda_utils.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,17 +3,17 @@
 
 import matplotlib.pyplot as plt
 import numpy as np
 import palettable.colorbrewer.qualitative as qual_palettes
 import pandas as pd
 import seaborn as sns
 import spatial_lda.online_lda
+from alpineer import io_utils, misc_utils
 from scipy.spatial.distance import pdist
 from spatial_lda.visualization import _standardize_topics, plot_adjacency_graph
-from alpineer import io_utils, misc_utils
 
 from ark.settings import BASE_COLS, CELL_TYPE, LDA_PLOT_TYPES
 
 
 def check_format_cell_table_args(cell_table, markers, clusters):
     """Checks the input arguments of the format_cell_table() function.
 
@@ -28,18 +28,23 @@
 
     # Check cell table columns
     misc_utils.verify_in_list(required_columns=BASE_COLS,
                               cell_table_columns=cell_table.columns.to_list())
 
     # Check markers/clusters
     if markers is None and clusters is None:
-        raise ValueError("markers and clusters cannot both be None")
+        raise ValueError("Markers and clusters cannot both be None.")
+
     if markers is not None:
+        if len(markers) == 0:
+            raise ValueError(f"The markers list is empty.")
         misc_utils.verify_in_list(markers=markers, cell_table_columns=cell_table.columns.to_list())
     if clusters is not None:
+        if len(clusters) == 0:
+            raise ValueError(f"The clusters list is empty.")
         cell_table_clusters = cell_table[CELL_TYPE].unique().tolist()
         misc_utils.verify_in_list(clusters=clusters, cell_table_clusters=cell_table_clusters)
 
 
 def check_featurize_cell_table_args(cell_table, featurization, radius, cell_index):
     """Checks the input arguments of the featurize_cell_table() function.
```

### Comparing `ark-analysis-0.6.3/src/ark_analysis.egg-info/PKG-INFO` & `ark-analysis-0.6.4/src/ark_analysis.egg-info/PKG-INFO`

 * *Files 10% similar despite different names*

```diff
@@ -1,31 +1,39 @@
 Metadata-Version: 2.1
 Name: ark-analysis
-Version: 0.6.3
-Summary: Toolbox for analysis on segmented images from MIBI
+Version: 0.6.4
+Summary: Toolbox for analysis on segmented images from MIBI.
 Author-email: Angelo Lab <theangelolab@gmail.com>
 License: Modified Apache License 2.0
 Project-URL: repository, https://github.com/angelolab/ark-analysis
 Classifier: Development Status :: 4 - Beta
 Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Topic :: Scientific/Engineering :: Bio-Informatics
-Requires-Python: >=3.8
+Requires-Python: >=3.9
 Description-Content-Type: text/markdown
 Provides-Extra: test
+Provides-Extra: lab_ext
 License-File: LICENSE
 
-[![CI](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml)
-[![Coverage Status](https://coveralls.io/repos/github/angelolab/ark-analysis/badge.svg?branch=main)](https://coveralls.io/github/angelolab/ark-analysis?branch=main)
-![Docker Image Version (latest by date)](https://img.shields.io/docker/v/angelolab/ark-analysis?arch=amd64&color=%23469ae5&label=Docker%20Version&sort=date)
-[![Read the Docs](https://readthedocs.org/projects/ark-analysis/badge/?version=latest)](https://ark-analysis.readthedocs.io/en/latest/)
-
 # ark-analysis
 
+<div align="center">
+
+| | | 
+| ---        |    ---  |
+| CI / CD | [![CI](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml/badge.svg)](https://github.com/angelolab/ark-analysis/actions/workflows/ci.yml) ![Read the Docs](https://img.shields.io/readthedocs/ark-analysis) [![Coverage Status](https://coveralls.io/repos/github/angelolab/ark-analysis/badge.svg?branch=main)](https://coveralls.io/github/angelolab/ark-analysis?branch=main) ![Docker Image Version (latest by date)](https://img.shields.io/docker/v/angelolab/ark-analysis?arch=amd64&color=%23469ae5&label=Docker%20Version&sort=date) |
+| Package | [![PyPI - Version](https://img.shields.io/pypi/v/ark-analysis.svg?logo=pypi&label=PyPI&logoColor=gold)](https://pypi.org/project/ark-analysis/) [![PyPI - Downloads](https://img.shields.io/pypi/dm/ark-analysis.svg?color=blue&label=Downloads&logo=pypi&logoColor=gold)](https://pypi.org/project/ark-analysis/) [![PyPI - Python Version](https://img.shields.io/pypi/pyversions/ark-analysis.svg?logo=python&label=Python&logoColor=gold)](https://pypi.org/project/ark-analysis/) |
+|Meta | [![PyPI - License](https://img.shields.io/pypi/l/ark-analysis?color=9400d3)](LICENSE) |
+
+</div>
+
 Toolbox for analyzing multiplexed imaging data.
 
 Full documentation for the project can be found [here](https://ark-analysis.readthedocs.io/en/latest/).
 
 ## Table of Contents
 - [Pipeline Flowchart](#pipeline-flowchart)
 - [Getting Started](#getting-started)
@@ -110,30 +118,30 @@
 However, the repository will still need to be cloned if you wish to use the Jupyter Notebooks.
 
 #### Download the Repo
 
 We recommend using the latest release of `ark`. You can find all the versions available in the [Releases Section](https://github.com/angelolab/ark-analysis/releases).
 Open terminal and navigate to where you want the code stored. 
 
-Currently, the latest release is `v0.6.3`.
-Then install the latest release with:
+
+If you would like to use the latest version of `ark` simply clone the project and create the Conda environment.
 
 ```sh
-git clone -b v0.6.3 https://github.com/angelolab/ark-analysis.git
+git clone -b v0.6.4 https://github.com/angelolab/ark-analysis.git
+cd ark-analysis
+conda env create -f environment.yml
 ```
 
-You may also install previous releases by simply changing the version after the `-b`.
-
 #### Setting up Docker
 
 There is a complementary [setup video](https://youtu.be/EXMGdi_Izdw).
 
 Next, you'll need to download Docker Desktop:
  - First, [download](https://hub.docker.com/?overlay=onboarding) Docker Desktop. 
- - Once it's sucessfully installed, make sure it is running by looking in toolbar for the Docker whale icon. 
+ - Once it's successfully installed, make sure it is running by looking in toolbar for the Docker whale icon. 
 
 
 #### Running on Windows
 
 Our repo runs best on Linux-based systems (including MacOS). If you need to run on Windows, please consult our [Windows guide](https://ark-analysis.readthedocs.io/en/latest/_rtd/windows_setup.html) for additional instructions.
 
 #### Using the Repository (Running the Docker)
```

### Comparing `ark-analysis-0.6.3/src/ark_analysis.egg-info/SOURCES.txt` & `ark-analysis-0.6.4/src/ark_analysis.egg-info/SOURCES.txt`

 * *Files 2% similar despite different names*

```diff
@@ -1,22 +1,23 @@
 .dockerignore
 .gitignore
 .readthedocs.yml
 Dockerfile
 LICENSE
 README.md
 conftest.py
+environment.yml
 pyproject.toml
 setup.py
 start_docker.sh
 start_jupyter.sh
 tox.ini
 update_notebooks.sh
-./src/ark/utils/_bootstrapping.c
 .github/dependabot.yml
+.github/scripts/get_example_dataset.py
 .github/workflows/build.yml
 .github/workflows/ci.yml
 .github/workflows/docker.yml
 .github/workflows/pypi_publish.yml
 .github/workflows/release-drafter.yml
 .github/workflows/test.yml
 docs/Makefile
@@ -37,14 +38,15 @@
 docs/_rtd/pipeline.md
 docs/_rtd/windows_setup.md
 docs/_static/.gitkeep
 docs/_templates/.gitkeep
 src/ark/__init__.py
 src/ark/settings.py
 src/ark/analysis/__init__.py
+src/ark/analysis/cell_neighborhood_stats.py
 src/ark/analysis/dimensionality_reduction.py
 src/ark/analysis/neighborhood_analysis.py
 src/ark/analysis/spatial_analysis_utils.py
 src/ark/analysis/spatial_enrichment.py
 src/ark/analysis/visualize.py
 src/ark/phenotyping/__init__.py
 src/ark/phenotyping/cell_cluster_utils.py
@@ -62,14 +64,15 @@
 src/ark/segmentation/marker_quantification.py
 src/ark/segmentation/regionprops_extraction.py
 src/ark/segmentation/segmentation_utils.py
 src/ark/segmentation/signal_extraction.py
 src/ark/spLDA/__init__.py
 src/ark/spLDA/processing.py
 src/ark/utils/__init__.py
+src/ark/utils/_bootstrapping.c
 src/ark/utils/_bootstrapping.pyx
 src/ark/utils/data_utils.py
 src/ark/utils/deepcell_service_utils.py
 src/ark/utils/example_dataset.py
 src/ark/utils/plot_utils.py
 src/ark/utils/spatial_lda_utils.py
 src/ark/utils/metacluster_remap_gui/__init__.py
@@ -89,21 +92,23 @@
 templates/3_Pixie_Cluster_Cells.ipynb
 templates/4_Post_Clustering.ipynb
 templates/Calculate_Mixing_Scores.ipynb
 templates/Image_Stitching.ipynb
 templates/LDA_Preprocessing.ipynb
 templates/LDA_Training_and_Inference.ipynb
 templates/OME-TIFF_Conversion.ipynb
+templates/cell_neighbors_analysis.ipynb
 templates/example_fiber_segmentation.ipynb
 templates/example_neighborhood_analysis_script.ipynb
 templates/example_visualization.ipynb
 templates/generic_cell_clustering.ipynb
 tests/synthetic_spatial_datagen.py
 tests/test_utils.py
 tests/analysis/__init__.py
+tests/analysis/cell_neighborhood_stats_test.py
 tests/analysis/dimensionality_reduction_test.py
 tests/analysis/neighborhood_analysis_test.py
 tests/analysis/spatial_analysis_utils_test.py
 tests/analysis/spatial_enrichment_test.py
 tests/analysis/visualize_test.py
 tests/phenotyping/__init__.py
 tests/phenotyping/cell_cluster_utils_test.py
```

### Comparing `ark-analysis-0.6.3/src/ark_analysis.egg-info/requires.txt` & `ark-analysis-0.6.4/src/ark_analysis.egg-info/requires.txt`

 * *Files 24% similar despite different names*

```diff
@@ -1,42 +1,47 @@
-alpineer>=0.1.5
+alpineer>=0.1.8
 Cython<1,>=0.29
 datasets<3.0,>=2.6
 dill<0.4,>=0.3.5
 feather-format<1,>=0.4.1
 importlib-metadata>=5.0
 ipympl<1.0.0,>=0.9.2
 ipython<9,>=8.4
-ipywidgets==8.0.0
-jupyter_contrib_nbextensions<1,>=0.5.1
-jupyter>=1.0.0
 jupyterlab<4,>=3.4.3
-matplotlib<4,>=3.6.2
+matplotlib<4,>=3.7
 multiprocess>=0.70.13
 natsort<9,>=8
-numpy<2,>=1.20
+numpy<1.24,>=1.20
 palettable<4,>=3.3.0
-pandas<2,>=1.3
+pandas>=2
 pillow<10,>=9
-pyFlowSOM==0.1.14
+pyFlowSOM>=0.1.15
 requests<3,>=2.20
-scikit-image<0.20,>=0.19
+scikit-image>=0.21
 scikit-learn<2,>=1.1
 scipy<2,>=1.7
 seaborn<1,>=0.12
 spatial-lda<1,>=0.1.3
 statsmodels<1,>=0.13.2
 tables>=3.7
 tifffile>=2022
 tqdm<5,>=4
 umap-learn<1.0,>=0.5
 xarray>=2022
 xmltodict<1,>=0.13.0
 zstandard<1,>=0.19.0
 
+[lab_ext]
+jupyterlab-lsp
+python-lsp-server[all]
+jupyterlab-git
+jupyterlab_execute_time
+jupyterlab-skip-traceback
+lckr-jupyterlab-variableinspector
+
 [test]
 attrs
 coveralls[toml]
 pytest
 pytest-cases
 pytest-cov
 pytest-mock
```

### Comparing `ark-analysis-0.6.3/start_docker.sh` & `ark-analysis-0.6.4/start_docker.sh`

 * *Files 16% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 #!/usr/bin/env bash
 
 # define the version number, this needs to be updated every new Docker release
-VERSION='v0.6.3'
+VERSION='v0.6.4'
 
 # check for template developer flag
 JUPYTER_DIR='scripts'
 update=0
 external=''
 while test $# -gt 0
 do
@@ -40,15 +40,15 @@
   else
     bash update_notebooks.sh
 fi
 
 # find lowest open port available
 PORT=8888
 
-until [[ $(docker container ls | grep 0.0.0.0:$PORT | wc -l) -eq 0 ]]
+until [[ $(netstat -an | grep LISTEN | grep $PORT | wc -l) -eq 0 ]]
   do
     ((PORT=$PORT+1))
 done
 
 # define the run parameters
 run_params=(
   -p $PORT:$PORT
```

### Comparing `ark-analysis-0.6.3/templates/1_Segment_Image_Data.ipynb` & `ark-analysis-0.6.4/templates/1_Segment_Image_Data.ipynb`

 * *Files 10% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9809887566137566%*

 * *Differences: {"'cells'": "{0: {'attachments': OrderedDict()}, 1: {'metadata': {delete: ['slideshow']}, "*

 * *            "'source': {insert: [(5, 'from skimage import io\\n'), (7, 'from ark.utils import "*

 * *            "deepcell_service_utils, example_dataset, plot_utils')], delete: [12, 11, 9, 7, 6, 5, "*

 * *            "4]}}, 2: {'attachments': OrderedDict()}, 3: {'attachments': OrderedDict()}, 5: "*

 * *            "{'attachments': OrderedDict()}, 7: {'attachments': OrderedDict()}, 8: "*

 * *            "{'execution_count': None}, 9: {' […]*

```diff
@@ -1,52 +1,47 @@
 {
     "cells": [
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### This is a notebook to format your data for segmentation, run the images through the cloud instance of Mesmer, and then extract marker counts and morphological information from all the cells in your images"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {
-                "slideshow": {
-                    "slide_type": "slide"
-                },
                 "tags": [
                     "import"
                 ]
             },
             "outputs": [],
             "source": [
                 "# import required packages\n",
                 "import os\n",
                 "import warnings\n",
                 "\n",
-                "import matplotlib.pyplot as plt\n",
-                "import numpy as np\n",
-                "import skimage.io as io\n",
-                "import xarray as xr\n",
                 "from alpineer import io_utils\n",
-                "\n",
+                "from skimage import io\n",
                 "from ark.segmentation import marker_quantification, segmentation_utils\n",
-                "from ark.utils import (deepcell_service_utils, example_dataset,\n",
-                "                       plot_utils)"
+                "from ark.utils import deepcell_service_utils, example_dataset, plot_utils"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 0: Set root directory and download example dataset"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Here we are using the example data located in `/data/example_dataset/input_data`. To modify this notebook to run using your own data, simply change `base_dir` to point to your own sub-directory within the data folder.\n",
                 "\n",
                 "* `base_dir`: the path to all of your imaging data. This directory will contain all of the data generated by this notebook."
             ]
@@ -62,14 +57,15 @@
             "outputs": [],
             "source": [
                 "# set up the base directory\n",
                 "base_dir = \"../data/example_dataset\""
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "If you would like to test the features in Ark with an example dataset, run the cell below. It will download a dataset consisting of 11 FOVs with 22 channels. You may find more information about the example dataset in the [README](../README.md#example-dataset).\n",
                 "\n",
                 "If you are using your own data, skip the cell below.\n",
                 "\n",
@@ -86,27 +82,28 @@
             },
             "outputs": [],
             "source": [
                 "example_dataset.get_example_dataset(dataset=\"segment_image_data\", save_dir = base_dir, overwrite_existing = True)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 1: set file paths and parameters\n",
                 "\n",
                 "### All data, images, files, etc. must be placed in the 'data' directory, and referenced via '../data/path_to_your_data'\n",
                 "\n",
                 "If you're interested in directly interfacing with Google Drive, consult the documentation [here](https://ark-analysis.readthedocs.io/en/latest/_rtd/google_docs_usage.html)."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 2,
+            "execution_count": null,
             "metadata": {
                 "tags": [
                     "file_path"
                 ]
             },
             "outputs": [],
             "source": [
@@ -116,15 +113,15 @@
                 "deepcell_input_dir = os.path.join(base_dir, \"segmentation/deepcell_input\")\n",
                 "deepcell_output_dir = os.path.join(base_dir, \"segmentation/deepcell_output\")\n",
                 "deepcell_visualization_dir = os.path.join(base_dir, \"segmentation/deepcell_visualization\")"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 3,
+            "execution_count": null,
             "metadata": {
                 "tags": [
                     "create_dirs"
                 ]
             },
             "outputs": [],
             "source": [
@@ -132,15 +129,15 @@
                 "for directory in [cell_table_dir, deepcell_input_dir, deepcell_output_dir, deepcell_visualization_dir]:\n",
                 "    if not os.path.exists(directory):\n",
                 "        os.makedirs(directory)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 7,
+            "execution_count": null,
             "metadata": {
                 "tags": [
                     "validate_path"
                 ]
             },
             "outputs": [],
             "source": [
@@ -151,23 +148,24 @@
                 "                         deepcell_output_dir,\n",
                 "                         cell_table_dir,\n",
                 "                         deepcell_visualization_dir\n",
                 "                         ])"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### Compute and filter fov paths"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 8,
+            "execution_count": null,
             "metadata": {
                 "tags": [
                     "load_fovs"
                 ]
             },
             "outputs": [],
             "source": [
@@ -175,23 +173,24 @@
                 "fovs = io_utils.list_folders(tiff_dir)\n",
                 "\n",
                 "# ... or optionally, select a specific set of fovs manually\n",
                 "# fovs = [\"fov0\", \"fov1\"]"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### Load images into notebook, process, and save as Mesmer compatable input"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 9,
+            "execution_count": null,
             "metadata": {
                 "tags": [
                     "nuc_mem_set"
                 ]
             },
             "outputs": [],
             "source": [
@@ -201,15 +200,15 @@
                 "\n",
                 "# membrane channel name(s) (or mems = None)\n",
                 "mems = ['CD14', 'CD45', 'ECAD']"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 10,
+            "execution_count": null,
             "metadata": {
                 "tags": [
                     "gen_input"
                 ]
             },
             "outputs": [],
             "source": [
@@ -222,27 +221,28 @@
                 "    mems,\n",
                 "    fovs,\n",
                 "    img_sub_folder=None\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 2: Upload files to Deepcell and download results\n",
                 "\n",
                 "Deepcell input images will be zipped into a single file, uploaded to [deepcell.org](https://deepcell.org),\n",
                 "\n",
                 "and the output will be downloaded to the deepcell output directory."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 11,
+            "execution_count": null,
             "metadata": {
                 "tags": [
                     "seg_scale_set"
                 ]
             },
             "outputs": [],
             "source": [
@@ -260,31 +260,25 @@
             },
             "outputs": [],
             "source": [
                 "deepcell_service_utils.create_deepcell_output(deepcell_input_dir, deepcell_output_dir, fovs=fovs, scale=rescale_factor)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
-            "metadata": {
-                "pycharm": {
-                    "name": "#%% md\n"
-                }
-            },
+            "metadata": {},
             "source": [
                 "### We can then save the segmented mask overlaid on the imaging data"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {
-                "pycharm": {
-                    "name": "#%%\n"
-                },
                 "tags": [
                     "overlay_mask"
                 ]
             },
             "outputs": [],
             "source": [
                 "# display the channel overlay for a fov, useful for quick verification\n",
@@ -320,14 +314,15 @@
                 "    output_dir=deepcell_visualization_dir,\n",
                 "    fovs=io_utils.remove_file_extensions(fovs),\n",
                 "    channels=['nuclear_channel', 'membrane_channel']\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### Afterwards, we can generate expression matrices from the labeling + imaging data"
             ]
         },
         {
@@ -345,27 +340,25 @@
                 "\n",
                 "# set to True to bypass expensive cell property calculations\n",
                 "# only cell label, size, and centroid will be extracted if True\n",
                 "fast_extraction = False"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "For a full list of features extracted, please refer to the cell table section of: https://ark-analysis.readthedocs.io/en/latest/_rtd/data_types.html"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {
-                "pycharm": {
-                    "name": "#%%\n"
-                },
                 "tags": [
                     "create_exp_mat"
                 ]
             },
             "outputs": [],
             "source": [
                 "# now extract the segmented imaging data to create normalized and transformed expression matrices\n",
@@ -417,15 +410,15 @@
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.8.15"
+            "version": "3.11.3"
         },
         "vscode": {
             "interpreter": {
                 "hash": "9cd428f2623867f362c6ffd1805d28fe273bb79d15f4a3a73107e7f51d98be79"
             }
         }
     },
```

### Comparing `ark-analysis-0.6.3/templates/2_Pixie_Cluster_Pixels.ipynb` & `ark-analysis-0.6.4/templates/2_Pixie_Cluster_Pixels.ipynb`

 * *Files 11% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.959786848684738%*

 * *Differences: {"'cells'": "{0: {'attachments': OrderedDict()}, 1: {'source': {insert: [(7, 'from matplotlib "*

 * *            "import rc_file_defaults\\n'), (9, 'from ark.phenotyping import (pixel_cluster_utils, "*

 * *            "pixel_meta_clustering,\\n'), (10, '                             pixel_som_clustering, "*

 * *            "pixie_preprocessing)\\n'), (12, 'from ark.utils.metacluster_remap_gui import "*

 * *            "(MetaClusterGui,\\n')], delete: [20, 18, 17, 16, 15, 14, 11, 10, 9, 8, 6, 3]}}, 2: "*

 * *            "{'attachment […]*

```diff
@@ -1,10 +1,11 @@
 {
     "cells": [
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "# Pixie: pixel clustering notebook"
             ]
         },
         {
@@ -16,37 +17,30 @@
                 ]
             },
             "outputs": [],
             "source": [
                 "# import required packages\n",
                 "import json\n",
                 "import os\n",
-                "import subprocess\n",
                 "from datetime import datetime as dt\n",
                 "\n",
-                "import feather\n",
                 "import matplotlib.pyplot as plt\n",
-                "import numpy as np\n",
-                "import pandas as pd\n",
-                "import xarray as xr\n",
-                "from matplotlib import rc_file_defaults\n",
                 "from alpineer import io_utils, load_utils\n",
+                "from matplotlib import rc_file_defaults\n",
                 "\n",
-                "from ark.analysis import visualize\n",
-                "from ark.phenotyping import (pixie_preprocessing,\n",
-                "                             pixel_cluster_utils,\n",
-                "                             pixel_som_clustering,\n",
-                "                             pixel_meta_clustering)\n",
+                "from ark.phenotyping import (pixel_cluster_utils, pixel_meta_clustering,\n",
+                "                             pixel_som_clustering, pixie_preprocessing)\n",
                 "from ark.utils import data_utils, example_dataset, plot_utils\n",
-                "from ark.utils.metacluster_remap_gui import (MetaClusterData, MetaClusterGui,\n",
+                "from ark.utils.metacluster_remap_gui import (MetaClusterGui,\n",
                 "                                             colormap_helper,\n",
                 "                                             metaclusterdata_from_files)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 0: Set root directory and download the example dataset\n",
                 "\n",
                 "Here we are using the example data located in `data/example_dataset`. To use your own data, change `base_dir` to point to your own sub-directory within the data folder.\n",
                 "\n",
@@ -63,14 +57,15 @@
             },
             "outputs": [],
             "source": [
                 "base_dir = \"../data/example_dataset\""
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "If you would like to test the features in ark with an example dataset, run the cell below. It will download a dataset consisting of 11 FOVs with 22 channels. You may find more information about the example dataset in the [README](../README.md#example-dataset).\n",
                 "\n",
                 "If you are using your own data, skip the cell below.\n",
                 "\n",
@@ -87,30 +82,33 @@
             },
             "outputs": [],
             "source": [
                 "example_dataset.get_example_dataset(dataset=\"cluster_pixels\", save_dir = base_dir, overwrite_existing = False)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {
                 "tags": []
             },
             "source": [
                 "## 1: Set file paths and parameters"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "* `tiff_dir`: path to the directory containing your imaging data. Images should be single-channel TIFFs.\n",
                 "* `img_sub_folder`: if `tiff_dir` contains an additional subfolder structure, override `None` with the appropriate folder name\n",
                 "* `segmentation_dir`: path to the directory containing your segmentations (which can be generated using `1_Segment_Image_Data.ipynb`). Set this argument to `None` if you do not have segmentation labels or wish to run pixel clustering without them (they are required for cell clustering)\n",
-                "* `seg_suffix`: the suffix plus the file extension of the segmented images for each FOV. Note that these should be the same for all FOVs. This argument will be ignored if `segmentation_dir` is set to `None`"
+                "* `seg_suffix`: the suffix plus the file extension of the segmented images for each FOV. Note that these should be the same for all FOVs. This argument will be ignored if `segmentation_dir` is set to `None`\n",
+                "* `pixie_seg_dir`: the created path from the `segmentation_dir`. Is `None` if `segmentation_dir` is `None`."
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {
                 "tags": [
@@ -118,18 +116,24 @@
                 ]
             },
             "outputs": [],
             "source": [
                 "tiff_dir = os.path.join(base_dir, \"image_data\")\n",
                 "img_sub_folder = None\n",
                 "segmentation_dir = os.path.join(\"segmentation\", \"deepcell_output\")\n",
-                "seg_suffix = '_whole_cell.tiff'"
+                "seg_suffix = '_whole_cell.tiff'\n",
+                "\n",
+                "if segmentation_dir is not None:\n",
+                "    pixie_seg_dir = os.path.join(base_dir, segmentation_dir)\n",
+                "else:\n",
+                "    pixie_seg_dir = None"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "* `fovs` (optional): set a specific set of fovs to load, default loads all the fovs in `tiff_dir`"
             ]
         },
         {
@@ -146,21 +150,23 @@
                 "fovs = io_utils.list_folders(tiff_dir)\n",
                 "\n",
                 "# ... or optionally, select a specific set of fovs manually\n",
                 "# fovs = [\"fov14\"]"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### Define multiprocessing parameters"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Turning on multiprocessing provides a speed boost; however, it is not always cross-platform compatible. If you receive errors such as hanging cells without progress updates, try setting `multiprocess` back to `False`."
             ]
         },
         {
@@ -177,23 +183,25 @@
                 "multiprocess = False\n",
                 "\n",
                 "# define the number of FOVs to process in parallel, ignored if multiprocessing is set to False\n",
                 "batch_size = 5"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {
                 "tags": []
             },
             "source": [
                 "## 2: Preprocess"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Set a prefix to be applied to all data directories/files created during pixel clustering. If the prefix is not set, a default of the datetime at the start of the run is used."
             ]
         },
         {
@@ -210,14 +218,15 @@
                 "pixel_cluster_prefix = \"example\"\n",
                 "\n",
                 "if pixel_cluster_prefix is None:\n",
                 "    pixel_cluster_prefix = dt.now().strftime('%Y-%m-%dT%H:%M:%S')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The following data directories/files will be created with names prefixed by `pixel_cluster_prefix`:\n",
                 "\n",
                 "* `pixel_output_dir`: directory name where the pixel clustering outputs are stored\n",
                 "* `preprocessed_dir`: directory name where the preprocessed pixel data are stored\n",
@@ -243,14 +252,15 @@
                 "# define the preprocessed pixel data folders\n",
                 "pixel_data_dir = os.path.join(pixel_output_dir, 'pixel_mat_data')\n",
                 "pixel_subset_dir = os.path.join(pixel_output_dir, 'pixel_mat_subset')\n",
                 "norm_vals_name = os.path.join(pixel_output_dir, 'channel_norm_post_rowsum.feather')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "For certain channels, such as membraneous tumor markers, the subcellular localization of the marker isn't important. Instead, what matters is that cells which are positive for the marker show up as positive. In these cases, we have sometimes found it useful to add additional blurring to these markers before clustering. This ensures that more of the pixels within the cell are positive for the marker, instead of only a few pixels at the border, especially for cells which are under-segmented. However, higher blur levels will also cause more of the pixels in neighboring cells to show up as positive. Therefore, this works best when you have other, robust markers (like CD45) which you can use to determine which cells are false positives for the blurred channel. If you have markers in your panel which fit this description, you can add them in the cell below. Then, when specifying the list of markers to include for clustering, make sure to add `{marker_name}_smoothed`, as that is what the TIFF will be called.\n",
                 "\n",
                 "Skip this cell if you don't want to add an additional blur."
             ]
@@ -275,14 +285,15 @@
                 "    img_sub_folder=img_sub_folder,\n",
                 "    channels=blurred_channels,\n",
                 "    smooth_vals=smooth_vals,\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Sometimes, markers will have background staining that you'll want to filter out for the clustering process. Define the name of the marker you want to filter using `filter_channel`. If the marker is only present in the nucleus, set `exclude = False` to filter it out from the membrane. Conversely, if the marker is only present in the membrane, set `exclude = True` to filter it out from the nucleus.\n",
                 "\n",
                 "When specifying the list of markers to include for clustering, make sure to add `{marker_name}_nuc_exclude` or `{marker_name}_nuc_include` depending on what type of signal was filtered out.\n",
                 "\n",
@@ -310,14 +321,15 @@
                 "    nuc_seg_suffix=\"_nuclear.tiff\",\n",
                 "    img_sub_folder=img_sub_folder,\n",
                 "    exclude=nuclear_exclude\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Set the following arguments:\n",
                 "\n",
                 "* `channels`: channels to run pixel clustering on\n",
                 "* `blur_factor`: sigma (standard deviation) for the Gaussian blur. Higher values are more aggressive in smoothing signal.\n",
@@ -338,14 +350,15 @@
                 "            \"CD163_nuc_exclude\", \"CK17\", \"Collagen1\", \"Fibronectin\", \n",
                 "            \"ECAD_smoothed\", \"HLADR\", \"SMA\", \"Vim\"]\n",
                 "blur_factor = 2\n",
                 "subset_proportion = 0.1"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "During pixel preprocessing, the following is done for each FOV:\n",
                 "\n",
                 "* Gaussian blur each channel separately\n",
                 "* Remove empty pixels\n",
@@ -367,43 +380,46 @@
             "source": [
                 "# run pixel data preprocessing\n",
                 "pixie_preprocessing.create_pixel_matrix(\n",
                 "    fovs,\n",
                 "    channels,\n",
                 "    base_dir,\n",
                 "    tiff_dir,\n",
-                "    os.path.join(base_dir, segmentation_dir),\n",
+                "    pixie_seg_dir,\n",
                 "    img_sub_folder=img_sub_folder,\n",
                 "    seg_suffix=seg_suffix,\n",
                 "    pixel_output_dir=pixel_output_dir,\n",
                 "    data_dir=pixel_data_dir,\n",
                 "    subset_dir=pixel_subset_dir,\n",
                 "    norm_vals_name=norm_vals_name,\n",
                 "    blur_factor=blur_factor,\n",
                 "    subset_proportion=subset_proportion,\n",
                 "    multiprocess=multiprocess,\n",
                 "    batch_size=batch_size\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 3: Pixel clustering"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 3.1: Train pixel SOM"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Train the pixel SOM using the subsetted data. Training is done using a self-organizing map (SOM).\n",
                 "\n",
                 "The following data directories/files will be created for pixel clustering:\n",
                 "\n",
@@ -426,14 +442,15 @@
                 "pixel_som_weights_name = os.path.join(pixel_output_dir, 'pixel_som_weights.feather')\n",
                 "pc_chan_avg_som_cluster_name = os.path.join(pixel_output_dir, 'pixel_channel_avg_som_cluster.csv')\n",
                 "pc_chan_avg_meta_cluster_name = os.path.join(pixel_output_dir, 'pixel_channel_avg_meta_cluster.csv')\n",
                 "pixel_meta_cluster_remap_name = os.path.join(pixel_output_dir, 'pixel_meta_cluster_mapping.csv')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Each channel is normalized by their 99.9% value across the entire dataset before training. These values get saved to `norm_vals_name`.\n",
                 "\n",
                 "For a full set of parameters you can customize for `train_pixel_som`, please consult <a href=https://ark-analysis.readthedocs.io/en/latest/_markdown/ark.phenotyping.html#ark.phenotyping.pixel_cluster_utils.train_pixel_som>pixel training docs</a>."
             ]
@@ -458,21 +475,23 @@
                 "    som_weights_name=pixel_som_weights_name,\n",
                 "    num_passes=1,\n",
                 "    seed=42\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 3.2: Assign pixel SOM clusters"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Use the SOM weights learned from `train_pixel_som` to assign pixel clusters to the full preprocessed dataset.\n",
                 "\n",
                 "Note that each channel is normalized by the respective value stored in `norm_vals_name` (computed in `train_pixel_som`) prior to cluster assignment.\n",
                 "\n",
@@ -508,35 +527,38 @@
                 "    pixel_pysom,\n",
                 "    data_dir=pixel_data_dir,\n",
                 "    pc_chan_avg_som_cluster_name=pc_chan_avg_som_cluster_name\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 3.3: Run pixel consensus clustering"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Use consensus hierarchical clustering to cluster pixel SOM clusters into a user-defined number of meta clusters. The consensus clusters are trained on the average channel expression across all pixel SOM clusters (the data stored in `pc_chan_avg_som_cluster_name`). These values are z-scored and capped at the value specified in the `cap` argument prior to consensus clustering. This helps improve meta clustering performance.\n",
                 "\n",
                 "After consensus clustering, the following are computed by `generate_meta_avg_files`:\n",
                 "\n",
                 "* The average channel expression across all pixel meta clusters, and the number of pixels per meta cluster (the data in `pc_chan_avg_meta_cluster_name`)\n",
                 "* The meta cluster mapping for each pixel SOM cluster in `pc_chan_avg_som_cluster_name` (data is resaved, same data except with an associated meta cluster column)\n",
                 "\n",
                 "For a full set of parameters you can customize for `pixel_consensus_cluster`, please consult <a href=https://ark-analysis.readthedocs.io/en/latest/_markdown/ark.phenotyping.html#ark.phenotyping.pixel_cluster_utils.pixel_consensus_cluster>pixel consensus clustering docs</a>"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "* `max_k`: the number of consensus clusters desired\n",
                 "* `cap`: used to clip z-scored values prior to consensus clustering (in the range `[-cap, cap]`)"
             ]
         },
@@ -575,28 +597,31 @@
                 "    data_dir=pixel_data_dir,\n",
                 "    pc_chan_avg_som_cluster_name=pc_chan_avg_som_cluster_name,\n",
                 "    pc_chan_avg_meta_cluster_name=pc_chan_avg_meta_cluster_name\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 4: Visualize results"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.1: Interactive adjustments to relabel pixel meta clusters"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The visualization shows the z-scored average channel expression per pixel SOM and meta cluster. The heatmaps are faceted by pixel SOM clusters on the left and pixel meta clusters on the right.\n",
                 "\n",
                 "## Usage\n",
                 "\n",
@@ -611,15 +636,15 @@
                 "- To remap the selected clusters, click the **New metacluster** button (alternatively, right click anywhere). Note that remapping an entire metacluster deletes it.\n",
                 "- To clear the selected SOM/meta clusters, use the **Clear Selection** button.\n",
                 "- **After remapping a meta cluster, make sure to deselect the newly created one to prevent unwanted combinations.**\n",
                 "\n",
                 "### Other features and notes\n",
                 "- You will likely need to zoom out to see the entire visualization. To toggle Zoom, use Ctrl -/Ctrl + on Windows or \u2318 +/\u2318 - on Mac.\n",
                 "- The bars at the top show the number of pixels in each SOM cluster.\n",
-                "- The text box at the bottom right allows you to rename a particular meta cluster. This can be useful as remapping may cause inconsistent numbering.\n",
+                "- The text box at the bottom right allows you to rename a particular meta cluster. This can be useful as remapping may cause inconsistent numbering. **You cannot use the same name for different meta clusters; doing so will cause the next step to fail.**\n",
                 "- Adjust the z-score limit using the slider on the bottom left to adjust your dynamic range.\n",
                 "- When meta clusters are combined or a meta cluster is renamed, the change is immediately saved to `pixel_meta_cluster_remap_name`.\n",
                 "- You won't be able to advance in the notebook until you've clicked `New metacluster` or renamed a meta cluster at least once. If you don't want to make changes, just click `New metacluster` to trigger a save before continuing."
             ]
         },
         {
             "cell_type": "code",
@@ -640,14 +665,15 @@
                 "    cluster_type='pixel'\n",
                 ")\n",
                 "pixel_mcd.output_mapping_filename = os.path.join(base_dir, pixel_meta_cluster_remap_name)\n",
                 "pixel_mcg = MetaClusterGui(pixel_mcd, width=17)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Relabel the pixel meta clusters using the mapping, and recompute the meta cluster average files with the new meta cluster names."
             ]
         },
         {
@@ -680,14 +706,15 @@
                 "    pixel_meta_cluster_remap_name,\n",
                 "    pc_chan_avg_som_cluster_name,\n",
                 "    pc_chan_avg_meta_cluster_name\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Generate the color scheme returned by the interactive reclustering process. This will be for visualizing the pixel phenotype maps."
             ]
         },
         {
@@ -703,14 +730,15 @@
                 "raw_cmap, _ = colormap_helper.generate_meta_cluster_colormap_dict(\n",
                 "    pixel_mcd.output_mapping_filename,\n",
                 "    pixel_mcg.im_cl.cmap\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.2: Generate pixel phenotype maps\n",
                 "\n",
                 "Generate pixel phenotype maps, in which each pixel in the image corresponds to its pixel meta cluster. Select a small subset of your FOVs to view within this notebook. Or if you wish to generate and save a significant amount of FOVs, the masks will be created and saved in batches.\n",
                 "\n",
@@ -762,14 +790,43 @@
                 "    pixel_cluster_col='pixel_meta_cluster',\n",
                 "    sub_dir='pixel_masks',\n",
                 "    name_suffix='_pixel_mask',\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "Save the colored pixel masks for each FOV in `subset_pixel_fovs`."
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": null,
+            "metadata": {
+                "tags": [
+                    "save_pixel_masks"
+                ]
+            },
+            "outputs": [],
+            "source": [
+                "plot_utils.save_colored_masks(\n",
+                "    fovs=subset_pixel_fovs,\n",
+                "    mask_dir=os.path.join(base_dir, pixel_output_dir, \"pixel_masks\"),\n",
+                "    save_dir=os.path.join(base_dir, pixel_output_dir, \"pixel_mask_colored\"),\n",
+                "    cluster_id_to_name_path=os.path.join(base_dir, pixel_meta_cluster_remap_name),\n",
+                "    metacluster_colors=raw_cmap,\n",
+                "    cluster_type=\"pixel\"\n",
+                ")"
+            ]
+        },
+        {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Load a subset of the pixel cluster masks that you would like to preview."
             ]
         },
         {
@@ -797,21 +854,23 @@
                 "        [pixel_fov],\n",
                 "        os.path.join(base_dir, pixel_meta_cluster_remap_name),\n",
                 "        metacluster_colors=raw_cmap\n",
                 "    )"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 5: Save parameters for use in cell clustering"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The following parameters are saved:\n",
                 "\n",
                 "* `fovs`: fovs in `pixel_data_dir`\n",
                 "* `channels`: channels used for clustering\n",
@@ -847,14 +906,15 @@
                 "\n",
                 "# save the params dict\n",
                 "with open(os.path.join(base_dir, pixel_output_dir, 'cell_clustering_params.json'), 'w') as fh:\n",
                 "    json.dump(cell_clustering_params, fh)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 5.1 Save images for Mantis Viewer\n",
                 "\n",
                 "Mantis Viewer is a visualization tool for multi-dimensional imaging in pathology. Learn more about Mantis Viewer in the [README](../README.md#mantis-viewer)."
             ]
@@ -871,15 +931,15 @@
             "source": [
                 "plot_utils.create_mantis_dir(\n",
                 "    fovs=subset_pixel_fovs,\n",
                 "    mantis_project_path=os.path.join(base_dir, pixel_output_dir, \"mantis\"),\n",
                 "    img_data_path=tiff_dir,\n",
                 "    mask_output_dir=os.path.join(base_dir, pixel_output_dir, \"pixel_masks\"),\n",
                 "    mapping = os.path.join(base_dir, pixel_meta_cluster_remap_name),\n",
-                "    seg_dir=os.path.join(base_dir, segmentation_dir),\n",
+                "    seg_dir=pixie_seg_dir,\n",
                 "    mask_suffix=\"_pixel_mask\",\n",
                 "    seg_suffix_name=seg_suffix\n",
                 ")"
             ]
         }
     ],
     "metadata": {
@@ -896,14 +956,58 @@
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
             "version": "3.8.16"
         },
+        "nbdime-conflicts": {
+            "local_diff": [
+                {
+                    "diff": [
+                        {
+                            "key": "version",
+                            "op": "remove"
+                        }
+                    ],
+                    "key": "language_info",
+                    "op": "patch"
+                }
+            ],
+            "remote_diff": [
+                {
+                    "diff": [
+                        {
+                            "diff": [
+                                {
+                                    "diff": [
+                                        {
+                                            "key": 5,
+                                            "op": "addrange",
+                                            "valuelist": "5"
+                                        },
+                                        {
+                                            "key": 5,
+                                            "length": 1,
+                                            "op": "removerange"
+                                        }
+                                    ],
+                                    "key": 0,
+                                    "op": "patch"
+                                }
+                            ],
+                            "key": "version",
+                            "op": "patch"
+                        }
+                    ],
+                    "key": "language_info",
+                    "op": "patch"
+                }
+            ]
+        },
         "toc-autonumbering": false,
         "toc-showcode": true,
         "toc-showmarkdowntxt": true,
         "vscode": {
             "interpreter": {
                 "hash": "b0ac63cc785e7c4cb24da0642dbfe09cfb2d314979108d7192228f9c45902a86"
             }
```

### Comparing `ark-analysis-0.6.3/templates/3_Pixie_Cluster_Cells.ipynb` & `ark-analysis-0.6.4/templates/3_Pixie_Cluster_Cells.ipynb`

 * *Files 6% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9453085732819726%*

 * *Differences: {"'cells'": "{0: {'attachments': OrderedDict()}, 1: {'attachments': OrderedDict()}, 2: {'source': "*

 * *            "{insert: [(8, 'from alpineer import load_utils\\n'), (11, 'from ark.phenotyping "*

 * *            "import (cell_cluster_utils, cell_meta_clustering,\\n'), (12, "*

 * *            "'                             cell_som_clustering, weighted_channel_comp)\\n'), (14, "*

 * *            "'from ark.utils.metacluster_remap_gui import (MetaClusterGui,\\n')], delete: [22, 20, "*

 * *            "19, 18, 17, 16, 14, 12, 11, […]*

```diff
@@ -1,19 +1,21 @@
 {
     "cells": [
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {
                 "tags": []
             },
             "source": [
                 "# Pixie: cell clustering notebook"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "NOTE: this notebook should be run after `2_Pixie_Cluster_Pixels.ipynb`"
             ]
         },
         {
@@ -25,39 +27,32 @@
                 ]
             },
             "outputs": [],
             "source": [
                 "# import required packages\n",
                 "import json\n",
                 "import os\n",
-                "import subprocess\n",
                 "from datetime import datetime as dt\n",
                 "\n",
                 "import feather\n",
                 "import matplotlib.pyplot as plt\n",
-                "import numpy as np\n",
                 "import pandas as pd\n",
-                "import scipy.stats as stats\n",
-                "import seaborn as sns\n",
-                "import xarray as xr\n",
+                "from alpineer import load_utils\n",
                 "from matplotlib import rc_file_defaults\n",
-                "from alpineer import io_utils, load_utils\n",
                 "\n",
-                "from ark.analysis import visualize\n",
-                "from ark.phenotyping import (cell_cluster_utils,\n",
-                "                             cell_som_clustering,\n",
-                "                             cell_meta_clustering,\n",
-                "                             weighted_channel_comp)\n",
+                "from ark.phenotyping import (cell_cluster_utils, cell_meta_clustering,\n",
+                "                             cell_som_clustering, weighted_channel_comp)\n",
                 "from ark.utils import data_utils, example_dataset, plot_utils\n",
-                "from ark.utils.metacluster_remap_gui import (MetaClusterData, MetaClusterGui,\n",
+                "from ark.utils.metacluster_remap_gui import (MetaClusterGui,\n",
                 "                                             colormap_helper,\n",
                 "                                             metaclusterdata_from_files)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {
                 "tags": []
             },
             "source": [
                 "## 0: Set root directory and download the example dataset\n",
                 "\n",
@@ -77,14 +72,15 @@
             "outputs": [],
             "source": [
                 "# define the home directory (should contain pixel_output_dir from pixel clustering notebook)\n",
                 "base_dir = \"../data/example_dataset/\""
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "If you would like to test the features in ark with an example dataset, run the cell below. It will download a dataset consisting of 11 FOVs with 22 channels. You may find more information about the example dataset in the [README](../README.md#example-dataset).\n",
                 "\n",
                 "If you are using your own data, skip the cell below.\n",
                 "\n",
@@ -101,23 +97,25 @@
             },
             "outputs": [],
             "source": [
                 "example_dataset.get_example_dataset(dataset=\"cluster_cells\", save_dir = base_dir, overwrite_existing = False)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {
                 "tags": []
             },
             "source": [
                 "## 1: Load parameters for cell clustering (saved during `2_Pixie_Cluster_Pixels.ipynb`)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "`cell_clustering_params_name` should be `cell_clustering_params.json` contained in `{pixel_cluster_prefix}_pixel_output_dir`. Make sure to set `base_dir` and `pixel_output_dir` to the same value used in `2_Pixie_Cluster_Pixels.ipynb`.\n",
                 "\n",
                 "NOTE: `{pixel_cluster_prefix}` is set in `2_Pixie_Cluster_Pixels.ipynb`. If you did not explicity set a `{pixel_cluster_prefix}` in `2_Pixie_Cluster_Pixels.ipynb`, the prefix defaults to the timestamp of the run. Please check the run directory (`base_dir` as set in `2_Pixie_Cluster_Pixels.ipynb`) to see the prefix that was used."
             ]
@@ -139,14 +137,15 @@
                 "cell_clustering_params_name = 'cell_clustering_params.json'\n",
                 "\n",
                 "# define the name of the directory with the extracted image data\n",
                 "tiff_dir = os.path.join(base_dir, \"image_data\")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The following params are loaded:\n",
                 "\n",
                 "* `fovs`: subset of fovs used for pixel clustering\n",
                 "* `channels`: subset of channels used for pixel clustering\n",
@@ -185,21 +184,23 @@
                 "pc_chan_avg_meta_cluster_name = cell_clustering_params['pc_chan_avg_meta_cluster_name']\n",
                 "\n",
                 "# define the cell table path\n",
                 "cell_table_path = os.path.join(base_dir, 'segmentation', 'cell_table', 'cell_table_size_normalized.csv')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 2: Preprocess"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Set a prefix to be applied to all data directories/files created during cell clustering. If the prefix is not set, a default of the datetime at the start of the run is used."
             ]
         },
         {
@@ -216,14 +217,15 @@
                 "cell_cluster_prefix = \"example\"\n",
                 "\n",
                 "if cell_cluster_prefix is None:\n",
                 "    cell_cluster_prefix = dt.now().strftime('%Y-%m-%dT%H:%M:%S')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The following folders/files will be created with names prefixed by `cell_cluster_prefix`:\n",
                 "\n",
                 "* `cell_output_dir`: directory name where the cell clustering outputs are stored\n",
                 "* `cell_som_weights_name`: file name to store the cell SOM weights\n",
@@ -261,14 +263,15 @@
                 "cell_meta_cluster_count_avg_name = os.path.join(\"pixie\", cell_output_dir, 'cell_meta_cluster_count_avg.csv')\n",
                 "cell_som_cluster_channel_avg_name = os.path.join(\"pixie\", cell_output_dir, 'cell_som_cluster_channel_avg.csv')\n",
                 "cell_meta_cluster_channel_avg_name = os.path.join(\"pixie\", cell_output_dir, 'cell_meta_cluster_channel_avg.csv')\n",
                 "cell_meta_cluster_remap_name = os.path.join(\"pixie\", cell_output_dir, 'cell_meta_cluster_mapping.csv')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Additionally, define the following variable:\n",
                 "\n",
                 "* `pixel_cluster_col`: whether to use the pixel SOM or meta cluster counts for cell clustering. Must be either `'pixel_som_cluster'` or `'pixel_meta_cluster_rename'`. Note that if you did not explicitly rename your pixel meta clusters in `2_Pixie_Cluster_Pixels.ipynb`, the default numeric names will be used."
             ]
@@ -290,53 +293,69 @@
                 "if pixel_cluster_col == 'pixel_som_cluster':\n",
                 "    pc_chan_avg_name = pc_chan_avg_som_cluster_name\n",
                 "elif pixel_cluster_col == 'pixel_meta_cluster_rename':\n",
                 "    pc_chan_avg_name = pc_chan_avg_meta_cluster_name"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Generate the input data for the cell SOM. This computes the counts of each pixel cluster per cell, normalized by cell size."
+                "Generate the input data for the cell SOM. This computes the counts of each pixel cluster per cell, both raw and normalized by cell size.\n",
+                "\n",
+                "If both datasets already exist, load them in instead."
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {
                 "tags": [
                     "generate_som_input_data"
                 ]
             },
             "outputs": [],
             "source": [
-                "# generate the preprocessed data before \n",
-                "cluster_counts, cluster_counts_size_norm = cell_cluster_utils.create_c2pc_data(\n",
-                "    fovs, os.path.join(base_dir, pixel_data_dir), cell_table_path, pixel_cluster_col\n",
-                ")\n",
+                "if os.path.exists(os.path.join(base_dir, cluster_counts_name)) and os.path.exists(os.path.join(base_dir, cluster_counts_size_norm_name)):\n",
+                "    # load the data if it exists\n",
+                "    cluster_counts = feather.read_dataframe(os.path.join(base_dir, cluster_counts_name))\n",
+                "    cluster_counts_size_norm = feather.read_dataframe(os.path.join(base_dir, cluster_counts_size_norm_name))\n",
+                "else:\n",
+                "    # generate the preprocessed data \n",
+                "    cluster_counts, cluster_counts_size_norm = cell_cluster_utils.create_c2pc_data(\n",
+                "        fovs, os.path.join(base_dir, pixel_data_dir), cell_table_path, pixel_cluster_col\n",
+                "    )\n",
                 "\n",
+                "    # write both unnormalized and normalized input data for reference\n",
+                "    feather.write_dataframe(\n",
+                "        cluster_counts,\n",
+                "        os.path.join(base_dir, cluster_counts_name),\n",
+                "        compression='uncompressed'\n",
+                "    )\n",
+                "    feather.write_dataframe(\n",
+                "        cluster_counts_size_norm,\n",
+                "        os.path.join(base_dir, cluster_counts_size_norm_name),\n",
+                "        compression='uncompressed'\n",
+                "    )\n",
+                "    \n",
                 "# define the count columns found in cluster_counts_norm\n",
                 "cell_som_cluster_cols = cluster_counts_size_norm.filter(\n",
                 "    regex=f'{pixel_cluster_col}.*'\n",
-                ").columns.values\n",
-                "\n",
-                "# write the unnormalized input data to cluster_counts_name for reference\n",
-                "feather.write_dataframe(\n",
-                "    cluster_counts,\n",
-                "    os.path.join(base_dir, cluster_counts_name),\n",
-                "    compression='uncompressed'\n",
-                ")"
+                ").columns.values"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "Generate the weighted cell channel expression file. This data will be needed to compute the weighted average channel expression per cell cluster (the data stored in `cell_som_cluster_channel_avg_name` and `cell_meta_cluster_channel_avg_name`). See documentation of `compute_p2c_weighted_channel_avg` for how weighted cell channel average is computed: <a href=https://ark-analysis.readthedocs.io/en/latest/_markdown/ark.phenotyping.html#ark.phenotyping.cell_cluster_utils.compute_p2c_weighted_channel_avg>cell channel weighting docs</a>."
+                "Generate the weighted cell channel expression file. This data will be needed to compute the weighted average channel expression per cell cluster (the data stored in `cell_som_cluster_channel_avg_name` and `cell_meta_cluster_channel_avg_name`). See documentation of `compute_p2c_weighted_channel_avg` for how weighted cell channel average is computed: <a href=https://ark-analysis.readthedocs.io/en/latest/_markdown/ark.phenotyping.html#ark.phenotyping.cell_cluster_utils.compute_p2c_weighted_channel_avg>cell channel weighting docs</a>.\n",
+                "\n",
+                "If this file already exists, skip this step."
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {
                 "tags": [
@@ -347,47 +366,51 @@
             "source": [
                 "# depending on which pixel_cluster_col is selected, choose the pixel channel average table accordingly\n",
                 "if pixel_cluster_col == 'pixel_som_cluster':\n",
                 "    pc_chan_avg_name = pc_chan_avg_som_cluster_name\n",
                 "elif pixel_cluster_col == 'pixel_meta_cluster_rename':\n",
                 "    pc_chan_avg_name = pc_chan_avg_meta_cluster_name\n",
                 "\n",
-                "# generate the weighted cell channel expression data\n",
-                "pixel_channel_avg = pd.read_csv(os.path.join(base_dir, pc_chan_avg_name))\n",
-                "weighted_cell_channel = weighted_channel_comp.compute_p2c_weighted_channel_avg(\n",
-                "    pixel_channel_avg,\n",
-                "    channels,\n",
-                "    cluster_counts,\n",
-                "    fovs=fovs,\n",
-                "    pixel_cluster_col=pixel_cluster_col\n",
-                ")\n",
+                "if not os.path.exists(os.path.join(base_dir, weighted_cell_channel_name)):\n",
+                "    # generate the weighted cell channel expression data\n",
+                "    pixel_channel_avg = pd.read_csv(os.path.join(base_dir, pc_chan_avg_name))\n",
+                "    weighted_cell_channel = weighted_channel_comp.compute_p2c_weighted_channel_avg(\n",
+                "        pixel_channel_avg,\n",
+                "        channels,\n",
+                "        cluster_counts,\n",
+                "        fovs=fovs,\n",
+                "        pixel_cluster_col=pixel_cluster_col\n",
+                "    )\n",
                 "\n",
-                "# write the data to weighted_cell_channel_name\n",
-                "feather.write_dataframe(\n",
-                "    weighted_cell_channel,\n",
-                "    os.path.join(base_dir, weighted_cell_channel_name),\n",
-                "    compression='uncompressed'\n",
-                ")"
+                "    # write the data to weighted_cell_channel_name\n",
+                "    feather.write_dataframe(\n",
+                "        weighted_cell_channel,\n",
+                "        os.path.join(base_dir, weighted_cell_channel_name),\n",
+                "        compression='uncompressed'\n",
+                "    )"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 3: Cell clustering"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 3.1: Train cell SOM"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Train the cell SOM on the size-normalized number of pixel clusters per cell (the data stored in `cluster_counts_size_norm_name`). Training is done using the self-organizing map (SOM) algorithm. Note that each of the pixel SOM/meta cluster columns are normalized by their 99.9% value prior to training.\n",
                 "\n",
                 "For a full set of parameters you can customize for `train_cell_som`, please consult <a href=https://ark-analysis.readthedocs.io/en/latest/_markdown/ark.phenotyping.html#ark.phenotyping.cell_cluster_utils.train_cell_som>cell training docs</a>."
             ]
@@ -412,21 +435,23 @@
                 "    som_weights_name=cell_som_weights_name,\n",
                 "    num_passes=1,\n",
                 "    seed=42\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 3.2: Assign cell SOM clusters"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Use the weights learned from `train_cell_som` to assign cell clusters to the dataset. Note that this is done on the size-normalized pixel cluster counts table. As with `train_pixel_som`, each of the columns are normalized by their 99.9% value prior to assigning a cell SOM cluster label.\n",
                 "\n",
                 "`generate_som_avg_files` will compute the average number of pixel clusters per cell SOM cluster, as well as the number of cells in each cell SOM cluster (the data placed in `cell_som_cluster_count_avg_name`). This is needed for cell consensus clustering."
             ]
@@ -444,31 +469,40 @@
                 "# use cell SOM weights to assign cell clusters\n",
                 "cluster_counts_size_norm = cell_som_clustering.cluster_cells(\n",
                 "    base_dir,\n",
                 "    cell_pysom,\n",
                 "    cell_som_cluster_cols=cell_som_cluster_cols\n",
                 ")\n",
                 "\n",
+                "# intermediate saving of cell data with SOM labels assigned\n",
+                "feather.write_dataframe(\n",
+                "    cluster_counts_size_norm,\n",
+                "    os.path.join(base_dir, cluster_counts_size_norm_name),\n",
+                "    compression='uncompressed'\n",
+                ")\n",
+                "\n",
                 "# generate the SOM cluster summary files\n",
                 "cell_som_clustering.generate_som_avg_files(\n",
                 "    base_dir,\n",
                 "    cluster_counts_size_norm,\n",
                 "    cell_som_cluster_cols=cell_som_cluster_cols,\n",
                 "    cell_som_expr_col_avg_name=cell_som_cluster_count_avg_name\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 3.3: Run cell consensus clustering"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Use consensus hierarchical clustering to cluster cell SOM clusters into a user-defined number of meta clusters. The consensus clusters are trained on the average number of pixel clusters across all cell SOM clusters (the data stored in `cell_som_cluster_count_avg_name`). These values are z-scored and capped at the value specified in the `cap` argument prior to consensus clustering. This helps improve meta clustering performance.\n",
                 "\n",
                 "After consensus clustering, the following are computed by `generate_meta_avg_files`:\n",
                 "\n",
@@ -479,14 +513,15 @@
                 "\n",
                 "* The weighted channel average across all cell clusters (the data placed in `cell_som_cluster_channel_avg_name` and `cell_meta_cluster_channel_avg_name`). This will be done for both `'cell_som_cluster'` and `'cell_meta_cluster'`.\n",
                 "\n",
                 "For a full set of parameters you can customize for `cell_consensus_cluster`, please consult <a href=https://ark-analysis.readthedocs.io/en/latest/_markdown/ark.phenotyping.html#ark.phenotyping.cell_cluster_utils.cell_consensus_cluster>cell consensus clustering docs</a>"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "* `max_k`: the number of consensus clusters desired\n",
                 "* `cap`: used to clip z-scored values prior to consensus clustering (in the range `[-cap, cap]`)"
             ]
         },
@@ -510,14 +545,21 @@
                 "    cell_som_cluster_cols=cell_som_cluster_cols,\n",
                 "    cell_som_input_data=cluster_counts_size_norm,\n",
                 "    cell_som_expr_col_avg_name=cell_som_cluster_count_avg_name,\n",
                 "    max_k=max_k,\n",
                 "    cap=cap\n",
                 ")\n",
                 "\n",
+                "# intermediate saving of cell data with SOM and meta labels assigned\n",
+                "feather.write_dataframe(\n",
+                "    cluster_counts_size_norm,\n",
+                "    os.path.join(base_dir, cluster_counts_size_norm_name),\n",
+                "    compression='uncompressed'\n",
+                ")\n",
+                "\n",
                 "# generate the meta cluster summary files\n",
                 "cell_meta_clustering.generate_meta_avg_files(\n",
                 "    base_dir,\n",
                 "    cell_cc,\n",
                 "    cell_som_cluster_cols=cell_som_cluster_cols,\n",
                 "    cell_som_input_data=cluster_counts_size_norm,\n",
                 "    cell_som_expr_col_avg_name=cell_som_cluster_count_avg_name,\n",
@@ -534,28 +576,31 @@
                 "    weighted_cell_channel_name=weighted_cell_channel_name,\n",
                 "    cell_som_cluster_channel_avg_name=cell_som_cluster_channel_avg_name,\n",
                 "    cell_meta_cluster_channel_avg_name=cell_meta_cluster_channel_avg_name\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 4: Visualize results"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.1: Interactive adjustments to relabel cell meta clusters"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The visualization shows the z-scored average pixel cluster count expression per cell SOM and meta cluster. The heatmaps are faceted by cell SOM clusters on the left and cell meta clusters on the right.\n",
                 "\n",
                 "## Usage\n",
                 "\n",
@@ -570,15 +615,15 @@
                 "- To remap the selected clusters, click the **New metacluster** button (alternatively, right click anywhere). Note that remapping an entire metacluster deletes it.\n",
                 "- To clear the selected SOM/meta clusters, use the **Clear Selection** button.\n",
                 "- **After remapping a meta cluster, make sure to deselect the newly created one to prevent unwanted combinations.**\n",
                 "\n",
                 "### Other features and notes\n",
                 "- You will likely need to zoom out to see the entire visualization. To toggle Zoom, use Ctrl -/Ctrl + on Windows or \u2318 +/\u2318 - on Mac.\n",
                 "- The bars at the top show the number of cells in each SOM cluster.\n",
-                "- The text box at the bottom right allows you to rename a particular meta cluster. This can be useful as remapping may cause inconsistent numbering.\n",
+                "- The text box at the bottom right allows you to rename a particular meta cluster. This can be useful as remapping may cause inconsistent numbering. **You cannot use the same name for different meta clusters; doing so will cause the next step to fail.**\n",
                 "- Adjust the z-score limit using the slider on the bottom left to adjust your dynamic range.\n",
                 "- When meta clusters are combined or a meta cluster is renamed, the change is immediately saved to `cell_meta_cluster_remap_name`.\n",
                 "- You won't be able to advance until you've clicked `New metacluster` or renamed a meta cluster at least once. If you do not want to make changes, just click `New metacluster` to trigger a save before continuing."
             ]
         },
         {
             "cell_type": "code",
@@ -600,14 +645,15 @@
                 "    prefix_trim=pixel_cluster_col + '_'\n",
                 ")\n",
                 "cell_mcd.output_mapping_filename = os.path.join(base_dir, cell_meta_cluster_remap_name)\n",
                 "cell_mcg = MetaClusterGui(cell_mcd, width=17)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Relabel the cell meta clusters using the mapping, and recompute the meta cluster average files with the new meta cluster names."
             ]
         },
         {
@@ -623,14 +669,21 @@
                 "# rename the meta cluster values in the cell dataset\n",
                 "cluster_counts_size_norm = cell_meta_clustering.apply_cell_meta_cluster_remapping(\n",
                 "    base_dir,\n",
                 "    cluster_counts_size_norm,\n",
                 "    cell_meta_cluster_remap_name\n",
                 ")\n",
                 "\n",
+                "# intermediate saving of cell data with SOM, raw meta, and renamed meta labels assigned\n",
+                "feather.write_dataframe(\n",
+                "    cluster_counts_size_norm,\n",
+                "    os.path.join(base_dir, cluster_counts_size_norm_name),\n",
+                "    compression='uncompressed'\n",
+                ")\n",
+                "\n",
                 "# recompute the mean column expression per meta cluster and apply these new names to the SOM cluster average data\n",
                 "cell_meta_clustering.generate_remap_avg_count_files(\n",
                 "    base_dir,\n",
                 "    cluster_counts_size_norm,\n",
                 "    cell_meta_cluster_remap_name,\n",
                 "    cell_som_cluster_cols,\n",
                 "    cell_som_cluster_count_avg_name,\n",
@@ -647,14 +700,15 @@
                 "    weighted_cell_channel_name,\n",
                 "    cell_som_cluster_channel_avg_name,\n",
                 "    cell_meta_cluster_channel_avg_name\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Generate the color scheme returned by the interactive reclustering process. This will be for visualizing the weighted channel average heatmaps and the cell phenotype maps."
             ]
         },
         {
@@ -671,14 +725,15 @@
                 "    cell_mcd.output_mapping_filename,\n",
                 "    cell_mcg.im_cl.cmap,\n",
                 "    cluster_type='cell'\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.2: Weighted cell SOM cluster average heatmap over channels (z-scored)"
             ]
         },
         {
@@ -697,14 +752,15 @@
                 "    channels,\n",
                 "    raw_cmap,\n",
                 "    renamed_cmap\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.3: Weighted cell meta cluster average heatmap over channels (z-scored)"
             ]
         },
         {
@@ -723,14 +779,15 @@
                 "    channels,\n",
                 "    raw_cmap,\n",
                 "    renamed_cmap\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.4: Generate cell phenotype maps\n",
                 "\n",
                 "Generate cell phenotype maps, in which each pixel in the image corresponds to its cell meta cluster. Run this cell if you wish to create cell cluster mask images for downstream analysis."
             ]
@@ -758,25 +815,53 @@
                 ]
             },
             "outputs": [],
             "source": [
                 "# generate and save the cell cluster masks for each fov in subset_cell_fovs\n",
                 "data_utils.generate_and_save_cell_cluster_masks(\n",
                 "    fovs=subset_cell_fovs,\n",
-                "    base_dir=base_dir,\n",
                 "    save_dir=os.path.join(base_dir, \"pixie\", cell_output_dir),\n",
                 "    seg_dir=os.path.join(base_dir, segmentation_dir),\n",
                 "    cell_data=cluster_counts_size_norm,\n",
                 "    seg_suffix=seg_suffix,\n",
                 "    sub_dir='cell_masks',\n",
                 "    name_suffix='_cell_mask'\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "Save the colored cell masks for each FOV in `subset_cell_fovs`."
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": null,
+            "metadata": {
+                "tags": [
+                    "save_cell_masks"
+                ]
+            },
+            "outputs": [],
+            "source": [
+                "plot_utils.save_colored_masks(\n",
+                "    fovs=subset_cell_fovs,\n",
+                "    mask_dir=os.path.join(base_dir, \"pixie\",cell_output_dir, \"cell_masks\"),\n",
+                "    save_dir=os.path.join(base_dir, \"pixie\",cell_output_dir, \"cell_mask_colored\"),\n",
+                "    cluster_id_to_name_path=os.path.join(base_dir, cell_meta_cluster_remap_name),\n",
+                "    metacluster_colors=raw_cmap,\n",
+                "    cluster_type=\"cell\"\n",
+                ")"
+            ]
+        },
+        {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Load a subset of the cell cluster masks that you would like to preview."
             ]
         },
         {
@@ -805,21 +890,23 @@
                 "        os.path.join(base_dir, cell_meta_cluster_remap_name),\n",
                 "        metacluster_colors=raw_cmap,\n",
                 "        cluster_type='cell'\n",
                 "    )"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.5: Append consensus cluster labels to cell table"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The cell table with cell meta cluster labels is saved to `{cell_table_path}_cell_labels.csv`"
             ]
         },
         {
@@ -834,49 +921,19 @@
             "source": [
                 "cell_cluster_utils.add_consensus_labels_cell_table(\n",
                 "    base_dir, cell_table_path, cluster_counts_size_norm\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "### 4.6: Save the full results of Pixie cell clustering"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "`cluster_counts_size_norm` with the SOM, meta, and renamed meta cluster labels, is saved to `cluster_counts_size_norm_name` as a `.feather` file."
-            ]
-        },
-        {
-            "cell_type": "code",
-            "execution_count": null,
-            "metadata": {
-                "tags": [
-                    "pixie_cell_save"
-                ]
-            },
-            "outputs": [],
-            "source": [
-                "feather.write_dataframe(\n",
-                "    cluster_counts_size_norm,\n",
-                "    os.path.join(base_dir, cluster_counts_size_norm_name),\n",
-                "    compression='uncompressed'\n",
-                ")"
-            ]
-        },
-        {
-            "cell_type": "markdown",
-            "metadata": {},
-            "source": [
-                "### 4.7: Save images for Mantis Viewer\n",
+                "### 4.6: Save images for Mantis Viewer\n",
                 "\n",
                 "Mantis Viewer is a visualization tool for multi-dimensional imaging in pathology. Learn more about Mantis Viewer in the [README](../README.md#mantis-viewer)."
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
@@ -915,14 +972,54 @@
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
             "version": "3.8.15"
         },
+        "nbdime-conflicts": {
+            "local_diff": [
+                {
+                    "diff": [
+                        {
+                            "key": "version",
+                            "op": "remove"
+                        }
+                    ],
+                    "key": "language_info",
+                    "op": "patch"
+                }
+            ],
+            "remote_diff": [
+                {
+                    "diff": [
+                        {
+                            "diff": [
+                                {
+                                    "key": 0,
+                                    "op": "addrange",
+                                    "valuelist": [
+                                        "3.9.16"
+                                    ]
+                                },
+                                {
+                                    "key": 0,
+                                    "length": 1,
+                                    "op": "removerange"
+                                }
+                            ],
+                            "key": "version",
+                            "op": "patch"
+                        }
+                    ],
+                    "key": "language_info",
+                    "op": "patch"
+                }
+            ]
+        },
         "vscode": {
             "interpreter": {
                 "hash": "b0ac63cc785e7c4cb24da0642dbfe09cfb2d314979108d7192228f9c45902a86"
             }
         }
     },
     "nbformat": 4,
```

### Comparing `ark-analysis-0.6.3/templates/4_Post_Clustering.ipynb` & `ark-analysis-0.6.4/templates/4_Post_Clustering.ipynb`

 * *Files 2% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9924665178571429%*

 * *Differences: {"'cells'": "{1: {'execution_count': None}, 3: {'execution_count': None}, 7: {'execution_count': "*

 * *            "None}, 9: {'execution_count': None}, 12: {'execution_count': None}, 14: "*

 * *            "{'execution_count': None}, 16: {'execution_count': None}, 18: {'execution_count': "*

 * *            "None}, 19: {'execution_count': None}, 22: {'execution_count': None}, 24: "*

 * *            "{'execution_count': None}, 26: {'execution_count': None}, 29: {'execution_count': "*

 * *            "None}, 31: {'execution_count':  […]*

```diff
@@ -9,15 +9,15 @@
                 "This notebook allows the user to inspect and fine-tune the output of the [clustering](https://github.com/angelolab/ark-analysis/blob/main/templates/3_Cluster_Cells.ipynb) notebook. There are two parts of this notebook. \n",
                 "1. Clustering cleanup: If there are clusters that were not properly separated during Pixie cell clustering, this provides the option of defining manual thresholds based on marker intensity to combine or separate specific clusters\n",
                 "2. Marker thresholding: For markers that were not directly used for clustering, but whose expression is important for phenotyping individual cells, this provides the user with visualization to determine accurate thresholds for positive/negative classification"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 1,
+            "execution_count": null,
             "id": "94732e91-d7c8-4f7c-a94d-cee6139c8d6a",
             "metadata": {
                 "tags": [
                     "import"
                 ]
             },
             "outputs": [],
@@ -45,15 +45,15 @@
                 "Here we are using the example data located in `/data/example_dataset/input_data`. To modify this notebook to run using your own data, simply change `base_dir` to point to your own sub-directory within the data folder.\n",
                 "\n",
                 "* `base_dir`: the path to all of your imaging data. This directory will contain all of the data generated by this notebook, as well as the data generated by cell clustering."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 2,
+            "execution_count": null,
             "id": "69c8e900",
             "metadata": {
                 "tags": [
                     "base_dir"
                 ]
             },
             "outputs": [],
@@ -99,15 +99,15 @@
                 "* `cell_table_name`: the name of the cell table containing the cluster labels\n",
                 "* `segmentation_dir`: the path to the directory containing the segmentation masks\n",
                 "* `image_dir`: the path to the directory containing the image data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 3,
+            "execution_count": null,
             "id": "52bc223f-6e8d-4cae-a53d-2dca4b3c5c87",
             "metadata": {
                 "tags": [
                     "file_path"
                 ]
             },
             "outputs": [],
@@ -128,15 +128,15 @@
             "metadata": {},
             "source": [
                 "The following directories will be automatically created without any user input required"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 5,
+            "execution_count": null,
             "id": "01308ac6-c939-482e-8751-2078a0122727",
             "metadata": {
                 "tags": [
                     "dir_set"
                 ]
             },
             "outputs": [],
@@ -180,15 +180,15 @@
                 "* `populations`: list of clustering populations to use for plotting\n",
                 "* `marker`: the channel whose expression will be used to determine problematic cells\n",
                 "* `threshold`: value that will be plotted with a vertical line for visualization purposes to aid identification of the correct value"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 6,
+            "execution_count": null,
             "id": "d6f06ccc-c1b2-4f22-a10c-b53d7203541c",
             "metadata": {
                 "tags": [
                     "identify_threshold"
                 ]
             },
             "outputs": [
@@ -225,15 +225,15 @@
                 "* `problematic_cluster`: the name of the new population that will be created based on the threshold\n",
                 "\n",
                 "This process of identifying thresholds and creating new populations can be repeated for each population where a problem was identified during the clustering process. We recommend making a copy of the cell below for each modification so that you have a record of what changes were made. "
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 7,
+            "execution_count": null,
             "id": "074cd479-e6ac-4b48-ba1a-8087133dab5f",
             "metadata": {
                 "tags": [
                     "split_problematic_clusters"
                 ]
             },
             "outputs": [],
@@ -258,15 +258,15 @@
             "source": [
                 "### Manual inspection of problematic clusters with Mantis\n",
                 "Once you've pulled out the problematic cells into new clusters, you'll need to visually inspect them to determine which cluster they belong to. The code below will create a directory to enable easy visualization with Mantis Viewer. See the [Mantis section of the README](../README.md#mantis-viewer) for an overview of how to use Mantis. You can then manually inspect each of the newly created clusters to determine what the true cell type is."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 8,
+            "execution_count": null,
             "id": "4c9f1ecd-dc67-47c1-9f72-27ea0d893549",
             "metadata": {
                 "tags": [
                     "mantis_manual_inspection"
                 ]
             },
             "outputs": [],
@@ -283,15 +283,15 @@
             "source": [
                 "### Determine final cluster assignment\n",
                 "Once you've inspected each of the clusters, you'll need to decide what their final assignment should be. You can either merge them back in with their original cluster, combine them with a different existing cluster, or create a new cluster, depending on what you found after manual inspection."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 9,
+            "execution_count": null,
             "id": "7f3d31ac-8309-4740-846b-49a7ea94f369",
             "metadata": {
                 "tags": [
                     "final_cluster_assignment"
                 ]
             },
             "outputs": [],
@@ -302,15 +302,15 @@
                 "\n",
                 "# assign problematic cluster new name\n",
                 "cell_table.loc[cell_table['cell_meta_cluster'] == problematic_cluster, 'cell_meta_cluster'] = final_assignment"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 10,
+            "execution_count": null,
             "id": "363d9b96-5b02-4cbd-a6d3-1e0963292a51",
             "metadata": {
                 "tags": [
                     "updated_cell_table"
                 ]
             },
             "outputs": [],
@@ -335,15 +335,15 @@
             "source": [
                 "### Set up variables\n",
                 "To evaluate the marker levels, we use the modified cell table from the previous step. In addition, we select which markers need to be thresholded"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 11,
+            "execution_count": null,
             "id": "b1f2a1a1-28fe-4386-9b7b-e78579210736",
             "metadata": {
                 "tags": [
                     "marker_thresholding_vars"
                 ]
             },
             "outputs": [],
@@ -362,15 +362,15 @@
             "source": [
                 "### Create Mantis project with functional marker counts\n",
                 "To identify the appropriate threshold, we will include the counts of the markers in the mantis directory. The code below will include the specified functional markers for mantis to view"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 12,
+            "execution_count": null,
             "id": "52cec373-71cf-418a-a16b-a2bacfdf5d04",
             "metadata": {
                 "tags": [
                     "mantis_marker_counts"
                 ]
             },
             "outputs": [],
@@ -393,15 +393,15 @@
             "source": [
                 "### Identify plausible range for a given marker threshold\n",
                 "To get a rough idea of what range works for a given functional marker, we can plot its expression across cell types that we do, and do not, expect to be positive for it"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 13,
+            "execution_count": null,
             "id": "a70d705c-a89d-4e92-a0bd-fb60442784f1",
             "metadata": {
                 "tags": [
                     "marker_threshold_range"
                 ]
             },
             "outputs": [
@@ -441,15 +441,15 @@
             "source": [
                 "### Record threshold values\n",
                 "After manual inspection, you'll need to record the value you selected as a threshold for each marker. Fill in the list below with the values you selected, adding additional brackets as necessary for all of the markers you wish to annotate"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 14,
+            "execution_count": null,
             "id": "9ffe19ba-b330-48df-b0fd-7e61efb280f6",
             "metadata": {
                 "tags": [
                     "threshold_list_vars"
                 ]
             },
             "outputs": [],
@@ -470,15 +470,15 @@
             "source": [
                 "### Update cell table\n",
                 "Finally, you'll update your cell table with the thresholded values. The code below will add a new column named `{marker}_threshold` for each of the indicated marker, with a value of `True` if it's greater than or equal to the threshold, and a value of `False` otherwise."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 15,
+            "execution_count": null,
             "id": "c24ba9cf-a1c8-4005-b1ad-67986173c6c9",
             "metadata": {
                 "tags": [
                     "cell_table_threshold"
                 ]
             },
             "outputs": [],
@@ -503,16 +503,15 @@
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
-            "pygments_lexer": "ipython3",
-            "version": "3.8.8"
+            "pygments_lexer": "ipython3"
         },
         "vscode": {
             "interpreter": {
                 "hash": "31e90e2a7155cbaa93471c58eaf30b3c41423e5d17fccea222aec5e482389189"
             }
         }
     },
```

### Comparing `ark-analysis-0.6.3/templates/Calculate_Mixing_Scores.ipynb` & `ark-analysis-0.6.4/templates/Calculate_Mixing_Scores.ipynb`

 * *Files 21% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9878596289492672%*

 * *Differences: {"'cells'": "{1: {'source': {insert: [(1, '\\n'), (3, 'import seaborn\\n'), (4, 'from alpineer "*

 * *            "import misc_utils\\n'), (8, 'from ark.analysis.neighborhood_analysis import "*

 * *            "(compute_cell_ratios, compute_mixing_score, create_neighborhood_matrix)\\n'), (9, "*

 * *            "'from ark.utils import example_dataset')], delete: [8, 7, 5, 1]}}, 11: {'source': "*

 * *            "['### Define cell populations of interest and compute neighbors matrices']}, 13: "*

 * *            "{'id': '674c5be8-5cf6 […]*

```diff
@@ -17,22 +17,23 @@
                 "tags": [
                     "import"
                 ]
             },
             "outputs": [],
             "source": [
                 "import os\n",
-                "import seaborn\n",
+                "\n",
                 "import pandas as pd\n",
+                "import seaborn\n",
+                "from alpineer import misc_utils\n",
                 "\n",
                 "import ark.settings as settings\n",
-                "from ark.analysis.neighborhood_analysis import compute_mixing_score, create_neighborhood_matrix, compute_cell_ratios\n",
                 "from ark.analysis import spatial_analysis_utils\n",
-                "from ark.utils import example_dataset\n",
-                "from alpineer import misc_utils"
+                "from ark.analysis.neighborhood_analysis import (compute_cell_ratios, compute_mixing_score, create_neighborhood_matrix)\n",
+                "from ark.utils import example_dataset"
             ]
         },
         {
             "cell_type": "markdown",
             "id": "807b26b6-e1c9-437e-86b1-0f86af92250a",
             "metadata": {},
             "source": [
@@ -168,67 +169,79 @@
             ]
         },
         {
             "cell_type": "markdown",
             "id": "79354c69-e1e3-441a-a4d0-4024d28c5b90",
             "metadata": {},
             "source": [
-                "### Define cell populations of interest and compute neighbors matrices\n",
-                "**If you have already generated a neighborhood matrix you would like to use, specify the file and read in the data below.**"
+                "### Define cell populations of interest and compute neighbors matrices"
+            ]
+        },
+        {
+            "cell_type": "markdown",
+            "id": "2dc376c4-4b3c-4ffa-a659-b68e87a4dbdd",
+            "metadata": {},
+            "source": [
+                "We will now define the neighbors matrix, which will be used as our input for mixing analysis. For each cell in the cell table, count the number of each cell phenotype within a certain distance of that cell. If a cell has no other cells within the distance specfied by `pixel_radius`, that cell is excluded from the analysis.\n",
+                "\n",
+                "The neighbors matrix will be saved in the `neighbors_mat_dir`.\n",
+                "- `pixel_radius`: radius used to define the neighbors of each cell\n",
+                "- `cell_type_col`: name of the column in your cell table containing cell phenotypes\n"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
-            "id": "e89d309e-95be-4880-a1e0-88348d90f14b",
+            "id": "674c5be8-5cf6-4d8d-9aaa-7ba3291a65b8",
             "metadata": {
-                "tags": []
+                "tags": [
+                    "neighbor_mat_args"
+                ]
             },
             "outputs": [],
             "source": [
                 "pixel_radius = 50\n",
                 "cell_type_col = 'cell_meta_cluster'\n",
                 "\n",
-                "neighbors_file_name = f\"neighborhood_counts-{cell_type_col}_radius{pixel_radius}.csv\"\n",
-                "neighbor_counts = pd.read_csv(os.path.join(neighbors_mat_dir, neighbors_file_name))"
+                "counts_path = os.path.join(neighbors_mat_dir, f\"neighborhood_counts-{cell_type_col}_radius{pixel_radius}.csv\")\n",
+                "freqs_path = os.path.join(neighbors_mat_dir, f\"neighborhood_freqs-{cell_type_col}_radius{pixel_radius}.csv\")"
             ]
         },
         {
             "cell_type": "markdown",
-            "id": "2dc376c4-4b3c-4ffa-a659-b68e87a4dbdd",
+            "id": "3d99f19f-a14a-4d76-990b-db5b80a9cef8",
             "metadata": {},
             "source": [
-                "**If you would like to create a neighborhood matrix based on a different radius or cell clustering, run the following.**\n",
-                "\n",
-                "The neighbors matrix will be saved in the `neighbors_mat_dir`.\n",
-                "- `pixel_radius`: radius used to define the neighbors of each cell\n",
-                "- `cell_type_col`: name of the column in your cell table containing cell phenotypes\n",
-                "\n",
-                "**Note: any cells that have no neighbors within the `pixel_radius`, will be excluded from the following analysis.**"
+                "**If you have previously generated a neighbors matrix with the `pixel_radius` and `cell_type_col` specified, the data will be loaded in below. Otherwise, a new neighbors matrix will be created.**"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "id": "80357476-1752-455f-b5cb-84de970e0140",
             "metadata": {
                 "tags": [
                     "cell_neighbors"
                 ]
             },
             "outputs": [],
             "source": [
-                "pixel_radius = 50\n",
-                "cell_type_col = 'cell_meta_cluster'\n",
-                "\n",
-                "# determine number of each cell type in specified distance around each cell\n",
-                "neighbor_counts, _ = create_neighborhood_matrix(all_data, dist_mat_dir, distlim=pixel_radius, cluster_name_col=cell_type_col)\n",
-                "\n",
-                "# save the neighborhood matrix\n",
-                "neighbor_counts.to_csv(os.path.join(neighbors_mat_dir, f\"neighborhood_counts-{cell_type_col}_radius{pixel_radius}.csv\"), index=False)"
+                "# Check for existing neighbors matrix\n",
+                "if os.path.exists(counts_path) and os.path.exists(freqs_path):\n",
+                "    neighbor_counts = pd.read_csv(counts_path)\n",
+                "    neighbor_freqs = pd.read_csv(freqs_path) \n",
+                "\n",
+                "else:\n",
+                "    # Create new matrix with the radius and cell column specified above\n",
+                "    neighbor_counts, neighbor_freqs = create_neighborhood_matrix(\n",
+                "        all_data, dist_mat_dir, distlim=pixel_radius, cell_type_col=cell_type_col)\n",
+                "\n",
+                "    # Save neighbor matrices\n",
+                "    neighbor_counts.to_csv(counts_path, index=False)\n",
+                "    neighbor_freqs.to_csv(freqs_path, index=False)"
             ]
         },
         {
             "cell_type": "markdown",
             "id": "1db05c17-992e-4482-ba3f-971f870174be",
             "metadata": {},
             "source": [
@@ -290,35 +303,42 @@
                 "population_2_cells = ['CD8T']\n",
                 "\n",
                 "bins = 30"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 17,
+            "execution_count": 11,
             "id": "23460a01-c77c-40b4-b5b9-33fa22a9c224",
             "metadata": {
+                "execution": {
+                    "iopub.execute_input": "2023-06-14T19:21:27.323158Z",
+                    "iopub.status.busy": "2023-06-14T19:21:27.322807Z",
+                    "iopub.status.idle": "2023-06-14T19:21:27.799166Z",
+                    "shell.execute_reply": "2023-06-14T19:21:27.798486Z",
+                    "shell.execute_reply.started": "2023-06-14T19:21:27.323134Z"
+                },
                 "tags": [
                     "ratio_plots"
                 ]
             },
             "outputs": [
                 {
                     "data": {
-                        "image/png": "iVBORw0KGgoAAAANSUhEUgAABQIAAAGjCAYAAAB31miZAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy88F64QAAAACXBIWXMAAA9hAAAPYQGoP6dpAABZWklEQVR4nO3de1yUdf7//ycHEQUGoYQSLcUMNUHzVGSLZrqetjUrd81WMU/Ympnmt7RaV4vSbNtq0VxSycNWaqWZqBRZix8rtaOmZbGiprihoTKgqMDM749+zDYNIocLZpjrcb/dutm857re83pf7xHfPr0OPna73S4AAAAAAAAAXs3X3QUAAAAAAAAAqHsEgQAAAAAAAIAJEAQCAAAAAAAAJkAQCAAAAAAAAJgAQSAAAAAAAABgAgSBAAAAAAAAgAkQBAIAAAAAAAAmQBAIAAAAAAAAmABBIAAAAAAAAGACBIEAAJjc0aNHFRMTo5kzZ9bp56xbt04xMTFat25dnX4O6tfOnTsVExOjlJSUOv2clJQUxcTEaOfOnXX6OWbXt29f9e3b191lAACAOuLv7gIAAGjoYmJinF77+vrKYrEoJiZGw4cP12233eamyurXzp07NXr0aN1///2aMmWKu8upEqvVqrVr1+rbb7/Vt99+q0OHDqmsrEyvvPKKbrrpphr3u2XLFj344IP6xz/+oQEDBlx0u6NHj+rWW291avPz81OzZs3UqVMn3XPPPerdu3eN62hI1q1bp1mzZmnevHm644473F1OlXz++efaunWrdu7cqdzcXBUVFSkiIkLx8fGaOHGirr766ir3VT7+X2rUqJGaN2+url27asKECWrfvn2tax41apR27dql7777rtZ9AQCAhocgEAAAg9x///2SpNLSUuXk5DgCgr1797r8Bd+M+vfvr86dOysiIsLdpTjk5ubq2WeflSRdccUVCgsL008//VTrft9//30FBgYqISGhStuHhIQoMTFRknT+/Hnt379fWVlZysrK0mOPPabRo0fXuqaG7p577tHgwYPVokULd5fi8MADD+jkyZO6/vrrddttt8nf319ffvml3nzzTW3evFlpaWm6/vrrq9Vn+/bt1a9fP0lSUVGRvvjiC6Wnp+u9997T8uXL1a1bt7oYisPy5cvrtH8AAOBeBIEAABjk12fBffLJJ7r33nu1YsUKjRo1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Jzs9OMLf398RIO3Zs6fWtdXEF198ofz8/GpfFmy1Wh3fn7/97W+aMGGCHnvsMUk/B1SBgYF65513VFJSoj/96U9OgVf5NkFBQdqwYUOFl7bed999jhBQkho3buw4g6uuvj9RUVEVng131113KTg42JDvT22OyYwZM5zC2qZNm+q2226TzWar8BLcqjpy5IiefPJJ+fv7X/QS68p8++23ju/CvHnzdOedd+qNN95QRESEHnnkEZftK7qnX0BAgO655x6Vlpbqk08+qdE4fumtt96Sj4+PZs6c6XRW4mWXXab77rtP0s8B7y/5+/tXeAajp93nEQAAs+GMQAAADLJw4UJJP18WaLFY1K1bN911110aOnSoJOmbb76RJN14440u+/r7+6tHjx7Kzc3VN9984/Jk1F9ealuuVatWuvLKK5Wbmyur1WrImUe/ZLfb9c4772j9+vXav3+/rFarysrKHO83atSo1p9Rm2PSqVMnl32uvPJKSXK5B119ef/99+Xj4+O4VLqqCgsLHd8fPz8/hYaGKiEhQX/605/Uu3dvSZUfq9DQUHXs2FGffvqpcnJy1L59e6f3K/r+dOvWTX5+fvr222+rVWtVlZSUaM2aNdq0aZMOHDigwsJC2Ww2x/t5eXm1/ozaHJO6+P7k5+drwoQJOnnypGbPnl3tJwZL0v79+7V//36nthYtWujVV1+t8InJx44d05IlS/TJJ5/ov//9r86dO+f0fm2Pc1FRkQ4fPqzIyEiXsFX637H/5ffotttu0/z58zVkyBANHjxYPXv2VNeuXQkBAQDwAASBAAAY5Lvvvqv0/fIHF1zsksPy9ooecPDry+vKXX755crNzVVhYaHhQeC8efO0YsUKNW/eXDfffLMiIyMVGBgoSY77jNVWbY5JRU8gLj8D7ZeBU33KzMxUbGxshQ+QqExUVJQ++OCDSrep6rGyWq0u711++eUubf7+/o57t9WFadOmKTMzU61atdKtt96qyy+/3HGG6YoVK1RSUlLrz6jNMano90ttvj/5+flKTEzUwYMH9dhjj9X4PnjDhg3T/PnzZbfblZ+frzfffFMvvPCCJk2apDVr1jg9PfrIkSO66667ZLVa1b17d918880KDg6Wn5+fcnNztX79+mo9/KQi5Q8kutgxjoiIkOR8jO+9916FhYXptdde06pVq7RixQr5+PioR48eevjhhxUbG1urmgAAQM0RBAIAUE/Kg6sTJ05U+H55e0UBV35+vqKjo13af/rpJ5d9fHx8VFpaWuFnVBSIVCQ/P1+rVq3Stddeq9dff93xUIdy6enpVernUmpzTDzNt99+q6NHj+qPf/xjnfRffgx++ukntWvXzuX9yo7VTz/95HI2WWlpqU6dOuU0t76+vo73KlLV78/XX3+tzMxM3XTTTVqyZInTJaI2m01Lly6tUj+XUptjYqTjx49rzJgxysnJ0ezZsw15GIaPj48uv/xyTZo0SQUFBUpLS9MLL7zgeLqy9PO9+06fPq158+a53FcxPT1d69evr3Ud5d+P8p81v1b+ZO9fH+Pbb79dt99+u6xWq7788ktlZmbqrbfe0vjx47VlyxbODgQAwE24RyAAAPWk/Emou3btcnmvtLRUn332mSSpY8eOLu9XtM+RI0f03//+V1FRUU5nN4WGhurHH3902b6srMzlksOLOXLkiGw2m3r16uUSAv744486evSoyz7lZ1P98vLhS6nNMfE0mZmZklTt+wNWVfmx2rlzp8t7VqtV3377rRo3blzh5ZsVHd/PP/9cZWVlFT6ht6LvT1FRkQ4dOlSlWn/44QdJUt++fV3uE7dnzx6Xy1el/4WQNfn+1OSYGOXHH3/UqFGjlJOTo7lz59bJE3EnT56s8PBwvfrqqzpy5Iij/fDhw5Kk3/72ty77VDTnUvWPc3BwsK666irl5eVVOP/lx/5iv0ctFot69+6t5ORkDRs2TKdPn9ann35apc8GAADGIwgEAKCe9OvXT82aNdOmTZv01VdfOb23YsUKHT16VDfddFOF9wFbuXKl06W4NptNCxYskM1mczkTKDY2VseOHXN5GMPixYurfDlv+YNJysOicmfOnNHjjz9e4Rlj5Q9e+O9//1ulz5Bqd0w8TWZmpq655hq1adOmTvr//e9/r0aNGulf//qXIwAq9+KLL6qoqEi///3vK3zAy+LFi53ue3f+/Hn9/e9/lyTdeeedjvbg4GBFR0friy++0H/+8x9He1lZmebNm1dhgFeR8u/Pr8Oo/Px8PfHEExXuExYWJql635/aHBMj5Obm6p577tEPP/ygp59+us7OBg0ODtaECRNUUlLiuJekdPHj/H//93968803K+yr/PdpRQ/guZg777xTdrtdCxYscPp5cPLkSb300kuObcrt2LFDdrvdpZ/yJwaX32IAAADUPy4NBgCgngQFBempp57Sgw8+qD/96U8aOHCgWrRooX379mn79u1q3rz5RUOSrl276vbbb9egQYMUEhKi7du3a//+/bruuus0YcIEp23HjRun7du3689//rMGDx6s0NBQffnllzp69Kh69ux50TOFfql58+YaMmSINm3apNtvv129evVSYWGhPv74YwUEBKhDhw4uD5lo06aNIiMjtWnTJvn7+6tFixby8fHR0KFDnZ54bNQxMcozzzyjU6dOSfo5+JSkZcuW6Z133pH0c1h5qYd/HD58WN9//70mTZpUZ3W2bNlSs2bN0hNPPKFhw4Zp0KBBCg8P16effqovv/xS0dHRmjFjRoX7RkdHa8iQIRo4cKD8/f21detW/fDDD+rTp4/jYTblxo0bp8cee0x33323Bg4cqMaNG2vnzp0qKSlR+/btq3RWaWxsrLp27ar33ntPI0aMUNeuXZWfn69t27apTZs2jvvK/VKXLl3UpEkTrVixQqdPn3bc13DUqFEXvbS3NsfECKNGjVJubq6uu+465ebmKiUlxWWbYcOGqWXLlrX+rJEjRyotLU3vvPOOJk6cqLZt22rkyJFat26dpk6dqgEDBigiIkLZ2dn6v//7Pw0aNEibN2926Sc+Pl4ZGRmaMmWKevfurcaNG6tFixa6/fbbL/rZY8eO1bZt27R161YNHTpUCQkJOnfunDIyMpSfn6/x48c7PfX7/vvvV9OmTdWlSxdFRUXJbrfrs88+09dff63rrrtON910U62PBwAAqBmCQAAA6lG/fv302muvKTU1Vdu3b1dRUZEuv/xyjRgxQn/+858v+pCJRx99VJmZmVq7dq1yc3PVrFkzjR49WlOnTlXjxo2dto2Pj9eiRYu0aNEibdq0SU2bNtVNN92k559/vsKg4mKeeuoptWrVSps3b9arr76q8PBw9e3bVw888IAeeOABl+39/Py0cOFCPffcc8rIyNCZM2dkt9vVrVu3iwaBtTkmRnn33XddzpT85dmUUVFRlwwCyy8LrugSTSPdc889uvrqq5WWlqb33ntPxcXFuvLKKzVu3DhNmjTpog+MefHFF7Vo0SJt3LhRx48fV2RkpKZMmaKJEyfKx8fHadu77rpLdrtdy5cv1/r16xUaGqpbb71V06ZNq3DeK+Ln56fFixfrhRde0LZt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\n",
+                        "image/png": "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zWYdO3ZMiYmJOn36tI4ePWp5mIbZbC7UmLlzvb12SapevboCAwN17Ngxmc1mSzjn6empatWqWfXN7/57d2Pbtm0aMmSIbt68qUmTJqlRo0Z3vW3Tpk3VtGlTSbfuI5h7pl2HDh301ltvWQWy0q0QsFOnTsrKytKhQ4d0/PhxnTx5UkeOHCny/sv9GZDf/nvwwQfl7u5u2cePP/645s6dq08++UQbN27UQw89pJYtW+rhhx9W5cqVC/W+AADAeRECAgDgBCZOnKjOnTvfVd+rV69aXer7R1WqVJGkPE8dzW3/o9wxrl69WphSC5SamqqJEydq7dq1unnzplxcXFSjRg01bdo0Tyh5N65duyZJBd7HraC55he+5Z4ZdvsZcraWmZmp+Ph4DRs27K63qV69urZs2XJXfXPX6s/2yY0bNyxtAQEB+e6T3PW/cuXKXdd6J99++62mTZtmOePO19dXoaGhql+/vrZv317ofZ871/wCYOnWXM+ePavMzExLqGartV+9erXeeOMN5eTkaNKkSerYsWOham/atKnVZe6DBw/WCy+8oC+//FLly5fX66+/nmeblStXas6cOZYHcVSoUEFhYWGqW7euDhw4UOT9l99nxc3NTRUrVrR8TqpUqaJPP/1Uc+fO1ebNm7Vu3TqtW7dO5cqV09///neNHj3a7uE5AACwP0JAAABKGV9f3wKf2Jn7ZNfbz7rL7zLY3PAnt++dwpLbg7b8xMXFadu2beratas6deqkkJAQywMq1q9f/6fb3y43/ClorqmpqVb1O4P9+/crPT292PcDLMif7ZP81v+PgeAf5YZEt++/29e/oO3/6Mcff9TQoUNVtWpVTZkyRY0aNVJQUJBcXFy0aNEibd++/U/HuN3dzNXLyyvPWXXF9d5772natGny9PTU9OnTLU+yLg5fX1/9+9//1t///nctW7ZM9erVs7oceMOGDRozZozq1aun0aNH64EHHrA8sGXcuHE6cOBAkd5TurX/KlasaPVaTk6Orl69anXWZFBQkCZMmKDs7Gz997//1ffff6/Vq1fr008/VYUKFRQXF1eUqQMAACfCPQEBAChlQkJClJaWpv/97395XtuzZ48k6f7777dq/+mnn/L0zQ0WwsLCJN26BFm6dfni7XKfUFyQtLQ0bdu2TQ0bNtRbb72liIgISwB49uxZpaenW4VLf7xnW0H8/PwUFBSk48eP53s/tL1790rKO1dH2r59u6pVq6Y6derYZfzch2js378/z2uZmZn66aefVKlSJQUEBFja09PTlZiYmKf/gQMHVKFCBd17772Sfj+L7vb1z31C8Z2sXbtWZrNZY8eOVYcOHVSjRg3LGud+Tgu7/nea6/nz53XixAmbPK33jz788ENNmzZNfn5+Wrx4sU0CwFz33HOPxo4dK+nWmb9nz561vPbVV19Jkt59913FxMRYPbH5559/llT4s1hz76O4b9++PK/997//VXp6umX/bdq0SWPGjNHVq1fl5uam8PBwDR48WB9//HGBYwAAgNKHEBAAgFIm99LECRMmWJ2llZiYqIULF8rb21uPPfaY1TabNm2yhGaSdOHCBc2ZM0fe3t7629/+JkmqWbOm3NzctGvXLqtxt27dqsOHD9+xJg8PD7m5uSktLc3q3ms3btzQuHHjJEk3b960tLu737oYISsr60/neuPGDU2ePNnqgQV79+7Vp59+qsqVK1s9IMPRtm/frqioKLuNHxERoRo1auibb76xOrvObDZr8uTJunz5sjp06JDnARZTp061WpelS5fqxIkT6tChg+VBHrVr15Z0a71zZWRkaPHixX9aV+7ZeBcuXLBq37lzpyXg+uNa577nHz8Tt2vTpo38/Py0YsUKq/tWZmZm6q233lJ2dnahL9O9k8OHD+udd96Rh4eHFi9enO+99IorJiZGjz32mNLT0/Xmm29a2gvaf2vWrNHu3bslWe+/u/n/p3379nJzc9OCBQusAscrV65owoQJkn7/WXLixAmtXLlSK1assBojd7u//OUvhZonAABwTlwODABAKdOpUydt3rxZmzZtUocOHdSyZUulpaVp06ZNysjI0IQJE/LczN/X11d9+vTR448/Lj8/P23atEkXLlzQm2++aTnrqGLFinr00Uf1zTff6KmnnlKrVq10+vRpbdmyRY0bN77j2UBeXl6KiYnR119/raeeekoPPfSQ0tPTtXXrVl24cEHly5fXlStXLA9xyL1PXXx8vCZNmqRHH30039BlwIAB+v777/X555/ryJEjatasmZKTk7V582a5u7tr8uTJd/0ADnu7cOGCjh49qhdeeMFu7+Hm5qZJkybpueee04ABAxQdHa3q1atrz549OnTokBo0aKAhQ4bk2W7//v36xz/+oRYtWigx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",
                         "text/plain": [
                             "<Figure size 1600x400 with 2 Axes>"
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 },
                 {
                     "data": {
-                        "image/png": "iVBORw0KGgoAAAANSUhEUgAABQIAAAGjCAYAAAB31miZAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy88F64QAAAACXBIWXMAAA9hAAAPYQGoP6dpAABThklEQVR4nO3deViU9d7H8c8AggoMiAsdAUssccNIzSVLjTSlTVs8eSw3TLHUyuqULXb0yZNe7YVmamrqMVNLstyOZKaPLW6llqmplCEelzQYcANm5vmjwzzhALIMzA33+3VdXcZv7vs337m/oD8/3ovF6XQ6BQAAAAAAAKBG8/F2AQAAAAAAAAAqH0EgAAAAAAAAYAIEgQAAAAAAAIAJEAQCAAAAAAAAJkAQCAAAAAAAAJgAQSAAAAAAAABgAgSBAAAAAAAAgAkQBAIAAAAAAAAmQBAIAAAAAAAAmABBIAAAJnfkyBHFxMRo/Pjxlfo+y5cvV0xMjJYvX16p74OqtWXLFsXExCg5OblS3yc5OVkxMTHasmVLpb6P2cXHxys+Pt7bZQAAgEri5+0CAACo7mJiYgp97ePjI6vVqpiYGPXv31+33367lyqrWlu2bNHgwYM1ZswYjR071tvllMrevXv12Wef6csvv9SRI0eUmZmpevXq6dprr9Xw4cPVunXrcs27Zs0aPfroo3rrrbfUu3fvYrc7cuSIbrrppkJjvr6+Cg0NVZs2bXTfffepe/fu5aqhulm+fLmefvppTZkyRXfddZe3yymVY8eOKSUlRXv37tXevXuVnp4up9OpdevW6fLLLy/TXAWf/89q1aqlhg0bql27dhoxYoRatGhR4ZoHDRqkrVu3av/+/RWeCwAAVD8EgQAAeMiYMWMkSfn5+UpLS9P69eu1ZcsW/fDDD25/wTejXr166eqrr1ajRo28XYrLP/7xD+3atUutW7dWr169VLduXe3bt0+rVq3Sv//9b73++uu6+eabyzzvZ599ptq1a6tbt26l2j44OFhDhgyRJF24cEH79u3Txo0btXHjRj377LMaPHhwmWuoae677z7dcsstaty4sbdLcfnhhx/0xhtvyGKxKDIyUsHBwbLZbBWas0WLFurZs6ckKScnR99++61WrlypdevW6b333lP79u09UXqx3nvvvUqdHwAAeBdBIAAAHnLxWXBff/21hg0bpvnz52vQoEGKjIz0UmXGEBwcrODgYG+XUcjtt9+ul19+2e3srU8++UR///vfNWHCBPXo0UP+/v6lnjM3N1dffPGFunbtqjp16pRqH6vV6vb989FHH+mZZ57R66+/rv79+5d6rpoqLCxMYWFh3i6jkDZt2mjRokVq0aKFgoKCXGfbVUTLli3dvheef/55LVmyRG+88YYWLlxYofkvpUmTJpU6PwAA8C7uEQgAQCXp0qWLoqOj5XQ69f3337vGf/jhB40dO1ZdunRRmzZtdOONN2rixIk6ceKE2xzjx49XTEyM0tPTNW/ePPXp00exsbHq1q2bXnzxReXk5LjtExMTo0GDBhVZU8F8R44cuWT9P//8s1555RXddddd6ty5s6vWCRMm6NixY27zFpy1Nm3aNMXExLj+K7inW0n3CCzPMTly5Ig++OAD3X777YqNjdV1112nCRMmKDs7+5KfrcCgQYOKvITzjjvu0BVXXKHMzEz99NNPpZ5Pkr755hvl5OSoV69eZdrvYnfddZfq1q2rs2fP6sCBA67xr7/+WsOHD1fHjh3Vpk0b9e7dW6+88kqRn3vQoEGKiYlRbm6uXn/9dcXHx6tNmzbq2bOnpk2bptzc3ELbX+p+kQXzlcYPP/ygyZMn64477lDHjh0VGxurm2++WVOnTlVWVpbbvAVnzT799NOFvn8KvldLukdgeY5Jfn6+3nnnHd18881q06aNunfvrpdfftntmJTksssuU4cOHRQUFFTqfcrjnnvukfTHMb3Y8uXLNXbsWN10001q27at2rVrpwEDBmjFihWFtivobUFQ+edj/OffL4q7R2Bubq5mzZql22+/XVdffbXatWungQMHavXq1UXWvH79eg0ZMkTXX3+92rRpo+uvv17333+/Fi1aVO7jAAAAKo4zAgEAqEROp1OSZLFYJEkbNmxwne3Tu3dvNW7cWHv27NHixYu1fv16vf/++4qKinKb58UXX9T27duVkJCg4OBgbd68WfPnz9f27du1ePFiBQQEeLz21NRUffDBB+rUqZPatWunWrVq6cCBA1q2bJk2bNigjz76SOHh4ZLkupQxJSVFHTt2VMeOHV3zRERElPg+5T0mL7/8sjZv3qwbb7xRXbt21ZYtW7R06VIdPnxYCxYsqPDn9/PzK/RraaWmpsrPz0833nhjhWu4+Pvngw8+0MSJE1WnTh316dNH9evX19atWzV79mxt2LBBixcvltVqdZvnkUce0ffff68+ffrIz89P69evV3Jysn744QfNmDHDNb8nLV26VJ999pmuvfZaXXfddXI4HNqzZ4/mzZunTZs2aenSpa4A7c4771RwcLDWr1+vm266SS1btnTNU9Tn+bPyHpPHH39cO3bs0A033KDu3btr06ZNevfdd3X69GlNmTLFswfDQ4r6Xpw4caKuvPJKXXvttWrYsKEyMzO1ceNGPfnkk/r555/16KOPSvrjOI4ZM0YpKSnKyMhw3cpAuvTPaG5uroYPH66tW7cqOjpaAwcO1Pnz5/Xvf/9b48aN0759+/TYY4+5tl+yZImef/55NWzYUDfeeKPq1aunU6dOaf/+/Vq+fLnuu+8+zxwQAABQZgSBAABUkq+++ko///yzLBaLYmNjdebMGY0fP152u10LFy5Uhw4dXNvOmjVLr776qv7xj39o7ty5bnN9++23+vjjj11/YX/88cf1yCOPaN26dXr33Xc1evRoj9fft29fDR061O2y2M2bN2vEiBF6++23NWnSJEl/BIHBwcGuILC0DwupyDHZtWuXPv30U9c94/Lz8zVkyBBt2bJFu3fvVtu2bcv70bVz504dPHhQ4eHhuuqqq0q9n8Ph0Pr163XttdcqNDS03O8v/XFp8Llz51S3bl1dddVVysjI0OTJk1W3bl0tW7ZMzZo1c207ceJELV68WC+//LJeeOEFt7nS0tK0atUqhYSESJLGjRunwYMHa8OGDVqxYoX69etXoVqLkpSUpH/84x/y9fUtNL5s2TI999xzev/99zVy5EhJcj0cZP369erZs2epHxZSkWOSnp6ulStXuvo0btw49e3bVx9//LEee+wxNWzYsDwfu1IsXbpUkoq8P+DKlSvdLufNzc3ViBEjNHv2bP3tb39TeHi46/LzrVu3KiMjo0wP9Jk3b562bt2qbt26acaMGa5AcsyYMerfv79mzpypHj16qF27dpL+CAJr1aqlFStWqH79+oXmOn36dJk+OwAA8CwuDQYAwEOSk5OVnJys119/XQ8//LAeeOABOZ1ODRkyRBEREVq/fr0yMzN1yy23FAq8JCkxMVERERH68ssvdfToUbe5Bw8eXOisHR8fHz355JPy8fHRRx99VCmfJzw8vMh7411//fW68sortXnz5gq/R0WOyejRows9OMLPz88VIO3evbvcNWVmZuqpp56S9MdlqhcHWSX59ttvderUqTJfFmyz2VzfP6+88opGjBihZ599VtIfAVXt2rX1ySefKC8vT/fff3+hwKtgm8DAQK1YsaLIS1sffPBBVwgoSQEBAa4zuCrr+yciIqLIY3fPPfcoKCjII98/FTkmTzzxRKGwtm7durr99tvlcDiKvAS3quzdu9f1vTBlyhTdfffdWrZsmRo1auT6vvyzou7p5+/vr/vuu0/5+fn6+uuvK1zTRx99JIvFovHjxxc6K7F+/fp68MEHJf0R8P6Zn59fkWcwGu0+jwAAmA1nBAIA4CHTpk2T9MdlnFarVe3bt9c999yjvn37SpJ+/PFHSVLnzp3d9vXz89O1116rjIwM/fjjj25PRv3zpbYFoqKi9Je//EUZGRmy2WyXvISyrJxOpz755BOlpKRo3759stlsstvtrtdr1apV4feoyDFp06aN2z5/+ctfJMntHnSldfbsWT300EP65Zdf9MADDyghIaFM+3/22WeyWCyuS6VLKzs72/X94+vrq5CQEHXr1k3333+/unfvLqnkYxUSEqJWrVpp27ZtSktLU4sWLQq9XtT3T/v27eXr66u9e/eWqdbSysvL05IlS7Rq1SodOnRI2dnZcjgcrtePHz9e4feoyDGpjO8fT9i3b5/27dtXaKxx48ZatGhRkU9MPnr0qGbPnq2vv/5a//nPf3T+/PlCr1f0OOfk5Ojw4cMKDw93C1ul/z/2f/4+uv322zV16lTdeuutuuWWW9SxY0e1a9eOEBAAAAMgCAQAwEP2799f4usFDy4o7pLDgvGiHnBw8eV1BRo0aKCMjAxlZ2d7PAicMmWK5s+fr4YNG+r6669XeHi4ateuLUmu+4xVVEWOSVFPIC44A+3PgVNpnT17VklJSdqxY4eGDRumv//972WeIzU1VbGxsa57J5ZWRESEPv/88xK3Ke2xstlsbq81aNDAbczPz89177bKMG7cOKWmpioqKko33XSTGjRo4DrDdP78+crLy6vwe1TkmBT181KR7x9PufPOOzV16lQ5nU6dOnVKH374od544w2NGjVKS5YsKfT06PT0dN1zzz2y2Wzq0KGDrr/+egUFBcnX11cZGRlKSUkp08NPilLwQKLijnGjRo0kFT7Gw4YNU7169fT+++9r4cKFmj9/viwWi6699lo9+eSTio2NrVBNAACg/AgCAQCoIgXB1cmTJ4t8vWC8qIDr1KlTio6Odhv/7bff3PaxWCzKz88v8j2KCkSKcurUKS1cuFDNmzfX4sWL3Z6KunLlylLNcykVOSaelJOTo6SkJG3fvl0PPPBAuULAvXv36siRI7r33nsrocL/Pwa//fZbkfctLOlY/fbbb25nk+Xn5+v3338v1FsfHx/Xa0Up7ffP999/r9TUVF133XWaPXt2oUtEHQ6H3n333VLNcykVOSZGZ7FY1KBBA40aNUpZWVmaO3eu3njjDdfTlaU/7t2XmZmpKVOmuN1XceXKlUpJSalwHQXfHwW/11ys4MneFx/jfv36qV+/frLZbPruu++Umpqqjz76SA888IDWrFnD2YEAAHgJ9wgEAKCKFDwJdevWrW6v5efna/v27ZKkVq1aub1e1D7p6en6z3/+o4iIiEJnN4WEhOjYsWNu29vtdrdLDouTnp4uh8Ohrl27uoWAx44d05EjR9z2KTib6s+XD19KRY6Jp2RnZ2v48OHavn27Ro0aVa4QUPrjbEBJZb4/YGkVHKstW7a4vWaz2bR3714FBAQUeflmUcd3x44dstvtRT6ht6jvn5ycHP3yyy+lqvXXX3+VJMXHx7vdJ2737t1ul69K/x9Cluf7pzzHpDoZPXq0wsLCtGjRIqWnp7vGDx8+LEm6+eab3fYpqudS2Y9zUFCQmjRpouPHjxfZ/4JjX9zPqNVqVffu3TV58mTdeeedyszM1LZt20r13gAAwPMIAgEAqCI9e/ZUaGioVq1apZ07dxZ6bf78+Tpy5Iiuu+66Iu8DtmDBgkKX4jocDr300ktyOBxuZwLFxsbq6NGjbg9jmDFjRqkv5y14MElBWFTgzJkzeu6554o8Y6zgwQv/+c9/SvUeUsWOiSdkZWVp6NCh2rlzp8aOHatx48aVe67U1FRdeeWVatq0qQcr/H933HGHatWqpX/961+uAKjAm2++qZycHN1xxx1FPuBlxowZhe57d+HCBb322muSpLvvvts1HhQUpOjoaH377bc6ePCga9xut2vKlClFBnhFKfj+uTiMOnXqlP7nf/6nyH3q1asnqWzfPxU5JtVJUFCQRowYoby8PNe9JKXij/P//u//6sMPPyxyroKf06IewFOcu+++W06nUy+99FKh3w9Onz6tt99+27VNgW+++UZOp9NtnoInBhfcYgAAAFQ9Lg0GAKCKBAYG6p///KceffRR3X///erTp48aN26sPXv2aPPmzWrYsGGxIUm7du3Ur18/JSQkKDg4WJs3b9a+ffvUunVrjRgxotC2w4cP1+bNm/XQQw/plltuUUhIiL777jsdOXJEHTt2LPZMoT9r2LChbr31Vq1atUr9+vVT165dlZ2dra+++kr+/v5q2bKl20MmmjZtqvDwcK1atUp+fn5q3LixLBaL+vbtW+iJx546Jp4wZswY/fDDD2rSpImcTqeSk5PdtunZs2ehs+aKcvjwYf30008aNWpUZZWqyMhIPf300/qf//kf3XnnnUpISFBYWJi2bdum7777TtHR0XriiSeK3Dc6Olq33nqr+vTpIz8/P61fv16//vqrevTo4XqYTYHhw4fr2Wef1d/+9jf16dNHAQEB2rJli/Ly8tSiRYtSnVUaGxurdu3aad26dRowYIDatWunU6dOadOmTWratKnrvnJ/FhcXpzp16mj+/PnKzMx03ddw0KBBxV7aW5Fj4injx493/X9aWpok6ZVXXlFgYKCkP56SfPETsctj4MCBmjt3rj755BONHDlSzZo108CBA7V8+XI98sgj6t27txo1aqQDBw7of//3f5WQkKDVq1e7zdOlSxetXbtWY8eOVffu3RUQEKDGjRurX79+xb53YmKiNm3apPXr16tv377q1q2bzp8/r7Vr1+rUqVN64IEHCn3GMWPGqG7duoqLi1NERIScTqe2b9+u77//Xq1bt9Z1111X4eMBAADKhyAQAIAq1LNnT73//vuaOXOmNm/erJycHDVo0EADBgzQQw89VOxDJp555hmlpqZq6dKlysjIUGhoqAYPHqxHHnlEAQEBhbbt0qWLpk+frunTp2vVqlWqW7eurrvuOr3++utFBl3F+ec//6moqCitXr1aixYtUlhYmOLj4/Xwww/r4Ycfdtve19dX06ZN06uvvqq1a9fqzJkzcjqdat++fbFBYEWOiScUnCH566+/FjrT6s8iIiIuGQQWXBZc1CWannTffffp8ssv19y5c7Vu3TqdO3dOf/nLXzR8+HCNGjWq2AfGvPnmm5o+fbo+/fRTnThxQuHh4Ro7dqxGjhwpi8VSaNt77rlHTqdT7733nlJSUhQSEqKbbrpJ48aNK7LvRfH19dWMGTP0xhtvaNOmTVq4cKHCw8PV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cerbt68+/PBDOZ1Ob5eGIpw5c0bdunVTTEyMvv/+e2+Xg/9KSUlRv379FBsbq06dOumBBx7Q+fPnvV2W6a1fv179+/fXNddco+uvv16PPPKI0tPTvV2WKR0+fFjPP/+8+vbtq1atWum2224rcrtly5apd+/eio2N1R133KENGzZUcaWo6ViPGhdr0uqD9agxsR41LtakxlCd1qN+Vf6OlSArK0tDhgzRFVdcoeTkZB0/flxTp07V+fPn9fzzz3u7PFN77733FBERofHjx6tevXr66quvNGHCBB07dkxjxozxdnm4yNtvvy273e7tMvAnM2bM0OzZszVq1CjFxcXp999/19dff02fvGzLli0aM2aM+vXrp3HjxikzM1NvvvmmEhMT9emnn6p27dreLtFUDhw4oI0bN+rqq6+Ww+Eo8i/2q1at0oQJEzRq1Ch17txZq1ev1pgxY7Ro0SLFxcVVfdGocViPGhtr0uqD9ajxsB41LtakxlGt1qPOGuCdd95xxsXFOX///XfX2AcffOBs2bKl89ixY94rDM5Tp065jT333HPOdu3aOe12uxcqQnEOHjzojIuLcy5evNjZvHlz5+7du71dkukdOnTI2apVK+cXX3zh7VJwkQkTJjjj4+OdDofDNfb11187mzdv7ty2bZsXKzOnP/958tRTTzlvvfVWt21uvvlm52OPPVZo7N5773U+8MADlV4fzIH1qLGxJq0eWI8aD+tRY2NNahzVaT1aIy4N3rRpk7p06aLQ0FDXWEJCghwOh7788kvvFQaFhYW5jbVs2VI5OTk6e/asFypCcSZPnqwBAwaoadOm3i4F/7V8+XJFRkaqe/fu3i4FF8nPz1dgYKAsFotrLDg4WJK4zMwLfHxKXs6kp6frl19+UUJCQqHxW265RV9//TWXbsIjWI8aG2vS6oH1qPGwHjU21qTGUZ3WozUiCExLS1N0dHShMavVqoYNGyotLc1LVaE4O3bsUHh4uIKCgrxdCv5r7dq1+umnnzR69Ghvl4I/2bVrl5o3b663335bXbp0UZs2bTRgwADt2rXL26WZ3l133aVDhw5p0aJFys7OVnp6ul577TW1atVK7dq183Z5uEjBWuDiv1g2a9ZMeXl53EcHHsF6tPphTWosrEeNifWosbEmrT6MtB6tEUGgzWaT1Wp1Gw8JCVFWVpYXKkJxtm/frtWr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yZKk++67T2FhYZo7d66++eYbde7cufI+NAAAAAyD9SiAmoQgEIChDR06tNDXERERevnll3XZZZdJknx9feXr6ytJcjgcstlscjgcatOmjX788cdyvefGjRslScOGDSs0npiYqLlz52rjxo0svAAAAEyC9SiAmoQgEIChPf/882ratKmys7P10Ucfadu2bYX+tVWSUlJSNHfuXP3888/Ky8tzjUdGRpbrPTMyMuTj46MmTZoUGm/YsKGsVqvrchAAAADUfKxHAdQkBIEADK1t27aup7T17NlTAwcO1OOPP661a9cqMDBQK1as0Pjx49WzZ08NHz5c9evXl6+vr2bOnOm6gXN5WSwWT3wEAAAAVGOsRwHUJDw1GEC14evrq8cee0wnTpzQokWLJEn//ve/FRUVpWnTpqlfv3664YYbdN111+nChQuF9i3LIioiIkIOh0OHDx8uNP7bb7/JZrMpIiKi4h8GAAAA1Q7rUQDVHUEggGqlU6dOatu2rebPn68LFy647sfidDpd2+zatUs7d+4stF+dOnUkSTab7ZLv0b17d0nS/PnzC43Pmzev0OsAAAAwH9ajAKozLg0GUO0MHz5cjzzyiJYvX64ePXpo3bp1Gj16tHr06KEjR47ogw8+0JVXXqmzZ8+69qldu7auvPJKrVmzRldccYVCQ0N11VVXqXnz5m7zt2jRQnfeeaeWLFkim82ma6+9Vt9//71SUlLUs2dPbswMAABgcqxHAVRXBIEAqp2bb75ZTZo00dy5c7V27Vr99ttvWrJkiTZv3qwrr7xSL7/8stauXautW7cW2m/y5Ml64YUXNGXKFOXl5WnMmDFFLrwKto2MjFRKSoo+++wzNWjQQElJSRozZkxVfEQAAAAYGOtRANWVxfnn85cBAAAAAAAA1EjcIxAAAAAAAAAwAYJAAAAAAAAAwAQIAgEAAAAAAAATIAgEAAAAAAAATIAgEAAAAAAAADABgkAAAAAAAADABAgCAQAAAAAAABMgCAQAAAAAAABMgCAQAAAAAAAAMAGCQAAAAAAAAMAECAIBAAAAAAAAEyAIBAAAAAAAAEzg/wBkDkdmI0FlSwAAAABJRU5ErkJggg==\n",
+                        "image/png": "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Xl0pKSn65ptvNG7cONlsNnXv3l1169ZV9+7d9fHHH6tWrVp64IEHCr0MNCMjQz169NCvv/6qsLAwdenSRSkpKdqwYYO+//57vf/++2rRooXTe9566y3t379f9913nwICArRq1SpNnz5dFotFL730UqH1+/v7FxgAStKWLVt0/vx5NWzYsEjHYtOmTbr//vuLNPdKkpKSJMnpfoAJCQnq1auXLly4oOjoaN18881KSEjQe++9px9++EELFiyQn5+fY35mZqa6d++ucuXK6V//+pf++usvffXVV9q6dauWLFnisnsNTp48Wf/9738VFhamzp07y2KxaNu2bVq5cqW2bdumb7/9Vj4+PurevbuWLVumPXv26KmnntLtt99e6DZXr16toUOHqly5crrnnnsUGBiozZs3a8qUKfrpp5/03nvvyWq1OuYnJyerS5cuqlmzpp588knt379fGzdu1K+//qoNGzY4wrfCtG3bVl26dNFNN93kkmNSkP/97386ffq0goODVbFiRcf44MGD9e2336pJkyZ68sknlZ2drU2bNmnx4sX67bffHMFpv379tGzZMh05ckQvvPDCFY/fRx99pClTpqhixYq699575ePjo++//14jR47Uzp07NW7cOEkX79HZs2dPnTlzRvfee6+qVq2qxMREffrpp/rpp5+0YsUKeXl5XbdjAgAASgchIAAABvbbb79pw4YN8vb2VqtWrSRJy5cv1/r169WmTRtNnz5dvr6+kqR9+/bpX//6l0aPHq2WLVs6BRm7du3S9OnTdd9990mS+vbtqy5duuj999/XQw89pNtuu63EtX7wwQdKTU3VRx995HQpZbdu3fT4449r1apVjhCwR48e+vjjj3X77bdfMYScPXu2fv31Vz3++OMaN26cI/BJSEhQjx49NGzYMG3YsMEpoDh48KCWL1+umjVrOj7/vvvu0+LFi68YAhYmIyNDkyZNkiQ9+eSTV51/4MABHT58uMSXk+bm5mrmzJmSpPbt20uScnJyNHz4cNlsNs2ePdvx4JHc3FyNGzdOixYtUmxsrP797387tnPmzBndeuutWrBggXx8fCRJ8+bN08SJE/XOO+9o8uTJJapTklJSUjRv3jxFRERo3rx5TsFcnz59tHHjRm3btk2tWrVSz549tWfPHu3Zs0ddunQpNABOS0vT6NGjVb58ec2fP9/xgI7s7Gy98sor2rBhgxYuXOg4E06SDh06pKefflqjRo2SxWKRJI0aNUqfffaZvv76az3++ONX3I/69euX9FAUyG63Ky0tTdu3b3ecadu3b1/H67/88ou+/fZbPfjgg3r77bcd4zk5OXr88ce1e/du/fXXX44/L/Hx8Tpy5Ih69+6tgICAAj8zKSlJU6dO1S233KKPP/5YISEhkqSzZ8+qV69eWrx4se6++25FR0dr9erVOnr0qCZOnKjHHnvMsY1x48bpk08+0ebNm9W2bdvrcWgAAEAp4nJgAAAMYN26dZoxY4bj65133tGAAQP09NNPKycnR8OGDXNcWpr3RNVRo0Y5AkBJql27tp577jllZmZq5cqVTttv1KiRIwCUpKCgIPXp00c5OTlas2aNS/ahU6dOmjBhQr7wq0GDBipfvrxOnTpV7G0uX75cfn5+GjFihFOw1LRpU3Xu3FnHjx/Pd5++Dh06OAJASQoJCVHt2rWVnJysrKysYn1+dna2Bg4cqL1796pt27bq2LHjVd+zadMm+fn5qUmTJkX6jLS0NKfez5gxQ2+88YYeeughffvtt6pZs6YjvNyxY4cOHjyoBx980OnJwx4eHho6dKgqVqyopUuXym63O33G4MGDHQGgdDEYvfXWW/XNN9+45GnMXl5eevPNNzVy5EinPklyPKyiuP3fsGGDzp49q+7duzs9odfLy0uvv/66rFZrgZe1vvDCC44AUJLatGkj6WI4W1pmzpyp0NBQx1dYWJgiIyP10ksvKTU1VcOGDXMKlIODgzV58mQNHDjQaTuenp6Oy+OLe/xWrFghm82mfv36OQJA6eLTqF977TVJchy/vN8vO3bscLpsftCgQdq0aRMBIAAAJsGZgAAAGMD69eu1fv16x/flypVTpUqV1LJlS3Xp0kWtW7d2vJaYmKjg4GDVqFEj33bygqfL75dX0FND8y5tLer90q6madOmatq0qVJTU/X777/r4MGD+uuvv/Trr78qPT1dlSpVKtb2zp07p8OHD6tJkyYqX758vtebNGmiJUuWaM+ePbrnnnsc4wWd1VihQgVJF0M9b2/vIn1+RkaGBgwYoB9++EH16tXT1KlTi/S+TZs2KSIiosiXT549e9Zxxp8kWSwW+fn5qUaNGnrxxRf13HPPOS4bzetVQQGjv7+/435xf//9t2655RbH9i6/z6KHh4fq1aunNWvW6ODBg6pTp06Rai1MYGCgHnroIeXm5mrv3r3at2+fDh06pD179uinn36SdPFsxeLI29fLa5ekW265RcHBwdq7d69yc3Pl4XHx59re3t6qXr2609yC7r93vUVGRioyMlLSxQfO5J1p16lTJ40fP94pkJUuhoCdO3dWTk6Odu3apf379yspKUm///77NR+/vP8HFHT87rrrLnl6ejqO8X333ae4uDgtWbJEa9euVcuWLdWqVSvdfffdqlKlSrH3HwAAGBMhIAAABjBp0iQ9+uijRZp77ty5Qu9ZVrVqVUnK99TRvPFL5W3j3LlzxSm1UGfOnNGkSZO0cuVKXbhwQRaLRTVq1FBkZGS+ULIozp8/L0mF3setsH0tKHzLOzPs8jPkCnPq1Cn16dNHv/76qxo2bKjZs2df9X5y0sWgaevWrRo0aFCRPke6GGht2LChSHPzenW1Y5KZmekYCwwMLPCY5PX/7NmzRa71Sr799lu9/fbbjjPuypcvr3r16qlu3bratGlTkY99nrx9LSgAli7u65EjR5Sdne0I1VzRe1eIjIx0usy9X79+evHFF/XVV1+pYsWKev311/O959NPP9WsWbMcD+KoVKmSGjRooDp16mjHjh3XfPwK+r1itVoVFBTk+H1StWpVff7554qLi9P69eu1atUqrVq1SuXKldPDDz+s0aNHFzk8BwAAxkUICABAGVO+fPlCn9iZ92TXy8+6K+gy2LzwJ2/ulcKSy4O2ggwbNkzff/+9nnzySXXu3FlhYWGOB1SsXr36qu+/XF74U9i+njlzxql+V/n777/17LPP6sCBA4qKilJsbGyhQdTlfv75Z6Wnp5f4foCFudoxKaj/lwaCl8oLiS4/fpf3v7D3X+rXX3/VK6+8omrVqumtt95So0aNFBISIovFojlz5mjTpk1X3cblirKvPj4++c6qM6Ly5cvr3Xff1cMPP6z58+frjjvucLoceM2aNRozZozuuOMOjR49Wg0bNnQ8sGXcuHHasWPHNX2mdPH4BQUFOb1mt9t17tw5p7MmQ0JCNHHiRNlsNv3vf//Tjz/+qKVLl+rzzz9XpUqVNGzYsGvZdQAAYCDcExAAgDImLCxMaWlp+vPPP/O9tm3bNknSP/7xD6fxnTt35pubFyw0aNBA0sVLkKWLly9eLu8JxYVJS0vT999/r/r162v8+PFq3LixIwA8cuSI0tPTncKlS+/ZVhh/f3+FhIRo//79Bd4PLSEhQVL+fS2JU6dOOQLAjh076v333y9yAChdvBS4evXqql27tstqulTeQzR+/vnnfK9lZ2dr586dqly5sgIDAx3j6enp2rdvX775O3bsUKVKlXTrrbdK+n9n0V3e/7wnFF/JypUrlZubq5iYGHXq1Ek1atRw9Djv92lx+3+lfT1+/LgOHDhQ4suYS9NNN92kmJgYSRfP/D1y5IjjtRUrVkiSpk2bpvbt2zs9sfmPP/6QVPwzGfPuo7h9+/Z8r/3vf/9Tenq64/itW7dOY8aM0blz52S1WhUeHq5+/frpk08+KXQbAACg7CEEBACgjHnkkUckSRMnTnQ6S2vfvn2aPXu2fH191aFDB6f3rFu3zhGaSdKJEyc0a9Ys+fr66v7775ck1axZU1arVT/99JPTdjdu3Kjdu3dfsSYvLy9ZrValpaU53XstMzNT48aNkyRduHDBMe7pefFihJycnKvua2Zmpt58802nBxYkJCTo888/V5UqVZwekFFSMTExOnDggDp06KC3337bEYwW1aZNmxQVFeWyei7XuHFj1ahRQ998843T2XW5ubl68803lZqaqk6dOjnukZdn6tSpTn2ZN2+eDhw4oE6dOjke5FGrVi1JF/udJysrSx999NFV68o7G+/EiRNO41u2bHEEXJf2Ou8zL/09cbl27drJ399fixYtcrpvZXZ2tsaPHy+bzeb4s1BWtG/fXh06dFB6errGjh3rGC/s+C1fvlzx8fGSnI9fUf78PPTQQ7JarfrPf/7jFDiePXtWEydOlPT//l9y4MABffrpp1q0aJHTNvLed/PNNxdrPwEAgDFxOTAAAGVM586dtX79eq1bt06dOnVSq1atlJaWpnXr1ikrK0sTJ07MdzP/8uXLq2fPnrrvvvvk7++vdevW6cSJExo7dqzjrKOgoCDdc889+uabb/TEE0+odevWOnTokDZs2KAmTZpc8WwgHx8ftW/fXl9//bWeeOIJtWzZUunp6dq4caNOnDihihUr6uzZs46HOOTdp27r1q2aPHmy7rnnngIfYNC7d2/9+OOPWrZsmX7//Xc1a9ZMKSkpWr9+vTw9PfXmm28W+QEcV7Nr1y598803slgsuvnmmzVr1qx8c7y9vdW7d+8C33/ixAnt2bNHL774okvqKYjVatXkyZP1/PPPq3fv3oqOjtYtt9yibdu2adeuXbrzzjs1YMCAfO/7+eef9dhjj6lFixbat2+fNm3apDp16jjNffzxx7Vw4UJNnDhRO3fuVKVKlbR+/XpVqFDBcVZnYTp27Kj//ve/Gjt2rLZt26YqVaooMTFRmzZtUmBgoE6ePKnU1FTH/ODgYEnSm2++qebNm6tfv375tlmhQgW98cYbGjJkiJ566indc889CgwM1ObNm/XXX3+pdevW6tq16zUeSfd5/fXX9X//93/6/vvvtWrVKj3wwAPq1KmTVq1apX79+umBBx6Qv7+/fvvtN8XHx6ty5cqFHr8RI0bon//8p7p3757vc2rWrKlhw4Zp8uTJ6ty5s9q1aycfHx999913+vvvv/Xkk08qOjpakvTkk09q8eLFmjp1quLj4xUaGqqTJ0/q66+/lp+f33X9PQ0AAEoPZwICAFDGWCwWxcbGavjw4fL29tZnn32mH374Qc2aNdP8+fMLPDuqU6dOeu2115SQkKDly5erRo0a+s9//qOnnnrKad7EiRPVrVs3nT59WvPnz9eRI0cUGxub78zCgkyYMEE9evTQ2bNntWDBAv34449q0KCBFi1a5Dijb+vWrZIunjk4evRoBQQE6JNPPnE8AfVy3t7emjdvnvr166fMzEwtXLhQCQkJuvfee7VkyRKXngWYdym13W7X3LlzNXPmzHxfH3zwQaHv37RpkywWi0trKkjTpk21ZMkSdejQQQkJCVq4cKEyMjLUv39/LVq0qMDAbt68eapataoWL16sP/74Q927d9eiRYscT02WLl4++sEHH6h+/fpavXq1vvrqK7Vo0UJz5851nLlXmLp16zreu27dOn322Wc6ceKEBgwYoC+//FIeHh76/vvvHfO7du2qli1baufOnZo/f77jITCXu//++7VgwQI1a9ZM33//vZYsWSJvb2+NHDlS77///lXrMqJq1ao5HhwzceJEnTlzRnfffbfeeecd1axZUytWrNCyZcuUlZWl0aNHa/bs2ZLkdPz69Omj8PBwbdq0yXHJbkGeffZZvf/++woNDdXXX3+t5cuXq2rVqpoyZYrGjx/vmBcQEKAFCxaoS5cuOnDggObNm6fvvvtOrVu31pIlSxQaGnqdjgYAAChNFntpPioNAACUqq1bt6p79+7q3r27Ro4c6e5yUMq6deum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22/q37+/goKC1LlzZzfvDQAAgLFxOXAh/vrrT507d65Y7/G4kKHccqV7s0d/f3/dfjs/+QYAAGXPN998owsXLmjt2rVau3at02udO3dWv3791K5dO02aNEmPPvqoqlevrnnz5mnq1Knq0qWL7Ha7WrZsqY8//lg+Pj5u2gsAAICygRCwAH/99aeaN29crPfUCPTT+kH3qt073+jQadfcWLqofvrpZ4JAAABQ5vTp00d9+vS54pzExESn7+vWras5c+Zcz7IAAABMiRCwAHlnAMbFfag77ggt0nu8zh+T9beF+mTux8ouX/V6luewd2+iXn75hWKfsQgAAAAAAIAbCyHgFdxxR6gaNryrSHNtJw4o/TfpH/+4Q9abbruudQEAAAAAAADFwYNBAAAAUCzbtm3T+fPnC3wtLS1Nq1atKuWKAAAAcDWEgAAAACiW7t27a9++fQW+tnv3bg0fPryUKwIAAMDVcDkwAAAAruq1115TcnKyJMlutysmJkb+/v755h04cEA33XRTaZcHAACAq+BMQAAAAFzVvffeK7vdLrvd7hjL+z7vy8PDQ3fddZcmTZrkxkoBAABQEM4EBAAAwFVFR0crOjpaktStWzfFxMSodu3abq4KAAAARUUICAAAgGKZP3++u0sAAABAMRECAgAAoFgyMjL0/vvva+PGjcrIyFBubq7T6xaLRevWrXNTdQAAACgIISAAAACKZcKECfriiy8UGRmpunXrysOD20wDAAAY3Q0RAp48eVKVK1d2dxkoIfoIAIAxfPvttxo0aJB69+7t7lIAAABQRKb/se2BA/tVr15tHTiw392loAToIwAAxpGTk6OGDRu6uwwAAAAUg+lDwLS0M8rNzVVa2hl3l4ISoI8AABhHVFSUfvjhB3eXAQAAgGK4IS4HBgAAgOt07NhRY8aM0alTpxQeHi5fX998cx555JHSLwwAAACFIgQEAABAsQwcOFCStHz5ci1fvjzf6xaLhRAQAADAYAgBAQAAUCzr1693dwkAAAAoJkJAAAAAFMstt9zi7hIAAABQTISAAADAdHLtdu07ky5bRpas2TbV8POWh8Xi7rJMY+bMmVed069fv1KoBAAAAEVVohAwLi5OW7Zs0fz5811VDwAAQIn879Q5rTx4XGkXchxjAeU89eCtVVQ/yN+NlZnHlUJAf39/Va1alRAQAADAYK45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",
                         "text/plain": [
                             "<Figure size 1600x400 with 2 Axes>"
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 }
@@ -335,80 +355,79 @@
             "cell_type": "markdown",
             "id": "9a617887-4ff8-4a4d-a6ec-6c678267f03b",
             "metadata": {},
             "source": [
                 "## 4. Calculate mixing scores\n",
                 "This will compute the mixing score for each FOV and save the output in the `mixing_score_dir`. \n",
                 "- `ratio_threshold`: the maximum cell population ratio in a sample that will be assigned a mixing score, **(usually <=5)**\n",
-                "- `cell_count_threshold`: the minimum number of cells in each population in a FOV required to be assigned a mixing score\n",
+                "- `cell_count_threshold`: the minimum number of total cells from both populations in an FOV required to be assigned a mixing score\n",
                 "- `file_name`: name of the file where mixing score and ratio data will be saved (i.e. *CD4_CD8-homogeneous_mixing_score.csv*)"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "id": "9f642f2f-d345-4357-8a60-0e46b82fc5da",
             "metadata": {
                 "tags": [
                     "mixing_args"
                 ]
             },
             "outputs": [],
             "source": [
-                "ratio_threshold = 3\n",
-                "cell_count_threshold = 50\n",
+                "ratio_threshold = 5\n",
+                "cell_count_threshold = 200\n",
                 "\n",
                 "file_name = f\"CD4_CD8-{mixing_type}_mixing_score.csv\""
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 14,
+            "execution_count": 13,
             "id": "29f8d624-ef26-4299-a9b0-aaa5fb631b14",
             "metadata": {
+                "execution": {
+                    "iopub.execute_input": "2023-06-14T19:21:29.967458Z",
+                    "iopub.status.busy": "2023-06-14T19:21:29.965885Z",
+                    "iopub.status.idle": "2023-06-14T19:21:30.135487Z",
+                    "shell.execute_reply": "2023-06-14T19:21:30.134609Z",
+                    "shell.execute_reply.started": "2023-06-14T19:21:29.967424Z"
+                },
                 "tags": [
                     "mixing_score"
                 ]
             },
             "outputs": [
                 {
                     "data": {
-                        "text/plain": [
-                            "<Axes: xlabel='mixing_score', ylabel='Count'>"
-                        ]
-                    },
-                    "execution_count": 14,
-                    "metadata": {},
-                    "output_type": "execute_result"
-                },
-                {
-                    "data": {
-                        "image/png": "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mj17tkaOHKkdO3Z43pGvefPmSkpKUuvWrSu8zXPnzmn79u2SpKNHj6qwsFBbt26VJHXr1k1RUVEaMWKEcnNzlZmZKUnatGmTtm3bpj59+ig6Olo5OTlaunSp7Ha7Ro0a5evhAQAAAB4VCs1FRUX6y1/+ot/85jcaNmyYJKl169blAvKqVau0bt06PfnkkxW6T/OJEyf06KOPeo2VPV61apW6d+8ut9stl+unOb8tWrTQsWPH9Oyzz6qgoEANGjRQjx49NGHChErfOQMAAACQKhiaX331Vb3xxhvavHnzZZfr27ev/va3vyk+Pl5Dhw694u23aNHC9P7Kq1ev9nqcmJhYbgwAAACoShW6wd2WLVt0yy23mF7BbdmypW699Va/3XIOAAAAsFKFQvNXX32lLl26XNGynTp14l35AAAAUCNUKDSXlJRc8RzlsLAwFRcX+1QUAAAAEEwqFJqjo6N1+PDhK1r28OHDio6O9qkoAAAAIJhUKDTfeOONevPNN3XixInLLnfixAm9+eabuvHGGytVHAAAABAMKhSaU1NTVVRUpBEjRujAgQMXXebAgQMaOXKkioqK9OCDD1ZJkQAAAEAgVeiWczExMXr++ef12GOPaciQIYqJiVF8fLzq1aunM2fO6PDhw/ruu+9Up04dzZs3Ty1btrSqbgAAAMBvKvyOgH379tVbb72lZcuW6YMPPtC7777reS46OlqDBw9WamoqbywCAACAGsOnt9Fu0aKFZs6cKUkqLCzUmTNnVK9ePdWvX79KiwMAAACCgU+h+efq169PWAYAAECNVqE/BAQAAABqI0IzAAAAYILQDAAAAJggNAMAAAAmCM0AAACACUIzAAAAYILQDAAAAJggNAMAAAAmCM0AAACACUIzAAAAYILQDAAAAJggNAMAAAAmCM0AAACACUIzAAAAYILQDAAAAJggNAMAAAAmCM0AAACACUIzAAAAYILQDAAAAJggNAMAAAAmCM0AAACACUIzAAAAYILQDAAAAJggNAMAAAAmCM0AAACACUIzAAAAYILQDAAAAJggNAMAAAAmCM0AAACACUIzAAAAYILQDAAAAJggNAMAAAAmCM0AAACACUIzAAAAYILQDAAAAJggNAMAAAAmCM0AAACACUIzAAAAYCKoQvORI0f01FNPKSUlRW3bttXtt99+ResZhqGlS5eqb9++6tix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KjiC6svq3jdr1kz/+te/vMJbYWGhjhw5oubNm1fNQVRDlen7xezbt08xMTFe28/Pz/c657Ozs/X5558rKSmpcsVXc1b3XpKWLl2qF198UbNnzy7325fayuq+//Lna9k9sYcMGaJVq1YpLCys8gdRDVnd9969eyssLEy7d+/2Wm737t0V/vnK9IxqZsiQIVq9erXGjRuntLQ05eXlac6cORoyZIiaNm3qWW7EiBHKzc1VZmampAvvtjNu3Di1atVKKSkp2r9/v2fZqKgotWzZUhEREeVuMVf2h4C//vWv1blzZ+sPMEhZ2XfpwivjAQMGaPr06Tp9+rSaNGmiV155RT/++KPGjBnj12MNNlb3fsiQIRo3bpwmT56slJQUFRcXa8WKFSouLtbgwYP9eqzBxNe+f/DBB9qwYYP69u2rX/3qV8rPz9emTZu0c+dOz4twSerUqZN69+6tJ554QlOmTFFERISee+45JSQk6JZbbvH78QYTq3u/ceNGzZ07V4MGDVKLFi28vjZatmx50VvS1QZW9/1St3Bt2bJlrb69q9V9b9y4sYYNG6YXXnhBNptNcXFxevvtt7V//34tX768QrUSmquZyMhIvfTSS3r66ac1btw41atXT/fcc48mTZrktZzb7ZbL5fI8PnDggAoKClRQUKD777/fa9k777xTs2fP9kv91ZU/+j579mzNmzdPc+fOVWFhodq1a6eVK1cqISHB2oMLclb3vl+/fnr++eeVkZGhSZMmKSwsTG3bttWqVatq9Z0EfO17TEyMiouLNXfuXJ06dUqNGjVSQkKCVq9erW7dunmt+/zzz2vWrFl66qmnVFpaqt69e2vatGm1+t0AJet7X3bv27feektvvfWW1zZnzZpVa+8f7I9zHuX5o++PP/64rrrqKmVkZOjkyZOKi4vTwoUL1bt37wrVajN+OaEMAAAAgBfmNAMAAAAmCM0AAACACUIzAAAAYILQDAAAAJggNAMAAAAmCM0AAACACUIzAAAAYILQDAAAAJggNAOABb7//nslJCTof/7nfyq87tSpU5WcnGxBVQAAXxGaAQAAABO8jTYAWMAwDBUXFys0NFR2u71C65aUlMgwDIWHh1tUHQCgogjNAICgde7cOdWtWzfQZQAA0zMA4FLS09OVkJCg7OxsTZ48WV26dFGPHj30/PPPyzAM/fvf/9bvf/97de7cWb169dKKFSs86/5yTvOJEyfUo0cPDRs2TD+/VnHkyBElJiZq4sSJnrFfzmku21ZGRoZeffVV9evXT+3bt9fdd9+tgwcPlqt7y5Yt+u1vf6sOHTro9ttvV2Zmpk/zpL/99luNHz9evXr1UocOHZSUlKRJkyapoKDAa7k333xT99xzj66//np17dpVv/vd77Rz506vZdasWaPbbrtN7du3V+/evTVz5kw5nU6vZYYNG6bbb79dn332mX73u9/p+uuv17x58yRJxcXFmj9/vvr376/27durT58+mjNnjoqLiyt0TADgq9BAFwAAwW7SpEmKi4vT448/ru3bt2vRokVq2LCh1q1bpx49emjy5MnauHGj/vrXv6pDhw7q2rVruW1cffXVmjFjhh599FGtXr1aw4cPl9vt1tSpU1WvXj39+c9/Nq1j06ZNOnPmjO677z7ZbDYtX75c48eP17vvvquwsDBJ0gcffKBJkyYpPj5ejz/+uPLz8/Xkk0+qadOmFTrm4uJijRkzRsXFxXrggQfUuHFj5eXl6YMPPpDT6VSDBg0kSQsWLFB6ero6deqkCRMmKCwsTAcOHNCHH36o3r17S7rw4mPBggW68cYbdf/99ys7O1tr167Vp59+qrVr13pql6TTp08rNTVVt912mwYNGqSrr75abrdbv//977Vv3z7de++9iouL01dffaWXXnpJ3377rf7+979X6NgAwCcGAOCi5s+fb8THxxvTp0/3jJWWlhpJSUlGQkKCsWTJEs94fn6+0bFjR2PKlCmGYRhGTk6OER8fb/zjH//w2uZjjz1mXH/99UZ2draxfPlyIz4+3sjMzPRaZsqUKcZNN93keVy2rW7duhmnT5/2jL/77rtGfHy88f7773vGbr/9diMpKckoLCz0jH300UdGfHy81zbNfP7550Z8fLyxZcuWSy7z7bffGq1btzbGjRtnuFwur+fcbrdhGIZx4sQJo127dsbo0aO9lnn55ZeN+Ph4Y/369Z6xBx54wIiPjzfWrl3rta0NGzYYrVu3Nvbu3es1vnbtWiM+Pt7Yt2/fFR8XAPiK6RkAYOKee+7xfG6329W+fXsZhuE17nA4dN111yknJ+ey25o+fbrq16+vCRMm6IUXXlBKSor69et3RXX89re/VWRkpOfxDTfcIEmefebl5emrr77SHXfcoXr16nmW69atm+Lj469oH2Xq168vSdq5c6fOnTt30WXeffddud1ujRs3TiEh3j9ObDabJGn37t0qKSnR8OHDvZYZPHiw6tevr+3bt3utFx4errvuustrbOvWrYqLi1NsbKxOnjzp+dejRw9J0kcffVShYwMAXzA9AwBMNGvWzOtxgwYNFBERoaioqHLjp0+fvuy2GjZsqGnTpunRRx9V48aNNW3atCuu41e/+pXX47IAXTY3ODc3V5LUsmXLcutee+21+vzzz694XzExMRo1apRWrlypjRs36oYbblBycrIGDRrkmZrx3XffKSQkRHFxcZfcTllNsbGxXuPh4eGKiYnR0aNHvcabNm1a7q4hR44c0TfffKOePXtedB8nTpy44uMCAF8RmgHAxC+vokq65G3kjCu4IVHZH8nl5+frhx9+kMPhuKI6KrNPX0ydOlV33nmn3nvvPe3atUvPPPOMlixZotdee03XXHONJfusU6dOuTG32634+Hj96U9/uug6VtUCAD/H9AwA8KMdO3bo9ddf14MPPqioqChNnTpVpaWlVbLtsivi3333Xbnnjhw54tM2ExISNHbsWK1Zs0Zr1qxRXl6e1q5dK+nCFW23261vvvnGtKasrCyv8eLiYn3//fdq3ry5aQ0tW7ZUfn6+evbsqRtvvLHcv19exQYAKxCaAcBPnE6npk2bpo4dO+qxxx7TM888o0OHDmnx4sVVsv2mTZsqPj5eGzZs0JkzZzzje/bs0VdffVWhbRUWFpYL8/Hx8QoJCfHc5q1fv34KCQnRwoUL5Xa7vZYtu/p94403KiwsTKtXr/a6Ir5+/XoVFBSoT58+prUMHDhQeXl5eu2118o9d/78eZ09e7ZCxwYAvmB6BgD4yV/+8hedPn1aK1eulN1uV1JSkgYPHqzFixerX79+at26daX3MWnSJI0dO1b333+/7rrrLjmdTq1Zs0bx8fFeQdrMhx9+qP/6r//SrbfeqlatWsnlcunNN9+U3W7XgAEDJF2YJ/3www/r73//u4YOHapbbrlF4eHh+vTTTxUdHa3HH39cUVFRSktL04IFC/Tggw8qOTlZ2dnZeuWVV9ShQwcNGjTItJaUlBRt2bJFf/7zn/XRRx+pc+fOcrlcysrK0tatW7V8+XJ16NDB554BwJUgNAOAH7z33nvasGGDpk6d6vWHc1OnTtXu3bs1ZcoUrV+/3uuexb5ITk7WvHnzlJ6errlz56pVq1aaNWuWNmzYoMOHD1/xdhISEtS7d29t27ZNeXl5qlu3rhISErRs2TIlJiZ6lnv00UfVokULvfzyy3ruuec8y6WkpHiWGT9+vKKiovTyyy9r1qxZioyM1L333qvHHnvsio637Gr2iy++qDfffFOZmZmqW7euWrRooWHDhum6666rUI8AwBe8jTYA1AIpKSmKiorSypUrA10KAFRLzGkGgBqkpKSk3Fzkjz76SF988YW6desWoKoAoPpjegYA1CB5eXkaNWqUBg0apOjoaGVlZWndunVq0qSJhgwZIunCW1WXlJRccht2u73cPagBoLYjNANADRIZGal27drp9ddf18mTJ3XVVVepT58+mjx5sho1aiTpwhzjPXv2XHIbzZs31/vvv++vkgGgWmBOMwDUMp999pnnXQQvJiIiQl26dPFjRQAQ/AjNAAAAgAn+EBAAAAAwQWgGAAAATBCaAQAAABOEZgAAAMAEoRkAAAAwQWgGAAAATBCaAQAAABOEZgAAAMDE/wfNNbeCMuxUNwAAAABJRU5ErkJggg==\n",
+                        "image/png": "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mxrdsi0rK1PXrl3reiwAAABAvapR+E1ISND27dvreiwAAABAvarRYw8DBw7UzJkzderUKcXExCgwMLBCn8GDB9d2bAAAAECdqlH4feSRRyRJmzZt0qZNmyost9lshF8AAAA0OjUKv9u2bavrcQAAAAD1rkbh96qrrqrrcQAAAAD1rkbhd8mSJVfs8/DDD9dk0wAAAEC9qfPwGxwcrHbt2hF+AQAA0OjUKPweOnSoQltRUZEyMzM1a9YsPf7447UeGAAAAFDX6uz3EgcFBal3794aN26c5s+fX1ebBQAAAOpMnYXfch06dNDRo0frerMAAABArdXosYfLMQxD2dnZWrlyJZ8GAQAAgEapRuE3KipKNpvtsssMw+CxBwAAADRKNQq/48aNu2z4DQ4O1i9/+Utdc801tR0XAAAAUOdqFH6Tk5PrehwAAABAvavxM7+lpaXauHGjMjIyVFBQoFatWql79+4aMmSI/P39a7TN9PR07dy5Uy+99FKlfU6fPq3Zs2dr+/btkqSbb75Z06dPV1BQkLvPe++9p+eff17Hjx/XNddco5SUFPXp06dGYwIAAMCPR40+7aGgoEC33367Zs2apU8++UTnzp3Tvn37NGvWLN166606e/as19tct26dFi9efMV+48eP1/Hjx939P/roIz355JPu5bt27VJKSoqGDRumTZs2KSEhQePGjeMTKAAAAFCz8LtgwQLl5OTo5Zdf1ocffqgNGzboww8/1Msvv6zvvvtOzz33XLW3lZubq/vuu0/PPfecOnbsWGXf/fv3a/fu3UpNTVV0dLR69eqlp556Sm+99ZZyc3MlSStXrlRSUpKGDx+uTp066dFHH1V0dLTWr19fk0MFAADAj0iNwu+2bdv0yCOPqHv37h7t3bt31/jx4/XXv/612tv69NNP1bJlS7399tuKiYmpsu/evXsVGhqqTp06udt69Oghm82mzMxMuVwu7du3Tz179vRYLz4+Xnv37q32mAAAAPDjVKNnfgsLC3X11VdfdtnVV1+tM2fOVHtbiYmJSkxMrFbf3NxcdejQwaPNz89PISEhys7OVkFBgYqKihQWFubRp127dsrOzq72mCpjt9f57wRBNZTXnfqbg/qbjzkwF/W/pLwGNput0o88rRe2S682Vb5f95hsatjxVVP5mBrzuWSz2eTj41m78u+bNbObPnaXy5Bh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FwAAAGgojfuzNgAAAIA6RPgFAACAZRB+AQAAYBmEXwAAAFgG4RcAAACWQfgFAACAZRB+AQAAYBmWC78ul0uLFy9W7969FRMTo9GjR3v8uuQfOn36tCZPnqy4uDjFxcXp8ccfV1FRkUef9957TwMHDlSXLl00aNAgbd++vb4Po0mrjzlITExUZGSkx9eUKVPq+1CaJG/r//31xowZo+eff77CMq4B79THHHANVJ+39T9y5IgeeOABxcfHq1evXho/frxOnDjh0YdrwDv1MQdcA9Xnbf3/85//aOTIkbrxxhvVs2dPPfHEEyooKPDo06SuAcNinn/+eaNXr17G3//+d+Ozzz4zRo8ebSQlJRklJSWX7T98+HDjtttuM/7zn/8Y//rXv4x+/foZU6dOdS/fuXOnER0dbbz00kvG559/bsydO9f4+c9/bnz++ecNdUhNTl3PwdmzZ43IyEjjb3/7m5GXl+f+KigoaKhDalK8rb9hGEZxcbExadIkIyIiwli8eLHHMq4B79X1HHANeMeb+p86dcq46aabjEceecQ4fPiwceDAAWP48OHGr3/9a+P8+fOGYXAN1ERdzwHXgHe8qX9ubq7RvXt347HHHjO++OILIzMz07jllluMhx56yN2nqV0Dlgq/JSUlxo033mi88sor7rb8/Hyja9euxubNmyv037dvnxEREeExeTt27DAiIyONnJwcwzAMY/To0cYjjzzisd4dd9xhPP744/V0FE1bfcxBZmamERERYeTn59f/ATRx3tbfMC7W9+abbzb69+9vdO/evULw4hrwTn3MAddA9Xlb/z/96U9GbGysO2QZhmFkZ2cbERERxr/+9S/DMLgGvFUfc8A1UH01+Xd44sSJxoULF9xt69atM2JiYtzfN7VrwFKPPRw6dEiFhYXq2bOnu83hcKhz587as2dPhf579+5VaGioOnXq5G7r0aOHbDabMjMz5XK5tG/fPo/tSVJ8fLz27t1bfwfShNX1HEhSVlaWQkND5XA46v8Amjhv6y9JO3bsUFJSkjZt2qQWLVp4LOMa8F5dz4HENeANb+vfq1cvLV26VP7+/hWW5efncw3UQF3PgcQ14A1v63/jjTdq4cKF8vX1lSR9/vnnevPNN3XTTTdJapr/DviaPYCGlJOTI0nq0KGDR3u7du2UnZ1doX9ubm6Fvn5+fgoJCVF2drYKCgpUVFSksLCwam0PdT8HknT48GEFBQUpOTlZ+/fvV+vWrTV06FCNGDFCPj6W+vnuirytvyRNmDCh0u1xDXivrudA4hrwhrf1Dw8PV3h4uEfbihUr5O/vr7i4OK6BGqjrOZC4BrxRk7+Dyg0YMEBffvmlrrrqKqWnp0tqmv8OWOqMKC4ulnQxPH2fv7+/SkpKLtv/h32/3//8+fNebQ91PwfSxTdCnD17VgMHDtTq1at1xx136Lnnnrvsm4Ksztv6XwnXgPfqeg4krgFv1Lb+L774ol555RVNmjRJbdq04RqogbqeA4lrwBu1qX9aWppefvllhYaGasSIESosLGyS14Cl7vwGBARIkkpLS91/lqSSkhIFBgZetn9paWmF9pKSEgUFBbn/C+aHfSrbHup+DiRp7dq1KikpUXBwsCQpMjJShYWFWrZsmZKTk/mp/3u8rf+VcA14r67nQOIa8EZN628Yhp577jktW7ZMDz74oO69915JXAM1UddzIHENeKM2fwd16dJFkvT888+rb9++2rp1q/r27eve3vc15mvAUmdD+S3+vLw8j/a8vLwKt+slKSwsrELf0tJSnTlzRu3bt1dISIiCgoKqvT3U/RxIUrNmzdx/4ZWLiIhQUVGR+3kwXORt/a+Ea8B7dT0HEteAN2pS/wsXLiglJUXLly/X1KlTNWnSJPcyrgHv1fUcSFwD3vC2/kePHtU//vEPj7Z27dqpZcuWys3NbZLXgKXCb1RUlIKDg5WRkeFuKygo0MGDB9W9e/cK/ePi4pSTk+Px2Xfl68bGxspmsyk2Nla7d+/2WC8jI0PdunWrp6No2up6DlwulxITE7Vs2TKP9Q4cOKC2bduqVatW9XQkTZO39b8SrgHv1fUccA14pyb1nzp1qt5//30tWLBAY8aM8VjGNeC9up4DrgHveFv/HTt2aMKECTp37py77auvvtLp06fVqVOnpnkNmP1xEw1t4cKFRo8ePYwPPvjA/dl2v/rVr4ySkhKjrKzMyMvLM4qLiw3DMAyXy2XceeedxpAhQ4xPPvnE2Llzp9GvXz9j2rRp7u3t2LHDuP766401a9YYn3/+uTFv3jyja9eujfaz7RqDup6DuXPnGrGxscaWLVuMY8eOGa+99prRtWtXY8OGDWYdYqPmTf1/qF+/fhU+ZotrwHt1PQdcA97xpv5vvPGGERERYaxatcrj82O/34drwHt1PQdcA97xpv6nTp0yEhISjIceesg4fPiwsWfPHuN///d/jVtvvdUoKyszDKPpXQOWC79lZWXG/PnzjZ49exo33HCDcf/99xvHjx83DMMwjh8/bkRERBhvvPGGu/+3335rJCcnGzfccIMRHx9vzJw50+OzBg3DMN58800jKSnJ6NKlizFkyBD35w7i8up6Di5cuGCkp6cb/fv3N6Kjo40BAwbwF14VvK3/910ueBkG14C36noOuAa84039R40aZURERFz26/tzxDXgnbqeA64B73j7d9B///tf44EHHjC6detm9OjRw5g+fXqFz1RuSteAzTAMw+y7zwAAAEBDsNQzvwAAALA2wi8AAAAsg/ALAAAAyyD8AgAAwDIIvwAAALAMwi8AAAAsg/ALAAAAyyD8AgAAwDIIvwDQQBITEzVt2rRq97/nnnt0zz331OOIAMB6+A1vANBADh48qODgYP3kJz+pVv/PP/9cknTdddfV57AAwFIIvwAAALAMHnsAgBpITEzUkiVLlJqaqvj4eN14442aPHmyCgsL9cILL6hPnz7q1q2bkpOTdfr0afc65Y89pKamKjIyUrt27XJv86233lJkZKTeeOMNSRUfe4iMjNQf//hHzZgxQz169NCNN96o8ePH69tvv/UY2+rVq9W/f3917dpVd955pz788ENFRkYqIyPDq2PcsmWLfvOb36hr167q2bOnpkyZory8PPdywzD0xz/+Ubfccou6du2qpKQkrVy5Ut+/p/LRRx9p2LBh6tatm+Lj4zV58mRlZ2e7l2/cuFGdO3fW66+/roSEBPXp00dHjhyRJH3wwQcaOnSounTpoptuukmzZ89WUVGRV8cAAD9E+AWAGlq7dq1OnDihRYsW6aGHHtLmzZv129/+Vh999JGefvppJScna9u2bVq8eHGFdSdNmqSOHTtq5syZKi0tVW5urmbPnq1f/epX+u1vf1vpPhctWiSXy6WFCxdq6tSp+vvf/645c+a4ly9ZskRpaWn69a9/rfT0dMXExGjixIleH1tmZqamTJmiX/3qV1q5cqWmT5+uXbt2afLkye4+Cxcu1DPPPKO+fftq2bJluu2227Ro0SKlp6dLuhjmR48erfbt22vhwoWaPn269u/frzvuuEPfffedeztOp1PLly/X7Nmz9cgjj+i6667TO++8o3Hj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",
                         "text/plain": [
                             "<Figure size 800x500 with 1 Axes>"
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 }
             ],
             "source": [
-                "scores = []\n",
+                "scores, counts = [], []\n",
                 "for fov in all_fovs:\n",
                 "    fov_neighbor_counts = neighbor_counts[neighbor_counts[settings.FOV_ID] == fov]\n",
-                "    fov_score = compute_mixing_score(fov_neighbor_counts, fov, population_1_cells, population_2_cells, mixing_type, \n",
-                "                                     ratio_threshold, cell_count_threshold, cell_col=cell_type_col)\n",
+                "    fov_score, cell_counts = compute_mixing_score(fov_neighbor_counts, population_1_cells, \n",
+                "                                                  population_2_cells, mixing_type, \n",
+                "                                                  ratio_threshold, cell_count_threshold, cell_col=cell_type_col)\n",
                 "    scores.append(fov_score)\n",
-                "    \n",
-                "mixing_score_data = pd.DataFrame(list(zip(all_fovs, scores)), columns =['fov', 'mixing_score'])\n",
+                "    counts.append(cell_counts)\n",
+                "\n",
+                "mixing_score_data = pd.DataFrame(list(zip(all_fovs, scores, counts)), columns =['fov', 'mixing_score', 'cell_count'])\n",
                 "mixing_score_data = mixing_score_data.merge(ratios, on=['fov'])\n",
                 "mixing_score_data.to_csv(os.path.join(mixing_score_dir, file_name), index=False)\n",
                 "\n",
-                "seaborn.set(rc={'figure.figsize':(8,5)})\n",
-                "seaborn.histplot(mixing_score_data, x='mixing_score')"
+                "seaborn.set(rc={'figure.figsize': (8, 5)})\n",
+                "p = seaborn.histplot(mixing_score_data, x='mixing_score').set(xlim=(0, None))"
             ]
         }
     ],
     "metadata": {
         "kernelspec": {
             "display_name": "Python 3 (ipykernel)",
             "language": "python",
@@ -420,15 +439,15 @@
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
             "pygments_lexer": "ipython3",
-            "version": "3.8.16"
+            "version": "3.11.4"
         },
         "vscode": {
             "interpreter": {
                 "hash": "b0ac63cc785e7c4cb24da0642dbfe09cfb2d314979108d7192228f9c45902a86"
             }
         }
     },
```

### Comparing `ark-analysis-0.6.3/templates/Image_Stitching.ipynb` & `ark-analysis-0.6.4/templates/Image_Stitching.ipynb`

 * *Files 6% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9816468253968254%*

 * *Differences: {"'cells'": "{0: {'attachments': OrderedDict()}, 2: {'attachments': OrderedDict()}, 3: "*

 * *            "{'attachments': OrderedDict()}, 5: {'attachments': OrderedDict()}, 7: {'attachments': "*

 * *            'OrderedDict()}}',*

 * * "'metadata'": "{'language_info': {delete: ['version']}}"}*

```diff
@@ -1,10 +1,11 @@
 {
     "cells": [
         {
+            "attachments": {},
             "cell_type": "markdown",
             "id": "e6396ae5-6cd6-476c-8215-1b8cea4c2b00",
             "metadata": {},
             "source": [
                 "# Image Stitching\n",
                 "The purpose of this notebook is to examine images according to the original tiled FOV shape. **Note: the FOV names for your data are expected to contain a grid name identifier of the form RnCm (e.g. example_data_R1C3, example_data_R2C1) which indicates the relative location of each FOV.**\n",
                 "\n",
@@ -22,25 +23,27 @@
             "outputs": [],
             "source": [
                 "# import required packages\n",
                 "from ark.utils.data_utils import stitch_images_by_shape"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "id": "8ecd7b8c-b55b-4aa8-9306-65a9eca6b692",
             "metadata": {},
             "source": [
                 "**If you would like to stitch images from an external drive, see [External Hard Drives and Google File Stream](https://github.com/angelolab/ark-analysis#external-hard-drives-and-google-file-stream). Otherwise all data, images, files, etc. must be placed in the 'data' directory, and referenced via `'../data/path_to_your_data'`.**\n",
                 "\n",
                 "* `image_dir` / `segmentation_dir` / `clustering_dir`: path to where appropriate images are stored\n",
                 "* `stitched_dir`: path to a new directory that will be created to store the stitched images, to avoid conflicts **do not make this a subdirectory of your image directory**"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "id": "977f8d09-85a6-4db2-9c88-189710566c8e",
             "metadata": {},
             "source": [
                 "### Stitch Channel Images\n",
                 "Images are expected to be contained within FOV subdfolders in the `image_dir`.\n",
                 "* `channels`: list of channels to create stitched images for, leaving as None will generate tiled images for all channels"
@@ -59,14 +62,15 @@
                 "\n",
                 "channels = None      # channels = []\n",
                 "\n",
                 "stitch_images_by_shape(image_dir, stitched_dir, img_sub_folder=None, channels=channels, segmentation=False, clustering=False)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "id": "de1ae179-c815-4fdf-a9cc-eb72e72b97aa",
             "metadata": {},
             "source": [
                 "### Stitch Segmentation Output Images\n",
                 "Images are expected to be contained directly within the `segmentation_dir`.\n",
                 "* `segmentation`: set to True when stitching images from the deepcell_output directory after running `1_Segment_Image_Data`"
@@ -85,14 +89,15 @@
                 "\n",
                 "segmentation = True\n",
                 "\n",
                 "stitch_images_by_shape(segmentation_dir, stitched_dir, img_sub_folder=None, channels=None, segmentation=segmentation, clustering=False)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "id": "9cb51103-359f-42fc-86b7-b51331fe62f8",
             "metadata": {},
             "source": [
                 "### Stitch Clustering Output Images\n",
                 "Images are expected to be contained directly within the `clustering_dir`.\n",
                 "* `clustering`: set to either \"pixel\" or \"cell\" when stitching images from the the corresponding masks directory after running `2_Pixie_Cluster_Pixels` or `3_Pixie_Cluster_Cells`"
@@ -126,14 +131,13 @@
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
-            "pygments_lexer": "ipython3",
-            "version": "3.8.8"
+            "pygments_lexer": "ipython3"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 5
 }
```

### Comparing `ark-analysis-0.6.3/templates/LDA_Preprocessing.ipynb` & `ark-analysis-0.6.4/templates/LDA_Preprocessing.ipynb`

 * *Files 2% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9906512605042016%*

 * *Differences: {"'cells'": "{2: {'execution_count': None}, 8: {'execution_count': None}, 15: {'execution_count': "*

 * *            "None}, 17: {'execution_count': None}, 18: {'execution_count': None}, 21: "*

 * *            "{'execution_count': None}, 23: {'execution_count': None}, 24: {'execution_count': "*

 * *            "None}, 25: {'execution_count': None}, 28: {'execution_count': None}, 29: "*

 * *            "{'execution_count': None}, 30: {'execution_count': None}, 32: {'execution_count': "*

 * *            "None}, 33: {'execution_count' […]*

```diff
@@ -25,15 +25,15 @@
             "metadata": {},
             "source": [
                 "#### Import Required Packages"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 1,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -98,15 +98,15 @@
                 "- `cell_table_path`: The path to the Cell Table\n",
                 "- `processed_dir`: destination directory for the processed data\n",
                 "- `viz_dir`: destination directory for all plots and visualizations"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 2,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -200,15 +200,15 @@
             "source": [
                 "Check that the column names in your cell table match those in `settings.BASE_COLS`.  If there are\n",
                 "descrepencies the above cell will output `False` and you will need to change the relevant column names in `rename` below."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 8,
+            "execution_count": null,
             "metadata": {},
             "outputs": [],
             "source": [
                 "if not correct_cols:\n",
                 "    rename = {\n",
                 "        'Your_FOV_column_name' : settings.FOV_ID,\n",
                 "        'Your_centroid_x_coord_column_name': settings.CENTROID_0,\n",
@@ -231,15 +231,15 @@
                 "The following code will transform the cell table into a format suitable for Spatial-LDA.  Here is where you can specify which clusters or markers to include in your analysis.  Indicate markers by their column name.\n",
                 "\n",
                 "At this stage, you must specify either clusters, markers, or both.  By specifying both fields, you can fit separate models later based on either one.  If you know you do not want to include any markers (or clusters), set `markers = None` (likewise for clusters).\n"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 9,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -264,15 +264,15 @@
                 "\n",
                 "# or use manually specified cluster names\n",
                 "# clusters = ['CD4_T', 'CD8_T', ...]"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 10,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -310,15 +310,15 @@
                 "Determining a reasonable neighborhood size around a particular cell will depend on the size and quantity of all cells in the FOV, but a typical size is a radius between 100-200 pixels.  The neighborhood around that cell then includes all cells whose centroid falls within the provided radius.\n",
                 "\n",
                 "The code below collects metrics regarding the distribution of cell counts and cell size among all FOVs.  If the pixel dimension of your FOVs is anything other than 1,024 x 1,024 then indicate it using the `total_pix` argument."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 11,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -344,15 +344,15 @@
                 "- `total_cells`: total number of individual cells\n",
                 "\n",
                 "These metrics can be visualized below."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 12,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -374,15 +374,15 @@
                 "# Average area\n",
                 "visualize.visualize_fov_stats(\n",
                 "    fov_stats, metric=\"average_area\", save_dir=viz_dir)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 13,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -404,15 +404,15 @@
                 "# Cellular density\n",
                 "visualize.visualize_fov_stats(\n",
                 "    fov_stats, metric=\"cellular_density\", save_dir=viz_dir)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 14,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -463,15 +463,15 @@
                 "In this step, the neighborhood around each index cell is summarized using one of four featurization methods.  The four methods are `cluster`, `marker`, `avg_marker`, and `count`.  For specific details about each method, see the [documentation](__https://ark-analysis.readthedocs.io/en/latest/_markdown/ark.spLDA.html#ark.spLDA.processing.featurize_cell_table__) of `featurize_cell_table()`.\n",
                 "\n",
                 "By default, all cells are labelled as index cells, but you can choose to only use specific cells if desired.  If so, you must create a new column to indicate which cells are index cells.  Below is an example of code that would create an index column for tumor cells:"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 15,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -484,15 +484,15 @@
                 "for i in formatted_cell_table[\"fovs\"]:\n",
                 "    is_tumor = formatted_cell_table[i][\"cluster\"] == \"tumor_ck17\"\n",
                 "    formatted_cell_table[i][\"is_tumor\"] = is_tumor"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 16,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -504,15 +504,15 @@
                 "featurization = \"cluster\"\n",
                 "radius = 200\n",
                 "cell_index = \"is_index\""
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 17,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -553,15 +553,15 @@
                 "\n",
                 "#### Constructing the Adjacency Network\n",
                 "The following code computes pairwise distances between cells and uses this information to build a network graph of adjacent cells.  Cells are considered adjacent if they share a facet in the Voronoi partitioning of cell positions.  Spatial-LDA uses this information to regulate how likely adjacent cells are to have similar topic preferences."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 18,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -571,15 +571,15 @@
             "source": [
                 "difference_mats = processing.create_difference_matrices(\n",
                 "    cell_table=formatted_cell_table, features=featurized_cell_table)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 19,
+            "execution_count": null,
             "metadata": {},
             "outputs": [],
             "source": [
                 "disp_fovs = list(formatted_cell_table.keys())[:2]"
             ]
         },
         {
@@ -591,15 +591,15 @@
             },
             "source": [
                 "The output contains the difference matrices for the training data and also the full combined data.  The adjacency network graph of the training data can be visualized for each FOV which can help give you an idea of how sparsely populated a particular FOV may be."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 20,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -640,15 +640,15 @@
                 "\n",
                 "#### Computing EDA Metrics\n",
                 "The code block below allows you to specify different number of topics to explore using all five metrics."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 23,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -659,15 +659,15 @@
                 "# specify different topic numbers and bootstrap iterations\n",
                 "num_topics = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n",
                 "num_boots = None"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 24,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -708,15 +708,15 @@
                 "#### Visualizing EDA Metrics\n",
                 "\n",
                 "The following code blocks produce plots of each metric as a function of the number of clusters (topics)."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 25,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -738,15 +738,15 @@
                 "# Inertia\n",
                 "visualize.visualize_topic_eda(\n",
                 "    data=topic_eda, metric=\"inertia\", save_dir=viz_dir)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 26,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -768,15 +768,15 @@
                 "# Silhouette Score\n",
                 "visualize.visualize_topic_eda(\n",
                 "    data=topic_eda, metric=\"silhouette\", save_dir=viz_dir)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 27,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -799,15 +799,15 @@
             },
             "source": [
                 "The code below plots a heatmap of the cell features against the specific cluster assignments from a given K-means clustering.  You must specify one value of `k` present in the `num_topics` variable above."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 29,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -844,15 +844,15 @@
                 "The plots and figures above will be saved in the directory specified by `viz_dir` if it was passed to the visualization functions.  To save the formatted and/or featurized cell tables along with the difference matrices, use the code block below.\n",
                 "\n",
                 "*Note: entire dictionary objects can be saved into .pkl files.  If you want to save data frames for specific FOVs individually as .csv files, you need to extract the desired data frame and specify format=\"csv\" in the saving function.*"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 30,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -864,15 +864,15 @@
                 "file_name = \"formatted_cell_table\"\n",
                 "spatial_lda_utils.save_spatial_lda_file(\n",
                 "    data=formatted_cell_table, dir=processed_dir, file_name=file_name, format=\"pkl\")"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 31,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -884,15 +884,15 @@
                 "file_name = \"featurized_cell_table\"\n",
                 "spatial_lda_utils.save_spatial_lda_file(\n",
                 "    data=featurized_cell_table, dir=processed_dir, file_name=file_name, format=\"pkl\")"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 32,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -904,15 +904,15 @@
                 "file_name = \"difference_mats\"\n",
                 "spatial_lda_utils.save_spatial_lda_file(\n",
                 "    data=difference_mats, dir=processed_dir, file_name=file_name, format=\"pkl\")"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 33,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -924,15 +924,15 @@
                 "file_name = \"fov_stats\"\n",
                 "spatial_lda_utils.save_spatial_lda_file(\n",
                 "    data=fov_stats, dir=processed_dir, file_name=file_name, format=\"pkl\")"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 34,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -958,16 +958,15 @@
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
-            "pygments_lexer": "ipython3",
-            "version": "3.8.8"
+            "pygments_lexer": "ipython3"
         },
         "vscode": {
             "interpreter": {
                 "hash": "31e90e2a7155cbaa93471c58eaf30b3c41423e5d17fccea222aec5e482389189"
             }
         }
     },
```

### Comparing `ark-analysis-0.6.3/templates/LDA_Training_and_Inference.ipynb` & `ark-analysis-0.6.4/templates/LDA_Training_and_Inference.ipynb`

 * *Files 1% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9915550595238095%*

 * *Differences: {"'cells'": "{2: {'execution_count': None}, 9: {'execution_count': None}, 11: {'execution_count': "*

 * *            "None}, 13: {'execution_count': None}, 16: {'execution_count': None}, 17: "*

 * *            "{'execution_count': None}, 19: {'execution_count': None}, 21: {'execution_count': "*

 * *            "None}, 22: {'execution_count': None}, 24: {'execution_count': None}, 26: "*

 * *            "{'execution_count': None}, 27: {'execution_count': None}, 29: {'execution_count': "*

 * *            "None}, 30: {'execution_count' […]*

```diff
@@ -20,15 +20,15 @@
             "metadata": {},
             "source": [
                 "#### Import Required Packages"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 1,
+            "execution_count": null,
             "metadata": {
                 "tags": []
             },
             "outputs": [],
             "source": [
                 "import os\n",
                 "\n",
@@ -103,15 +103,15 @@
                 "- `difference_matrices_name`: name of the difference matrices file (`.pkl`)\n",
                 "- `features_name`: name of the featurized cell table file (`.pkl`)\n",
                 "- `viz_dir`: destination directory for all plots and visualizations"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 2,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -141,15 +141,15 @@
             },
             "source": [
                 "#### Load in Data"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 3,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -185,15 +185,15 @@
                 "You can specify the number of parallel processes, topics, and the difference penalty below.  Larger values for the difference penalty mean adjacent cells are more likely to share topic preferences.\n",
                 "\n",
                 "To see periodic progress updates, set `verbose=1`.  For more detailed output, set `verbose=2`.  Set `verbose=0` to silence all progress output."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 5,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -247,15 +247,15 @@
                 "        difference_penalty=difference_penalty,\n",
                 "        verbosity=verbose\n",
                 "    )"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 7,
+            "execution_count": null,
             "metadata": {},
             "outputs": [],
             "source": [
                 "if not load_trained_model:\n",
                 "    # Trained Model\n",
                 "    train_name = \"trained_spatial_lda_model_num_topics={}_diff={}\".format(\n",
                 "        num_topics, difference_penalty)\n",
@@ -265,15 +265,15 @@
                 "        dir=os.path.join(base_dir, processed_dir),\n",
                 "        file_name=train_name,\n",
                 "        format=\"pkl\")"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 8,
+            "execution_count": null,
             "metadata": {},
             "outputs": [],
             "source": [
                 "if load_trained_model:\n",
                 "    # Trained Model\n",
                 "    train_name = \"trained_spatial_lda_model_num_topics={}_diff={}\".format(\n",
                 "        num_topics, difference_penalty)\n",
@@ -291,15 +291,15 @@
             "source": [
                 "#### Visualize Topic Heatmap\n",
                 "The code below produces a heatmap of cell features against topic loadings and saves the output as a `png` file."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 9,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -337,15 +337,15 @@
             "source": [
                 "#### Visualize Topic Assignments\n",
                 "Run the two code blocks below to visualize individual FOVs and the cell-level topic assignment.  The output will be saved to `viz_dir`."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 10,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -359,15 +359,15 @@
                 "training_cells = {}\n",
                 "for i in np.unique(fov_indices):\n",
                 "    training_cells[i] = cell_table[i].iloc[cell_indices[fov_indices == i],:]"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 11,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -420,15 +420,15 @@
             "source": [
                 "## Inferring Topic Weights on New Data\n",
                 "Based on the output from the trained model, you can choose to infer topic weights on the entire pooled data by running the code below.  You can change the number of parallel processes if you like, otherwise it will be the same as when running the training algorithm."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 13,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -467,15 +467,15 @@
                 "## Visualizing and Saving Results\n",
                 "\n",
                 "You can use the same heatmap and plotting functions as above to visualize the results of the full model."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 14,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -502,15 +502,15 @@
                 "spatial_lda.visualization.plot_topics_heatmap(\n",
                 "    complete_model.components_, featurized_cell_table[\"featurized_fovs\"].columns)\n",
                 "plt.savefig(heatmap_path)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 15,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -556,15 +556,15 @@
             "source": [
                 "#### Saving the Trained and Complete Models\n",
                 "Use the code below to save the trained and complete models for use on future data."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 16,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -581,15 +581,15 @@
                 "    dir=os.path.join(base_dir, processed_dir),\n",
                 "    file_name=train_name,\n",
                 "    format=\"pkl\")"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 17,
+            "execution_count": null,
             "metadata": {
                 "collapsed": false,
                 "jupyter": {
                     "outputs_hidden": false
                 },
                 "pycharm": {
                     "name": "#%%\n"
@@ -627,16 +627,15 @@
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
-            "pygments_lexer": "ipython3",
-            "version": "3.8.8"
+            "pygments_lexer": "ipython3"
         },
         "vscode": {
             "interpreter": {
                 "hash": "31e90e2a7155cbaa93471c58eaf30b3c41423e5d17fccea222aec5e482389189"
             }
         }
     },
```

### Comparing `ark-analysis-0.6.3/templates/OME-TIFF_Conversion.ipynb` & `ark-analysis-0.6.4/templates/OME-TIFF_Conversion.ipynb`

 * *Files 4% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9585521708683473%*

 * *Differences: {"'cells'": "{0: {'attachments': OrderedDict()}, 1: {'source': {insert: [(0, 'import os\\n'), (2, "*

 * *            "'from typing import List\\n'), (3, '\\n'), (4, 'from alpineer import load_utils\\n'), "*

 * *            "(6, '\\n'), (7, 'from ark.utils import example_dataset')], delete: [5, 2, 1, 0]}}, 2: "*

 * *            "{'attachments': OrderedDict()}, 5: {'attachments': OrderedDict()}, 7: {'attachments': "*

 * *            'OrderedDict()}}',*

 * * "'metadata'": "{'language_info': {delete: ['version']}, delete: ['orig_nbform […]*

```diff
@@ -1,10 +1,11 @@
 {
     "cells": [
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "# Utility Notebook - OME-TIFF Conversion\n",
                 "\n",
                 "This small notebook contains utilities to convert:\n",
                 "- Multichannel OME-TIFFs into single channel tiff files, with one tiff file per channel in the OME-TIFF.\n",
@@ -24,23 +25,26 @@
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {},
             "outputs": [],
             "source": [
-                "from ark.utils import example_dataset\n",
-                "from alpineer import load_utils\n",
-                "from typing import List\n",
+                "import os\n",
                 "import pathlib\n",
+                "from typing import List\n",
+                "\n",
+                "from alpineer import load_utils\n",
                 "from tqdm.notebook import tqdm\n",
-                "import os"
+                "\n",
+                "from ark.utils import example_dataset"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## OME-TIFF to Single Channel TIFFs"
             ]
         },
         {
@@ -57,14 +61,15 @@
             "metadata": {},
             "outputs": [],
             "source": [
                 "example_dataset.get_example_dataset(dataset=\"ome_tiff\", save_dir = pathlib.Path(\"../data/example_dataset/\"), overwrite_existing = True)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "**Variables:**\n",
                 "* `ome_dir_path`: The directory containing all the OME-TIFFs which will be used.\n",
                 "* `data_dir`: The directory where the Single Channel TIFFs get saved to. Recommended to be a subdirectory in `../data/`."
             ]
@@ -83,14 +88,15 @@
                 "\n",
                 "# Make the paths if they do not exist\n",
                 "data_dir.mkdir(parents=True, exist_ok=True)\n",
                 "ome_dir.mkdir(parents=True, exist_ok=True)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Convert all the OME-TIFFS to Single Channel TIFFs and save them in `data_dir`."
             ]
         },
         {
@@ -201,18 +207,16 @@
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
-            "pygments_lexer": "ipython3",
-            "version": "3.8.15"
+            "pygments_lexer": "ipython3"
         },
-        "orig_nbformat": 4,
         "vscode": {
             "interpreter": {
                 "hash": "9cd428f2623867f362c6ffd1805d28fe273bb79d15f4a3a73107e7f51d98be79"
             }
         }
     },
     "nbformat": 4,
```

### Comparing `ark-analysis-0.6.3/templates/example_neighborhood_analysis_script.ipynb` & `ark-analysis-0.6.4/templates/example_neighborhood_analysis_script.ipynb`

 * *Files 2% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9748351432372659%*

 * *Differences: {"'cells'": "{0: {'attachments': OrderedDict()}, 1: {'attachments': OrderedDict()}, 2: {'source': "*

 * *            "{insert: [(4, 'from scipy.stats import zscore\\n'), (7, 'from ark.analysis import "*

 * *            "(neighborhood_analysis, spatial_analysis_utils,\\n'), (8, '                          "*

 * *            "visualize)\\n')], delete: [10, 6, 5, 3, 2]}}, 3: {'attachments': OrderedDict()}, 5: "*

 * *            "{'attachments': OrderedDict()}, 7: {'attachments': OrderedDict()}, 8: {'attachments': "*

 * *            "Or […]*

```diff
@@ -1,17 +1,19 @@
 {
     "cells": [
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "# Use k-means clustering to find neighborhoods"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "This notebook should be run after cell phenotype labels have been generated. This notebook walks through generation of neighborhoods using k-means clustering.\n",
                 "\n",
                 "Part 1 walks through steps for pre-processing the data, including reading the single cell data and counting the number of neighbors for each cell within a specified pixel radius. Part 2 walks through calculating two metrics that can be used to help determine the optimal number of neighborhoods, k. Part 3 uses k-means clustering to find the neighborhoods. Part 4 walks through some visualizations and Part 5 saves the data."
             ]
@@ -22,27 +24,26 @@
             "metadata": {
                 "tags": []
             },
             "outputs": [],
             "source": [
                 "import os\n",
                 "\n",
-                "import matplotlib.pyplot as plt\n",
-                "import numpy as np\n",
                 "import pandas as pd\n",
-                "import xarray as xr\n",
-                "from scipy.stats import zscore\n",
                 "from alpineer import io_utils, load_utils, misc_utils\n",
+                "from scipy.stats import zscore\n",
                 "\n",
                 "import ark.settings as settings\n",
-                "from ark.analysis import neighborhood_analysis, visualize, spatial_analysis_utils\n",
+                "from ark.analysis import (neighborhood_analysis, spatial_analysis_utils,\n",
+                "                          visualize)\n",
                 "from ark.utils import data_utils, example_dataset, plot_utils"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 0. Download the Example Dataset\n",
                 "\n",
                 "Here we are using the example data located in `/data/example_dataset/input_data`. To modify this notebook to run using your own data, simply change the `base_dir` to point to your own sub-directory within the data folder, rather than `'example_dataset'`.\n",
                 "\n",
@@ -57,14 +58,15 @@
             },
             "outputs": [],
             "source": [
                 "base_dir = \"../data/example_dataset\""
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "If you would like to test the features in Ark with an example dataset, run the cell below. It will download a dataset consisting of 11 FOVs with 22 channels. You may find more information about the example dataset in the [README](../README.md#example-dataset).\n",
                 "\n",
                 "* `overwrite_existing`: If set to `False`, it will not overwrite existing data in the `data/example_dataset`. Recommended setting it to `True` if you have not run Notebooks 1-3."
             ]
@@ -75,33 +77,36 @@
             "metadata": {},
             "outputs": [],
             "source": [
                 "example_dataset.get_example_dataset(dataset=\"neighborhood_analysis\", save_dir=base_dir, overwrite_existing=False)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 1. Pre-process data"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Check `settings.py` and confirm that the correct column names are specified. Importantly, the cell phenotype labels generated from cell clustering should be specified by the \"CELL_TYPE\" variable in `settings.py`. The k-means cluster IDs will be written to the \"KMEANS_CLUSTER\" column specified in `settings.py`.\n",
                 "\n",
                 "* `base_dir`: the path to all of your imaging data. Should contain a directory for your images, segmentations, and cell table (generated from `1_Segment_Image_Data.ipynb`). This directory will also store all of the directories/files created during neighborhood analysis.\n",
                 "* `segmentation_dir`: the path to the directory containing your segmentations (generated from `1_Segment_Image_Data.ipynb`).\n",
                 "* `cell_table_path`: the path to the cell table that contains columns for fov, cell label, and cell phenotype (generated from `3_Pixie_Cluster_Cells.ipynb`)\n",
                 "* `spatial_analysis_dir`: the path to the output directory to store all files created during neighborhood analysis"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 1.1 Read data"
             ]
         },
         {
@@ -117,15 +122,17 @@
                 "spatial_analysis_dir = os.path.join(base_dir, \"spatial_analysis/neighborhood_analysis\")\n",
                 "\n",
                 "neighbors_mat_dir = os.path.join(base_dir, \"spatial_analysis/neighborhood_mats\")\n",
                 "dist_mat_dir = os.path.join(base_dir, \"spatial_analysis/dist_mats\")\n",
                 "\n",
                 "# Create output directory\n",
                 "if not os.path.exists(spatial_analysis_dir):\n",
-                "    os.makedirs(spatial_analysis_dir)"
+                "    os.makedirs(spatial_analysis_dir)\n",
+                "if not os.path.exists(neighbors_mat_dir):\n",
+                "    os.makedirs(neighbors_mat_dir)"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {
                 "tags": []
@@ -171,21 +178,23 @@
                 "misc_utils.verify_in_list(\n",
                 "    dist_mat_fovs=[f.replace('_dist_mat.xr', '') for f in io_utils.list_files(dist_mat_dir, substrs='_dist_mat.xr')],\n",
                 "    input_fovs=all_data[settings.FOV_ID].unique()\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 1.2 Find neighbors for each cell"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "We will now define the neighbors matrix, which will be used as our input for clustering. For each cell in the cell table, count the number of each cell phenotype within a certain distance of that cell. If a cell has no other cells within the distance specfied by `pixel_radius`, that cell is excluded from the analysis.\n",
                 "\n",
                 "The neighbors matrix is saved in the `neighbors_mat_dir`.\n",
                 "- `pixel_radius`: radius used to define the neighbors of each cell\n",
@@ -202,14 +211,15 @@
                 "cell_type_col = settings.CELL_TYPE\n",
                 "\n",
                 "counts_path = os.path.join(neighbors_mat_dir, f\"neighborhood_counts-{cell_type_col}_radius{pixel_radius}.csv\")\n",
                 "freqs_path = os.path.join(neighbors_mat_dir, f\"neighborhood_freqs-{cell_type_col}_radius{pixel_radius}.csv\")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "**If you have previously generated a neighbors matrix with the `pixel_radius` and `cell_type_col` specified, the data will be loaded in below. Otherwise, a new neighbors matrix will be created.**"
             ]
         },
         {
@@ -224,22 +234,23 @@
                 "if os.path.exists(counts_path) and os.path.exists(freqs_path):\n",
                 "    neighbor_counts = pd.read_csv(counts_path)\n",
                 "    neighbor_freqs = pd.read_csv(freqs_path) \n",
                 "    \n",
                 "else:\n",
                 "    # Create new matrix with the radius and cell column specified above\n",
                 "    neighbor_counts, neighbor_freqs = neighborhood_analysis.create_neighborhood_matrix(\n",
-                "        all_data, dist_mat_dir, distlim=pixel_radius)\n",
+                "        all_data, dist_mat_dir, distlim=pixel_radius, cell_type_col=cell_type_col)\n",
                 "    \n",
                 "    # Save neighbor matrices\n",
                 "    neighbor_counts.to_csv(counts_path, index=False)\n",
                 "    neighbor_freqs.to_csv(freqs_path, index=False)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Choose whether to find neighborhoods using count (number of each cell phenotype) or frequency (number of each cell phenotype divided by total number of close neighbors for each cell)."
             ]
         },
         {
@@ -258,21 +269,23 @@
                 "elif neighborhood_method == \"frequency\":\n",
                 "    input_features = neighbor_freqs\n",
                 "else:\n",
                 "    raise ValueError(\"neighborhood_method must be either 'counts' or 'frequency'\")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 2. Find optimal k using various metrics"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Use various metrics to determine the optimal k for k-means clustering. k's ranging from `min_k` to `max_k` will be tested."
             ]
         },
         {
@@ -285,30 +298,32 @@
             "source": [
                 "# The minimum and maximum k that will be tested\n",
                 "min_k = 2\n",
                 "max_k = 10"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 2.1 Inertia"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Inertia is calculated by measuring the distance between each data point and its centroid, squaring this distance, and summing these squares across one cluster."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 10,
+            "execution_count": null,
             "metadata": {
                 "tags": []
             },
             "outputs": [
                 {
                     "data": {
                         "application/vnd.jupyter.widget-view+json": {
@@ -321,49 +336,52 @@
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 },
                 {
                     "data": {
-                        "image/png": "iVBORw0KGgoAAAANSUhEUgAAAlUAAAHHCAYAAACWQK1nAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy88F64QAAAACXBIWXMAAA9hAAAPYQGoP6dpAABhTklEQVR4nO3deVxU5f4H8M/MwAzrsMiuLCIqsrhhIlppSaKh7WpmpZlphTdNM6N+udR1a7uZmZp1xVuZZmXlhplbqbihKCoiKijKpiirrDPP7w9lcgJ1wIEzDJ/36zWv65zzzJnvGbjNh/MsRyaEECAiIiKiuyKXugAiIiIic8BQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRdTE4uLiIJPJkJGRIXUptYwePRp+fn5Sl9GsjR49GnZ2dlKXYbD4+Hh07doVVlZWkMlkKCgoaPCxduzYAZlMhh07dhitPqLmhKGKqIXJysrCzJkzkZSUJHUpJLH8/HwMGzYM1tbWWLRoEb755hvY2tpKXdYt7dmzBzNnzryr4EfUmBiqiJrYc889h7KyMvj6+kry/llZWZg1a1adoWrZsmVITU1t+qJIEgcOHEBxcTHef/99vPjii3j22WdhaWkpdVm3tGfPHsyaNYuhikwWQxVRE1MoFLqulqZUXV2NysrK27axtLSESqVqooqooYQQKCsru+vj5OXlAQAcHR3v+ljN2bVr16QugcwEQxVRE6trTJWfnx8GDx6MXbt2oWfPnrCysoK/vz/+97//1Xp9QUEBJk2aBG9vb6hUKgQEBGD+/PnQarW6NhkZGZDJZPjoo4/w6aefol27dlCpVPjiiy9wzz33AABeeOEFyGQyyGQyxMXFAah7TNVHH32E3r17o1WrVrC2tkZYWBh+/PHHO57nhAkTYGdnV+cX1ogRI+Dh4QGNRgMAOHjwIKKiouDi4gJra2u0bdsWY8aMueN7GPq5zZw5s84Qe7ufxY4dO9CjRw9YW1sjNDRUN07o559/RmhoKKysrBAWFobDhw/XWdvZs2cRFRUFW1tbeHl54b333oMQQq+NVqvFp59+iuDgYFhZWcHd3R3jx4/H1atX6zzPzZs362paunTpbT+bNWvWICwsDNbW1nBxccGzzz6Lixcv6vb369cPo0aNAgDcc889kMlkGD169G2PefHiRbz44ovw8vKCSqVC27Zt8corr9w2rPv5+dV53H79+qFfv3562xYuXIjg4GDY2NjAyckJPXr0wMqVKwFc/xlOnToVANC2bVvd7+7NP7tvv/1Wd87Ozs54+umnkZmZWet9Q0JCkJiYiPvvvx82NjZ4++23ATT895CohoXUBRDRdadPn8ZTTz2FF198EaNGjcJ///tfjB49GmFhYQgODgZw/S/qvn374uLFixg/fjx8fHywZ88exMbGIjs7G59++qneMZcvX47y8nKMGzcOKpUKjz/+OIqLizF9+nSMGzcO9913HwCgd+/et6xrwYIFeOSRRzBy5EhUVlZi1apVGDp0KNavX4/o6Ohbvm748OFYtGgRNmzYgKFDh+q2X7t2DevWrcPo0aOhUCiQl5eHAQMGwNXVFW+99RYcHR2RkZGBn3/+2WifW32dPn0azzzzDMaPH49nn30WH330EYYMGYIlS5bg7bffxquvvgoAmDt3LoYNG4bU1FTI5X//jarRaDBw4ED06tULH3zwAeLj4zFjxgxUV1fjvffe07UbP3484uLi8MILL+C1115Deno6Pv/8cxw+fBi7d+/W64pLTU3FiBEjMH78eLz00kvo2LHjLeuvOeY999yDuXPnIjc3FwsWLMDu3btx+PBhODo64p133kHHjh3x5Zdf4r333kPbtm3Rrl27Wx4zKysLPXv2REFBAcaNG4fAwEBcvHgRP/74I65duwalUtmgz7rGsmXL8Nprr+Gpp57CxIkTUV5ejqNHj2Lfvn145pln8MQTT+DUqVP4/vvv8Z///AcuLi4AAFdXVwDA7Nmz8e6772LYsGEYO3YsLl26hIULF+L+++/XnXON/Px8DBo0CE8//TSeffZZuLu73/XvIREAQBBRk1q+fLkAINLT03XbfH19BQDx559/6rbl5eUJlUolpkyZotv2/vvvC1tbW3Hq1Cm9Y7711ltCoVCI8+fPCyGESE9PFwCEWq0WeXl5em0PHDggAIjly5fXqm3UqFHC19dXb9u1a9f0nldWVoqQkBDx4IMP3vY8tVqtaN26tXjyySf1tv/www9657p27VoBQBw4cOC2x6uLoZ/bjBkzRF3/ubvdz2LPnj26bZs3bxYAhLW1tTh37pxu+9KlSwUAsX37dt22UaNGCQDiX//6l95nER0d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AT777DMsWbIE+/btg62tLaKiolBeXq5rM3LkSBw/fhxbtmzB+vXr8eeff2LcuHG6/UVFRRgwYAB8fX2RmJiIDz/8EDNnzsSXX36pa7Nnzx6MGDECL774Ig4fPozHHnsMjz32GI4dO1avWloKK0sFHmIXIBER0d+EhKZNmybuvffeW+7XarXCw8NDfPjhh7ptBQUFQqVSie+//14IIcSJEycEAHHgwAFdm02bNgmZTCYuXrwohBDiiy++EE5OTqKiokLvvTt27Kh7PmzYMBEdHa33/uHh4WL8+PEG13InhYWFAoAoLCw0qL2p+/14jvCdtl70mvOH0Gi0UpdDRETUKAz9/pb0StVvv/2GHj16YOjQoXBzc0O3bt2wbNky3f709HTk5OQgMjJSt83BwQHh4eFISEgAACQkJMDR0RE9evTQtYmMjIRcLse+fft0be6//34olUpdm6ioKKSmpuLq1au6Nje/T02bmvcxpJaW5r72LrBTWSC7sByHM69KXQ4REZGkJA1VZ8+exeLFi9G+fXts3rwZr7zyCl577TWsWLECAJCTkwMAcHd313udu7u7bl9OTg7c3Nz09ltYWMDZ2VmvTV3HuPk9btXm5v13quWfKioqUFRUpPcwJzd3Aa5nFyAREbVwkoYqrVaL7t27Y86cOejWrRvGjRuHl156CUuWLJGyLKOZO3cuHBwcdA9vb2+pSzK6aM4CJCIiAiBxqPL09ERQUJDetk6dOuH8+fMAAA8PDwBAbm6uXpvc3FzdPg8PD+Tl5entr66uxpUrV/Ta1HWMm9/jVm1u3n+nWv4pNjYWhYWFukdmZmad7Zqz+zq4wF5lgdyiChw6zy5AIiJquSQNVX369EFqaqretlOnTsHX1xcA0LZtW3h4eGDr1q26/UVFRdi3bx8iIiIAABERESgoKEBiYqKuzbZt26DVahEeHq5r8+eff6KqqkrXZsuWLejYsaNupmFERITe+9S0qXkfQ2r5J5VKBbVarfcwNyoLdgESEREBkHb23/79+4WFhYWYPXu2SEtLE999952wsbER3377ra7NvHnzhKOjo/j111/F0aNHxaOPPiratm0rysrKdG0GDhwounXrJvbt2yd27dol2rdvL0aMGKHbX1BQINzd3cVzzz0njh07JlatWiVsbGzE0qVLdW12794tLCwsxEcffSRSUlLEjBkzhKWl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fXtYW1sbvNyCq6sriouLUVpaqttW12fXoUMHvP766/j999/xxBNP6Ab0K5VKaDQavbbdunWDRqNBXl5erc/Ew8PjjjV169YNsbGx2LNnD0JCQrBy5UqDzoXIHDFUEVGjCA0NxciRI/HZZ5/pbe/Xrx8uXbqEDz74AGfOnMGiRYuwadMmo73vokWLsHbtWpw8eRIxMTG4evUqxowZAwCIiYnBlStXMGLECBw4cABnzpzB5s2b8cILL9QKG3cydepUzJ8/H6tXr0ZqaireeustJCUlYeLEiQYfw8rKCtOmTcObb76J//3vfzhz5gz27t2Lr7/+us724eHhsLGxwdtvv40zZ85g5cqViIuL0+0vKyvDhAkTsGPHDpw7dw67d+/GgQMHdKHSz88PJSUl2Lp1Ky5fvoxr166hQ4cOGDlyJJ5//nn8/PPPSE9Px/79+zF37lxs2LDhlrWnp6cjNjYWCQkJOHfuHH7//XekpaXp3ouoJWKoIqJG895779XqnuvUqRO++OILLFq0CF26dMH+/ftvOTOuIebNm4d58+ahS5cu2LVrF3777Te4uLgAgO7qkkajwYABAxAaGopJkybB0dFRb/yWIV577TVMnjwZU6ZMQWhoKOLj4/Hbb7+hffv29TrOu+++iylTpmD69Ono1KkThg8fXmucWA1nZ2d8++232LhxI0JDQ/H999/rLdWgUCiQn5+P559/Hh06dMCwYcMwaNAgzJo1CwDQu3dvvPzyyxg+fDhcXV3xwQcfALjejff8889jypQp6NixIx577DEcOHAAPj4+t6zbxsYGJ0+exJNPPokOHTpg3LhxiImJwfjx4+t1/kTmRCb+2UFPRERERPXGK1VERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQE/w8AEp9p/cY+pgAAAABJRU5ErkJggg==\n",
+                        "image/png": "iVBORw0KGgoAAAANSUhEUgAAAlUAAAHHCAYAAACWQK1nAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy88F64QAAAACXBIWXMAAA9hAAAPYQGoP6dpAABhTklEQVR4nO3deVxU5f4H8M/MwAzrsMiuLCIqsrhhIlppSaKh7WpmpZlphTdNM6N+udR1a7uZmZp1xVuZZmXlhplbqbihKCoiKijKpiirrDPP7w9lcgJ1wIEzDJ/36zWv65zzzJnvGbjNh/MsRyaEECAiIiKiuyKXugAiIiIic8BQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRdTE4uLiIJPJkJGRIXUptYwePRp+fn5Sl9GsjR49GnZ2dlKXYbD4+Hh07doVVlZWkMlkKCgoaPCxduzYAZlMhh07dhitPqLmhKGKqIXJysrCzJkzkZSUJHUpJLH8/HwMGzYM1tbWWLRoEb755hvY2tpKXdYt7dmzBzNnzryr4EfUmBiqiJrYc889h7KyMvj6+kry/llZWZg1a1adoWrZsmVITU1t+qJIEgcOHEBxcTHef/99vPjii3j22WdhaWkpdVm3tGfPHsyaNYuhikwWQxVRE1MoFLqulqZUXV2NysrK27axtLSESqVqooqooYQQKCsru+vj5OXlAQAcHR3v+ljN2bVr16QugcwEQxVRE6trTJWfnx8GDx6MXbt2oWfPnrCysoK/vz/+97//1Xp9QUEBJk2aBG9vb6hUKgQEBGD+/PnQarW6NhkZGZDJZPjoo4/w6aefol27dlCpVPjiiy9wzz33AABeeOEFyGQyyGQyxMXFAah7TNVHH32E3r17o1WrVrC2tkZYWBh+/PHHO57nhAkTYGdnV+cX1ogRI+Dh4QGNRgMAOHjwIKKiouDi4gJra2u0bdsWY8aMueN7GPq5zZw5s84Qe7ufxY4dO9CjRw9YW1sjNDRUN07o559/RmhoKKysrBAWFobDhw/XWdvZs2cRFRUFW1tbeHl54b333oMQQq+NVqvFp59+iuDgYFhZWcHd3R3jx4/H1atX6zzPzZs362paunTpbT+bNWvWICwsDNbW1nBxccGzzz6Lixcv6vb369cPo0aNAgDcc889kMlkGD169G2PefHiRbz44ovw8vKCSqVC27Zt8corr9w2rPv5+dV53H79+qFfv3562xYuXIjg4GDY2NjAyckJPXr0wMqVKwFc/xlOnToVANC2bVvd7+7NP7tvv/1Wd87Ozs54+umnkZmZWet9Q0JCkJiYiPvvvx82NjZ4++23ATT895CohoXUBRDRdadPn8ZTTz2FF198EaNGjcJ///tfjB49GmFhYQgODgZw/S/qvn374uLFixg/fjx8fHywZ88exMbGIjs7G59++qneMZcvX47y8nKMGzcOKpUKjz/+OIqLizF9+nSMGzcO9913HwCgd+/et6xrwYIFeOSRRzBy5EhUVlZi1apVGDp0KNavX4/o6Ohbvm748OFYtGgRNmzYgKFDh+q2X7t2DevWrcPo0aOhUCiQl5eHAQMGwNXVFW+99RYcHR2RkZGBn3/+2WifW32dPn0azzzzDMaPH49nn30WH330EYYMGYIlS5bg7bffxquvvgoAmDt3LoYNG4bU1FTI5X//jarRaDBw4ED06tULH3zwAeLj4zFjxgxUV1fjvffe07UbP3484uLi8MILL+C1115Deno6Pv/8cxw+fBi7d+/W64pLTU3FiBEjMH78eLz00kvo2LHjLeuvOeY999yDuXPnIjc3FwsWLMDu3btx+PBhODo64p133kHHjh3x5Zdf4r333kPbtm3Rrl27Wx4zKysLPXv2REFBAcaNG4fAwEBcvHgRP/74I65duwalUtmgz7rGsmXL8Nprr+Gpp57CxIkTUV5ejqNHj2Lfvn145pln8MQTT+DUqVP4/vvv8Z///AcuLi4AAFdXVwDA7Nmz8e6772LYsGEYO3YsLl26hIULF+L+++/XnXON/Px8DBo0CE8//TSeffZZuLu73/XvIREAQBBRk1q+fLkAINLT03XbfH19BQDx559/6rbl5eUJlUolpkyZotv2/vvvC1tbW3Hq1Cm9Y7711ltCoVCI8+fPCyGESE9PFwCEWq0WeXl5em0PHDggAIjly5fXqm3UqFHC19dXb9u1a9f0nldWVoqQkBDx4IMP3vY8tVqtaN26tXjyySf1tv/www9657p27VoBQBw4cOC2x6uLoZ/bjBkzRF3/ubvdz2LPnj26bZs3bxYAhLW1tTh37pxu+9KlSwUAsX37dt22UaNGCQDiX//6l95nER0d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AT777DMsWbIE+/btg62tLaKiolBeXq5rM3LkSBw/fhxbtmzB+vXr8eeff2LcuHG6/UVFRRgwYAB8fX2RmJiIDz/8EDNnzsSXX36pa7Nnzx6MGDECL774Ig4fPozHHnsMjz32GI4dO1avWloKK0sFHmIXIBER0d+EhKZNmybuvffeW+7XarXCw8NDfPjhh7ptBQUFQqVSie+//14IIcSJEycEAHHgwAFdm02bNgmZTCYuXrwohBDiiy++EE5OTqKiokLvvTt27Kh7PmzYMBEdHa33/uHh4WL8+PEG13InhYWFAoAoLCw0qL2p+/14jvCdtl70mvOH0Gi0UpdDRETUKAz9/pb0StVvv/2GHj16YOjQoXBzc0O3bt2wbNky3f709HTk5OQgMjJSt83BwQHh4eFISEgAACQkJMDR0RE9evTQtYmMjIRcLse+fft0be6//34olUpdm6ioKKSmpuLq1au6Nje/T02bmvcxpJaW5r72LrBTWSC7sByHM69KXQ4REZGkJA1VZ8+exeLFi9G+fXts3rwZr7zyCl577TWsWLECAJCTkwMAcHd313udu7u7bl9OTg7c3Nz09ltYWMDZ2VmvTV3HuPk9btXm5v13quWfKioqUFRUpPcwJzd3Aa5nFyAREbVwkoYqrVaL7t27Y86cOejWrRvGjRuHl156CUuWLJGyLKOZO3cuHBwcdA9vb2+pSzK6aM4CJCIiAiBxqPL09ERQUJDetk6dOuH8+fMAAA8PDwBAbm6uXpvc3FzdPg8PD+Tl5entr66uxpUrV/Ta1HWMm9/jVm1u3n+nWv4pNjYWhYWFukdmZmad7Zqz+zq4wF5lgdyiChw6zy5AIiJquSQNVX369EFqaqretlOnTsHX1xcA0LZtW3h4eGDr1q26/UVFRdi3bx8iIiIAABERESgoKEBiYqKuzbZt26DVahEeHq5r8+eff6KqqkrXZsuWLejYsaNupmFERITe+9S0qXkfQ2r5J5VKBbVarfcwNyoLdgESEREBkHb23/79+4WFhYWYPXu2SEtLE999952wsbER3377ra7NvHnzhKOjo/j111/F0aNHxaOPPiratm0rysrKdG0GDhwounXrJvbt2yd27dol2rdvL0aMGKHbX1BQINzd3cVzzz0njh07JlatWiVsbGzE0qVLdW12794tLCwsxEcffSRSUlLEjBkzhKWlpUhOTq5XLbdjbrP/avxx4voswHv+vYWzAImIyOwY+v0taagSQoh169aJkJAQoVKpRGBgoPjyyy/19mu1WvHuu+8Kd3d3oVKpRP/+/UVqaqpem/z8fDFixAhhZ2cn1Gq1eOGFF0RxcbFemyNHjoh7771XqFQq0bp1azFv3rxatfzwww+iQ4cOQqlUiuDgYLFhw4Z613I75hqqyquqRciMeOE7bb3YdzZf6nKIiIiMytDvb5kQgqOLm0hRUREcHBxQWFhodl2BU344gp8OXcDo3n6Y+Uiw1OUQEREZjaHf35LfpobMw+DOf88C1HAWIBERtUAMVWQUfQJcoLayQF5xBQ5mXJG6HCIioibHUEVGobSQY0Dw9aUlNiRzFiAREbU8DFVkNNG6LsAcdgESEVGLw1BFRtOnnQscrC1xuaQCB9gFSERELQxDFRmN0kKOATcWAt3AhUCJiKiFYagio6rpAtx0jLMAiYioZWGoIqPqE1DTBViJfen5UpdDRETUZBiqyKgsFXIMvDELcCNnARIRUQvCUEVG9/CNLsD4Yzmo1mglroaIiKhpMFSR0fVu1wqONte7APencxYgERG1DAxVZHQ3dwGuZxcgERG1EAxV1ChqZgFuZhcgERG1EAxV1Cgi/FvBycYS+aWV2McuQCIiagEYqqhRWCjkGBhyowuQC4ESEVELwFBFjSY61AsAEH8sm12ARERk9hiqqNH08neGs60SV69VIeEsFwIlIiLzxlBFjebmLkAuBEpEROaOoYoaVXTo3wuBVrELkIiIzBhDFTWq8LbOaFXTBXiGXYBERGS+GKqoUd3cBbiBswCJiMiMMVRRo9MtBHqCXYBERGS+GKqo0YW3bQUXOyUKrlVhD7sAiYjITDFUUaNTyGU3dQFmSVwNERFR42CooiZRsxDo5uO5qKxmFyAREZkfhipqEj3bOsPFToXCsirsPnNZ6nKIiIiMjqGKmoRCLsPDoTcWAuUsQCIiMkMMVdRkHr6xEOjm4znsAiQiIrPDUEVN5h4/Z7jaq1BUXo3dp9kFSERE5oWhipqMQi7DwzdmAa5nFyAREZkZhipqUtGdr88C/P0EuwCJiMi8MFRRk+rh6wQ3exWKy6ux6/QlqcshIiIyGoYqalJyuUw3YJ1dgEREZE4YqqjJ1dwLcMvxXFRUaySuhoiIyDgYqqjJhfk4wV2tQnFFNXalcRYgERGZB4YqanI3dwFuYBcgERGZCYYqkkT0jVC15UQuyqvYBUhERM0fQxVJoruPEzzUViiuqMZf7AIkIiIzwFBFktDvAsySuBoiIqK7x1BFkqmZBfhHSh67AImIqNljqCLJdPN2hKeDFUoqqvHnKS4ESkREzRtDFUlGrwswmbMAiYioeWOoIknpugA5C5CIiJo5hiqSVDdvR7R2tEZppQY72QVIRETNGEMVSUomk2FQiAcALgRKRETNG0MVSe7vWYDsAiQiouaLoYok1/VGF+C1Sg12pOZJXQ4REVGDMFSR5GQyme5q1YbkHImrISIiahiGKjIJNfcC3JqSi7JKdgESEVHzw1BFJqFzGwe0cWIXIBERNV8MVWQSZDKZ7mrVei4ESkREzZBFQ1944cIF/Pbbbzh//jwqKyv19n3yySd3XRi1PNGdPbH0z7PYlpKHskoNrJUKqUsiIiIyWINC1datW/HII4/A398fJ0+eREhICDIyMiCEQPfu3Y1dI7UQoa0d4O1sjcwrZdiemqe7hQ0REVFz0KDuv9jYWLzxxhtITk6GlZUVfvrpJ2RmZqJv374YOnSosWukFkImu+legFwIlIiImpkGhaqUlBQ8//zzAAALCwuUlZXBzs4O7733HubPn2/UAqllGRzqBQDYejIX1yqrJa6GiIjIcA0KVba2trpxVJ6enjhz5oxu3+XLl41TGbVIIa3V8HG2QXmVFttOchYgERE1Hw0KVb169cKuXbsAAA8//DCmTJmC2bNnY8yYMejVq5dRC6SW5eaFQDdyFiARETUjDRqo/sknn6CkpAQAMGvWLJSUlGD16tVo3749Z/7RXYsO9cTiHWew7WQeSiuqYatq8CRVIiKiJtOgK1X+/v7o3LkzgOtdgUuWLMHRo0fx008/wdfX1+DjzJw5EzKZTO8RGBio219eXo6YmBi0atUKdnZ2ePLJJ5Gbm6t3jPPnzyM6Oho2NjZwc3PD1KlTUV2tPxZnx44d6N69O1QqFQICAhAXF1erlkWLFsHPzw9WVlYIDw/H/v379fYbUgsZR7CXGr6t2AVIRETNi+SLfwYHByM7O1v3qOlWBIDXX38d69atw5o1a7Bz505kZWXhiSee0O3XaDSIjo5GZWUl9uzZgxUrViAuLg7Tp0/XtUlPT0d0dDQeeOABJCUlYdKkSRg7diw2b96sa7N69WpMnjwZM2bMwKFDh9ClSxdERUUhLy/P4FrIeG5eCJSzAImIqNkQBnJychKXLl0SQgjh6OgonJycbvkw1IwZM0SXLl3q3FdQUCAsLS3FmjVrdNtSUlIEAJGQkCCEEGLjxo1CLpeLnJwcXZvFixcLtVotKioqhBBCvPnmmyI4OFjv2MOHDxdRUVG65z179hQxMTG65xqNRnh5eYm5c+caXIshCgsLBQBRWFho8GtaqmMXC4TvtPWiwzsbRUl5ldTlEBFRC2bo97fBg1X+85//wN7eXvdvmUxmlFCXlpYGLy8vWFlZISIiAnPnzoWPjw8SExNRVVWFyMhIXdvAwED4+PggISEBvXr1QkJCAkJDQ+Hu7q5rExUVhVdeeQXHjx9Ht27dkJCQoHeMmjaTJk0CAFRWViIxMRGxsbG6/XK5HJGRkUhISAAAg2qpS0VFBSoqKnTPi4qKGv5BtTBBnmq0dbFF+uVSbD2Zh0e6eEldEhER0W0ZHKpGjRql+/fo0aON8ubh4eGIi4tDx44dkZ2djVmzZuG+++7DsWPHkJOTA6VSCUdHR73XuLu7IycnBwCQk5OjF6hq9tfsu12boqIilJWV4erVq9BoNHW2OXnypO4Yd6qlLnPnzsWsWbMM+zBIz/WFQD2waPsZbDiaxVBFREQmr0FjqhQKhd54oxr5+flQKAy/X9ugQYMwdOhQdO7cGVFRUdi4cSMKCgrwww8/NKQskxMbG4vCwkLdIzMzU+qSmpXoGwuBbk+9hJIKLgRKRESmrUGhSghR5/aKigoolcoGF+Po6IgOHTrg9OnT8PDwQGVlJQoKCvTa5ObmwsPDAwDg4eFRawZezfM7tVGr1bC2toaLiwsUCkWdbW4+xp1qqYtKpYJardZ7kOE6edrD38UWldVabE3hTEsiIjJt9QpVn332GT777DPIZDJ89dVXuuefffYZ/vOf/yAmJkZvSYT6KikpwZkzZ+Dp6YmwsDBYWlpi69atuv2pqak4f/48IiIiAAARERFITk7Wu2q2ZcsWqNVqBAUF6drcfIyaNjXHUCqVCAsL02uj1WqxdetWXRtDaiHju3khUM4CJCIik1ef0e9+fn7Cz89PyGQy4e3trXvu5+cnOnToIAYMGCD27t1r8PGmTJkiduzYIdLT08Xu3btFZGSkcHFxEXl5eUIIIV5++WXh4+Mjtm3bJg4ePCgiIiJERESE7vXV1dUiJCREDBgwQCQlJYn4+Hjh6uoqYmNjdW3Onj0rbGxsxNSpU0VKSopYtGiRUCgUIj4+Xtdm1apVQqVSibi4OHHixAkxbtw44ejoqDer8E61GIKz/+rvRFah8J22XrR/Z6MoKquUuhwiImqBDP3+rleoqtGvXz9x9erVhrxUz/Dhw4Wnp6dQKpWidevWYvjw4eL06dO6/WVlZeLVV18VTk5OwsbGRjz++OMiOztb7xgZGRli0KBBwtraWri4uIgpU6aIqir9Kfjbt28XXbt2FUqlUvj7+4vly5fXqmXhwoXCx8dHKJVK0bNnz1rh0JBa7oShqv60Wq144KPtwnfaerH20AWpyyEiohbI0O9vmRC3GCB1C1VVVQgMDMT69evRqVOnxrh4ZraKiorg4OCAwsJCjq+qh09+T8Vn204jwr8Vvh0bDoXcOMt5EBERGcLQ7+96D1S3tLREeXn5XRVHVB+PdmsNhVyGhLP5eH11Eqo1WqlLIiIiqqVBs/9iYmIwf/78WvfYI2oM7Vzt8PmIbrCQy/DbkSz86/vDqKxmsCIiItNS7+4/AHj88cexdetW2NnZITQ0FLa2tnr7f/75Z6MVaE7Y/Xd3/jiRi1e/O4RKjRaRndywaGR3qCwMXxeNiIioIRqt+w+4vp7Uk08+iaioKHh5ecHBwUHvQdQYIoPc8eXzYVBZyPFHSh5e+l8iyqs0UpdFREQEoIFXqqhheKXKOPacvowXVxxEWZUGvdu1wlejesBGafAdl4iIiOqlUa9UAUB1dTX++OMPLF26FMXFxQCArKwslJSUNPSQRAbpHeCCFWN6wlapwJ4z+Rj93wO8jQ0REUmuQaHq3LlzCA0NxaOPPoqYmBhcunQJADB//ny88cYbRi2QqC492zrjm7HhsLeywP6MK3ju630oLKuSuiwiImrBGhSqJk6ciB49euDq1auwtrbWba8ZwE7UFLr7OGHl2F5wsLbE4fMFeParfSi4Vil1WURE1EI1KFT99ddf+L//+79aN0/28/PDxYsXjVIYkSFC2zjg+5d6wdlWieSLhXj6y73IL6mQuiwiImqBGhSqtFotNJras64uXLgAe3v7uy6KqD6CvNRYNa4XXOxUOJlTjKe/3Iu8Yi5QS0RETatBoWrAgAH49NNPdc9lMhlKSkowY8YMPPzww8aqjchgHdzt8cP4XvBQWyEtrwRPL92LnEIGKyIiajoNWlLhwoULiIqKghACaWlp6NGjB9LS0uDi4oI///wTbm5ujVFrs8clFRrfufxSPLNsHy4WlMHH2QYrXwpHGycbqcsiIqJmzNDv7wavU1VdXY1Vq1bh6NGjKCkpQffu3TFy5Ei9geukj6GqaVy4eg3PLNuH81euobWjNVa+FA7fVrZ3fiEREVEdGj1UUf0xVDWd7MIyjFy2D2cvl8JDbYXvXgpHO1c7qcsiIqJmqNFDVVpaGrZv3468vDxotfo3t50+fXpDDmn2GKqaVl5xOUYu24e0vBK42Kmw8qVwdHDnRAoiIqqfRg1Vy5YtwyuvvAIXFxd4eHhAJpP9fUCZDIcOHWpY1WaOoarp5ZdU4Nmv9yMluwjOtkp8+2I4grz42RMRkeEaNVT5+vri1VdfxbRp0+6qyJaGoUoaBdcq8dzX+5F8sRAO1pb45sWe6NzGUeqyiIiomWjUe/9dvXoVQ4cObXBxRE3J0UaJb8eGo5uPIwrLqjBy2T4cOn9V6rKIiMjMNChUDR06FL///ruxayFqNNevUIWjp58ziiuq8dxX+7A//YrUZRERkRmxaMiLAgIC8O6772Lv3r0IDQ2FpaWl3v7XXnvNKMURGZOdygJxY+7B2BUHsedMPkb9dz++GtUDfQJcpC6NiIjMQIPGVLVt2/bWB5TJcPbs2bsqylxxTJVpKK/SYPw3idh56hJUFnIsfS4M/TpywVoiIqob16kyQQxVpqOiWoOY7w7hj5Q8KBVyfDGyOyKD3KUui4iITJDRQ9XkyZPx/vvvw9bWFpMnT771AWUyfPzxx/WvuAVgqDItldVaTFx1GJuO5cBCLsPCEd0wKNRT6rKIiMjEGPr9bfCYqsOHD6Oqqkr371u5ec0qIlOmtJBj4YhumPzDEfx2JAsTvj+MTzRaPNq1tdSlERFRM8TuvybEK1WmSaMVmPbTUfyYeAEyGfDhU13wVFgbqcsiIiIT0ajrVBGZE4Vchg+e7IwRPX0gBDD1xyNYue+81GUREVEzw1BFBEAul2HO4yEYFeELIYC31yZjxZ4MqcsiIqJmhKGK6AaZTIaZjwTjpfuuLxky47fjWPYnlwchIiLDMFQR3UQmk+HthzthwgMBAIDZG1Pw+bY0iasiIqLmgKGK6B9kMhneiOqIyQ91AAB89PspfPJ7Kjing4iIboehiugWXuvfHm8NCgQAfLbtNObFn2SwIiKiW2KoIrqNl/u2w/TBQQCApTvP4r31JxisiIioTgxVRHcw5t62+PdjIQCA5bsz8O6vx6DVMlgREZE+hioiAzzbyxcfPNkZMhnw7d7zeOvno9AwWBER0U0YqogMNOweb3wyrAvkMuCHgxfwxpojqNZopS6LiIhMBEMVUT083q0NPhvRDQq5DGsPX8TEVUmoYrAiIiIwVBHV2+DOXvhiZHdYKmTYkJyNV787hIpqjdRlERGRxBiqiBogKtgDXz7XA0oLObacyMXL3ySivIrBioioJWOoImqgBwLd8PWoHrCylGN76iWMXXEQZZUMVkRELRVDFdFduK+9K+Je6AkbpQK7Tl/G6OX7UVpRLXVZREQkAYYqorvUy78V/jemJ+xUFtiXfgXP/3c/isqrpC6LiIiaGEMVkRH08HPGt2PDobayQOK5q3juq30ovMZgRUTUkjBUERlJV29HrHypF5xsLHHkQiFGLNuLK6WVUpdFRERNhKGKyIhCWjvg+3G94GKnxInsIoz4ci8uFVdIXRYRETUBhioiIwv0UGPVuAi42auQmluMp79MQG5RudRlERFRI2OoImoEAW52+GF8BLwcrHDmUimGL01AVkGZ1GUREVEjYqgiaiR+LrZYPT4CbZyskZF/DcOWJiDzyjWpyyIiokbCUEXUiLydbfDD+Aj4tbLBhatlGLY0AemXS6Uui4iIGgFDFVEj83K0xurxEWjnaovswnIMX5qA03nFUpdFRERGxlBF1ATc1VZYNS4CHd3tkVdcgeFL9+JkTpHUZRERkRExVBE1EVd7Fb4f1wvBXmrkl1bi6S/34tjFQqnLIiIiI2GoImpCzrZKrBzbC128HVFwrQrPLNuLpMwCqcsiIiIjYKgiamIONpb49sWe6OHrhKLyajz71T4czLgidVlERHSXGKqIJGBvZYkVY3qil78zSiqq8fx/9yPhTL7UZRER0V1gqCKSiK3KAstH98R97V1wrVKDUf/dj/nxJ1FczhsxExE1RwxVRBKyViqw7PkeiAp2R6VGi8U7zqDfhzvwzd5zqNZopS6PiIjqQSaEEFIX0VIUFRXBwcEBhYWFUKvVUpdDJkQIga0peZizKQVnL11fHDTAzQ5vPxyIBzq6QSaTSVwhEVHLZej3t8lcqZo3bx5kMhkmTZqk21ZeXo6YmBi0atUKdnZ2ePLJJ5Gbm6v3uvPnzyM6Oho2NjZwc3PD1KlTUV1drddmx44d6N69O1QqFQICAhAXF1fr/RctWgQ/Pz9YWVkhPDwc+/fv19tvSC1EDSWTyRAZ5I7Nk+7He48Gw9lWidN5JRgTdxDPfr0Px7O49AIRkakziVB14MABLF26FJ07d9bb/vrrr2PdunVYs2YNdu7ciaysLDzxxBO6/RqNBtHR0aisrMSePXuwYsUKxMXFYfr06bo26enpiI6OxgMPPICkpCRMmjQJY8eOxebNm3VtVq9ejcmTJ2PGjBk4dOgQunTpgqioKOTl5RlcC5ExWCrkeD7CDzum9sP4vv5QKuTYfTofgxfuwhtrjiCnsFzqEomI6FaExIqLi0X79u3Fli1bRN++fcXEiROFEEIUFBQIS0tLsWbNGl3blJQUAUAkJCQIIYTYuHGjkMvlIicnR9dm8eLFQq1Wi4qKCiGEEG+++aYIDg7We8/hw4eLqKgo3fOePXuKmJgY3XONRiO8vLzE3LlzDa7FEIWFhQKAKCwsNPg11LKdzy8VE1YeEr7T1gvfaetF4P9tEp/8nipKK6qkLo2IqMUw9Ptb8itVMTExiI6ORmRkpN72xMREVFVV6W0PDAyEj48PEhISAAAJCQkIDQ2Fu7u7rk1UVBSKiopw/PhxXZt/HjsqKkp3jMrKSiQmJuq1kcvliIyM1LUxpJa6VFRUoKioSO9BVB/ezjZYOKIb1r7aG2G+Tiir0mDB1jT0+3AHfjiQCY2WQyKJiEyFpKFq1apVOHToEObOnVtrX05ODpRKJRwdHfW2u7u7IycnR9fm5kBVs79m3+3aFBUVoaysDJcvX4ZGo6mzzc3HuFMtdZk7dy4cHBx0D29v71u2Jbqdbj5O+PHlCHwxsjt8nG2QV1yBN386iujP/sJfaZekLo+IiCBhqMrMzMTEiRPx3XffwcrKSqoyGlVsbCwKCwt1j8zMTKlLomZMJpPh4VBPbJl8P/4vuhPUVhY4mVOM577ejxeW70dabrHUJRIRtWiSharExETk5eWhe/fusLCwgIWFBXbu3InPPvsMFhYWcHd3R2VlJQoKCvRel5ubCw8PDwCAh4dHrRl4Nc/v1EatVsPa2houLi5QKBR1trn5GHeqpS4qlQpqtVrvQXS3VBYKjL3PHzunPoAX+vjBQi7D9tRLGLjgL7yzNhmXiiukLpGIqEWSLFT1798fycnJSEpK0j169OiBkSNH6v5taWmJrVu36l6TmpqK8+fPIyIiAgAQERGB5ORkvVl6W7ZsgVqtRlBQkK7NzceoaVNzDKVSibCwML02Wq0WW7du1bUJCwu7Yy1ETc3JVokZQ4KxZXJfRAW7Q6MV+G7feTzw0Q4s2n4a5VUaqUskImpZmmjgvEFunv0nhBAvv/yy8PHxEdu2bRMHDx4UERERIiIiQre/urpahISEiAEDBoikpCQRHx8vXF1dRWxsrK7N2bNnhY2NjZg6dapISUkRixYtEgqFQsTHx+varFq1SqhUKhEXFydOnDghxo0bJxwdHfVmFd6pFkNw9h81pr1nLoshC//SzRSMmPOH+PlQptBotFKXRkTUrBn6/W3SoaqsrEy8+uqrwsnJSdjY2IjHH39cZGdn670mIyNDDBo0SFhbWwsXFxcxZcoUUVWlP918+/btomvXrkKpVAp/f3+xfPnyWu+9cOFC4ePjI5RKpejZs6fYu3ev3n5DarkThipqbBqNVqw9dEFEzPlDF66GLPxL7D1zWerSiIiaLUO/v3mbmibE29RQUymv0uDrXelYvOMMSiqu32FgQJA7Yh/uhLYuthJXR0TUvBj6/c1Q1YQYqqipXS6pwH+2nML3+89DKwALuQzP9vLFxP7t4WSrlLo8IqJmgaHKBDFUkVTScosxZ2MKtqdeX9NKbWWBfz3YHs/39oXKQiFxdUREpo2hygQxVJHUdqVdxr83nMDJnOtrWvk422DawEA8HOoBmUwmcXVERKaJocoEMVSRKdBoBX46dAEfbU5F3o01rcJ8nfBOdCd093GSuDoiItPDUGWCGKrIlFyrrMaXf57F0p1nUXZjTavBnT0xbWAgvJ1tJK6OiMh0MFSZIIYqMkW5ReX4aHMqfjx0AUIASoUcL/Txw6sPBMDB2lLq8oiIJMdQZYIYqsiUHc8qxJyNKdh9Oh8A4GRjiUmRHfBMuA8sFZLee52ISFIMVSaIoYpMnRACO1IvYfbGFJzOKwEA+LvaInZQJ0R2cuNgdiJqkRiqTBBDFTUX1RotVh3IxH+2nEJ+aSUAoJe/M/4vOgghrR0kro6IqGkxVJkghipqborLq7B4xxl8tSsdldVayGTA491aY2pUR3g6WEtdHhFRk2CoMkEMVdRcXSwow4fxJ/FLUhYAwMpSjpfu88f4vu1gp7KQuDoiosbFUGWCGKqouTuSWYDZG1KwP+MKAMDFToUpAzpgaFgbWHAwOxGZKYYqE8RQReZACIHNx3Mxb1MKMvKvAQA6utvj7ehO6NvBVeLqiIiMj6HKBDFUkTmprNbi273nsGBrGgrLqgAA93dwxTsPd0JHD3uJqyMiMh6GKhPEUEXmqPBaFRZuS8OKhAxUaQTkMmD4Pd54/aEOcLO3kro8IqK7xlBlghiqyJydyy/F/PiT2JicAwCwUSrwSt92GHufP6yVComrIyJqOIYqE8RQRS3BwYwr+PeGFCRlFgAAPNRWeCOqI57o1hpyORcPJaLmh6HKBDFUUUshhMC6o9mYv+kkLhaUAQCCvdSYMSQYPds6S1wdEVH9MFSZIIYqamnKqzSI25OBRdtOo7iiGgDwWFcvvP1wJ7ipOd6KiJoHhioTxFBFLVV+SQU++v0UVh04DyEAW6UCkyI7YHQfP96smYhMHkOVCWKoopbu6IUCTP/1uG68VYCbHWY9Eow+AS7SFkZEdBsMVSaIoYoI0GoFfjx0AfM3ndTdrDk61BNvR3dCa0feT5CITI+h39+87k5ETUoul2FYD29se6MfRvf2g1wGbEjORuTHO7Fo+2lUVGukLpGIqEF4paoJ8UoVUW0p2UWY8etx3f0E/VrZYMYjwXigo5vElRERXcfuPxPEUEVUNyEEfjuShdkbUpBXXAEAiOzkjumDg+DTykbi6oiopWP3HxE1GzKZDI92bY2tU/pi3P3+sJDL8EdKLiL/sxOfbDmF8ip2CRKR6eOVqibEK1VEhjmdV4wZvx3H7tP5AIA2TtZ4d3AQBgS5QybjquxE1LTY/WeCGKqIDCeEwKZjOfj3+hPIKiwHAPTt4IoZQ4Lg72oncXVE1JIwVJkghiqi+rtWWY0vtp/Bl3+eRaVGC0uFDGPv88eEBwJgq7KQujwiagEYqkwQQxVRw6VfLsWsdcexI/USAMDTwQrvRHdCdKgnuwSJqFExVJkghiqiuyOEwNaUPMxafxyZV67fqDnCvxVmPRqMDu72EldHROaKocoEMVQRGUd5lQZf/nn2xmKhWijkMozu7YdJke1hb2UpdXlEZGa4pAIRmS0rSwVe698ef0zui6hgd2i0Al/vSscDH+3Ez4cugH8rEpEUeKWqCfFKFVHj2HnqEmb+dhzpl0sBAD18nTDr0WAEezlIXBkRmQN2/5kghiqixlNRrcF/d2Vg4bY0XKvUQC4Dnu3liykPdYSDDbsEiajh2P1HRC2KykKBV/q1w9YpfTG4sye0Avhfwjk88PEOrNp/Hlot/34kosbFK1VNiFeqiJrOnjOXMePX40jLKwEAdGnjgPceDUEXb0dpCyOiZofdfyaIoYqoaVVptPhfwjl8uuUUiiuqIZMBw3t4482BgXC2VUpdHhE1E+z+I6IWz1Ihx4v3tsXWN/riie6tIQSw6kAmHvhoB75JyICGXYJEZES8UtWEeKWKSFoHM65g+q/HcSK7CAAQ5KnGe48Go4efs8SVEZEpY/efCWKoIpKeRiuwct85fLg5FUXl1QCAJ7q3xluDAuFmbyVxdURkitj9R0RUB4Vchuci/LD9jX4Y0dMbMhnw86GLePCjnfjqr7Oo0milLpGImileqWpCvFJFZHqSMgsw49djOHKhEADQwd0OMx8JRu92LhJXRkSmgt1/Joihisg0abUCaxIzMT8+FVdKKwEAgzt74p3oTvB0sJa4OiKSGrv/iIgMJJfLMPweH2yb0hfPR/hCLgPWH83Ggx/txBc7TqOiWiN1iUTUDPBKVRPilSqi5uF4ViFm/HocB89dBQD4u9hixiPB6NvBVeLKiEgK7P4zQQxVRM2HEAJrD1/EnI0ncbmkAgAwIMgd7w4OgrezjcTVEVFTYvcfEdFdkMlkeKJ7G2x/oy/G3tsWCrkMv5/IReQnO7HgjzSUV7FLkIj08UpVE+KVKqLm61RuMWb8ehwJZ/MBAN7O1pg+OBiRndwgk8kkro6IGhO7/0wQQxVR8yaEwIbkbPx7fQpyisoBAP06umLGkGC0dbGVuDoiaiwMVSaIoYrIPJRWVGPR9tNY9tdZVGkElAo5Xrq/LV7tFwBblYXU5RGRkTFUmSCGKiLzcvZSCWauO4E/T10CAFjIZejkqUYXbwd09XZCV28H+LvYQS5n9yBRc8ZQZYIYqojMjxACW07kYs7GFGTkX6u1315lgdA2Duji7YgubRzRzccR7mreY5CoOWGoMkEMVUTmSwiBC1fLcORCAY5kFuBIZiGSLxairI5Zgh5qK3Txvh60urZxRGgbB9hbWUpQNREZgqHKBDFUEbUs1Rot0vJKcCSzAEk3Hqdyi6H9x391ZTKgnasduno76oJWRw97KC246g2RKWCoMkEMVUR0rbIaxy4WXQ9aN65qXbhaVqud0kKOYC+1rsuwSxtH+Lay4fINRBJgqDJBDFVEVJdLxRU4eiNgJV0oxJHMAhSWVdVq52BteeNK1o0xWt6OcLFTSVAxUcvSLFZUX7x4MTp37gy1Wg21Wo2IiAhs2rRJt7+8vBwxMTFo1aoV7Ozs8OSTTyI3N1fvGOfPn0d0dDRsbGzg5uaGqVOnorq6Wq/Njh070L17d6hUKgQEBCAuLq5WLYsWLYKfnx+srKwQHh6O/fv36+03pBYiooZwtVehfyd3TB7QEf8b0xNJ0x/Cjjf6YcHTXfFCHz9093GE0kKOwrIq/HnqEj7bdhovrjiIHv/+A33mbUPMykNY9udZ7E+/gmuV1Xd+QyJqFJJeqVq3bh0UCgXat28PIQRWrFiBDz/8EIcPH0ZwcDBeeeUVbNiwAXFxcXBwcMCECRMgl8uxe/duAIBGo0HXrl3h4eGBDz/8ENnZ2Xj++efx0ksvYc6cOQCA9PR0hISE4OWXX8bYsWOxdetWTJo0CRs2bEBUVBQAYPXq1Xj++eexZMkShIeH49NPP8WaNWuQmpoKNzc3ALhjLYbglSoiaqjKai1Sc4p1XYZHMgtw+lIJ/vlfcLkM6OBuj67ejroxWu3d7GCh4PgsooZqtt1/zs7O+PDDD/HUU0/B1dUVK1euxFNPPQUAOHnyJDp16oSEhAT06tULmzZtwuDBg5GVlQV3d3cAwJIlSzBt2jRcunQJSqUS06ZNw4YNG3Ds2DHdezz99NMoKChAfHw8ACA8PBz33HMPPv/8cwCAVquFt7c3/vWvf+Gtt95CYWHhHWsxBEMVERlTcXkVki8WIinz7xmHNSu938zaUoHQ1g5/zzj0dkRrR2uOzyIykKHf3yaz9K9Go8GaNWtQWlqKiIgIJCYmoqqqCpGRkbo2gYGB8PHx0QWZhIQEhIaG6gIVAERFReGVV17B8ePH0a1bNyQkJOgdo6bNpEmTAACVlZVITExEbGysbr9cLkdkZCQSEhIAwKBa6lJRUYGKigrd86KiooZ/QERE/2BvZYne7VzQu52LbltOYfnfyzpcKMDRzEIUV1Rjf8YV7M+4omvnYqdElzaOurFZXdo4wNFGKcVpEJkNyUNVcnIyIiIiUF5eDjs7O6xduxZBQUFISkqCUqmEo6OjXnt3d3fk5OQAAHJycvQCVc3+mn23a1NUVISysjJcvXoVGo2mzjYnT57UHeNOtdRl7ty5mDVrlmEfBBGREXg4WMHDwQNRwR4AAK1W4OzlEiRlFuqCVkp2ES6XVGLryTxsPZmne61fKxvdlawu3o4I8lTDylIh1akQNTuSh6qOHTsiKSkJhYWF+PHHHzFq1Cjs3LlT6rKMIjY2FpMnT9Y9Lyoqgre3t4QVEVFLI5fLEOBmjwA3ezwV1gYAUF6lQUp2kW79rCMXCpF+uRQZ+deQkX8NvyZlAdC/7U6XNo7o7usEfxdbdhsS3YLkoUqpVCIgIAAAEBYWhgMHDmDBggUYPnw4KisrUVBQoHeFKDc3Fx4e1/8C8/DwqDVLr2ZG3s1t/jlLLzc3F2q1GtbW1lAoFFAoFHW2ufkYd6qlLiqVCioVpzsTkWmxslSgm48Tuvk46bYVXKvE0Qt/X81KyizA5ZJKJF+8vjL8tzgPAPB3tcWgEA8MCvFEsJeaAYvoJiY3HUSr1aKiogJhYWGwtLTE1q1bdftSU1Nx/vx5REREAAAiIiKQnJyMvLy/L19v2bIFarUaQUFBujY3H6OmTc0xlEolwsLC9NpotVps3bpV18aQWoiImjNHGyXu7+CKf/Vvj69G3YMD70Ri91sPYtEz3THufn/09HOGUiHH2UulWLT9DAYv3IX7P9yOORtTcOj8VWj/uUw8UQsk6ey/2NhYDBo0CD4+PiguLsbKlSsxf/58bN68GQ899BBeeeUVbNy4EXFxcVCr1fjXv/4FANizZw+Av5dU8PLywgcffICcnBw899xzGDt2bK0lFWJiYjBmzBhs27YNr732Wq0lFUaNGoWlS5eiZ8+e+PTTT/HDDz/g5MmTurFWd6rFEJz9R0TNWXF5FbadzMOm5BzsOJWH8iqtbp+ngxWigj0wKMQDPfycoZDzChaZD4O/v4WExowZI3x9fYVSqRSurq6if//+4vfff9ftLysrE6+++qpwcnISNjY24vHHHxfZ2dl6x8jIyBCDBg0S1tbWwsXFRUyZMkVUVVXptdm+fbvo2rWrUCqVwt/fXyxfvrxWLQsXLhQ+Pj5CqVSKnj17ir179+rtN6SWOyksLBQARGFhYb1eR0RkakorqsTGo1niXysPiaB3Nwnfaet1j7D3t4i3fz4q/jp1SVRVa6QuleiuGfr9bXLrVJkzXqkiInNUXqXBrrTL2HQsB1tO5KCo/O9V3R1tLDEgyB2DQjzRO6AVVBacTUjNT7Nd/NOcMVQRkbmrrNYi4Ww+4o9l4/fjucgvrdTts1dZoH8nNwwK9UTfDq5croGaDYYqE8RQRUQtSbVGi/0ZVxB/LAfxx3KQV/z3Ysg2SgUe6OiGQaEeeKCjG2xVkk9GJ7olhioTxFBFRC2VVitwOPMqNiZfD1gXC8p0+1QWctzfwRWDQjzQv5M7HKwtJayUqDaGKhPEUEVEBAghcPRCITYdy0H8sWxk5F/T7bNUyNAnwAWDQjzwUJAHnG156xySHkOVCWKoIiLSJ4TAyZxibErOxqZjOUjLK9HtU8hl6OXvjIEhnogKdoebvZWElVJLxlBlghiqiIhu73ReCeKPZWNjcg5OZP99E3qZDLjH1xkDQzwwMMQDXo7WElZJLQ1DlQliqCIiMty5/FLEH8vBxmM5OJJZoLevi7cjHr5xuxyfVjbSFEgtBkOVCWKoIiJqmKyCMt0swgPnruDmb64gTzUeDvXAwBBPBLjZSVckmS2GKhPEUEVEdPfyisux+Xgu4o9lY+/ZK9DcdN/B9m52GBTqiUEhHgj0sOcNn8koGKpMEEMVEZFxXSmtxJYTOdh0LAe7T19GlebvrzS/VjYYGOKJh0M9ENragQGLGoyhygQxVBERNZ7CsipsTcnFpmM52HnqEiqr/77hc2tHawwM8cDDoR7o5u0EOW/4TPXAUGWCGKqIiJpGaUU1tqfmYVNyDradzENZlUa3z12tQlTw9VmEPf2cYaGQS1gpNQcMVSaIoYqIqOmVVWqw89QlxB/LxtaUPBRX/H3D51a2SgwIdsfAEE/0btcKlgxYVAeGKhPEUEVEJK2Kag32nM7HxuRsbEnJRcG1Kt0+tZUFQlo7oK2LLdq62MLf1RZtXezQxsmaYauFY6gyQQxVRESmo0qjxb6zV7DpWDY2H8/B5ZLKOttZyGXwcbbRha22rjdCl4sd3NUqDoBvARiqTBBDFRGRadJoBZIvFuJ0XgnSL5cg/XIpzl4qRUZ+KcqrtLd8nbWlAn4utvCvCVw3Qpe/iy0cbXjfQnPBUGWCGKqIiJoXrVYgp6j8esi6XIr0G0Er/XIpzl+5prdG1j852VjeCFp2aOtic+N/beHnYgMbpUUTngXdLYYqE8RQRURkPqo0WmReuYb0y6V6oSv9cilyispv+1pPB6u/r2xx/JbJY6gyQQxVREQtQ2lFNTLyS5Fx+RrSL5dcD1w3uhQLy6pu+bqa8Vt+NweuG12K7vZWXF9LIoZ+f/P6IxERkZHZqiwQ7OWAYC+HWvuullbqQlbN+K30G+GrvEqLszeuev0Tx2+ZPl6pakK8UkVERLei1QrkFpcj/VLpTaHLsPFbjrrxWzWhi+O3jIndfyaIoYqIiBrin+O3bn5kFxo+fsvf1Q4d3O3Q3s2ey0HUA0OVCWKoIiIiY7tWWX1j7Fap3vitjMuluHrt1uO37K0s0N7NDh3c7dHe3V73b4at2hiqTBBDFRERNaWrpZVIzy+90aVYgjN5pTiVV4xz+bfuTmTYqo2hygQxVBERkSmoqNYg/XIpTuWW4HRuMU7lltQrbAXc+N+WErYYqkwQQxUREZmyuwlb7d3s0d695gqXHTzUVmYTthiqTBBDFRERNUc1YSsttwRpN8JWWl4xMlpI2GKoMkEMVUREZE4qqjXIuHwNp3KLkZZbjLS8EpzKvUPYUlkgwN0OHW6Erfbu9uhg4mGLocoEMVQREVFLYG5hi6HKBDFUERFRS1ZZrb0xZut60LrelWj6YYuhygQxVBEREdVWE7bS8m6M17oRutIvl94xbP1z+QdPB+OHLYYqE8RQRUREZLh/hq3TN/4343Ipqm8Rtt4c2BGv9gswah28oTIRERE1a0oLOTp62KOjh73e9spqLTLyr3cj/jNs+bvYSVQtQxURERE1M0oLuW7x0ZtVVmslqug6hioiIiIyC0oLuaTvL+27ExEREZkJhioiIiIiI2CoIiIiIjIChioiIiIiI2CoIiIiIjIChioiIiIiI2CoIiIiIjIChioiIiIiI2CoIiIiIjIChioiIiIiI2CoIiIiIjIChioiIiIiI2CoIiIiIjICC6kLaEmEEACAoqIiiSshIiIiQ9V8b9d8j98KQ1UTKi4uBgB4e3tLXAkRERHVV3FxMRwcHG65XybuFLvIaLRaLbKysmBvbw+ZTGa04xYVFcHb2xuZmZlQq9VGO64pMfdzNPfzA8z/HHl+zZ+5nyPPr+GEECguLoaXlxfk8luPnOKVqiYkl8vRpk2bRju+Wq02y/+j3Mzcz9Hczw8w/3Pk+TV/5n6OPL+Gud0VqhocqE5ERERkBAxVREREREbAUGUGVCoVZsyYAZVKJXUpjcbcz9Hczw8w/3Pk+TV/5n6OPL/Gx4HqREREREbAK1VERERERsBQRURERGQEDFVERERERsBQRURERGQEDFXN2Ny5c3HPPffA3t4ebm5ueOyxx5Camip1WUazePFidO7cWbeQW0REBDZt2iR1WY1m3rx5kMlkmDRpktSlGM3MmTMhk8n0HoGBgVKXZVQXL17Es88+i1atWsHa2hqhoaE4ePCg1GUZjZ+fX62foUwmQ0xMjNSlGYVGo8G7776Ltm3bwtraGu3atcP7779/x3u8NSfFxcWYNGkSfH19YW1tjd69e+PAgQNSl9Vgf/75J4YMGQIvLy/IZDL88ssvevuFEJg+fTo8PT1hbW2NyMhIpKWlNUltDFXN2M6dOxETE4O9e/diy5YtqKqqwoABA1BaWip1aUbRpk0bzJs3D4mJiTh48CAefPBBPProozh+/LjUpRndgQMHsHTpUnTu3FnqUowuODgY2dnZuseuXbukLslorl69ij59+sDS0hKbNm3CiRMn8PHHH8PJyUnq0ozmwIEDej+/LVu2AACGDh0qcWXGMX/+fCxevBiff/45UlJSMH/+fHzwwQdYuHCh1KUZzdixY7FlyxZ88803SE5OxoABAxAZGYmLFy9KXVqDlJaWokuXLli0aFGd+z/44AN89tlnWLJkCfbt2wdbW1tERUWhvLy88YsTZDby8vIEALFz506pS2k0Tk5O4quvvpK6DKMqLi4W7du3F1u2bBF9+/YVEydOlLoko5kxY4bo0qWL1GU0mmnTpol7771X6jKa1MSJE0W7du2EVquVuhSjiI6OFmPGjNHb9sQTT4iRI0dKVJFxXbt2TSgUCrF+/Xq97d27dxfvvPOORFUZDwCxdu1a3XOtVis8PDzEhx9+qNtWUFAgVCqV+P777xu9Hl6pMiOFhYUAAGdnZ4krMT6NRoNVq1ahtLQUERERUpdjVDExMYiOjkZkZKTUpTSKtLQ0eHl5wd/fHyNHjsT58+elLslofvvtN/To0QNDhw6Fm5sbunXrhmXLlkldVqOprKzEt99+izFjxhj1pvBS6t27N7Zu3YpTp04BAI4cOYJdu3Zh0KBBEldmHNXV1dBoNLCystLbbm1tbVZXjWukp6cjJydH77+nDg4OCA8PR0JCQqO/P2+obCa0Wi0mTZqEPn36ICQkROpyjCY5ORkREREoLy+HnZ0d1q5di6CgIKnLMppVq1bh0KFDzXp8w+2Eh4cjLi4OHTt2RHZ2NmbNmoX77rsPx44dg729vdTl3bWzZ89i8eLFmDx5Mt5++20cOHAAr732GpRKJUaNGiV1eUb3yy+/oKCgAKNHj5a6FKN56623UFRUhMDAQCgUCmg0GsyePRsjR46UujSjsLe3R0REBN5//3106tQJ7u7u+P7775GQkICAgACpyzO6nJwcAIC7u7vednd3d92+xsRQZSZiYmJw7Ngxs/vLo2PHjkhKSkJhYSF+/PFHjBo1Cjt37jSLYJWZmYmJEydiy5Yttf6KNBc3/7XfuXNnhIeHw9fXFz/88ANefPFFCSszDq1Wix49emDOnDkAgG7duuHYsWNYsmSJWYaqr7/+GoMGDYKXl5fUpRjNDz/8gO+++w4rV65EcHAwkpKSMGnSJHh5eZnNz/Cbb77BmDFj0Lp1aygUCnTv3h0jRoxAYmKi1KWZHXb/mYEJEyZg/fr12L59O9q0aSN1OUalVCoREBCAsLAwzJ07F126dMGCBQukLssoEhMTkZeXh+7du8PCwgIWFhbYuXMnPvvsM1hYWECj0UhdotE5OjqiQ4cOOH36tNSlGIWnp2etgN+pUyez6uKsce7cOfzxxx8YO3as1KUY1dSpU/HWW2/h6aefRmhoKJ577jm8/vrrmDt3rtSlGU27du2wc+dOlJSUIDMzE/v370dVVRX8/f2lLs3oPDw8AAC5ubl623Nzc3X7GhNDVTMmhMCECROwdu1abNu2DW3btpW6pEan1WpRUVEhdRlG0b9/fyQnJyMpKUn36NGjB0aOHImkpCQoFAqpSzS6kpISnDlzBp6enlKXYhR9+vSptYzJqVOn4OvrK1FFjWf58uVwc3NDdHS01KUY1bVr1yCX638VKhQKaLVaiSpqPLa2tvD09MTVq1exefNmPProo1KXZHRt27aFh4cHtm7dqttWVFSEffv2Ncl4XHb/NWMxMTFYuXIlfv31V9jb2+v6ix0cHGBtbS1xdXcvNjYWgwYNgo+PD4qLi7Fy5Urs2LEDmzdvlro0o7C3t681/s3W1hatWrUym3Fxb7zxBoYMGQJfX19kZWVhxowZUCgUGDFihNSlGcXrr7+O3r17Y86cORg2bBj279+PL7/8El9++aXUpRmVVqvF8uXLMWrUKFhYmNfXxpAhQzB79mz4+PggODgYhw8fxieffIIxY8ZIXZrRbN68GUIIdOzYEadPn8bUqVMRGBiIF154QerSGqSkpETvand6ejqSkpLg7OwMHx8fTJo0Cf/+97/Rvn17tG3bFu+++y68vLzw2GOPNX5xjT6/kBoNgDofy5cvl7o0oxgzZozw9fUVSqVSuLq6iv79+4vff/9d6rIalbktqTB8+HDh6ekplEqlaN26tRg+fLg4ffq01GUZ1bp160RISIhQqVQiMDBQfPnll1KXZHSbN28WAERqaqrUpRhdUVGRmDhxovDx8RFWVlbC399fvPPOO6KiokLq0oxm9erVwt/fXyiVSuHh4SFiYmJEQUGB1GU12Pbt2+v87hs1apQQ4vqyCu+++65wd3cXKpVK9O/fv8l+d2VCmNGysUREREQS4ZgqIiIiIiNgqCIiIiIyAoYqIiIiIiNgqCIiIiIyAoYqIiIiIiNgqCIiIiIyAoYqIiIiIiNgqCIis5CRkQGZTIakpCSpS9E5efIkevXqBSsrK3Tt2rXerzfFcyKiW2OoIiKjGD16NGQyGebNm6e3/ZdffoFMJpOoKmnNmDEDtra2SE1N1bsXmVTi4uLg6OgodRlEZouhioiMxsrKCvPnz8fVq1elLsVoKisrG/zaM2fO4N5774Wvry9atWplxKqkpdFozPKGw0R3i6GKiIwmMjISHh4emDt37i3bzJw5s1ZX2Keffgo/Pz/d89GjR+Oxxx7DnDlz4O7uDkdHR7z33nuorq7G1KlT4ezsjDZt2mD58uW1jn/y5En07t0bVlZWCAkJwc6dO/X2Hzt2DIMGDYKdnR3c3d3x3HPP4fLly7r9/fr1w4QJEzBp0iS4uLggKiqqzvPQarV477330KZNG6hUKnTt2hXx8fG6/TKZDImJiXjvvfcgk8kwc+bMWx7ngw8+QEBAAFQqFXx8fDB79uw629Z1pemfVwKPHDmCBx54APb29lCr1QgLC8PBgwexY8cOvPDCCygsLIRMJtOrqaKiAm+88QZat24NW1tbhIeHY8eOHbXe97fffkNQUBBUKhXOnz+PHTt2oGfPnrC1tYWjoyP69OmDc+fO1Vk7UUvAUEVERqNQKDBnzhwsXLgQFy5cuKtjbdu2DVlZWfjzzz/xySefYMaMGRg8eDCcnJywb98+vPzyyxg/fnyt95k6dSqmTJmCw4cPIyIiAkOGDEF+fj4AoKCgAA8++CC6deuGgwcPIj4+Hrm5uRg2bJjeMVasWAGlUondu3djyZIldda3YMECfPzxx/joo49w9OhRREVF4ZFHHkFaWhoAIDs7G8HBwZgyZQqys7Pxxhtv1Hmc2NhYzJs3D++++y5OnDiBlStXwt3dvcGf28iRI9GmTRscOHAAiYmJeOutt2BpaYnevXvj008/hVqtRnZ2tl5NEyZMQEJCAlatWoWjR49i6NChGDhwoO5cAODatWuYP38+vvrqKxw/fhzOzs547LHH0LdvXxw9ehQJCQkYN25ci+3qJQIANMltm4nI7I0aNUo8+uijQgghevXqJcaMGSOEEGLt2rXi5v/UzJgxQ3Tp0kXvtf/5z3+Er6+v3rF8fX2FRqPRbevYsaO47777dM+rq6uFra2t+P7774UQQqSnpwsAYt68ebo2VVVVok2bNmL+/PlCCCHef/99MWDAAL33zszMFAB0d7Hv27ev6Nat2x3P18vLS8yePVtv2z333CNeffVV3fMuXbqIGTNm3PIYRUVFQqVSiWXLltW5v+acDh8+LIQQYvny5cLBwUGvzT8/X3t7exEXF1fn8ep6/blz54RCoRAXL17U296/f38RGxurex0AkZSUpNufn58vAIgdO3bc8vyIWhpeqSIio5s/fz5WrFiBlJSUBh8jODgYcvnf/4lyd3dHaGio7rlCoUCrVq2Ql5en97qIiAjdvy0sLNCjRw9dHUeOHMH27dthZ2enewQGBgK4Pv6pRlhY2G1rKyoqQlZWFvr06aO3vU+fPvU655SUFFRUVKB///4Gv+ZOJk+ejLFjxyIyMhLz5s3TO6+6JCcnQ6PRoEOHDnqfy86dO/Veq1Qq0blzZ91zZ2dnjB49GlFRURgyZAgWLFiA7Oxso50HUXPEUEVERnf//fcjKioKsbGxtfbJ5XIIIfS2VVVV1WpnaWmp91wmk9W5rT4DpktKSjBkyBAkJSXpPdLS0nD//ffr2tna2hp8zLthbW1dr/aGfHYzZ87E8ePHER0djW3btiEoKAhr16695TFLSkqgUCiQmJio95mkpKRgwYIFerX+s2tv+fLlSEhIQO/evbF69Wp06NABe/furdc5EZkThioiahTz5s3DunXrkJCQoLfd1dUVOTk5euHAmOsw3fylXl1djcTERHTq1AkA0L17dxw/fhx+fn4ICAjQe9QnSKnVanh5eWH37t1623fv3o2goCCDj9O+fXtYW1sbvNyCq6sriouLUVpaqttW12fXoUMHvP766/j999/xxBNP6Ab0K5VKaDQavbbdunWDRqNBXl5erc/Ew8PjjjV169YNsbGx2LNnD0JCQrBy5UqDzoXIHDFUEVGjCA0NxciRI/HZZ5/pbe/Xrx8uXbqEDz74AGfOnMGiRYuwadMmo73vokWLsHbtWpw8eRIxMTG4evUqxowZAwCIiYnBlStXMGLECBw4cABnzpzB5s2b8cILL9QKG3cydepUzJ8/H6tXr0ZqaireeustJCUlYeLEiQYfw8rKCtOmTcObb76J//3vfzhz5gz27t2Lr7/+us724eHhsLGxwdtvv40zZ85g5cqViIuL0+0vKyvDhAkTsGPHDpw7dw67d+/GgQMHdKHSz88PJSUl2Lp1Ky5fvoxr166hQ4cOGDlyJJ5//nn8/PPPSE9Px/79+zF37lxs2LDhlrWnp6cjNjYWCQkJOHfuHH7//XekpaXp3ouoJWKoIqJG895779XqnuvUqRO++OILLFq0CF26dMH+/ftvOTOuIebNm4d58+ahS5cu2LVrF3777Te4uLgAgO7qkkajwYABAxAaGopJkybB0dFRb/yWIV577TVMnjwZU6ZMQWhoKOLj4/Hbb7+hffv29TrOu+++iylTpmD69Ono1KkThg8fXmucWA1nZ2d8++232LhxI0JDQ/H999/rLdWgUCiQn5+P559/Hh06dMCwYcMwaNAgzJo1CwDQu3dvvPzyyxg+fDhcXV3xwQcfALjejff8889jypQp6NixIx577DEcOHAAPj4+t6zbxsYGJ0+exJNPPokOHTpg3LhxiImJwfjx4+t1/kTmRCb+2UFPRERERPXGK1VERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQEDFVERERERsBQRURERGQE/w8AEp9p/cY+pgAAAABJRU5ErkJggg==",
                         "text/plain": [
                             "<Figure size 640x480 with 1 Axes>"
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 }
             ],
             "source": [
-                "neighbor_inertia = neighborhood_analysis.compute_cluster_metrics_inertia(input_features, min_k=min_k, max_k=max_k)\n",
+                "neighbor_inertia = neighborhood_analysis.compute_cluster_metrics_inertia(input_features, min_k=min_k, max_k=max_k, \n",
+                "                                                                         cell_col=cell_type_col)\n",
                 "\n",
                 "# Use the elbow curve method to choose the optimal k\n",
                 "visualize.visualize_neighbor_cluster_metrics(neighbor_inertia, metric_name=\"inertia\")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 2.2 Silhouette score"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The Silhouette score is calculated using the mean intra-cluster distance (a) and the mean nearest-cluster distance (b) for each sample. The Silhouette score for a sample is `(b - a) / max(a, b)`.\n",
                 "\n",
                 "Silhouette score can be an expensive calculation, so depending on the size of your dataset, you may want to subsample the number of cells in each cluster for this calculation. Each neighborhoood cluster will be sampled down to the number of cells specified by `num_cells_per_cluster`. Set this variable as `None` to use all cells."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 11,
+            "execution_count": null,
             "metadata": {
                 "tags": []
             },
             "outputs": [
                 {
                     "data": {
                         "application/vnd.jupyter.widget-view+json": {
@@ -376,44 +394,46 @@
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 },
                 {
                     "data": {
-                        "image/png": "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\n",
+                        "image/png": "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",
                         "text/plain": [
                             "<Figure size 640x480 with 1 Axes>"
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 }
             ],
             "source": [
                 "# Subsample each phenotype to avoid long runtimes\n",
                 "num_cells_per_cluster = 1000\n",
                 "\n",
                 "neighbor_silhouette_scores = neighborhood_analysis.compute_cluster_metrics_silhouette(input_features,\n",
-                "                                                                                 min_k=min_k,\n",
-                "                                                                                 max_k=max_k,\n",
-                "                                                                                 subsample=num_cells_per_cluster)\n",
+                "                                                                                      min_k=min_k, max_k=max_k,\n",
+                "                                                                                      subsample=num_cells_per_cluster, \n",
+                "                                                                                      cell_col=cell_type_col)\n",
                 "\n",
                 "# Use the elbow curve method to choose the optimal k\n",
                 "visualize.visualize_neighbor_cluster_metrics(neighbor_silhouette_scores, metric_name=\"silhouette\")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 3. Generate cluster results"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "While the metrics above algorithmically help to choose a k, visualizing the clustering results may help choose the best k. Iterate between steps 3 and 4 to choose the optimal cluster number."
             ]
         },
         {
@@ -438,42 +458,56 @@
             "source": [
                 "# These channels will be excluded when generating table of mean marker expression per neighborhood cluster\n",
                 "excluded_channels = None\n",
                 "\n",
                 "# k-means clustering\n",
                 "all_data_cluster_labeled, num_cell_type_per_cluster, mean_marker_exp_per_cluster = \\\n",
                 "    neighborhood_analysis.generate_cluster_matrix_results(\n",
-                "        all_data, input_features, cluster_num=k, excluded_channels=excluded_channels)"
+                "        all_data, input_features, cluster_num=k, excluded_channels=excluded_channels, cell_type_col=cell_type_col)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 4. Visualize cluster results"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.1 Cluster composition by neighboring cell types\n",
                 "First, we want to understand how the generated clusters relate to the input data that was provided (neighboring cell types by either count or frequency). Below, we find the average count/frequency of neighboring cell phenotypes that surround the cells belonging to each cluster (then z-score those values within each cell type)."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 15,
+            "execution_count": null,
+            "metadata": {},
+            "outputs": [],
+            "source": [
+                "# Directory to save kmeans output for the specified parameters\n",
+                "kmeans_out_dir = os.path.join(spatial_analysis_dir, f\"{cell_type_col}_radius{pixel_radius}_{neighborhood_method}\")\n",
+                "if not os.path.exists(kmeans_out_dir):\n",
+                "    os.makedirs(kmeans_out_dir)"
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": null,
             "metadata": {
                 "tags": []
             },
             "outputs": [
                 {
                     "data": {
-                        "image/png": "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fn0AAAAoFKYPAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKaZB0AAAAACsHq1aujoqIipk2bFuXl5dG4cePo3r17LFu2LCIievfuvcmvOX/+/JgxY0b07NlzszJdcsklsXDhwigvL4+IiGuuuSZOPPHEej9fKQAAAAD10K9fv4iImDx5cpSVlUVVVVVMnDgxVwpsjgULFsTEiRM3uRSoqamJkpKSiIgYNmxYHH/88Zv19U0fAAAAgM/x1ltvxdNPPx0/+tGPoqysLCIiSktL48ILL6zzuP79+8eECRNyty+55JJ44YUXIiJi1KhR0bVr1+jWrVtccsklEbHuDf1rr70WPXr0iBtuuCEiImbOnBkXXXRR9OzZM77xjW/EP/7xj4iImDBhQlx22WVx+eWXR9euXWPJkiVbfF5GCgAAAJCUzp07f+b906dP3+DY7Nmzo23btrHjjjtu1tdcsmRJTJ06NaZMmRKNGjWKpUuXRkTEoEGDYvTo0TFmzJjc40aMGBF33XVXtGjRIv7617/GwIEDY/z48RER8fLLL8fkyZOjVatWudf+0Y9+FI0aNYqjjz46+vbtG82aNat3LqVAHgwYMCCqqqqyjkEDqKioyDoCAABQBJo3bx7l5eUxcODA6NixY5xyyikbfdxLL70U77zzTlx66aW5Y+sLhIiIE044oU4hMHLkyGjVqlWsXr06hg8fHjfffHMMGzas3rmUAnlQVVXlzSQAAMA2amMjAT5P+/btY+7cubFs2bJo3rz5pz6ucePGUVNTk7u9atWq3PFx48bFzJkz49lnn42KioqYOHHiBs+vra2NI488Mu68886Nvv76BQXXW18QNG3aNC688ML44Q9/uEnnZU0BAAAA+Bz77bdfnHTSSTFkyJBYuXJlRKx7wz9u3Lg6j2vTpk28+uqrERHx5ptvxpw5cyIiorKyMpYsWRIdO3aMvn37RmlpaSxcuDCaNWsWlZWVued36NAhZs2aFa+//npErFtQcNasWRvNtHbt2vjggw9ytx977LH44he/uEnnZaQAAAAA1MPIkSOjoqIiunXrFmVlZVFSUhLnnHNOncecf/750atXrzjzzDOjXbt20a5du4hYVwr07t07qqqqora2Njp16hQHHXRQVFdXx8477xzdunWLY445JgYPHhyjRo2KoUOHxooVK2LNmjVx+umnx8EHH7xBntWrV8dll10Wa9asidra2th///1j8ODBm3ROSgEAAACoh+233z769+8f/fv3/9TH7LzzzjF27NiN3vfggw9ucKxJkyZx99131zl21FFHbTACISKiZ8+edbYuLC8vr7PTweYwfQAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAAS1STrALCt22XxW1lHyIvS3XfPOkJeNG/dJusIebP3yZ2yjpAXyxfMyzpCXhzR/9qsI+TN6jU1WUfIi/c/XJZ1hLzYZYc9s46QN/M+WpN1BDbRDmVNs46QF7W1tVlHyIv992qZdQS2AiMFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARDXJOkBDKy0tjT59+mSaYdGiRZl+fQAAAKiPoisFhg8fnnWEzEsJAAAAqA/TBwAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQ1yToAAAAAFILVq1dHRUVFTJs2LcrLy6Nx48bRvXv3WLZsWURE9O7de5Nfc/78+TFjxozo2bPnJj+3pqYmrrzyyvj73/8eTZs2jbZt28bQoUOjZcuW9X4NIwUAAACgHvr16xfvvfdeTJ48OR5++OEYO3ZsbL/99lv0mgsWLIiJEydu8vNqamqitrY2evbsGVOnTo1HHnkk2rZtG6NHj96k1zFSAAAAgKR07tz5M++fPn36BsfeeuutePrpp+P3v/99lJWVRUREaWlpXHjhhXH77bfnHte/f/847rjjcp/8X3LJJdGrV684/vjjY9SoUfHEE09Eo0aNYqeddooxY8bEsGHDYv78+dGjR4846qijYvDgwTFz5sy49dZbo6qqKsrKyuKGG26IAw44ICZMmBCPPfZYlJSUxLx582Ls2LFx6qmn5r724YcfHpMmTdqkvwulQJEZMGBAVFVVZR2jaFRUVGQdAQAA2AbMnj072rZtGzvuuONmPX/JkiUxderUmDJlSjRq1CiWLl0aERGDBg2K0aNHx5gxY3KPGzFiRNx1113RokWL+Otf/xoDBw6M8ePHR0TEyy+/HJMnT45WrVrVef3a2toYP358fPWrX92kXEqBIlNVVeWNLAAAwGfY2EiAfGvevHmUl5fHwIEDo2PHjnHKKads9HEvvfRSvPPOO3HppZfmjq0vECIiTjjhhA0KgYiIW265JUpLS+PrX//6JuVSCgAAAMDnaN++fcydOzeWLVsWzZs3/9THNW7cOGpqanK3V61alTs+bty4mDlzZjz77LNRUVGx0bUEamtr48gjj4w777xzo69fXl6+wbFf/vKX8dprr8Vdd90VJSUlm3ReFhoEAACAz7HffvvFSSedFEOGDImVK1dGxLo3/OPGjavzuDZt2sSrr74aERFvvvlmzJkzJyIiKisrY8mSJdGxY8fo27dvlJaWxsKFC6NZs2ZRWVmZe36HDh1i1qxZ8frrr0fEugUFZ82a9am57r///nj88cfj5z//+WYtemikAAAAANTDyJEjo6KiIrp16xZlZWVRUlIS55xzTp3HnH/++dGrV68488wzo127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xKxZs+L111+PiHULCs6aNetTc/3Hf/xH/OEPf4iIdYsWLly4MPbZZ596n5eRAgAAAFAPI0eOjIqKiujWrVuUlZVFSUlJnHPOOXUec/7550evXr3izDPPjHbt2kW7du0iYl0p0Lt376iqqora2tro1KlTHHTQQVFdXR0777xzdOvWLY455pgYPHhwjBo1KoYOHRorVqyINWvWxOmnnx4HH3zwRjP98Ic/jGuuuSZ+9atfRePGjWPo0KHRokWLep9TSW1tbe3m/5XU1adPHwuzUXTm/H1B1hHyYvlD92QdIS8q587LOkLe7Hpkh6wj5EXbCy7OOkJebLe2KusIeVO9XVnWEfJi0e+fzDpCXuzZsWPWEfJm7u+eyDpCXqzucFLWEfLm/Q+XZx0hL3ZrWf75DypAB+2zaavYF5Km5cX5Pdscpg8AAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAoppkHQC2df9Y8O+sI+TF7L1PyTpCXpTu2zjrCHmzYnV11hHy4vmfvJB1hLy44ISds46QN3vuskPWEfJi+70OzjpCXvzzjX9lHSFv/t7kgKwj5EXLb16YdYS82avj0VlHyIvmp52WdYS8WLZ236wj5M0uhx6WdYRthpECAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACSqSdYBAAAAoBCsXr06KioqYtq0aVFeXh6NGzeO7t27x7JlyyIionfv3pv8mvPnz48ZM2ZEz549NyvT7bffHpMmTYr58+fH9OnTo3Xr1pv0fCMFAAAAoB769esX7733XkyePDkefvjhGDt2bGy//fZb9JoLFiyIiRMnbvLzampqora2Nk466aQYM2ZM7L333pv19Y0UAAAAICmdO3f+zPunT5++wbG33nornn766fj9738fZWVlERFRWloaF154Ydx+++25x/Xv3z+OO+643Cf/l1xySfTq1SuOP/74GDVqVDzxxBPRqFGj2GmnnWLMmDExbNiwmD9/fvTo0SOOOuqoGDx4cMycOTNuvfXWqKqqirKysrjhhhvigAMOiAkTJsRjjz0WJSUlMW/evBg7dmx06NBhi/4utplSYMCAAVFVVZV1DKijoqIi6wgAAMA2YPbs2dG2bdvYcccdN+v5S5YsialTp8aUKVOiUaNGsXTp0oiIGDRoUIwePTrGjBmTe9yIESPirrvuihYtWsRf//rXGDhwYIwfPz4iIl5++eWYPHlytGrVqkHOa5spBaqqqrwBAwAAIO82NhIg35o3bx7l5eUxcODA6NixY5xyyikbfdxLL70U77zzTlx66aW5Y+sLhIiIE044ocEKgYhtqBQAAACAbVX79u1j7ty5sWzZsmjevPmnPq5x48ZRU1OTu71q1arc8XHjxsXMmTPj2WefjYqKio2uJVBbWxtHHnlk3HnnnRt9/fLy8i08k7osNAgAAACfY7/99ouTTjophgwZEitXroyIdW/4x40bV+dxbdq0iVdffTUiIt58882YM2dORERUVlbGkiVLomPHjtG3b98oLS2NhQsXRrNmzaKysjL3/A4dOsSsWbPi9ddfj4h1CwrOmjUrb+dlpAAAAADUw8iRI6OioiK6desWZWVlUVJSEuecc06dx5x//vnRq1evOPPMM6Ndu3bRrl27iFhXCvTu3TuqqqqitrY2OnXqFAcddFBUV1fHzjvvHN26dYtjjjkmBg8eHKNGjYqhQ4fGihUrYs2aNXH66afHwQcfvNFMP/3pT2PChAnxr3/9K77+9a/Hfvvtl1ufoD5Kamtrazf/r6SuPn36bPa6AFvyXMinR59+LesIeTF73kdZR8iL0u0aZx0hb1asrs46Ql48/+bKrCPkxQUn7Jx1hLzZc5cdso6QF9sX6c+PFVVrso6QN39/tzj/LWs58v+XdYS82avj0VlHyIvWp52WdYS8aN5236wj5M0uhx6WdYRthukDAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopo05IuVlpZGnz59Nuu5ixYtasgo0GC2365x1hHy4ttHNs86Ql48+35t1hHypt0+u2QdIS/+q/uOWUfIiw8/WpF1hLxZ+EFl1hHyYsmIa7OOkBe7HNwu6wh5c+hHy7KOkBdfmPRw1hHyZuH9v846Ql7MuXdM1hHyombt2qwj5M3XJkzIOsI2o0FLgeHDh2/2cze3TAAAAAA2j+kDAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkKgmWQcAAACAQrB69eqoqKiIadOmRXl5eTRu3Di6d+8ey5Yti4iI3r17b/Jrzp8/P2bMmBE9e/bcomx33HFHjBo1KqZPnx6tW7eu9/OUAgAAAFAP/fr1i4iIyZMnR1lZWVRVVcXEiRNzpcDmWLBgQUycOHGTS4GampooKSmJkpKS+Mc//hEvvvhi7LXXXpv89ZUCAAAAJKVz586fef/06dM3OPbWW2/F008/Hb///e+jrKwsIiJKS0vjwgsvjNtvvz33uP79+8dxxx2Xe5N/ySWXRK9eveL444+PUaNGxRNPPBGNGjWKnXbaKcaMGRPDhg2L+fPnR48ePeKoo46KwYMHx8yZM+PWW2+NqqqqKCsrixtuuCEOOOCAmDBhQjz22GNRUlIS8+bNi7Fjx0aLFi3ihhtuiKFDh8a3v/3tTf672GZKgdLS0ujTp0/WMaCOioqKrCMAAADbgNmzZ0fbtm1jxx133KznL1myJKZOnRpTpkyJRo0axdKlSyMiYtCgQTF69OgYM2ZM7nEjRoyIu+66K1q0aBF//etfY+DAgTF+/PiIiHj55Zdj8uTJ0apVq4iI+M1vfhNf+tKXYt99992sXNtMKTB8+PCsIwAAAJCAjY0EyLfmzZtHeXl5DBw4MDp27BinnHLKRh/30ksvxTvvvBOXXnpp7tj6AiEi4oQTTsgVAnPnzo3HHnss7r///s3Otc2UAgAAALCtat++fcydOzeWLVsWzZs3/9THNW7cOGpqanK3V61alTs+bty4mDlzZjz77LNRUVEREydO3OD5tbW1ceSRR8add9650dcvLy/P/fnll1+OBQsWRJcuXSIiYuHChXHRRRfFz372szjssMPqdV62JAQAAIDPsd9++8VJJ50UQ4YMiZUrV0bEujf848aNq/O4Nm3axKuvvhoREW+++WbMmTMnIiIqKytjyZIl0bFjx+jbt2+UlpbGwoULo1mzZlFZWZl7focOHWLWrFnx+uuvR8S6BQVnzZq10UzdunWLP/7xj/Hkk0/Gk08+Ga1atYqxY8fWuxCIMFIAAAAA6mXkyJFRUVER3bp1i7KysigpKYlzzjmnzmPOP//86NWrV5x55pnRrl27aNeuXUSsKwV69+4dVVVVUVtbG506dYqDDjooqqurY+edd45u3brFMcccE4MHD45Ro0bF0KFDY8WKFbFmzZo4/fTT4+CDD87LOZXU1tbW5uWVoUj87o+zs46QF0e1WJt1hLx49v3i/ZHWbp9dso6QF3vttnmL9WzrPvxoRdYR8mbhB5Wf/6ACtGTEtVlHyItdDm6XdYS8Wf3R5m8Bti37Qt+BWUfIm4X3/zrrCHmx8IU/Zx0hL2rWFufvixERX5swIesI2wzTBwAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgESV1NbW1mYdAgAAANj6jBQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgCgHq644oqsI0BEFP+1WF1dHWeddVbWMfJm2bJl8frrr2cdo8FUV1fHwIEDs47RoF599dV45plnNjj+9NNPF9X3DrYFf/zjH+t1jPxqknUASNUll1wSJSUln3r/fffdtxXT5MeiRYtixIgRsXDhwrj//vvjjTfeiL/85S9x4YUXZh1tk73//vtZR8iruXPnxl133RXz58+PtWvX5o4Xw3UY4VosJI0bN44dd9wxKisro1mzZlnHaVDTpk2LESNGRHV1dTz55JMxa9as+OlPfxq//OUvs4622Ro3bhx///vfs47RoCoqKmLIkCEbHN9///3jhhtuiLvvvnvrh2ogxfq7x8033xxdu3aNww47LOsoefXMM8/E3/72t1i1alXuWK9evTJMtOV+/OMfx5e+9KU6x37yk59scIz8UgpARnr37p11hLwbOHBgnHXWWXHnnXdGRMQXvvCF6Nu3b0G+EVu7dm289957UVtbu9H799prr62cqGH16tUrunbtGqeffno0btw46zgNzrVYWHbfffc499xz49RTT43y8vLc8UL/5feOO+6Ihx56KC699NKIiDj44IPj3XffzTjVljvqqKPihz/8YXTv3r3O9+vYY4/NMNXmW7ZsWeyzzz4bHN9nn31i8eLFGSRqOOt/93jqqadi7ty50bNnz4iIePjhh2PvvffOMtoWeeihh+Lxxx+PsrKyOOuss6JHjx6xxx57ZB2rQd14442xYMGCeOWVV6Jbt27x+OOPx/HHH591rM02Z86cmD17dixdujQmTZqUO75s2bJYvXp1dsESpRSAjBx33HFZR8i7Dz74ILp27Rq/+tWvIiKiSZMm0ahRYc5aevvtt+Piiy/e6BuxkpKSmD59egapGk6TJk2Keli6a7Gw7LvvvrHvvvtmHaPBrR8F8cljhW79kPq77rord6ykpKRgP3VesmTJp963YsWKrRckD9b/7nHLLbfEb3/729zxU045Jc4///ysYm2xvffeOyZOnBjPP/98PPzww9G1a9c4/PDD46yzzorTTz89SktLs464xZ577rl45JFHonv37nHNNdfE5ZdfHn369Mk61mabP39+zJgxI5YvXx4vvPBC7vgOO+wQN910U4bJ0qQUgIwU6xC+j9tuu+1i9erVufNcsGBBNGlSmD92DjjggDpNdrE5/fTT49FHH40uXbrEdtttl3WcBudaLCyFPiLg0+y2224xZ86c3HU4duzYaNOmTcapttyYMWOyjtCg9ttvv5g6dWqcccYZdY4/8cQTRVNWffTRR7Fs2bJo3rx5REQsX748Pvroo4xTbb6SkpIoKSmJjh07RseOHWPlypXxxBNPxKRJk2Lo0KHx5z//OeuIW6y0tDRKSkqiSZMmsXz58mjZsmVBTyc77bTT4rTTTovnnnsuOnbsmHWc5BXmb0RQBFKYPnDZZZfFZZddFosXL45hw4bF9OnTY/DgwVnHYiPatm0b1157bVx99dUREVFbWxslJSUxe/bsjJM1DNdiYSmmNSA+7vrrr48BAwbEP/7xjzj66KPjkEMOiZEjR2Yda4vV1NTEb3/725g7d2707ds35s+fH++//34cffTRWUfbLFdffXV885vfjGnTpsXhhx8eERGvvPJK/OlPf4p7770343QN46KLLoqzzz47TjvttIiIePLJJ+Piiy/OONXm++TIqbKysujRo0f06NGjoN84f1ybNm1i6dKlccYZZ8TFF18czZs3j/333z/rWFvsn//8Zxx66KHRvHnzGDx4cLz66qtx9dVXKwq2spLaT5uUCGxVH374Yey8885Zx2hw77zzTvzhD3+IiIgTTzwx9ttvv4wTbZ7bbrstrrzyyqxj5M2pp54at912Wxx88MEFO6z+87gWC8dll12WWwNi8uTJsXbt2jj77LPjkUceyTpag1ixYkXU1tbGDjvskHWUBrG+YJsxY0Y89thjsXTp0vj2t78dDz30UMbJNt/7778fY8eOzRWj7du3jwsvvDBatWqVcbKGM2fOnJgxY0ZErJtW0K5du4wTbb5nnnkmvvKVr2QdY6v585//HMuWLYuTTjqp4Ef3devWLR555JGYMWNG3HnnndGrV68YOnRoTJgwIetoSTFSADL24osvRr9+/aK6ujq33dHYsWPjxhtvzDpag2jbtm20bds26xhbbGNvwvr16xe33HJLBmka3u677x6HHnpo1jHyqliuxcsvvzzGjh0be+yxR3Tu3DmmTJkSL774YhxwwAFxwQUXFMUc9WJaA+LjLrjgghg/fnydxfjWHytkL7/8ckyaNCm3lWSLFi1izZo12YbaQk2bNo2vfvWr8d3vfjc3xL7YtGvXrqCLgI9LpRCoqamJxYsX5xaFXLx4ccEvLrt+Kt9zzz0XPXr0iCOPPDJqamoyTpUepQBkbMSIEXHffffFf//3f0dExCGHHBIvvfRStqEayKmnnrrBugnNmzePww8/PK666qqCGhkxYMCADY5NmzYtd3z48OFbO1KDOvroo+P666+PLl26RNOmTXPHC3X18E8qpmtx4MCBsXbt2qiqqorf/e53sWjRoty8zNmzZ8fQoUOzjrjFimkNiI/75IralZWVBT2Pe72P/8yIiFi5cuWn7o5RCB555JEYNGhQNGvWLKqqquK2224ruu3R5s2bFz/+8Y/j73//e53t7YphodJPuuaaa2LEiBFZx9hiY8eOjVtvvTXKyspyJWlJSUk8/fTT2QbbQjvuuGP88pe/jMcffzzuv//+WLt2bVRXV2cdKzmF/y8sFLiampoNtgEq9KFg63Xv3j1WrFiR2/Jo0qRJUVJSEs2aNYuBAwfGz3/+84wT1t+zzz4bX/7yl+OEE07I/bL71FNPFc0uEq+88kpERPziF7/IHSvk1cM/qZiuxb/97W/xyCOPxJo1a+LLX/5yPPvss9G0adO44IILcp/UFrpiWwNi9OjRMXr06IhYNwx9vR122CG++c1vZhWrwZx88slxyy235BZ3u//++6Nbt25Zx9psd955ZzzwwANx0EEHxcyZM6OioqLoSoFrr702Lr744rjtttvi5z//eYwfPz5atmyZday8+PjK9oXs7rvvjkcffbSoprBERNx6663xyCOPxLBhw6Jly5axYMGC+M///M+sYyVHKQAZ23HHHWPhwoW5T8SeeeaZgvrU8rM8++yzdeaU9u/fP3r27BkTJkyIrl27Zphs002ZMiVuuummmDlzZlxzzTXRvHnzGD16dJx99tlZR2sQxbZ6+CcV07W4vpSqrq6u82lKo0aNimbI5WmnnRYHHnhgbg2IX//61wW7BkTEut0UevXqFcOGDYtBgwZlHafB9erVKyZOnBgLFiyIRx99NM4666yC/tnYuHHjOOiggyIi4phjjin4bQg3Zvny5dGlS5cYPXp0fPGLX4zrrrsuzj333ILd+ePjZdvHrV80txjstddesccee2Qdo8Htsssu8a1vfSt3e++9984V+Gw9SgHI2LXXXhu9e/eOt99+O7p16xZr1qyJO+64I+tYDaKysjIWLVoUu+++e0SsW1F8+fLlEVF4oyFatGgRI0aMiKeffjr+8z//M77zne9kHalBfdp2TcUyfaCYrsUvfelL8fWvfz1Wr14d5557bvTt2zc6duwYzz///Kf+YlyIimUNiI9r3rx5LFy4sOg+6YuIOPvsswu6CPi4lStXxsyZM3MF3IoVK+r8jCyGn4vr1x5p2bJlzJw5M/bcc8/48MMPM061+XbbbbeYNGnSRj9UKZb1Bvr27Rs/+MEP4stf/nKdKTuFPkIspaks2zKlAGTsgAMOiHHjxsVbb70VtbW1sd9++xXF3NmIiB/84AfRs2fPOOqoo6K2tjZeeuml6N+/fyxfvjw6d+6cdbzN0qlTpzjmmGPilltuiWbNmmUdp8HcdtttuT+vXr065syZE+3bt49x48ZlmKrhFNO1OGDAgPjjH/8YjRo1io4dO8arr74akyZNisMPPzy+8Y1vZB2vQTz11FNx8803x4IFC6K6urpotshs3LhxXHTRRfHFL34xLrjggujUqVNRfIo5b968+NWvfhXz58+PtWvX5o4X6vSjPfbYI0aNGpW7vfvuu8dtt90WJSUlsWLFivjtb3+bYbqG8Y1vfCOWLl0affr0ib59+0ZlZWVuS9pC1KlTp/jnP/+50VLgxBNPzCBRw7vvvvvinXfeidLS0joLyhZ6KZDSVJZtmS0JIWNTp06NE088MXbccceIiFi6dGm88MILcfrpp2ecrGF88MEHuYUTjzjiiNh1112zDUS9vPnmm3HnnXcWze4KEa7FQvLVr341Ro4cGYcffnhR7DrwcTU1NfHMM8/E+PHj429/+1ucc845cd555+VGsRSis88+O/7jP/4jDjvssDpvVoplzZWIdSujT5o0KaZPnx4zZ87MOg4J6tKlS0ydOrUoisSPWz+Vb/3WhBER5557blGUb4WkuP6lhQL085//PFcIRKwbpl4s0wci1s0V69y5c3Tu3Lng34Q99thjcc4550SHDh3iyCOPjPPOOy+mTp2aday8+MIXvlDwn8p+UrFdi+eee27RXostW7aMDh06FF0hELFu7YfDDjssOnToELW1tfHaa6/FRRddlNt+sRDV1NTE5ZdfHh07dozjjjsu91+he+utt6KioiJOOeWU+N73vhdHHHFEPP7441nHahA//vGPY+nSpbnbS5YsiZ/85CcZJmoYGxtyfs8992z9IHlwwAEHFMVuJZ/0yaksCxYsKOipLIWqOMYoQwHb2GCdYtmK5fXXX4/BgwfH3//+9zpbcRXim83f/e53MXz48Ojdu3ccdthhuV/mhw8fHk2aNInTTjst64hbZNKkSbk/19TUxKuvvlqnrCp0rsXC8O6770bEutXsf/azn8XXvva12H777XP3F/p+3H/84x9j/PjxMXv27OjZs2c8+OCDseuuu0ZVVVX8x3/8R1x22WVZR9wsHTt2jJkzZ8YxxxyTdZQGMXbs2Hj44Ydj8eLF0aNHj/j1r38d3/nOd+Kiiy7KOlqD+cMf/hB9+/bN3d5pp53iD3/4Q/zwhz/MMNWWu+OOO2KnnXaKo48+OiLWFQLTp0+vs5Bdoaquro4zzzwzjjvuuDprChT6lsjrp7JcddVVcfXVVxf8VJZCpRSAjO21117x29/+Ns4999yIiHjwwQdjzz33zDhVwxgyZEgMGTIkBg0aFPfff3+MGzeuYAuP++67L26//fY44ogjcsfat28fBx10UIwcObKg34hF1N2yqXHjxtGmTZu48sorM0zUsFyLheHiiy+OkpKSXFn68R0jSkpKCn7hqbvvvjsuuuii+OlPf1pnFERpaWn0798/w2Sb59RTT819v+65557YddddY/vtt8+tAVGo368f/ehHcfzxx8dvfvOb3GKXxTZk+5M//2pqauoUpoXqZz/7WVx++eUxcuTIeP7552PatGkFPQrn47p06RJdunTJOkaDW78mwlFHHVWwPzOKgTUFIGPvvfde9O3bN/72t79FROR+sS+GYmBj88TWHys0Xbp0+dRho591H9sG1yLbgsrKyigtLc0tJrt27dqoqqoq2EVLFyxY8Jn377333lspScOaO3duTJo0KR5++OHYbbfdonv37vGrX/0qnnrqqayjNZihQ4fGihUr4tJLL42IdWVjWVlZXH/99Rkn23JvvvlmfO9734tWrVrFL3/5yygrK8s6Ehvx8RGKG1PoCygWGiMFIGN77rln3H///bnt0XbYYYeMEzWc9Vu97bXXXvHwww/HnnvuGcuWLcs41eb5rO9LeXn5VkzSsMaPHx8XXHBBjB49eqP3F+qe1Z/kWiwsvXv3jttvv/1zjxWab3/72/Gb3/wmVwpUVVXFd7/73YLd5WP9m/4777wzrrjiijr3bexYodhnn33iyiuvjCuvvDJmzJgREydOjGXLlsX3v//9+NrXvhZnnnlm1hG32DXXXBN33HFHDBo0KEpKSuKkk06K733ve1nH2myXXHJJndEc1dXVsWLFitw1WKg7YXzcBx98EEOHDo3nn38+ItZN2xk0aFDssssuGSfbPB8fobgxSoGtSykAGVq+fHlst9120bRp03j77bfjhRdeiH333TdOPfXUrKM1iCuvvDKWLVsW/fr1ixtuuCEqKytj0KBBWcfaLIsWLfrUN86LFy/eymkaTiqDxVyLhWX+/PkbHHvrrbcySNKwVq1aVafUadasWaxcuTLDRA1j6tSpGxQAGztWiNYvmnj99dfH448/HhMmTCiKUqBp06Zx1VVXxVVXXZV1lAbRu3fvrCPk3aBBg+Koo46KoUOHRm1tbTzwwAMxaNCg+PnPf551tM1S6GshFBvTByAjY8eOjR//+MdRVlYW3/ve9+Kee+6Jww8/PGbNmhVnnHFG9OnTJ+uIfMynvQlbr1g+UWfbV8zX4r333hv33ntvLF68uM4WfStWrIhTTjklbrrppgzTbbmzzz47fvGLX8Qee+wRERELFy6MK664Ih5++OGMk22eadOmxfTp0+PJJ5+sU2ZXVlbGokWLYvz48Rmm47MsWrQoRowYEQsXLoz7778/3njjjfjLX/4SF154YdbRtkhlZWWUlZXlVrQv9Ck6H9ejR48NflZs7FihWbt2bYwfPz43cuCEE06I888/Pzeiiq3D3zZkZOzYsTFt2rRYvnx5dO3aNZ566qnYZZddYvny5XHeeecVRSmwZMmSeOCBB2LevHmxdu3a3PFCbIebNWsWZWVlccEFF9Q5Pn78+IJenKmY32B+nGuxMPTs2TM6d+4cN954Y52RHM2aNYsWLVpkmKxhfO9734uvf/3rcdppp0VtbW08+eSTBbnA4HqtW7eO4447Lp5//vk4/vjjc8ebNWtW5zbbnoEDB8ZZZ50Vd955Z0Ss24a2b9++BV8KrJ+is35ETqFP0fm4kpKSWLBgQW7azoIFC4piAcwhQ4bEv//97+jZs2dErFtrYNasWTFs2LCMk6VFKQAZadKkSey8886x8847R9u2bXNzwnbYYYc6W80Usv/+7/+OL3zhC3HEEUfkWvtC9eijj8bYsWM3OH722WfH+eefH5dcckkGqagv12JhaN68eTRv3jx+/vOfx9q1a3NTBtZ/sl7ounTpEgcccEBuTvBdd90V+++/f8apNl+7du2iXbt2cdJJJ8WwYcPiueeei5KSkujYsWMceeSRWcfjM3zwwQfRtWvX3Mr8TZo0qbMjRqEq1ik6EeumSJx//vlx5JFHRm1tbbz88ssxdOjQrGNtsRdffDEee+yx3O1TTjklunbtmmGiNCkFICMfb3c/OUSqGJrfiIiPPvoofvSjH2Udo0FUV1dvtKxp2rRp1NTUZJCoYRTLSIDP41osLK+88kpcddVV0aJFi6itrY2PPvoofvrTn8bhhx+edbQt1rZt29z3aZ999sk4TcO47rrrcnOdI9aNWinkuc4p2G677WL16tW53zcWLFhQFMO1GzVqFO+//36dKTrFoKamJvbee++YPHlyvPzyyxGxbuvMQl1k8ON22WWXWLZsWTRv3jwi1q23VQznVWgK//9+KFCzZ8+O9u3bR8S6xd4+/udiKQUOOeSQePvtt2PffffNOsoWW758eaxevXqDN2NVVVVF8SlEsc4vXc+1WFhuvPHGuPXWW6NDhw4REfHyyy/HjTfeWPBz1Iu17Hj33XfrFADf/e53c1t/sm267LLL4rLLLovFixfHsGHDYvr06TF48OCsY22xj0/RiYiYPn16QU/RWa9Ro0bRr1+/mDx5ctEsRr1++uKee+4ZZ511Vnz1q1+NiHXfMyONtj6lAGRkzpw5WUfIm/VbA61evTrOOuusaNeuXZ03MIW4NVDnzp2jf//+8aMf/Si3YFFlZWUMGTIk98tHISvW+aWuxcK0cuXKXCEQEXHEEUcUReFRrGVHsc51LmannXZaHHjggfGHP/whIiJ+/etfx3777Zdxqi3XpUuXOPDAA+O5556LiMKfovNxBx54YPztb3+LL37xi1lHaVBt27aNtm3b5m736NEjwzTpUgoADa4Ytwbq06dP9OvXL0466aTcp83vvPNOnHTSSUWxKGSxzi91LRamFi1axOOPPx5dunSJiIgnnniiKBYaLNayo1jnOhe7T74Z+7hvfvObce+9927lRA1j//33/9QioJDPa968edGzZ89o165dlJeX544XYrkdkc70xUKhFAAa3HHHHVfn9vLlyyMi6iz+U2iaNm0aP/3pT+Ptt9+O2bNnR0RE+/bti2I4ekTxzi91LRamG264Ifr27RvXX399RES0adMmRo4cmXGqLVesZUfnzp2jQ4cORTfXOWVLly7NOkJeFPJ59e3bN+sIebFixYq44447cqM7OnbsGN///vfrFB/kX0ltbW1t1iGA4vTmm29Gv379Yv78+RGx7hf7ESNGxBe+8IWMk/FJ06ZNizFjxsSbb74ZZ5xxRm5+aadOnbKO1iBci4WpsrIyImKDPcZffPHFOProo7OItEX++c9/Rt++fWPBggURse46vOWWW4pmeDPF4+yzz46JEydmHaPBFfJ5TZw4Mc4+++zPPVZorrnmmigrK4uvf/3rERHx4IMPxrJly+KWW27JOFlalAJA3px33nlx2WWXxemnnx4R69543nnnnfHggw9mnIyNeeedd3LzS0888cSimF+6nmuxuBTyL/YRn152wLai0P8f+zSFfF4by96zZ8+YMGFCRokaRvfu3WPy5Mmfe4z8KvyxocA2q6qqKvcmLGLdwkajRo3KMBGf5bPmlxY612JxKeTPM1566aWYN29eVFdX546dddZZ2QWCjSjk/8c+SyGe14wZM2LGjBmxePHi3Ir9EevKxWLYhra2tjaWLl2am0q1dOnSgvw+FTqlAJA3Rx99dEybNq3O1kDHHntsxqnYmKeeeipuvvnmWLBgQVRXV+e2xlw/Z73QuRaLS6GubD9w4MB45ZVXon379tG4cePccaUAW1N1dXU88MADn7m7zPrt4QpJsZ7Xp2nVqlXcfvvtWcfYYpdcckn07Nmzzr/PV1xxRcap0mP6AJA3p556arz77rt12t+99torItb9Uj99+vQs4/ExX/3qV2PkyJFx+OGHF8WuA5/kWiwuhToEuEuXLjFlypSiWMSTwlYMw843pljPKyLiBz/4QQwbNix22GGHuOyyy+K1116L66+/Prp27Zp1tC2ydOnSeO+99+LPf/5zRKxbIPiggw7KOFV6/KsE5M2YMWOyjkA9tWzZss5WacXGtVhcCvXzjNatW8fatWuVAmSuc+fOMW7cuOjRo0eUlZVlHafBFOt5RUS89dZb0bx583jmmWdip512ikceeSQuu+yygi4Famtr46KLLoopU6ZEu3btso6TNP8qAXmz9957x9q1a+Ott96KiIj99tvPL8PbmHfffTciIk4++eT42c9+Fl/72tdi++23z92//tP0QudaLDzLli2LuXPnxiGHHLLBfTfffHMGibbcbrvtFueff3506tQpmjZtmjtuv262tvXDzocMGRIlJSVFM2WsWM8rInKj+GbMmBFdunSJ3XffvWCnUq1XUlISrVu3jkWLFsXuu++edZyk+Y0IyJtXXnklrrrqqmjRokXU1tbGRx99FD/96U/j8MMPzzoa/38XX3xx7heniIiHHnood18xDat3LRaWadOmxYgRI6K6ujqefPLJmDVrVvz0pz+NX/7ylxERBfuJUuvWraN169ZZx4CYM2dO1hHyoljPK2Ldz4/BgwfH888/H//1X/8VVVVVBTtq6uNqa2ujW7duccIJJ0R5eXnu+PDhwzNMlR5rCgB5c8EFF8SAAQNyw9JffvnluOmmm2L8+PHZBiM5rsXC0rNnz7jnnnvi0ksvjUmTJkVExJlnnhmPPvpotsGgiHz44YfxyiuvRETEEUccES1btsw4UcMo1vOqqqqKZ599Ntq1axdt2rSJ999/P9544404+eSTs462RT5tfZizzz57KydJm5ECQN6sXLmyzjz1I444IlauXJldID5V7969N1jFeGPHCpVrsbA0btw4dtxxxw2OFboVK1bEHXfcEc8991xERHTs2DG+//3v1/l0DLaGZ555JgYOHBgdOnSI2trauO666+LGG28s+DeYxXpeERGlpaV1dk/YY489Yo899sgwUcPw5n/boBQA8qZFixbx+OOPR5cuXSIi4oknnsit/s62Zf78+RscWz//vhi4FgvLbrvtFnPmzMnNlx07dmy0adMm41Rb7oYbboiysrK48cYbIyLiwQcfjCFDhsQtt9yScTJSM2rUqPjf//3f3P9X8+bNix/84AcF/+a5WM+rmC1atCiGDRsWL7zwQkREnHDCCTFw4EBrDGxlSgEgb2644Ybo27dvXH/99RER0aZNmxg5cmTGqfi4e++9N+69995YvHhxdO7cOXd8xYoVccopp2SYrGG5FgvL9ddfHwMGDIh//OMfcfTRR8chhxxSFN+v2bNnx+TJk3O3r7vuuujevXuGiUjV2rVr6xRtbdq0ibVr12aYqGEU63kVs6uvvjo6deoUN910U0RE/Pa3v42rr7467r333oyTpUUpAORFdXV1vPDCCzFhwoSorKyMiIhmzZplnIpP6tmzZ3Tu3DluvPHGGDRoUO54s2bNiuaTdNdi4WnVqlX85je/iRUrVkRtbW3ssMMOWUdqELW1tbF06dLc/1tLly4tioXCKDx77bVX3H333XHBBRdERMQDDzwQe+65Z8aptlyxnlcx++CDD+I///M/c7e/9a1vxW9/+9sME6XJQoNA3vTs2TMmTJiQdQzqqZi37HMtFp6XXnop5s2bF9XV1bljZ511VnaBGsADDzwQd955Z5x22mkRETF9+vS44oor4rzzzss4Gakp1iHbxXpexeyqq66Kyy67LLf97KxZs+Kuu+6KW2+9NeNkaVEKAHnzs5/9LHbZZZfo0aNHlJWVZR2Hz1DsW/a5FgvLwIED45VXXon27dvXWWCwGLaomjNnTvz5z3+OiIjjjjsuDjrooIwTAWx9l1xySZSUlMSqVavitddey/0sfOONN+Kwww6LcePGZZwwLUoBIG8+vpd4SUlJ1NbWRklJScyePTvDVGxMsW/Z51osLF26dIkpU6YU1WgV2JasWbMmnnjiiZg3b16dOfe9evXKMNWWK9bzKkYzZsz4zPuPO+64rZSECGsKAHk0Z86crCNQT8W+ZZ9rsbC0bt061q5dW3SlwJNPPhkjRoyIBQsWRHV1tXKKzPz3f/93VFdXxyGHHBKNGjXKOk6DKdbzKkbe9G9biutfW2Cb8uKLL8ZBBx2UW9StsrIy/va3v8VRRx2VcTI+qdi37HMtFpbddtstzj///OjUqVM0bdo0d7zQP+278cYb48c//nEccsghdaZFwNa2YMGCmDJlStYxGlyxnlcxuu6662Lo0KG5aQSfdN9992WQKl1KASBvhg4dWmdxt/Ly8hg2bJgF37ZBG9uyr5j2TnctFpbWrVtH69ats47R4Hbfffc48sgjs44Bccghh8S8efPqbN9XDIr1vIrR17/+9YiI6N27d8ZJiFAKAHlUW1tbZ/heo0aN7Be8jdp///2Less+12JhKfQRAZ/miiuuiJtuuim+8pWv1BkBceyxx2aYihR961vfivPOOy/23XffOtdioX86W6znVYyGDRsW//u//xu/+93vYuDAgVnHSZ5SAMibFi1axHPPPRcdO3aMiIg//elPRTUkvRisXwX90xTLmxXXYmEZPXr0Ro8XelkwY8aMmDJlSrz++uu5kqqkpMQbFra6q6++Oi6//PINdvgodMV6XsVoyZIl8c9//jOee+65eO+99+KTa9/vtddeGSVLk1IAyJuBAwdG7969o6ysLGpra2PVqlVx++23Zx2Lj7ntttsiYt2Kza+88kqdLYEOP/zwotkSyLVYuFatWhVPP/10bg/rQvb444/H9OnTo7S0NOsoJG777bePb3/721nHaHDFel7F6OKLL45evXrF3Llz4xvf+Ead+0pKSmL69OkZJUuTLQmBvFq7dm289dZbERGx3377Fd1q4sXiqquuiu985ztx2GGHRUTEa6+9Fr/+9a/j1ltvzThZw3EtFq7ly5dHr1694je/+U3WUbbId77znfj5z39eZ1gzZOGXv/xl7LXXXtGlS5fYbrvtso7TYIr1vIrZNddcEyNGjMg6RvKUAkDeffDBB7Fq1arcbUPCtj1nnnlmPProo3WOdevWLR555JGMEuWHa7EwVVdXR9euXWPq1KlZR9ki11xzTbzxxhvxla98pc4blkKfFkHhadeuXUREbtX3Ytkes1jPq9h9+OGH8corr0TEui2RW7ZsmXGi9PiYBMibZ599NgYPHhyLFy+O8vLy+Oijj2LPPfeMJ598MutofELLli3j3nvvjXPOOSciIh566KHYaaedsg3VgFyLhWXAgAG5P9fW1sbs2bPj6KOPzjBRw2jTpo1V0dkmzJkzJ+sIeVGs51XMnnnmmRg4cGB06NAhamtr47rrrosbb7wxTj755KyjJcVIASBvzjrrrPjFL34R3/ve92LSpEkxderU+Mtf/hLXXntt1tH4hIULF8aNN94YL7zwQpSUlMTxxx8f1157bbRq1SrraA3CtVhYJk6cmPtz48aNo02bNkls5XfvvffGN7/5zaxjAGw1PXv2jFGjRuUK03nz5sUPfvADWwZvZUYKAHnTqFGjaNWqVW7rtzPOOCPuvPPOjFOxMa1atSrqhfdci4Xl7LPPzjpCJiZNmqQUYKto165dlJSU5IbXr1fow+yL9byK2dq1a+uMoGrTpo0tgzOgFADyZvvtt4/q6uo44IAD4o477og999yzznxuth1r1qyJJ554IubNm1fnH+NimevsWiwsL7/8ctx2220xf/78Otdjsa9GbfAmW8vHh9mvWrUq/u///i8WLVqUYaKGUaznVcz22muvuPvuu+OCCy6IiIgHHngg9txzz4xTpcf0ASBv5syZE/vss09UVlZGRUVFVFZWxuWXX55b4Z5tx3/913/FmjVr4rDDDquzt3OxlAKuxcLSpUuX6N27dxxyyCF1rsd99tknw1T5d/bZZ9eZOgFbU8+ePYtyyHaxnlexWLRoUQwbNixeeOGFiIg44YQTYuDAgbH77rtnnCwtRgoAebN+FeDy8vIYPnx4xmn4LO+880783//9X9Yx8sa1WFh23HHHOPPMM7OOAUXr3Xffzf25pqYmXnnllaiqqsowUcMo1vMqZrvvvnvcdtttWcdInlIAyJu5c+fGXXfdtcEQ4Pvuuy/DVGzM/vvvHx9++GHsvPPOWUfJC9diYTn//PPjV7/6VXz1q1+Npk2b5o4X+xaSjRo1yjoCibj44otzc++bNGkSbdq0iZtvvjnrWFusWM+rmHXu3DnOP//8OPfcc2OXXXbJOk6ylAJA3vTq1Su6du0ap59+ep0hwGx71q5dG927d4/jjz++zpuwYvlU3bVYWFauXBl33HFHjB07NrdYWElJSVGtKXD//ffHN77xjTrHHnrooYzSkJpdd901HnjggTrHLrjgghg/fnxGiRpGsZ5XMbv33nvjwQcfjHPOOScOP/zwuOCCC+JLX/pS1rGSoxQA8qZJkyZxxRVXZB2DeujSpUt06dIl9wlLRNRZubnQuRYLyz333BNPPPFE7LbbbllHaRCTJk3a4Njo0aNjhx12iIh1W2bC1rRmzZo6t5cvXx4fffRRRmkaTrGeVzFr3bp19OnTJ3r37h3Tpk2La6+9Npo2bRpf//rX46KLLoqysrKsIyZBKQDkzemnnx6PPvpodOnSJbbbbrus4/AZDj/88Bg4cGAsWrQonnzyyZg9e3Y88cQTWcdqMK7FwrL33nvHrrvumnWMBnPttdfGySefHC1btswdq6qqyi2spRRgaxk9enSMHj06IiLat28fEet2vWjWrFlBb4dZrOeViiVLlsTEiRPjwQcfjPbt28c555wTM2fOjG9/+9vxv//7v1nHS4LdB4C8eeyxx+Laa6/NLfKzft9g+wVvey655JL44Q9/GEOGDIlJkyZFbW1tnHnmmTFlypSsozUI12Jh+dGPfhTz5s3bYE2BQn3zPHPmzPjxj38cF110UXTv3j0iIk499dR48sknM05GqoYNGxaDBg3KOkaDK9bzKmY//OEP4y9/+Ut07949Lrjggjprx3zta18r6kWQtyVGCgB5M3LkyBgzZkwcfPDBFtDaxq1YsSI6dOiQu11SUhJNmhTPPxGuxcKycuXK2HXXXeOvf/1rneOFWgocc8wxce+998aoUaNiypQpcf311xfV9BwKT7G+cS7W8ypmnTp1iptvvnmjo/gefvjhDBKlqXh+4wO2ObvvvnsceuihWcegHkpLS2PZsmW5NyqzZs2K8vLyjFM1HNdiYSmWBS4/bvvtt49+/frFK6+8En369IkVK1ZkHQkgM+u3jzz66KNj8eLFG9y/1157me63FZk+AOTNyJEjY9myZdGlS5c6Q4CPPfbYDFOxMTNnzoxbbrkl3nnnnTjyyCNj9uzZMWrUqDqjBwqZa7GwrFmzJp544omYN29enS0ke/XqlWGqhrN27dpYvHhx7LnnnllHAchEu3btolWrVtG4ceP45NvRYtttphAoBYC8ueSSSzY4VlJSYm/4bdTSpUvjpZdeitra2ujQoUPstNNOWUdqMK7FwnL55ZdHdXV1HHLIIXWme1x11VXZhcqTp556Kk455ZSsYwBsVYMGDYo///nPccopp8RZZ50V7dq1yzpS0pQCQGZefPHFOProo7OOAa7FbUzXrl2LZpHLz9OpU6d4+umns44BsNWtWrUqpk2bFpMmTYoPPvggunfvHj169KizUwtbhzUFgMwMGzYsJk6cmHUMcC1uYw455JCYN29etGnTJusoDWLAgAGfet/SpUu3YhKAbcf2228fXbt2ja5du8b06dNj4MCBsXbt2vjud7+bdbTkKAWAzBioxLbCtbht+da3vhXnnXde7LvvvnXWgCjU6R5Tp06N/v371zmXiHXXnW0JgVS9//77MWnSpJgyZUq0bt06brjhBtOpMqIUADJjSy62Fa7FbcvVV18dl19+ebRv3z4aN26cdZwtdvDBB0e7du3iiCOO2OC+UaNGZZAIIFvf+ta3orKyMnr06BH33nuvKQMZUwoAANuU7bffPr797W9nHaPB3HTTTdG8efON3vfII49s5TQA2Xv++ecjIuK1116Lm266KXe8trY2SkpKYvbs2VlFS5JSAMiMIdtsK1yL25YzzjgjHn300ejSpUtR7FPdtm3bT71vxx133IpJALYNc+bMyToCH2P3ASAzc+bMsQUN2wTX4rZl/fdi/bSOYvjk6LHHHou77ror3nzzzSgpKYkDDjggvvOd78QZZ5yRdTQAEqcUABrc0qVL4/bbb4/33nsvTj755Ljgggty91199dUxcuTIDNPBOpdeemnBLlxHYfnd734XQ4cOjd69e8dhhx0WtbW18dprr8Xo0aPjuuuui9NOOy3riAAkzPQBoMFdd911sc8++0SPHj1i/Pjx8eyzz0ZFRUVst9128Y9//CPreCTk3Xff3ejx2traeOutt7ZyGlJ13333xe23315nocH27dvHQQcdFCNHjlQKAJAppQDQ4N5555247bbbIiLi9NNPjxEjRsR3vvOd+MUvfmHuNlvVqaeeGnvvvfdGr7t///vfGSTis5x99tkxceLEaNeuXZSUlOSmDRT69IFFixZtdOeBww8/PBYtWpRBIgD4f5QCQINbtWpVndvXXHNN/PKXv4xLL700VqxYkVEqUtS6dev4n//5n2jVqtUG933lK1/JIBGfZeLEiRFRfAtQ7bDDDp96X3l5+VZMAgAbUgoADe7AAw+Mp59+Ojp16pQ7dvnll8cOO+wQw4YNyy4YyTnrrLNi0aJFGy0FevbsmUEiUrRo0aIYPXr0Ru9bvHjxVk4DAHVZaBBocOt/rKxfOfzjli9f/pmfmgEUm08rBNbr1avXVkoCABsyUgBocO+9995n3q8UYGv5tIUG19trr722UhJS1qxZsygrK6uzE0tExPjx42P16tUZpQKAdYwUABpcu3btolWrVtG4ceMNFngrKSmJ6dOnZ5SM1LgW2Race+65MXbs2GjatGmd46tXr47zzz8/Jk2alE0wAAgjBYA8OPfcc+PPf/5znHrqqdGjR49o165d1pFIlGuRbUF1dfUGhUBERNOmTaOmpiaDRADw/xgpAOTFqlWrYtq0aTFp0qT44IMPonv37tGjR49o2bJl1tFIjGuRrJ1++unx6KOPblAMVFVVRbdu3eJ3v/tdRskAQCkAbAXTp0+PgQMHxne/+9347ne/m3UcEuZaJAsjRoyI999/P370ox9Fs2bNIiKisrIyhgwZErvttltcc801GScEIGVKASAv3n///Zg0aVJMmTIlWrduHT169IhTTjllo0NoIZ9ci2Rt9erV0a9fv3jmmWdi3333jYiId955J0466aQYOXKkaxGATCkFgAb3rW99KyorK6NHjx5x5plnGqZNZlyLbEvefvvtmD17dkREtG/fPlcQAECWlAJAg/v4Ym4lJSW5P9fW1kZJSUnul2LIN9ciAMBnUwoAAABAohplHQAAAADIhlIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgET9f4tWD7VrJBFwAAAAAElFTkSuQmCC\n",
+                        "image/png": "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fn0AAAAoFKYPAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKaZB0AAAAACsHq1aujoqIipk2bFuXl5dG4cePo3r17LFu2LCIievfuvcmvOX/+/JgxY0b07NlzszJdcsklsXDhwigvL4+IiGuuuSZOPPHEej9fKQAAAAD10K9fv4iImDx5cpSVlUVVVVVMnDgxVwpsjgULFsTEiRM3uRSoqamJkpKSiIgYNmxYHH/88Zv19U0fAAAAgM/x1ltvxdNPPx0/+tGPoqysLCIiSktL48ILL6zzuP79+8eECRNyty+55JJ44YUXIiJi1KhR0bVr1+jWrVtccsklEbHuDf1rr70WPXr0iBtuuCEiImbOnBkXXXRR9OzZM77xjW/EP/7xj4iImDBhQlx22WVx+eWXR9euXWPJkiVbfF5GCgAAAJCUzp07f+b906dP3+DY7Nmzo23btrHjjjtu1tdcsmRJTJ06NaZMmRKNGjWKpUuXRkTEoEGDYvTo0TFmzJjc40aMGBF33XVXtGjRIv7617/GwIEDY/z48RER8fLLL8fkyZOjVatWudf+0Y9+FI0aNYqjjz46+vbtG82aNat3LqVAHgwYMCCqqqqyjkEDqKioyDoCAABQBJo3bx7l5eUxcODA6NixY5xyyikbfdxLL70U77zzTlx66aW5Y+sLhIiIE044oU4hMHLkyGjVqlWsXr06hg8fHjfffHMMGzas3rmUAnlQVVXlzSQAAMA2amMjAT5P+/btY+7cubFs2bJo3rz5pz6ucePGUVNTk7u9atWq3PFx48bFzJkz49lnn42KioqYOHHiBs+vra2NI488Mu68886Nvv76BQXXW18QNG3aNC688ML44Q9/uEnnZU0BAAAA+Bz77bdfnHTSSTFkyJBYuXJlRKx7wz9u3Lg6j2vTpk28+uqrERHx5ptvxpw5cyIiorKyMpYsWRIdO3aMvn37RmlpaSxcuDCaNWsWlZWVued36NAhZs2aFa+//npErFtQcNasWRvNtHbt2vjggw9ytx977LH44he/uEnnZaQAAAAA1MPIkSOjoqIiunXrFmVlZVFSUhLnnHNOncecf/750atXrzjzzDOjXbt20a5du4hYVwr07t07qqqqora2Njp16hQHHXRQVFdXx8477xzdunWLY445JgYPHhyjRo2KoUOHxooVK2LNmjVx+umnx8EHH7xBntWrV8dll10Wa9asidra2th///1j8ODBm3ROSgEAAACoh+233z769+8f/fv3/9TH7LzzzjF27NiN3vfggw9ucKxJkyZx99131zl21FFHbTACISKiZ8+edbYuLC8vr7PTweYwfQAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAAS1STrALCt22XxW1lHyIvS3XfPOkJeNG/dJusIebP3yZ2yjpAXyxfMyzpCXhzR/9qsI+TN6jU1WUfIi/c/XJZ1hLzYZYc9s46QN/M+WpN1BDbRDmVNs46QF7W1tVlHyIv992qZdQS2AiMFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARDXJOkBDKy0tjT59+mSaYdGiRZl+fQAAAKiPoisFhg8fnnWEzEsJAAAAqA/TBwAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQ1yToAAAAAFILVq1dHRUVFTJs2LcrLy6Nx48bRvXv3WLZsWURE9O7de5Nfc/78+TFjxozo2bPnJj+3pqYmrrzyyvj73/8eTZs2jbZt28bQoUOjZcuW9X4NIwUAAACgHvr16xfvvfdeTJ48OR5++OEYO3ZsbL/99lv0mgsWLIiJEydu8vNqamqitrY2evbsGVOnTo1HHnkk2rZtG6NHj96k1zFSAAAAgKR07tz5M++fPn36BsfeeuutePrpp+P3v/99lJWVRUREaWlpXHjhhXH77bfnHte/f/847rjjcp/8X3LJJdGrV684/vjjY9SoUfHEE09Eo0aNYqeddooxY8bEsGHDYv78+dGjR4846qijYvDgwTFz5sy49dZbo6qqKsrKyuKGG26IAw44ICZMmBCPPfZYlJSUxLx582Ls2LFx6qmn5r724YcfHpMmTdqkvwulQJEZMGBAVFVVZR2jaFRUVGQdAQAA2AbMnj072rZtGzvuuONmPX/JkiUxderUmDJlSjRq1CiWLl0aERGDBg2K0aNHx5gxY3KPGzFiRNx1113RokWL+Otf/xoDBw6M8ePHR0TEyy+/HJMnT45WrVrVef3a2toYP358fPWrX92kXEqBIlNVVeWNLAAAwGfY2EiAfGvevHmUl5fHwIEDo2PHjnHKKads9HEvvfRSvPPOO3HppZfmjq0vECIiTjjhhA0KgYiIW265JUpLS+PrX//6JuVSCgAAAMDnaN++fcydOzeWLVsWzZs3/9THNW7cOGpqanK3V61alTs+bty4mDlzZjz77LNRUVGx0bUEamtr48gjj4w777xzo69fXl6+wbFf/vKX8dprr8Vdd90VJSUlm3ReFhoEAACAz7HffvvFSSedFEOGDImVK1dGxLo3/OPGjavzuDZt2sSrr74aERFvvvlmzJkzJyIiKisrY8mSJdGxY8fo27dvlJaWxsKFC6NZs2ZRWVmZe36HDh1i1qxZ8frrr0fEugUFZ82a9am57r///nj88cfj5z//+WYtemikAAAAANTDyJEjo6KiIrp16xZlZWVRUlIS55xzTp3HnH/++dGrV68488wzo127dtGuXbuIWFcK9O7dO6qqqqK2tjY6deoUBx10UFRXV8fOO+8c3bp1i2OOOSYGDx4co0aNiqFDh8aKFStizZo1cfrpp8fBBx+8QZ7KysoYOnRotG7dOr7xjW9ERMQBBxwQP/nJT+p9TkoBAAAAqIftt98++vfvH/379//Ux+y8884xduzYjd734IMPbnCsSZMmcffdd9c5dtRRR20wAiEiomfPnrldDSIimjVrlhuJsLlMHwAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABKlFAAAAIBEKQUAAAAgUUoBAAAASJRSAAAAABLVJOsAxai0tDT69OmTyddetGhRJl+3mH3U6oCsI+TFew/dk3WEvKicOy/rCHmz65Edso6QF20vuDjrCHlRsmpl1hHypsl2ZVlHyIvtZr+YdYS8aNSxY9YR8ufPT2SdID86nJR1grxZvnJ11hHyYreW5VlHyItWuzTLOgJbgVIgD4YPH57Z186qjAAAAKDwmD4AAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiVIKAAAAQKKUAgAAAJAopQAAAAAkSikAAAAAiWqSdQAAAAAoBKtXr46KioqYNm1alJeXR+PGjaN79+6xbNmyiIjo3bv3Jr/m/PnzY8aMGdGzZ8/NylRdXR0VFRXxu9/9Lpo2bRqHHnpoDB8+vN7PVwoAAABAPfTr1y8iIiZPnhxlZWVRVVUVEydOzJUCm2PBggUxceLETS4FampqoqSkJH7zm9/Ev/71r/i///u/aNy4cfzrX//apNdRCgAAAJCUzp07f+b906dP3+DYW2+9FU8//XT8/ve/j7KysoiIKC0tjQsvvDBuv/323OP69+8fxx13XO5N/iWXXBK9evWK448/PkaNGhVPPPFENGrUKHbaaacYM2ZMDBs2LObPnx89evSIo446KgYPHhwzZ86MW2+9NaqqqqKsrCxuuOGGOOCAA2LChAnx2GOPRUlJScybNy/Gjh0b9957b0ycODEaN24cERG77rrrJv1dKAWKTGlpafTp0yfrGEWjoqIi6wgAAMA2YPbs2dG2bdvYcccdN+v5S5YsialTp8aUKVOiUaNGsXTp0oiIGDRoUIwePTrGjBmTe9yIESPirrvuihYtWsRf//rXGDhwYIwfPz4iIl5++eWYPHlytGrVKpYtWxarVq2KcePGxVNPPRWlpaXxgx/8II477rh651IKFJlNmTsCAACQoo2NBMi35s2bR3l5eQwcODA6duwYp5xyykYf99JLL8U777wTl156ae7Y+gIhIuKEE06IVq1aRUTE2rVrY+nSpdG8efN46KGHYs6cOfHd7343HnvssWjevHm9cikFAAAA4HO0b98+5s6dG8uWLfvMN9yNGzeOmpqa3O1Vq1bljo8bNy5mzpwZzz77bFRUVMTEiRM3eH5tbW0ceeSRceedd2709cvLy3N/btmyZZSXl0e3bt0iIqJdu3bRqlWrePvtt+Owww6r13nZkhAAAAA+x3777RcnnXRSDBkyJFauXBkRkRu6/3Ft2rSJV199NSIi3nzzzZgzZ05ERFRWVsaSJUuiY8eO0bdv3ygtLY2FCxdGs2bNorKyMvf8Dh06xKxZs+L111+PiHULCs6aNetTc/3Hf/xH/OEPf4iIdYsWLly4MPbZZ596n5eRAgAAAFAPI0eOjIqKiujWrVuUlZVFSUlJnHPOOXUec/7550evXr3izDPPjHbt2kW7du0iYl0p0Lt376iqqora2tro1KlTHHTQQVFdXR0777xzdOvWLY455pgYPHhwjBo1KoYOHRorVqyINWvWxOmnnx4HH3zwRjP98Ic/jGuuuSZ+9atfRePGjWPo0KHRokWLep9TSW1tbe3m/5XU1adPHwuzUXTm/H1B1hHyYvlD92QdIS8q587LOkLe7Hpkh6wj5EXbCy7OOkJebLe2KusIeVO9XVnWEfJi0e+fzDpCXuzZsWPWEfJm7u+eyDpCXqzucFLWEfLm/Q+XZx0hL3ZrWf75DypAB+2zaavYF5Km5cX5Pdscpg8AAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAoppkHQC2df9Y8O+sI+TF7L1PyTpCXpTu2zjrCHmzYnV11hHy4vmfvJB1hLy44ISds46QN3vuskPWEfJi+70OzjpCXvzzjX9lHSFv/t7kgKwj5EXLb16YdYS82avj0VlHyIvmp52WdYS8WLZ236wj5M0uhx6WdYRthpECAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACSqSdYBAAAAoBCsXr06KioqYtq0aVFeXh6NGzeO7t27x7JlyyIionfv3pv8mvPnz48ZM2ZEz549NyvT7bffHpMmTYr58+fH9OnTo3Xr1pv0fCMFAAAAoB769esX7733XkyePDkefvjhGDt2bGy//fZb9JoLFiyIiRMnbvLzampqora2Nk466aQYM2ZM7L333pv19Y0UAAAAICmdO3f+zPunT5++wbG33nornn766fj9738fZWVlERFRWloaF154Ydx+++25x/Xv3z+OO+643Cf/l1xySfTq1SuOP/74GDVqVDzxxBPRqFGj2GmnnWLMmDExbNiwmD9/fvTo0SOOOuqoGDx4cMycOTNuvfXWqKqqirKysrjhhhvigAMOiAkTJsRjjz0WJSUlMW/evBg7dmx06NBhi/4utplSYMCAAVFVVZV1DKijoqIi6wgAAMA2YPbs2dG2bdvYcccdN+v5S5YsialTp8aUKVOiUaNGsXTp0oiIGDRoUIwePTrGjBmTe9yIESPirrvuihYtWsRf//rXGDhwYIwfPz4iIl5++eWYPHlytGrVqkHOa5spBaqqqrwBAwAAIO82NhIg35o3bx7l5eUxcODA6NixY5xyyikbfdxLL70U77zzTlx66aW5Y+sLhIiIE044ocEKgYhtqBQAAACAbVX79u1j7ty5sWzZsmjevPmnPq5x48ZRU1OTu71q1arc8XHjxsXMmTPj2WefjYqKio2uJVBbWxtHHnlk3HnnnRt9/fLy8i08k7osNAgAAACfY7/99ouTTjophgwZEitXroyIdW/4x40bV+dxbdq0iVdffTUiIt58882YM2dORERUVlbGkiVLomPHjtG3b98oLS2NhQsXRrNmzaKysjL3/A4dOsSsWbPi9ddfj4h1CwrOmjUrb+dlpAAAAADUw8iRI6OioiK6desWZWVlUVJSEuecc06dx5x//vnRq1evOPPMM6Ndu3bRrl27iFhXCvTu3TuqqqqitrY2OnXqFAcddFBUV1fHzjvvHN26dYtjjjkmBg8eHKNGjYqhQ4fGihUrYs2aNXH66afHwQcfvNFMP/3pT2PChAnxr3/9K77+9a/Hfvvtl1ufoD5Kamtrazf/r6SuPn36bPa6AFvyXMinR59+LesIeTF73kdZR8iL0u0aZx0hb1asrs46Ql48/+bKrCPkxQUn7Jx1hLzZc5cdso6QF9sX6c+PFVVrso6QN39/tzj/LWs58v+XdYS82avj0VlHyIvWp52WdYS8aN5236wj5M0uhx6WdYRthukDAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopo05IuVlpZGnz59Nuu5ixYtasgo0GC2365x1hHy4ttHNs86Ql48+35t1hHypt0+u2QdIS/+q/uOWUfIiw8/WpF1hLxZ+EFl1hHyYsmIa7OOkBe7HNwu6wh5c+hHy7KOkBdfmPRw1hHyZuH9v846Ql7MuXdM1hHyombt2qwj5M3XJkzIOsI2o0FLgeHDh2/2cze3TAAAAAA2j+kDAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkCilAAAAACRKKQAAAACJUgoAAABAopQCAAAAkKgmWQcAAACAQrB69eqoqKiIadOmRXl5eTRu3Di6d+8ey5Yti4iI3r17b/Jrzp8/P2bMmBE9e/bcomx33HFHjBo1KqZPnx6tW7eu9/OUAgAAAFAP/fr1i4iIyZMnR1lZWVRVVcXEiRNzpcDmWLBgQUycOHGTS4GampooKSmJkpKS+Mc//hEvvvhi7LXXXpv89ZUCAAAAJKVz586fef/06dM3OPbWW2/F008/Hb///e+jrKwsIiJKS0vjwgsvjNtvvz33uP79+8dxxx2Xe5N/ySWXRK9eveL444+PUaNGxRNPPBGNGjWKnXbaKcaMGRPDhg2L+fPnR48ePeKoo46KwYMHx8yZM+PWW2+NqqqqKCsrixtuuCEOOOCAmDBhQjz22GNRUlIS8+bNi7Fjx0aLFi3ihhtuiKFDh8a3v/3tTf672GZKgdLS0ujTp0/WMaCOioqKrCMAAADbgNmzZ0fbtm1jxx133KznL1myJKZOnRpTpkyJRo0axdKlSyMiYtCgQTF69OgYM2ZM7nEjRoyIu+66K1q0aBF//etfY+DAgTF+/PiIiHj55Zdj8uTJ0apVq4iI+M1vfhNf+tKXYt99992sXNtMKTB8+PCsIwAAAJCAjY0EyLfmzZtHeXl5DBw4MDp27BinnHLKRh/30ksvxTvvvBOXXnpp7tj6AiEi4oQTTsgVAnPnzo3HHnss7r///s3Otc2UAgAAALCtat++fcydOzeWLVsWzZs3/9THNW7cOGpqanK3V61alTs+bty4mDlzZjz77LNRUVEREydO3OD5tbW1ceSRR8add9650dcvLy/P/fnll1+OBQsWRJcuXSIiYuHChXHRRRfFz372szjssMPqdV62JAQAAIDPsd9++8VJJ50UQ4YMiZUrV0bEujf848aNq/O4Nm3axKuvvhoREW+++WbMmTMnIiIqKytjyZIl0bFjx+jbt2+UlpbGwoULo1mzZlFZWZl7focOHWLWrFnx+uuvR8S6BQVnzZq10UzdunWLP/7xj/Hkk0/Gk08+Ga1atYqxY8fWuxCIMFIAAAAA6mXkyJFRUVER3bp1i7KysigpKYlzzjmnzmPOP//86NWrV5x55pnRrl27aNeuXUSsKwV69+4dVVVVUVtbG506dYqDDjooqqurY+edd45u3brFMcccE4MHD45Ro0bF0KFDY8WKFbFmzZo4/fTT4+CDD87LOZXU1tbW5uWVoUj87o+zs46QF0e1WJt1hLx49v3i/ZHWbp9dso6QF3vttnmL9WzrPvxoRdYR8mbhB5Wf/6ACtGTEtVlHyItdDm6XdYS8Wf3R5m8Bti37Qt+BWUfIm4X3/zrrCHmx8IU/Zx0hL2rWFufvixERX5swIesI2wzTBwAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgESV1NbW1mYdAgAAANj6jBQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgAAAAASpRQAAACARCkFAAAAIFFKAQAAAEiUUgCgHq644oqsI0BEFP+1WF1dHWeddVbWMfJm2bJl8frrr2cdo8FUV1fHwIEDs47RoF599dV45plnNjj+9NNPF9X3DrYFf/zjH+t1jPxqknUASNUll1wSJSUln3r/fffdtxXT5MeiRYtixIgRsXDhwrj//vvjjTfeiL/85S9x4YUXZh1tk73//vtZR8iruXPnxl133RXz58+PtWvX5o4Xw3UY4VosJI0bN44dd9wxKisro1mzZlnHaVDTpk2LESNGRHV1dTz55JMxa9as+OlPfxq//OUvs4622Ro3bhx///vfs47RoCoqKmLIkCEbHN9///3jhhtuiLvvvnvrh2ogxfq7x8033xxdu3aNww47LOsoefXMM8/E3/72t1i1alXuWK9evTJMtOV+/OMfx5e+9KU6x37yk59scIz8UgpARnr37p11hLwbOHBgnHXWWXHnnXdGRMQXvvCF6Nu3b0G+EVu7dm289957UVtbu9H799prr62cqGH16tUrunbtGqeffno0btw46zgNzrVYWHbfffc499xz49RTT43y8vLc8UL/5feOO+6Ihx56KC699NKIiDj44IPj3XffzTjVljvqqKPihz/8YXTv3r3O9+vYY4/NMNXmW7ZsWeyzzz4bHN9nn31i8eLFGSRqOOt/93jqqadi7ty50bNnz4iIePjhh2PvvffOMtoWeeihh+Lxxx+PsrKyOOuss6JHjx6xxx57ZB2rQd14442xYMGCeOWVV6Jbt27x+OOPx/HHH591rM02Z86cmD17dixdujQmTZqUO75s2bJYvXp1dsESpRSAjBx33HFZR8i7Dz74ILp27Rq/+tWvIiKiSZMm0ahRYc5aevvtt+Piiy/e6BuxkpKSmD59egapGk6TJk2Keli6a7Gw7LvvvrHvvvtmHaPBrR8F8cljhW79kPq77rord6ykpKRgP3VesmTJp963YsWKrRckD9b/7nHLLbfEb3/729zxU045Jc4///ysYm2xvffeOyZOnBjPP/98PPzww9G1a9c4/PDD46yzzorTTz89SktLs464xZ577rl45JFHonv37nHNNdfE5ZdfHn369Mk61mabP39+zJgxI5YvXx4vvPBC7vgOO+wQN910U4bJ0qQUgIwU6xC+j9tuu+1i9erVufNcsGBBNGlSmD92DjjggDpNdrE5/fTT49FHH40uXbrEdtttl3WcBudaLCyFPiLg0+y2224xZ86c3HU4duzYaNOmTcapttyYMWOyjtCg9ttvv5g6dWqcccYZdY4/8cQTRVNWffTRR7Fs2bJo3rx5REQsX748Pvroo4xTbb6SkpIoKSmJjh07RseOHWPlypXxxBNPxKRJk2Lo0KHx5z//OeuIW6y0tDRKSkqiSZMmsXz58mjZsmVBTyc77bTT4rTTTovnnnsuOnbsmHWc5BXmb0RQBFKYPnDZZZfFZZddFosXL45hw4bF9OnTY/DgwVnHYiPatm0b1157bVx99dUREVFbWxslJSUxe/bsjJM1DNdiYSmmNSA+7vrrr48BAwbEP/7xjzj66KPjkEMOiZEjR2Yda4vV1NTEb3/725g7d2707ds35s+fH++//34cffTRWUfbLFdffXV885vfjGnTpsXhhx8eERGvvPJK/OlPf4p7770343QN46KLLoqzzz47TjvttIiIePLJJ+Piiy/OONXm++TIqbKysujRo0f06NGjoN84f1ybNm1i6dKlccYZZ8TFF18czZs3j/333z/rWFvsn//8Zxx66KHRvHnzGDx4cLz66qtx9dVXKwq2spLaT5uUCGxVH374Yey8885Zx2hw77zzTvzhD3+IiIgTTzwx9ttvv4wTbZ7bbrstrrzyyqxj5M2pp54at912Wxx88MEFO6z+87gWC8dll12WWwNi8uTJsXbt2jj77LPjkUceyTpag1ixYkXU1tbGDjvskHWUBrG+YJsxY0Y89thjsXTp0vj2t78dDz30UMbJNt/7778fY8eOzRWj7du3jwsvvDBatWqVcbKGM2fOnJgxY0ZErJtW0K5du4wTbb5nnnkmvvKVr2QdY6v585//HMuWLYuTTjqp4Ef3devWLR555JGYMWNG3HnnndGrV68YOnRoTJgwIetoSTFSADL24osvRr9+/aK6ujq33dHYsWPjxhtvzDpag2jbtm20bds26xhbbGNvwvr16xe33HJLBmka3u677x6HHnpo1jHyqliuxcsvvzzGjh0be+yxR3Tu3DmmTJkSL774YhxwwAFxwQUXFMUc9WJaA+LjLrjgghg/fnydxfjWHytkL7/8ckyaNCm3lWSLFi1izZo12YbaQk2bNo2vfvWr8d3vfjc3xL7YtGvXrqCLgI9LpRCoqamJxYsX5xaFXLx4ccEvLrt+Kt9zzz0XPXr0iCOPPDJqamoyTpUepQBkbMSIEXHffffFf//3f0dExCGHHBIvvfRStqEayKmnnrrBugnNmzePww8/PK666qqCGhkxYMCADY5NmzYtd3z48OFbO1KDOvroo+P666+PLl26RNOmTXPHC3X18E8qpmtx4MCBsXbt2qiqqorf/e53sWjRoty8zNmzZ8fQoUOzjrjFimkNiI/75IralZWVBT2Pe72P/8yIiFi5cuWn7o5RCB555JEYNGhQNGvWLKqqquK2224ruu3R5s2bFz/+8Y/j73//e53t7YphodJPuuaaa2LEiBFZx9hiY8eOjVtvvTXKyspyJWlJSUk8/fTT2QbbQjvuuGP88pe/jMcffzzuv//+WLt2bVRXV2cdKzmF/y8sFLiampoNtgEq9KFg63Xv3j1WrFiR2/Jo0qRJUVJSEs2aNYuBAwfGz3/+84wT1t+zzz4bX/7yl+OEE07I/bL71FNPFc0uEq+88kpERPziF7/IHSvk1cM/qZiuxb/97W/xyCOPxJo1a+LLX/5yPPvss9G0adO44IILcp/UFrpiWwNi9OjRMXr06IhYNwx9vR122CG++c1vZhWrwZx88slxyy235BZ3u//++6Nbt25Zx9psd955ZzzwwANx0EEHxcyZM6OioqLoSoFrr702Lr744rjtttvi5z//eYwfPz5atmyZday8+PjK9oXs7rvvjkcffbSoprBERNx6663xyCOPxLBhw6Jly5axYMGC+M///M+sYyVHKQAZ23HHHWPhwoW5T8SeeeaZgvrU8rM8++yzdeaU9u/fP3r27BkTJkyIrl27Zphs002ZMiVuuummmDlzZlxzzTXRvHnzGD16dJx99tlZR2sQxbZ6+CcV07W4vpSqrq6u82lKo0aNimbI5WmnnRYHHnhgbg2IX//61wW7BkTEut0UevXqFcOGDYtBgwZlHafB9erVKyZOnBgLFiyIRx99NM4666yC/tnYuHHjOOiggyIi4phjjin4bQg3Zvny5dGlS5cYPXp0fPGLX4zrrrsuzj333ILd+ePjZdvHrV80txjstddesccee2Qdo8Htsssu8a1vfSt3e++9984V+Gw9SgHI2LXXXhu9e/eOt99+O7p16xZr1qyJO+64I+tYDaKysjIWLVoUu+++e0SsW1F8+fLlEVF4oyFatGgRI0aMiKeffjr+8z//M77zne9kHalBfdp2TcUyfaCYrsUvfelL8fWvfz1Wr14d5557bvTt2zc6duwYzz///Kf+YlyIimUNiI9r3rx5LFy4sOg+6YuIOPvsswu6CPi4lStXxsyZM3MF3IoVK+r8jCyGn4vr1x5p2bJlzJw5M/bcc8/48MMPM061+XbbbbeYNGnSRj9UKZb1Bvr27Rs/+MEP4stf/nKdKTuFPkIspaks2zKlAGTsgAMOiHHjxsVbb70VtbW1sd9++xXF3NmIiB/84AfRs2fPOOqoo6K2tjZeeuml6N+/fyxfvjw6d+6cdbzN0qlTpzjmmGPilltuiWbNmmUdp8HcdtttuT+vXr065syZE+3bt49x48ZlmKrhFNO1OGDAgPjjH/8YjRo1io4dO8arr74akyZNisMPPzy+8Y1vZB2vQTz11FNx8803x4IFC6K6urpotshs3LhxXHTRRfHFL34xLrjggujUqVNRfIo5b968+NWvfhXz58+PtWvX5o4X6vSjPfbYI0aNGpW7vfvuu8dtt90WJSUlsWLFivjtb3+bYbqG8Y1vfCOWLl0affr0ib59+0ZlZWVuS9pC1KlTp/jnP/+50VLgxBNPzCBRw7vvvvvinXfeidLS0joLyhZ6KZDSVJZtmS0JIWNTp06NE088MXbccceIiFi6dGm88MILcfrpp2ecrGF88MEHuYUTjzjiiNh1112zDUS9vPnmm3HnnXcWze4KEa7FQvLVr341Ro4cGYcffnhR7DrwcTU1NfHMM8/E+PHj429/+1ucc845cd555+VGsRSis88+O/7jP/4jDjvssDpvVoplzZWIdSujT5o0KaZPnx4zZ87MOg4J6tKlS0ydOrUoisSPWz+Vb/3WhBER5557blGUb4WkuP6lhQL085//PFcIRKwbpl4s0wci1s0V69y5c3Tu3Lng34Q99thjcc4550SHDh3iyCOPjPPOOy+mTp2aday8+MIXvlDwn8p+UrFdi+eee27RXostW7aMDh06FF0hELFu7YfDDjssOnToELW1tfHaa6/FRRddlNt+sRDV1NTE5ZdfHh07dozjjjsu91+he+utt6KioiJOOeWU+N73vhdHHHFEPP7441nHahA//vGPY+nSpbnbS5YsiZ/85CcZJmoYGxtyfs8992z9IHlwwAEHFMVuJZ/0yaksCxYsKOipLIWqOMYoQwHb2GCdYtmK5fXXX4/BgwfH3//+9zpbcRXim83f/e53MXz48Ojdu3ccdthhuV/mhw8fHk2aNInTTjst64hbZNKkSbk/19TUxKuvvlqnrCp0rsXC8O6770bEutXsf/azn8XXvva12H777XP3F/p+3H/84x9j/PjxMXv27OjZs2c8+OCDseuuu0ZVVVX8x3/8R1x22WVZR9wsHTt2jJkzZ8YxxxyTdZQGMXbs2Hj44Ydj8eLF0aNHj/j1r38d3/nOd+Kiiy7KOlqD+cMf/hB9+/bN3d5pp53iD3/4Q/zwhz/MMNWWu+OOO2KnnXaKo48+OiLWFQLTp0+vs5Bdoaquro4zzzwzjjvuuDprChT6lsjrp7JcddVVcfXVVxf8VJZCpRSAjO21117x29/+Ns4999yIiHjwwQdjzz33zDhVwxgyZEgMGTIkBg0aFPfff3+MGzeuYAuP++67L26//fY44ogjcsfat28fBx10UIwcObKg34hF1N2yqXHjxtGmTZu48sorM0zUsFyLheHiiy+OkpKSXFn68R0jSkpKCn7hqbvvvjsuuuii+OlPf1pnFERpaWn0798/w2Sb59RTT819v+65557YddddY/vtt8+tAVGo368f/ehHcfzxx8dvfvOb3GKXxTZk+5M//2pqauoUpoXqZz/7WVx++eUxcuTIeP7552PatGkFPQrn47p06RJdunTJOkaDW78mwlFHHVWwPzOKgTUFIGPvvfde9O3bN/72t79FROR+sS+GYmBj88TWHys0Xbp0+dRho591H9sG1yLbgsrKyigtLc0tJrt27dqoqqoq2EVLFyxY8Jn377333lspScOaO3duTJo0KR5++OHYbbfdonv37vGrX/0qnnrqqayjNZihQ4fGihUr4tJLL42IdWVjWVlZXH/99Rkn23JvvvlmfO9734tWrVrFL3/5yygrK8s6Ehvx8RGKG1PoCygWGiMFIGN77rln3H///bnt0XbYYYeMEzWc9Vu97bXXXvHwww/HnnvuGcuWLcs41eb5rO9LeXn5VkzSsMaPHx8XXHBBjB49eqP3F+qe1Z/kWiwsvXv3jttvv/1zjxWab3/72/Gb3/wmVwpUVVXFd7/73YLd5WP9m/4777wzrrjiijr3bexYodhnn33iyiuvjCuvvDJmzJgREydOjGXLlsX3v//9+NrXvhZnnnlm1hG32DXXXBN33HFHDBo0KEpKSuKkk06K733ve1nH2myXXHJJndEc1dXVsWLFitw1WKg7YXzcBx98EEOHDo3nn38+ItZN2xk0aFDssssuGSfbPB8fobgxSoGtSykAGVq+fHlst9120bRp03j77bfjhRdeiH333TdOPfXUrKM1iCuvvDKWLVsW/fr1ixtuuCEqKytj0KBBWcfaLIsWLfrUN86LFy/eymkaTiqDxVyLhWX+/PkbHHvrrbcySNKwVq1aVafUadasWaxcuTLDRA1j6tSpGxQAGztWiNYvmnj99dfH448/HhMmTCiKUqBp06Zx1VVXxVVXXZV1lAbRu3fvrCPk3aBBg+Koo46KoUOHRm1tbTzwwAMxaNCg+PnPf551tM1S6GshFBvTByAjY8eOjR//+MdRVlYW3/ve9+Kee+6Jww8/PGbNmhVnnHFG9OnTJ+uIfMynvQlbr1g+UWfbV8zX4r333hv33ntvLF68uM4WfStWrIhTTjklbrrppgzTbbmzzz47fvGLX8Qee+wRERELFy6MK664Ih5++OGMk22eadOmxfTp0+PJJ5+sU2ZXVlbGokWLYvz48Rmm47MsWrQoRowYEQsXLoz7778/3njjjfjLX/4SF154YdbRtkhlZWWUlZXlVrQv9Ck6H9ejR48NflZs7FihWbt2bYwfPz43cuCEE06I888/Pzeiiq3D3zZkZOzYsTFt2rRYvnx5dO3aNZ566qnYZZddYvny5XHeeecVRSmwZMmSeOCBB2LevHmxdu3a3PFCbIebNWsWZWVlccEFF9Q5Pn78+IJenKmY32B+nGuxMPTs2TM6d+4cN954Y52RHM2aNYsWLVpkmKxhfO9734uvf/3rcdppp0VtbW08+eSTBbnA4HqtW7eO4447Lp5//vk4/vjjc8ebNWtW5zbbnoEDB8ZZZ50Vd955Z0Ss24a2b9++BV8KrJ+is35ETqFP0fm4kpKSWLBgQW7azoIFC4piAcwhQ4bEv//97+jZs2dErFtrYNasWTFs2LCMk6VFKQAZadKkSey8886x8847R9u2bXNzwnbYYYc6W80Usv/+7/+OL3zhC3HEEUfkWvtC9eijj8bYsWM3OH722WfH+eefH5dcckkGqagv12JhaN68eTRv3jx+/vOfx9q1a3NTBtZ/sl7ounTpEgcccEBuTvBdd90V+++/f8apNl+7du2iXbt2cdJJJ8WwYcPiueeei5KSkujYsWMceeSRWcfjM3zwwQfRtWvX3Mr8TZo0qbMjRqEq1ik6EeumSJx//vlx5JFHRm1tbbz88ssxdOjQrGNtsRdffDEee+yx3O1TTjklunbtmmGiNCkFICMfb3c/OUSqGJrfiIiPPvoofvSjH2Udo0FUV1dvtKxp2rRp1NTUZJCoYRTLSIDP41osLK+88kpcddVV0aJFi6itrY2PPvoofvrTn8bhhx+edbQt1rZt29z3aZ999sk4TcO47rrrcnOdI9aNWinkuc4p2G677WL16tW53zcWLFhQFMO1GzVqFO+//36dKTrFoKamJvbee++YPHlyvPzyyxGxbuvMQl1k8ON22WWXWLZsWTRv3jwi1q23VQznVWgK//9+KFCzZ8+O9u3bR8S6xd4+/udiKQUOOeSQePvtt2PffffNOsoWW758eaxevXqDN2NVVVVF8SlEsc4vXc+1WFhuvPHGuPXWW6NDhw4REfHyyy/HjTfeWPBz1Iu17Hj33XfrFADf/e53c1t/sm267LLL4rLLLovFixfHsGHDYvr06TF48OCsY22xj0/RiYiYPn16QU/RWa9Ro0bRr1+/mDx5ctEsRr1++uKee+4ZZ511Vnz1q1+NiHXfMyONtj6lAGRkzpw5WUfIm/VbA61evTrOOuusaNeuXZ03MIW4NVDnzp2jf//+8aMf/Si3YFFlZWUMGTIk98tHISvW+aWuxcK0cuXKXCEQEXHEEUcUReFRrGVHsc51LmannXZaHHjggfGHP/whIiJ+/etfx3777Zdxqi3XpUuXOPDAA+O5556LiMKfovNxBx54YPztb3+LL37xi1lHaVBt27aNtm3b5m736NEjwzTpUgoADa4Ytwbq06dP9OvXL0466aTcp83vvPNOnHTSSUWxKGSxzi91LRamFi1axOOPPx5dunSJiIgnnniiKBYaLNayo1jnOhe7T74Z+7hvfvObce+9927lRA1j//33/9QioJDPa968edGzZ89o165dlJeX544XYrkdkc70xUKhFAAa3HHHHVfn9vLlyyMi6iz+U2iaNm0aP/3pT+Ptt9+O2bNnR0RE+/bti2I4ekTxzi91LRamG264Ifr27RvXX399RES0adMmRo4cmXGqLVesZUfnzp2jQ4cORTfXOWVLly7NOkJeFPJ59e3bN+sIebFixYq44447cqM7OnbsGN///vfrFB/kX0ltbW1t1iGA4vTmm29Gv379Yv78+RGx7hf7ESNGxBe+8IWMk/FJ06ZNizFjxsSbb74ZZ5xxRm5+aadOnbKO1iBci4WpsrIyImKDPcZffPHFOProo7OItEX++c9/Rt++fWPBggURse46vOWWW4pmeDPF4+yzz46JEydmHaPBFfJ5TZw4Mc4+++zPPVZorrnmmigrK4uvf/3rERHx4IMPxrJly+KWW27JOFlalAJA3px33nlx2WWXxemnnx4R69543nnnnfHggw9mnIyNeeedd3LzS0888cSimF+6nmuxuBTyL/YRn152wLai0P8f+zSFfF4by96zZ8+YMGFCRokaRvfu3WPy5Mmfe4z8KvyxocA2q6qqKvcmLGLdwkajRo3KMBGf5bPmlxY612JxKeTPM1566aWYN29eVFdX546dddZZ2QWCjSjk/8c+SyGe14wZM2LGjBmxePHi3Ir9EevKxWLYhra2tjaWLl2am0q1dOnSgvw+FTqlAJA3Rx99dEybNq3O1kDHHntsxqnYmKeeeipuvvnmWLBgQVRXV+e2xlw/Z73QuRaLS6GubD9w4MB45ZVXon379tG4cePccaUAW1N1dXU88MADn7m7zPrt4QpJsZ7Xp2nVqlXcfvvtWcfYYpdcckn07Nmzzr/PV1xxRcap0mP6AJA3p556arz77rt12t+99torItb9Uj99+vQs4/ExX/3qV2PkyJFx+OGHF8WuA5/kWiwuhToEuEuXLjFlypSiWMSTwlYMw843pljPKyLiBz/4QQwbNix22GGHuOyyy+K1116L66+/Prp27Zp1tC2ydOnSeO+99+LPf/5zRKxbIPiggw7KOFV6/KsE5M2YMWOyjkA9tWzZss5WacXGtVhcCvXzjNatW8fatWuVAmSuc+fOMW7cuOjRo0eUlZVlHafBFOt5RUS89dZb0bx583jmmWdip512ikceeSQuu+yygi4Famtr46KLLoopU6ZEu3btso6TNP8qAXmz9957x9q1a+Ott96KiIj99tvPL8PbmHfffTciIk4++eT42c9+Fl/72tdi++23z92//tP0QudaLDzLli2LuXPnxiGHHLLBfTfffHMGibbcbrvtFueff3506tQpmjZtmjtuv262tvXDzocMGRIlJSVFM2WsWM8rInKj+GbMmBFdunSJ3XffvWCnUq1XUlISrVu3jkWLFsXuu++edZyk+Y0IyJtXXnklrrrqqmjRokXU1tbGRx99FD/96U/j8MMPzzoa/38XX3xx7heniIiHHnood18xDat3LRaWadOmxYgRI6K6ujqefPLJmDVrVvz0pz+NX/7ylxERBfuJUuvWraN169ZZx4CYM2dO1hHyoljPK2Ldz4/BgwfH888/H//1X/8VVVVVBTtq6uNqa2ujW7duccIJJ0R5eXnu+PDhwzNMlR5rCgB5c8EFF8SAAQNyw9JffvnluOmmm2L8+PHZBiM5rsXC0rNnz7jnnnvi0ksvjUmTJkVExJlnnhmPPvpotsGgiHz44YfxyiuvRETEEUccES1btsw4UcMo1vOqqqqKZ599Ntq1axdt2rSJ999/P9544404+eSTs462RT5tfZizzz57KydJm5ECQN6sXLmyzjz1I444IlauXJldID5V7969N1jFeGPHCpVrsbA0btw4dtxxxw2OFboVK1bEHXfcEc8991xERHTs2DG+//3v1/l0DLaGZ555JgYOHBgdOnSI2trauO666+LGG28s+DeYxXpeERGlpaV1dk/YY489Yo899sgwUcPw5n/boBQA8qZFixbx+OOPR5cuXSIi4oknnsit/s62Zf78+RscWz//vhi4FgvLbrvtFnPmzMnNlx07dmy0adMm41Rb7oYbboiysrK48cYbIyLiwQcfjCFDhsQtt9yScTJSM2rUqPjf//3f3P9X8+bNix/84AcF/+a5WM+rmC1atCiGDRsWL7zwQkREnHDCCTFw4EBrDGxlSgEgb2644Ybo27dvXH/99RER0aZNmxg5cmTGqfi4e++9N+69995YvHhxdO7cOXd8xYoVccopp2SYrGG5FgvL9ddfHwMGDIh//OMfcfTRR8chhxxSFN+v2bNnx+TJk3O3r7vuuujevXuGiUjV2rVr6xRtbdq0ibVr12aYqGEU63kVs6uvvjo6deoUN910U0RE/Pa3v42rr7467r333oyTpUUpAORFdXV1vPDCCzFhwoSorKyMiIhmzZplnIpP6tmzZ3Tu3DluvPHGGDRoUO54s2bNiuaTdNdi4WnVqlX85je/iRUrVkRtbW3ssMMOWUdqELW1tbF06dLc/1tLly4tioXCKDx77bVX3H333XHBBRdERMQDDzwQe+65Z8aptlyxnlcx++CDD+I///M/c7e/9a1vxW9/+9sME6XJQoNA3vTs2TMmTJiQdQzqqZi37HMtFp6XXnop5s2bF9XV1bljZ511VnaBGsADDzwQd955Z5x22mkRETF9+vS44oor4rzzzss4Gakp1iHbxXpexeyqq66Kyy67LLf97KxZs+Kuu+6KW2+9NeNkaVEKAHnzs5/9LHbZZZfo0aNHlJWVZR2Hz1DsW/a5FgvLwIED45VXXon27dvXWWCwGLaomjNnTvz5z3+OiIjjjjsuDjrooIwTAWx9l1xySZSUlMSqVavitddey/0sfOONN+Kwww6LcePGZZwwLUoBIG8+vpd4SUlJ1NbWRklJScyePTvDVGxMsW/Z51osLF26dIkpU6YU1WgV2JasWbMmnnjiiZg3b16dOfe9evXKMNWWK9bzKkYzZsz4zPuPO+64rZSECGsKAHk0Z86crCNQT8W+ZZ9rsbC0bt061q5dW3SlwJNPPhkjRoyIBQsWRHV1tXKKzPz3f/93VFdXxyGHHBKNGjXKOk6DKdbzKkbe9G9biutfW2Cb8uKLL8ZBBx2UW9StsrIy/va3v8VRRx2VcTI+qdi37HMtFpbddtstzj///OjUqVM0bdo0d7zQP+278cYb48c//nEccsghdaZFwNa2YMGCmDJlStYxGlyxnlcxuu6662Lo0KG5aQSfdN9992WQKl1KASBvhg4dWmdxt/Ly8hg2bJgF37ZBG9uyr5j2TnctFpbWrVtH69ats47R4Hbfffc48sgjs44Bccghh8S8efPqbN9XDIr1vIrR17/+9YiI6N27d8ZJiFAKAHlUW1tbZ/heo0aN7Be8jdp///2Less+12JhKfQRAZ/miiuuiJtuuim+8pWv1BkBceyxx2aYihR961vfivPOOy/23XffOtdioX86W6znVYyGDRsW//u//xu/+93vYuDAgVnHSZ5SAMibFi1axHPPPRcdO3aMiIg//elPRTUkvRisXwX90xTLmxXXYmEZPXr0Ro8XelkwY8aMmDJlSrz++uu5kqqkpMQbFra6q6++Oi6//PINdvgodMV6XsVoyZIl8c9//jOee+65eO+99+KTa9/vtddeGSVLk1IAyJuBAwdG7969o6ysLGpra2PVqlVx++23Zx2Lj7ntttsiYt2Kza+88kqdLYEOP/zwotkSyLVYuFatWhVPP/10bg/rQvb444/H9OnTo7S0NOsoJG777bePb3/721nHaHDFel7F6OKLL45evXrF3Llz4xvf+Ead+0pKSmL69OkZJUuTLQmBvFq7dm289dZbERGx3377Fd1q4sXiqquuiu985ztx2GGHRUTEa6+9Fr/+9a/j1ltvzThZw3EtFq7ly5dHr1694je/+U3WUbbId77znfj5z39eZ1gzZOGXv/xl7LXXXtGlS5fYbrvtso7TYIr1vIrZNddcEyNGjMg6RvKUAkDeffDBB7Fq1arcbUPCtj1nnnlmPProo3WOdevWLR555JGMEuWHa7EwVVdXR9euXWPq1KlZR9ki11xzTbzxxhvxla98pc4blkKfFkHhadeuXUREbtX3Ytkes1jPq9h9+OGH8corr0TEui2RW7ZsmXGi9PiYBMibZ599NgYPHhyLFy+O8vLy+Oijj2LPPfeMJ598MutofELLli3j3nvvjXPOOSciIh566KHYaaedsg3VgFyLhWXAgAG5P9fW1sbs2bPj6KOPzjBRw2jTpo1V0dkmzJkzJ+sIeVGs51XMnnnmmRg4cGB06NAhamtr47rrrosbb7wxTj755KyjJcVIASBvzjrrrPjFL34R3/ve92LSpEkxderU+Mtf/hLXXntt1tH4hIULF8aNN94YL7zwQpSUlMTxxx8f1157bbRq1SrraA3CtVhYJk6cmPtz48aNo02bNkls5XfvvffGN7/5zaxjAGw1PXv2jFGjRuUK03nz5sUPfvADWwZvZUYKAHnTqFGjaNWqVW7rtzPOOCPuvPPOjFOxMa1atSrqhfdci4Xl7LPPzjpCJiZNmqQUYKto165dlJSU5IbXr1fow+yL9byK2dq1a+uMoGrTpo0tgzOgFADyZvvtt4/q6uo44IAD4o477og999yzznxuth1r1qyJJ554IubNm1fnH+NimevsWiwsL7/8ctx2220xf/78Otdjsa9GbfAmW8vHh9mvWrUq/u///i8WLVqUYaKGUaznVcz22muvuPvuu+OCCy6IiIgHHngg9txzz4xTpcf0ASBv5syZE/vss09UVlZGRUVFVFZWxuWXX55b4Z5tx3/913/FmjVr4rDDDquzt3OxlAKuxcLSpUuX6N27dxxyyCF1rsd99tknw1T5d/bZZ9eZOgFbU8+ePYtyyHaxnlexWLRoUQwbNixeeOGFiIg44YQTYuDAgbH77rtnnCwtRgoAebN+FeDy8vIYPnx4xmn4LO+880783//9X9Yx8sa1WFh23HHHOPPMM7OOAUXr3Xffzf25pqYmXnnllaiqqsowUcMo1vMqZrvvvnvcdtttWcdInlIAyJu5c+fGXXfdtcEQ4Pvuuy/DVGzM/vvvHx9++GHsvPPOWUfJC9diYTn//PPjV7/6VXz1q1+Npk2b5o4X+xaSjRo1yjoCibj44otzc++bNGkSbdq0iZtvvjnrWFusWM+rmHXu3DnOP//8OPfcc2OXXXbJOk6ylAJA3vTq1Su6du0ap59+ep0hwGx71q5dG927d4/jjz++zpuwYvlU3bVYWFauXBl33HFHjB07NrdYWElJSVGtKXD//ffHN77xjTrHHnrooYzSkJpdd901HnjggTrHLrjgghg/fnxGiRpGsZ5XMbv33nvjwQcfjHPOOScOP/zwuOCCC+JLX/pS1rGSoxQA8qZJkyZxxRVXZB2DeujSpUt06dIl9wlLRNRZubnQuRYLyz333BNPPPFE7LbbbllHaRCTJk3a4Njo0aNjhx12iIh1W2bC1rRmzZo6t5cvXx4fffRRRmkaTrGeVzFr3bp19OnTJ3r37h3Tpk2La6+9Npo2bRpf//rX46KLLoqysrKsIyZBKQDkzemnnx6PPvpodOnSJbbbbrus4/AZDj/88Bg4cGAsWrQonnzyyZg9e3Y88cQTWcdqMK7FwrL33nvHrrvumnWMBnPttdfGySefHC1btswdq6qqyi2spRRgaxk9enSMHj06IiLat28fEet2vWjWrFlBb4dZrOeViiVLlsTEiRPjwQcfjPbt28c555wTM2fOjG9/+9vxv//7v1nHS4LdB4C8eeyxx+Laa6/NLfKzft9g+wVvey655JL44Q9/GEOGDIlJkyZFbW1tnHnmmTFlypSsozUI12Jh+dGPfhTz5s3bYE2BQn3zPHPmzPjxj38cF110UXTv3j0iIk499dR48sknM05GqoYNGxaDBg3KOkaDK9bzKmY//OEP4y9/+Ut07949Lrjggjprx3zta18r6kWQtyVGCgB5M3LkyBgzZkwcfPDBFtDaxq1YsSI6dOiQu11SUhJNmhTPPxGuxcKycuXK2HXXXeOvf/1rneOFWgocc8wxce+998aoUaNiypQpcf311xfV9BwKT7G+cS7W8ypmnTp1iptvvnmjo/gefvjhDBKlqXh+4wO2ObvvvnsceuihWcegHkpLS2PZsmW5NyqzZs2K8vLyjFM1HNdiYSmWBS4/bvvtt49+/frFK6+8En369IkVK1ZkHQkgM+u3jzz66KNj8eLFG9y/1157me63FZk+AOTNyJEjY9myZdGlS5c6Q4CPPfbYDFOxMTNnzoxbbrkl3nnnnTjyyCNj9uzZMWrUqDqjBwqZa7GwrFmzJp544omYN29enS0ke/XqlWGqhrN27dpYvHhx7LnnnllHAchEu3btolWrVtG4ceP45NvRYtttphAoBYC8ueSSSzY4VlJSYm/4bdTSpUvjpZdeitra2ujQoUPstNNOWUdqMK7FwnL55ZdHdXV1HHLIIXWme1x11VXZhcqTp556Kk455ZSsYwBsVYMGDYo///nPccopp8RZZ50V7dq1yzpS0pQCQGZefPHFOProo7OOAa7FbUzXrl2LZpHLz9OpU6d4+umns44BsNWtWrUqpk2bFpMmTYoPPvggunfvHj169KizUwtbhzUFgMwMGzYsJk6cmHUMcC1uYw455JCYN29etGnTJusoDWLAgAGfet/SpUu3YhKAbcf2228fXbt2ja5du8b06dNj4MCBsXbt2vjud7+bdbTkKAWAzBioxLbCtbht+da3vhXnnXde7LvvvnXWgCjU6R5Tp06N/v371zmXiHXXnW0JgVS9//77MWnSpJgyZUq0bt06brjhBtOpMqIUADJjSy62Fa7FbcvVV18dl19+ebRv3z4aN26cdZwtdvDBB0e7du3iiCOO2OC+UaNGZZAIIFvf+ta3orKyMnr06BH33nuvKQMZUwoAANuU7bffPr797W9nHaPB3HTTTdG8efON3vfII49s5TQA2Xv++ecjIuK1116Lm266KXe8trY2SkpKYvbs2VlFS5JSAMiMIdtsK1yL25YzzjgjHn300ejSpUtR7FPdtm3bT71vxx133IpJALYNc+bMyToCH2P3ASAzc+bMsQUN2wTX4rZl/fdi/bSOYvjk6LHHHou77ror3nzzzSgpKYkDDjggvvOd78QZZ5yRdTQAEqcUABrc0qVL4/bbb4/33nsvTj755Ljgggty91199dUxcuTIDNPBOpdeemnBLlxHYfnd734XQ4cOjd69e8dhhx0WtbW18dprr8Xo0aPjuuuui9NOOy3riAAkzPQBoMFdd911sc8++0SPHj1i/Pjx8eyzz0ZFRUVst9128Y9//CPreCTk3Xff3ejx2traeOutt7ZyGlJ13333xe23315nocH27dvHQQcdFCNHjlQKAJAppQDQ4N5555247bbbIiLi9NNPjxEjRsR3vvOd+MUvfmHuNlvVqaeeGnvvvfdGr7t///vfGSTis5x99tkxceLEaNeuXZSUlOSmDRT69IFFixZtdOeBww8/PBYtWpRBIgD4f5QCQINbtWpVndvXXHNN/PKXv4xLL700VqxYkVEqUtS6dev4n//5n2jVqtUG933lK1/JIBGfZeLEiRFRfAtQ7bDDDp96X3l5+VZMAgAbUgoADe7AAw+Mp59+Ojp16pQ7dvnll8cOO+wQw4YNyy4YyTnrrLNi0aJFGy0FevbsmUEiUrRo0aIYPXr0Ru9bvHjxVk4DAHVZaBBocOt/rKxfOfzjli9f/pmfmgEUm08rBNbr1avXVkoCABsyUgBocO+9995n3q8UYGv5tIUG19trr722UhJS1qxZsygrK6uzE0tExPjx42P16tUZpQKAdYwUABpcu3btolWrVtG4ceMNFngrKSmJ6dOnZ5SM1LgW2Race+65MXbs2GjatGmd46tXr47zzz8/Jk2alE0wAAgjBYA8OPfcc+PPf/5znHrqqdGjR49o165d1pFIlGuRbUF1dfUGhUBERNOmTaOmpiaDRADw/xgpAOTFqlWrYtq0aTFp0qT44IMPonv37tGjR49o2bJl1tFIjGuRrJ1++unx6KOPblAMVFVVRbdu3eJ3v/tdRskAQCkAbAXTp0+PgQMHxne/+9347ne/m3UcEuZaJAsjRoyI999/P370ox9Fs2bNIiKisrIyhgwZErvttltcc801GScEIGVKASAv3n///Zg0aVJMmTIlWrduHT169IhTTjllo0NoIZ9ci2Rt9erV0a9fv3jmmWdi3333jYiId955J0466aQYOXKkaxGATCkFgAb3rW99KyorK6NHjx5x5plnGqZNZlyLbEvefvvtmD17dkREtG/fPlcQAECWlAJAg/v4Ym4lJSW5P9fW1kZJSUnul2LIN9ciAMBnUwoAAABAohplHQAAAADIhlIAAAAAEqUUAAAAgEQpBQAAACBRSgEAAABIlFIAAAAAEqUUAAAAgET9f4tWD7VrJBFwAAAAAElFTkSuQmCC",
                         "text/plain": [
                             "<Figure size 1000x1000 with 4 Axes>"
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 }
@@ -487,91 +521,95 @@
                 "mean_dat = merged_dat.groupby(settings.KMEANS_CLUSTER, as_index=False).mean(numeric_only=True)\n",
                 "\n",
                 "# Draw heatmap\n",
                 "mean_dat_values = mean_dat.drop(settings.KMEANS_CLUSTER, axis=1)\n",
                 "visualize.draw_heatmap(data=mean_dat_values.apply(zscore).values,\n",
                 "                       x_labels=[\"Cluster\"+str(x) for x in mean_dat[settings.KMEANS_CLUSTER].values],\n",
                 "                       y_labels=mean_dat.drop(settings.KMEANS_CLUSTER, axis=1).columns.values,\n",
-                "                       center_val=0)"
+                "                       center_val=0, save_dir=kmeans_out_dir, save_file='neighbor_type_heatmap')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.2 Cluster composition by cell phenotype\n",
                 "Now we want to examine the number of each cell type assigned to each kmeans neighborhood cluster (z-scored for each cell type)."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 16,
+            "execution_count": null,
             "metadata": {
                 "tags": []
             },
             "outputs": [
                 {
                     "data": {
-                        "image/png": "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AAAAAFvahu8+YE0BAAAAqCobPlLAmgIAAABQVTZiTQHTBwAAAKCa2H0AAAAASsruAwAAAFBSG7H7gFIAAAAAqol3+gAAAFBSdh+ACnnuuecyZMiQLF68OF26dMmXv/zl7Lrrrs3OWbJkSS677LL86U9/Srt27bLTTjsVlBYAACijDX+nX+OXXyX8tRmGDRuWz33uc3nwwQfTq1evfOUrX1nnnG9/+9vZfffd89BDD2XUqFF56qmnsnr16s37xgAAABtoI0qBGr/8Kt+vTfTXv/41L7zwQk466aQkyZlnnpmf/vSn65z3wAMP5Oyzz06SHHjggWnXrl2eeeaZTf6+AAAAG2PDpw9ACfXq1ett7582bdp6j8+bNy+77bZb0+327dtnu+22y9///vd07ty56fgrr7ySPfbYo+l2bW1tXnnllRxyyCGbmRwAAOCdbUQpsOmfmgIAAABbnw0uBRormQK2Um81EuCddO3aNa+88krT7SVLlmTZsmXNRgkkyW677Za5c+fmPe95T5KkoaGh2QgDAACASrKlAFTAzjvvnG7dumXq1KlJkh/96EdN6wu8We/evTNhwoQkybPPPpvly5fnoIMO2qJZAQCA8trwkQKGCsBGGT58eC677LLceOONTVsSJkm/fv3yzW9+M126dMmnPvWpDBkyJCeffHK23XbbHHLIIWnTRlcHAABsGRtcCqzWCsBG2W+//TJx4sR1jk+ZMqXp9x06dMitt97adHvQoEFbJBsAAEBi+gAAAACU1gaPFFi12kgBAAAAqCYbsaaAUgAAAACqiYUGAQAAoKQsNAgAAAAlZfoAAAAAlNSGLzS4anUlcwAAAABbmOkDAAAAUFIbXgrYkhAAAACqit0HAAAAoKQ2uBRYaU0BAAAAqCptig4AAAAAFGPDdx9YbaQAAAAAVBO7DwAAAEBJbfhCg3YfAAAAgKpipAAAAACU1IavKbBKKQAtafr06Rk+fHiWL1+e9773vRk1atR6zzv//PMzb9681NfXJ0kuu+yyfOADH9iSUQEAgCplpAAUYPXq1bniiivy1a9+NQceeGC+9KUv5dvf/vZbnj9y5MgcffTRWzAhAABQBhu+poBSgBLq1avX294/bdq0TXrcZ555Jp07d86BBx6YJDn77LMzcODA7L///pv0eAAAAJvCSAEowCuvvJLdd9+96fbuu++eV155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eAfPP/98Hn300Vx77bWpq6tLktTW1uacc85pdt7ll1+eiRMnNt0+//zz85vf/CZJMnbs2Jxyyinp06dPzj///CTJyJEj88wzz6Rfv3655pprkiTTp0/Pueeem/79++djH/tY/vKXvyRJJk6cmAsvvDAXXXRRTjnllCxYsCCHHnpodt99901+XqYPAAAAUCq9evV62/unTZu2zrGZM2emW7du2X777Tfpey5YsCAPPPBA7rvvvrRp0yYLFy5Mklx55ZUZN25c7rzzzqbzRo0aldtvvz2dOnXKH/7whwwdOjQTJkxIkjz55JO555570rVr103K8c+UAq3QFVdckYaGhqJjlMKYMWOKjgAAAFSBjh07pr6+PkOHDk3Pnj1zwgknrPe8J554Ii+++GIuuOCCpmNrC4QkOeaYY1qsEEiUAq1SQ0ODN6sAAACbaH0jAd5Jjx498tJLL2XRokXp2LHjW57Xtm3brF69uun2smXLmo7fddddmT59eh577LGMGTNmvWsJNDY25rDDDsttt9223sevr6/f6Oxvx5oCAAAA8A723nvvHHvssRk+fHjeeOONJGve8N91113Nzttrr73y9NNPJ0mee+65zJo1K0myePHiLFiwID179szgwYNTW1ubefPmpUOHDlm8eHHT1x966KGZMWNGnn322SRrFhScMWNGxZ6XkQIAAACwAUaPHp0xY8akT58+qaurS01NTc4444xm55x11lkZMGBATj311HTv3j3du3dPsqYUGDhwYBoaGtLY2Jjjjz8++++/f1atWpUdd9wxffr0yZFHHplhw4Zl7NixGTFiRJYuXZoVK1bk5JNPzgEHHLDeTF/96lczceLE/PWvf81HP/rR7L333k3rE2yImsbGxsZN/yNpbtCgQYa1bwH+nLesCQ88UXSEimh73cVFR6iI1y++segIFfPawhVFR6iI7nt2KDpCRXRq367oCBWzU6e6oiNUxJI3qvPf2KG7tC06QsX8fv7KoiNURLeunYqOUDFddqzO1/yG5dX5d7Ftm+odWL79Dm89/L9sqvcqAwAAAG9LKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCktik6AGztjnzjL0VHqIiFX/9e0REqou8+uxYdoWJqVq8qOkJFzFvQUHSEitiuXduiI1TMgkXVec267Nih6AgVMeu1fxQdoWL23XPHoiNUxMLF1flvLEn+9NJfi45QEdtuU72v+dXqgB06Fh1hq2GkAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpLYpOgAAAAC0BsuXL8+YMWMyderU1NfXp23btunbt28WLVqUJBk4cOBGP+acOXPy+OOPp3///hv9tatXr87nP//5/PnPf067du3SrVu3jBgxIp07d97gxzBSAAAAADbAkCFD8sorr+See+7JlClTMn78+Gy33Xab9Zhz587NpEmTNvrrVq9encbGxvTv3z8PPPBA7r333nTr1i3jxo3bqMcxUgAAAIBS6dWr19veP23atHWOPf/883n00Ufz85//PHV1dUmS2tranHPOObnllluazrv88stz1FFHNX3yf/7552fAgAE5+uijM3bs2Dz00ENp06ZNdthhh9x5550ZOXJk5syZk379+uXwww/PsGHDMn369Nx0001paGhIXV1drrnmmuy7776ZOHFi7r///tTU1GT27NkZP358TjzxxKbvfcghh2Ty5Mkb9WehFGCrcMUVV6ShoaHoGOsYM2ZM0REAAICtwMyZM9OtW7dsv/32m/T1CxYsyAMPPJD77rsvbdq0ycKFC5MkV155ZcaNG5c777yz6bxRo0bl9ttvT6dOnfKHP/whQ4cOzYQJE5IkTz75ZO6555507dq12eM3NjZmwoQJ+dCHPrRRuZQCbBUaGhq8AQcAALaI9Y0EqLSOHTumvr4+Q4cOTc+ePXPCCSes97wnnngiL774Yi644IKmY2sLhCQ55phj1ikEkuTGG29MbW1tPvrRj25ULqUAAAAAvIMePXrkpZdeyqJFi9KxY8e3PK9t27ZZvXp10+1ly5Y1Hb/rrrsyffr0PPbYYxkzZsx61xJobGzMYYcdlttuu229j19fX7/OsW9+85t55plncvvtt6empmajnpeFBgEAAOAd7L333jn22GMzfPjwvPHGG0nWvOG/6667mp2311575emnn06SPPfcc5k1a1aSZPHixVmwYEF69uyZwYMHp7a2NvPmzUuHDh2yePHipq8/9NBDM2PGjDz77LNJ1iwoOGPGjLfM9YMf/CAPPvhgvv71r2/SoodGCgAAAMAGGD16dMaMGZM+ffqkrq4uNTU1OeOMM5qdc9ZZZ2XAgAE59dRT071793Tv3j3JmlJg4MCBaWhoSGNjY44//vjsv//+WbVqVXbcccf06dMnRx55ZIYNG5axY8dmxIgRWbp0aVasWJGTTz45BxxwwDp5Fi9enBEjRmTPPffMxz72sSTJvvvum6985Ssb/JyUAgAAALABtttuu1x++eW5/PLL3/KcHXfcMePHj1/vfXffffc6x7bZZpt8+9vfbnbs8MMPX2cEQpL079+/aVeDJOnQoUPTSIRNZfoAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBS27Tkg9XW1mbQoEEt+ZCsx/z584uOAAAAQBVo0VLg+uuvb8mH4y0oXgAAAGgJpg8AAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBS2xQdgK3PFVdckYaGhi36PefPn79Fv9/GeO7Hk4qOUBE7Djmi6AgVcc8v/lx0hIqpbde26AgVsWp1Y9ERKqJNTU3RESqm6471RUeoiFdeX1x0hIqobVe9P+6tWLmq6AgVsWr16qIjVExjdb7kZ/mK6vy72LB8ZdER2AKq938JNllDQ0PGjBmzRb/noEGDtuj3AwAAwPQBAAAAKC2lAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJLapugAAAAA0BosX748Y8aMydSpU1NfX5+2bdumb9++WbRoUZJk4MCBG/2Yc+bMyeOPP57+/ftvUqb//M//zJw5c5Iku+yyS0aOHJnddtttg79eKQAAAAAbYMiQIUmSe+65J3V1dWloaMikSZOaSoFNMXfu3EyaNGmjS4HVq1enpqYmo0aNSseOHZMk3//+93PTTTdl9OjRG/w4SgEAAABKpVevXm97/7Rp09Y59vzzz+fRRx/Nz3/+89TV1SVJamtrc8455+SWW25pOu/yyy/PUUcd1fQm//zzz8+AAQNy9NFHZ+zYsXnooYfSpk2b7LDDDrnzzjszcuTIzJkzJ/369cvhhx+eYcOGZfr06bnpppvS0NCQurq6XHPNNdl3330zceLE3H///ampqcns2bMzfvz4dO7cuel7L1myJDU1NRv1Z6EUYKtQW1ubQYMGFR1jHWPGjCk6AgAAsBWYOXNmunXrlu23336Tvn7BggV54IEHct9996VNmzZZuHBhkuTKK6/MuHHjcueddzadN2rUqNx+++3p1KlT/vCHP2To0KGZMGFCkuTJJ5/MPffck65duzY99pAhQ/LLX/4yO+ywQ7773e9uVC6lAFuF66+/vugIAABASaxvJECldezYMfX19Rk6dGh69uyZE044Yb3nPfHEE3nxxRdzwQUXNB1bWyAkyTHHHNOsEEiSG2+8MUnyve99L1/72tcyfPjwDc5l9wEAAAB4Bz169MhLL730jusHtG3bNqtXr266vWzZsqbjd911V/r27ZtZs2alb9++WbBgwTpf39jYmMMOOyxTpkxp+vXoo4823V9fX/+W3/sjH/lIpkyZslHPSykAAAAA72DvvffOsccem+HDh+eNN95IsuYN/1133dXsvL322itPP/10kuS5557LrFmzkiSLFy/OggUL0rNnzwwePDi1tbWZN29eOnTokMWLFzd9/aGHHpoZM2bk2WefTbJmQcEZM2asN9PSpUvz8ssvN91+4IEHst9++23U8zJ9AAAAADbA6NGjM2bMmPTp0yd1dXWpqanJGWec0eycs846KwMGDMipp56a7t27p3v37knWlAIDBw5MQ0NDGhsbc/zxx2f//ffPqlWrsuOOO6ZPnz458sgjM2zYsIwdOzYjRozI0qVLs2LFipx88sk54IAD1snT0NCQiy++OG+88UZqamrStWvXjdp5IElqGhsbGzf9j4QiDBo0qKIL4FX68Vubh877WNERKmLHISOLjlARL8z7R9ERKqa2XduiI1TEqtXV+d9Qm41c+bc16brjWw9bbM2WLltZdISKqG1XvZ8BddmxfdERKmLR0mVFR6iYVauq8zW/WjUsr87XxSQ55rD3FB1hq2H6AAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJbVN0ADZebW1tBg0aVLHHnz9/fsUeuzVq859XFR2BjVB367CiI1TMobfeXnSEiti1fXX+VzR7QUPRESqmYdnKoiNURH3ttkVHqIjFb6woOgIbadWqxqIjQJKkfV11vi7SXHX+JFblrr/++oo+fiULBwAAALYepg8AAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlNQ2RQcAAACA1mD58uUZM2ZMpk6dmvr6+rRt2zZ9+/bNokWLkiQDBw7c6MecM2dOHn/88fTv33+TMp1//vmZN29e6uvrkySXXXZZPvCBD2zw1ysFAAAAYAMMGTIkSXLPPfekrq4uDQ0NmTRpUlMpsCnmzp2bSZMmbXQpsHr16tTU1CRJRo4cmaOPPnqTvr9SAAAAgFLp1avX294/bdq0dY49//zzefTRR/Pzn/88dXV1SZLa2tqcc845ueWWW5rOu/zyy3PUUUc1vck///zzM2DAgBx99NEZO3ZsHnroobRp0yY77LBD7rzzzowcOTJz5sxJv379cvjhh2fYsGGZPn16brrppjQ0NKSuri7XXHNN9t1330ycODH3339/ampqMnv27IwfP36z/yyUAmySK664Ig0NDUXHqLgxY8YUHQEAANgKzJw5M926dcv222+/SV+/YMGCPPDAA7nvvvvSpk2bLFy4MEly5ZVXZty4cbnzzjubzhs1alRuv/32dOrUKX/4wx8ydOjQTJgwIUny5JNP5p577knXrl2bHvvaa69NmzZtcsQRR2Tw4MHp0KHDBudSCrBJGhoavGEGAABapfWNBKi0jh07pr6+PkOHDk3Pnj1zwgknrPe8J554Ii+++GIuuOCCpmNrC4QkOeaYY5oVAqNHj07Xrl2zfPnyXH/99bnhhhsycuTIDc6lFAAAAIB30KNHj7z00ktZtGhROnbs+JbntW3bNqtXr266vWzZsqbjd911V6ZPn57HHnssY8aMyaRJk9b5+sbGxhx22GG57bbb1vv4axcUXGttQdCuXbucc845ueSSSzbqedmSEAAAAN7B3nvvnWOPPTbDhw/PG2+8kWTNG/677rqr2Xl77bVXnn766STJc889l1mzZiVJFi9enAULFqRnz54ZPHhwamtrM2/evHTo0CGLFy9u+vpDDz00M2bMyLPPPptkzYKCM2bMWG+mlStX5vXXX2+6ff/99+e9733vRj0vIwUAAABgA4wePTpjxoxJnz59UldXl5qampxxxhnNzjnrrLMyYMCAnHrqqenevXu6d++eZE0pMHDgwDQ0NKSxsTHHH3989t9//6xatSo77rhj+vTpkyOPPDLDhg3L2LFjM2LEiCxdujQrVqzIySefnAMOOGCdPMuXL8+FF16YFStWpLGxMfvss0+GDRu2Uc+pprGxsXHT/0ioRoMGDXrH9QI25JxqMfWXs4qOUBE7dNiu6AgV8erVg4qOUDGH3np70REqYtf21dlPz15QvYuxNixbWXSEiqjWH4kWv7Gi6AgV02XH9kVHqIgFi6r39YPWpW3bmqIjVMzB3d9VdISthukDAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASmqbogOw9amtrc2gQYPe9pz58+dvoTTF23OXjkVHqIily1YUHaEiTrztG0VHqJjHr72q6AgVsevorxQdoSJ2r19WdISKWb1j56IjVMS2bYtOUBm//9OrRUeomKUN1fl/2S6d2xcdoWL+9o+lRUeoiO22rc63VW3b1BQdgS2gOv/2slmuv/76dzznnUoDAAAAtn6mDwAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACU1DZFBwAAAIDWYPny5RkzZkymTp2a+vr6tG3bNn379s2iRYuSJAMHDtzox5wzZ04ef/zx9O/ff5MyrVq1KmPGjMlPf/rTtGvXLgcddFCuv/76Df56pQAAAABsgCFDhiRJ7rnnntTV1aWhoSGTJk1qKgU2xdy5czNp0qSNLgVWr16dmpqafPe7381f//rX/M///E/atm2bv/71rxv1OEoBAAAASqVXr15ve/+0adPWOfb888/n0Ucfzc9//vPU1dUlSWpra3POOefklltuaTrv8ssvz1FHHdX0Jv/888/PgAEDcvTRR2fs2LF56KGH0qZNm+ywww658847M3LkyMyZMyf9+vXL4YcfnmHDhmX69Om56aab0tDQkLq6ulxzzTXZd999M3HixNx///2pqanJ7NmzM378+Nxxxx2ZNGlS2rZtmyTZeeedN+rPQinAJqmtrc2gQYOKjlFxY8aMKToCAACwFZg5c2a6deuW7bfffpO+fsGCBXnggQdy3333pU2bNlm4cGGS5Morr8y4ceNy5513Np03atSo3H777enUqVP+8Ic/ZOjQoZkwYUKS5Mknn8w999yTrl27ZtGiRVm2bFnuuuuuPPLII6mtrc0XvvCFHHXUURucSynAJtmYOSoAAABbk/WNBKi0jh07pr6+PkOHDk3Pnj1zwgknrPe8J554Ii+++GIuuOCCpmNrC4QkOeaYY9K1a9ckycqVK7Nw4cJ07NgxP/7xjzNr1qx8+tOfzv3335+OHTtuUC6lAAAAALyDHj165KWXXsqiRYve9g1327Zts3r16qbby5Ytazp+1113Zfr06XnssccyZsyYTJo0aZ2vb2xszGGHHZbbbrttvY9fX1/f9PvOnTunvr4+ffr0SZJ07949Xbt2zQsvvJCDDz54g56XLQkBAADgHey999459thjM3z48LzxxhtJ0jR0/8322muvPP3000mS5557LrNmzUqSLF68OAsWLEjPnj0zePDg1NbWZt68eenQoUMWL17c9PWHHnpoZsyYkWeffTbJmgUFZ8yY8Za5/u3f/i2/+MUvkqxZtHDevHl517vetcHPy0gBAAAA2ACjR4/OmDFj0qdPn9TV1aWmpiZnnHFGs3POOuus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npvTTz89J510UpLk4YcfznnnnVdwqpZRrXNMaV26deuWL37xi7n00kuTJI2NjampqcnMmTMLTrZpLr300nz84x/P1KlTc8ghhyRJnnrqqfzyl7/MHXfcUXC6lnPhhRfmwgsvzGuvvZaRI0dm2rRpGTZsWNGxNsk/j8Kpq6tLv3790q9fv1b/Rmytarpeb3b11VfniiuuyF/+8pccccQROfDAAzN69OiiY222vfbaKwsXLsyHP/zhnHfeeenYsWP22WefomO1iP/7v//LQQcdlI4dO2bYsGF5+umnc+mll7b6omD16tX50Y9+lJdeeimDBw/OnDlz8uqrr+aII44oOlqp1DS+1WRLYIv629/+lh133LHoGC1q1qxZefzxx5OsmVbQvXv3ghO1jAsvvLBpjuk999yTlStX5vTTT8+9995bdLSNdvPNN+fzn/980TEqopqfW5KceOKJufnmm3PAAQdUxXDmZM3ikOPHj28qNnr06JFzzjknXbt2LThZy3rxxRfzi1/8IknygQ98IHvvvXfBiTbNz372s/zrv/5r0TEqrlqu1/osXbo0jY2Nad++fdFRWtxvf/vbLFq0KMcee2xVjKbq06dP7r333jz++OO57bbbMmDAgIwYMSITJ04sOtpmWVuyPf7447n//vuzcOHCfPKTn8yPf/zjgpOVi5ECULDf/e53GTJkSFatWtW09db48eNz3XXXFR1ts3Xv3r1qioA3q6Y5put70zxkyJDceOONBaRpWRdddFHGjx+fLl26pFevXrnvvvvyu9/9Lvvuu2/OPvvsVj9/dtddd81BBx1UdIwW1a5du3zoQx/Kpz/96aapR9WoW7du6datW9ExNlsZCoGkeq7Xm5199tmZMGFCs4Xd1h5r7VavXp3XXnutaXHj1157rdUvLJukadrKr371q/Tr1y+HHXZYVq9eXXCqzffkk09m8uTJTds9d+rUKStWrCg2VAkpBaBgo0aNyve///3813/9V5LkwAMPzBNPPFFsqBYwe/bsfPnLX86f//znZtsCtfbF3ZLqmmN6xRVXrHNs6tSpTcevv/76LR2pxQwdOjQrV65MQ0NDfvrTn2b+/PlN8zJnzpyZESNGFB1xsxxxxBG5+uqr07t377Rr167peGtdsfnee+/NlVdemQ4dOqShoSE333xzq95q662ceOKJ66wn07FjxxxyyCG5+OKLq2bE2GWXXZZRo0YVHWOzVev1+udV6xcvXlwV6/6MHz8+N910U+rq6prK+pqamjz66KPFBmsB22+/fb75zW/mwQcfzA9+8IOsXLkyq1atKjrWZnvz/19J8sYbb7zlrkFUTuv8KRaqyOrVq9fZqq8ahrl98YtfzHnnnZebb745X//61zNhwoR07ty56FgtoprmmD722GP5l3/5lxxzzDFN/wk/8sgjVbE7xp/+9Kfce++9WbFiRf7lX/4ljz32WNq1a5ezzz676ROJ1uypp55KknzjG99oOtaaV2y+7bbb8sMf/jD7779/pk+fnjFjxlRlKdC3b98sXbq0abvWyZMnp6amJh06dMjQoUPz9a9/veCELePNq6S3ZtV2vcaNG5dx48YlWTM9Z6327dvn4x//eFGxWsy3v/3t/OQnP6m6KUdJctNNN+Xee+/NyJEj07lz58ydOzf/8R//UXSszXbcccflxhtvbFqo9Ac/+EH69OlTdKzSUQpAwbbffvvMmzev6ZOIn/3sZ632k4c3W7JkSXr37p1x48blve99b6666qqceeaZVbFy/0knnZT99tuvaY7pd77znVY7x/S+++7Ll770pUyfPj2XXXZZOnbsmHHjxuX0008vOtpmW1tyrFq1qtmnKW3atKmKIZfVtmJz27Zts//++ydJjjzyyKrahvDNHnvssWZzZS+//PL0798/EydOzCmnnFJgso335jeVb7Z20ctqUE3XK1mze86AAQMycuTIXHnllUXHaXG77757unTpUnSMithpp53yiU98oun2Hnvs0VRWtWYDBgzIpEmTMnfu3PzkJz/JaaedVhU/g7Q2SgEo2Be/+MUMHDgwL7zwQvr06ZMVK1bk1ltvLTrWZls7X7tz586ZPn16dtttt/ztb38rOFXLqZY5pp06dcqoUaPy6KOP5j/+4z/yqU99quhILeaDH/xgPvrRj2b58uU588wzM3jw4PTs2TO//vWv3/LNTGvyVtu9tdbpA2+88UamT5/eVOYsXbq02XNsrc/rny1evDjz58/PrrvummTNbiZLlixJ0vpGie2yyy6ZPHnyeovsallvoJqu15t17Ngx8+bNq7pP1AcPHpwvfOEL+Zd/+Zdmw9KrYXRYNU/LPP300xUBBVMKQMH23Xff3HXXXXn++efT2NiYvffeu9XOT3+zj33sY1m4cGEGDRqUwYMHZ/HixU1bp7V2jzzySG644YbMnTs3q1atavVbwSXJ8ccfnyOPPDI33nhjOnToUHScFnHFFVfkf//3f9OmTZv07NkzTz/9dCZPnpxDDjkkH/vYx4qOt9luvvnmpt8vX748s2bNSo8ePXLXXXcVmGrTdenSJWPHjm26veuuu+bmm29OTU1Nli5dmh/96EcFpms5X/jCF9K/f/8cfvjhaWxszBNPPJHLL788S5YsSa9evYqOt1GOP/74/N///d96S4EPfOADBSRqedV0vd6sbdu2Offcc/Pe9743Z599do4//viqGN3x/e9/Py+++GJqa2ubLSZbDaVAtU7LnD17dr71rW9lzpw5WblyZdPx1joVrrWyJSEU7IEHHsgHPvCBbL/99kmShQsX5je/+U1OPvnkgpPxVj70oQ9l9OjROeSQQ1rtrgNUn+eeey633XZbVewcsdavfvWrTJ48OdOmTcv06dOLjtNiXn/99aYFZd/3vvdl5513LjYQb6tar9fq1avzs5/9LBMmTMif/vSnnHHGGfnIRz7SNCqiNerdu3ceeOCBqig4/tnaaStrtyZMkjPPPLPVF6ann356/u3f/i0HH3xwsyKnGtY2ak38NAsF+/rXv95UCCRrhnNXw/SBL3/5y1m4cGHT7QULFuQrX/lKgYlaTufOnXPooYdWTSFw//3354wzzsihhx6aww47LB/5yEfywAMPFB2rRdx///0588wzq/K5/bP3vOc9rXq0ylrPP/98xowZkxNOOCGf/exn8773vS8PPvhg0bFa1E477ZRevXqlV69eVfEGc33Dl7/3ve9t+SAVUm3Xa602bdrk4IMPzqGHHprGxsY888wzOffcc5u2222N9t1336rYRWF9/nla5ty5c6tiWubq1atz0UUXpWfPnjnqqKOafrFltf4xytDKrW+wTjVsMfOLX/wigwcPbrq9ww475Be/+EUuueSSAlNtnpdffjnJmpVyv/a1r+Xf//3fs9122zXd3xr3Qf7pT3+a66+/PgMHDszBBx/c9IPh9ddfn2222SYnnXRS0RE3WTU/t2TNKuhrrV69Ok8//XSzgrG1GT9+fKZMmZLXXnst/fr1y3e+85186lOfyrnnnlt0tBb17LPPZtiwYfnzn//cbFu41lzo3Hrrrdlhhx1yxBFHJFlTCEybNq3ZomitVTVeryT53//930yYMCEzZ85M//79c/fdd2fnnXdOQ0ND/u3f/i0XXnhh0RE3yapVq3LqqafmqKOOaramQGveXnettdMyL7744lx66aVVMy2zZ8+emT59eo488siio5SaUgAKtvvuu+dHP/pRzjzzzCTJ3Xffnd12263gVJvvn4uN1atXr7Mvcmtz3nnnpaampqnIefOK1DU1Na1ysZ/vf//7ueWWW/K+972v6ViPHj2y//77Z/To0a36jXM1P7ek+ZZvbdu2zV577ZXPf/7zBSbaPNdee22OPvrofPe7321axLMahwAPHz48w4cPz5VXXpkf/OAHueuuu1p9Efy1r30tF110UUaPHp1f//rXmTp1aqv+tPnNqvF6JWu27jv33HPz1a9+tdmot9ra2lx++eUFJts8vXv3Tu/evYuOURFr10U4/PDDW+XPG//sxBNPbPqZ6nvf+1523nnnbLfddk3rNFXDc2xNrCkABXvllVcyePDg/OlPf0qSpjcsrb0YGDFiRJYuXZoLLrggyZo3aHV1dbn66qsLTsab9e7d+y2HZr/dfa1BNT+3avTSSy9l8uTJmTJlSnbZZZf07ds33/rWt/LII48UHa1FrW9e8Npjrdlzzz2Xz372s+natWu++c1vpq6uruhILaJar9fixYtTW1vbtLDxypUr09DQUDULzVaTN48KW5/Wuoji3Llz3/b+PfbYYwslITFSAAq322675Qc/+EHTFkft27cvOFHLuOyyy3LrrbfmyiuvTE1NTY499th89rOfLTpWixg4cGBuueWWdzzWGrzd37f6+votmKTlVetzmzBhQs4+++yMGzduvfcPGDBgCydqGe9617vy+c9/Pp///Ofz+OOPZ9KkSVm0aFH+8z//M//+7/+eU089teiILWLtNna77757pkyZkt122y2LFi0qONWmOf/885uN5li1alWWLl2az3zmM0mqY/Xwarpeb/bJT34y3/3ud5tKgYaGhnz6059utbuXrPX6669nxIgR+fWvf51kzdD0K6+8MjvttFPByTbdm0eFrU9rLQXWvum/7bbbml4z1lrfMSpLKQAFWrJkSbbddtu0a9cuL7zwQn7zm9/k3e9+d0488cSio222du3a5eKLL87FF19cdJQWN2fOnHWOPf/88wUk2Xzz589/yzeXr7322hZO07Kq9bmVYYDf2oWmrr766jz44IOZOHFi1ZQCn//857No0aIMGTIk11xzTRYvXpwrr7yy6FibZODAgUVHqLhqul5vtmzZsmbFaYcOHfLGG28UmKhlXHnllTn88MMzYsSINDY25oc//GGuvPLKfP3rXy862iarhvUQ3s4DDzywTgGwvmNUlukDUJDx48fny1/+curq6vLZz3423/ve93LIIYdkxowZ+fCHP5xBgwYVHXGzzJ8/P6NGjcq8efPygx/8IH/84x/z+9//Puecc07R0TbZHXfckTvuuCOvvfZasy2bli5dmhNOOCFf+tKXCky3ad7qTfNarfVT56S6nxtsTRYvXpy6urqm1dENRd/6nX766fnGN76RLl26JEnmzZuXz3zmM5kyZUrByTZPv3791nkO6zvWGq1cuTITJkxoGjlwzDHH5Kyzzmoa7dHaTJ06NdOmTcvDDz/c7MOwxYsXZ/78+ZkwYUKB6cqndf4tgiowfvz4TJ06NUuWLMkpp5ySRx55JDvttFOWLFmSj3zkI62+FBg6dGhOO+203HbbbUnWbJc2ePDgVl0K9O/fP7169cp1113X7JOiDh06pFOnTgUm23QdOnRIXV1dzj777GbHJ0yY0OoXhqzW56bsaN0WLFiQH/7wh5k9e3ZWrlzZdLw1fxq4dij62k+eq2UoelKd1ytJPvvZz+ajH/1oTjrppDQ2Nubhhx9u1QsMrlVTU5O5c+c2DU2fO3du1SxYOnz48Pz9739P//79k6xZa2DGjBkZOXJkwck2zZ577pmjjjoqv/71r3P00Uc3He/QoUOz22wZSgEoyDbbbJMdd9wxO+64Y7p169Y03619+/bNttFprV5//fWccsopTStQb7PNNs1WOG6NOnbsmI4dO+brX/96Vq5c2TRlYO0nLa3RT37yk4wfP36d46effnrOOuusnH/++QWkahnV/Nxovf7rv/4r73nPe/K+972v6ZP11q5ah6In1Xm9kjWLre67775Nc+9vv/327LPPPgWn2nwDBw7MWWedlcMOOyyNjY158sknM2LEiKJjtYjf/e53uf/++5tun3DCCTnllFMKTLR5unfvnu7du+fYY4/NyJEj86tf/So1NTXp2bNnDjvssKLjlY5SAAry5ub6n4d+VUOrve2222b58uVNz2Xu3LmtdojbP3vqqady8cUXp1OnTmlsbMw//vGPfPWrX80hhxxSdLSNtmrVqvWWUO3atcvq1asLSNRyqvW5GQnQuv3jH//ItddeW3SMFtWmTZu8+uqrzYaiV4tqvF5rdevWrem18F3velfBaTbf6tWrs8cee+See+7Jk08+mWTNVqeteZHBN9tpp52yaNGidOzYMcmadamq4bldddVVTetAJGtG87X2dSBao+r4CR1aoZkzZ6ZHjx5J1iwc9ubfV0MpcOGFF+bCCy/Ma6+9lpEjR2batGkZNmxY0bFaxHXXXZebbrophx56aJLkySefzHXXXdcq578tWbIky5cvX+fNc0NDQ6v/pK+an1tSnet2lMGBBx6YF154Ie9+97uLjtJi3jwUPUmmTZtWFUPRk+q8Xkl1ldtrtWnTJkOGDMk999xTFQs2r7V2ythuu+2W0047LR/60IeSrPl3Vg2fqL/88svNCoBPf/rTTdt/suUoBaAgs2bNKjpCRZ100knZb7/98otf/CJJ8p3vfCd77713walaxhtvvNFUCCTJ+973vlb7JrNXr165/PLLc+211zYtCrZ48eIMHz686Qf81qqan1tSnet2VLO12/ctX748p512Wrp3796ssGrN2/f17t07++23X371q18lqY6h6NV8vZLqKrffbL/99suf/vSnvPe97y06Sovr1q1bunXr1nS7X79+BaZpOdW8DkRrohQAKuaf/wN7s49//OO54447tnCiltGpU6c8+OCD6d27d5LkoYcearULDQ4aNChDhgzJscce2/RJ2Isvvphjjz221S92Wc3PLanOdTuqWbVv37fPPvu8ZRHQGl/vq/16VVO5/WazZ89O//79071799TX1zcdb80lTrVPGavmdSBaE6UAUIiFCxcWHWGTXXPNNRk8eHCuvvrqJMlee+2V0aNHF5xq07Rr1y5f/epX88ILL2TmzJlJkh49elTFUNlqfm5Jda/bUY2OOuqoZreXLFmSJM0W6KtWrfH1vtqvVzWV2282ePDgoiNUzNKlS3Prrbc2jcjp2bNn/vM//7NZ+dEa9erVK4ceemhVrgPRmtQ0NjY2Fh0CKJ/TTz89kyZNKjrGZlm8eHGSrLMX9+9+97scccQRRUSiRKZOnZo777wzzz33XD784Q83rdtx/PHHFx2Nt/Hcc89lyJAhmTNnTpI1peKoUaPynve8p+BkldOaX++r9Xr93//9XwYPHpy5c+cmWfO8brzxxlY/7WPSpEk5/fTT3/FYa3TZZZelrq4uH/3oR5Mkd999dxYtWpQbb7yx4GRUA6UAUIjW/EPiO6nm58bW5cUXX2xat+MDH/hA1azbUc0+8pGP5MILL8zJJ5+cZE25c9ttt+Xuu+8uOFnltObXxGq/Xm9VbrdW6/u71r9//0ycOLGgRC2nb9++ueeee97xGGwK4wyBQlRzH1nNz42ty9ut28HWqaGhoekNZrJmUdaxY8cWmKjyWvNrYjVfryeeeCKzZ8/OqlWrmo6ddtppxQXaDI8//ngef/zxvPbaa02r9SdrSo/WvAXtmzU2NmbhwoVN0zwWLlzYqv9tsXVRCgAtbtWqVfnhD3/4tqugr91SpxpZNZct4ZFHHskNN9yQuXPnZtWqVU3bma5dP4Gt0xFHHJGpU6c2277v/e9/f8GpNl21v95X2/Vaa+jQoXnqqafSo0ePtG3btul4ay0F3krXrl1zyy23FB2jRZx//vnp379/s7+Ln/nMZwpORbUwfQCoiGoZrrcpWvNQWVqPD33oQxk9enQOOeQQuw60IieeeGJefvnlZp/27b777knWFIrTpk0rMt4mqebX+2q8XsmabSTvu+++qluc9Atf+EJGjhyZ9u3b58ILL8wzzzyTq6++OqecckrR0TbbwoUL88orr+S3v/1tkjWLYe6///4Fp6JaVNcrAbDV6NWrV+66667069cvdXV1RcfZonStbAmdO3dutqUYrcOdd95ZdIQWV82v99V4vZJkzz33zMqVK6uuFHj++efTsWPH/OxnP8sOO+yQe++9NxdeeGGrLwUaGxtz7rnn5r777kv37t2LjkMVqq5XAmCrsXa43vDhw1NTU1N1Q5sXLVqUl156KQceeOA6991www0FJKIsXn755STJcccdl6997Wv593//92y33XZN96/9FJOt0x577JGVK1fm+eefT5Lsvfferf6NWTW/3lfj9UqSXXbZJWeddVaOP/74tGvXrun4gAEDCky1+daOmnr88cfTu3fv7LrrrlUxpa+mpiZ77rln5s+fn1133bXoOFSh1v+qBmyVZs2aVXSEipk6dWpGjRqVVatW5eGHH86MGTPy1a9+Nd/85jeTRItPRZ133nlNb7yS5Mc//nHTfa15OHNZPPXUU7n44ovTqVOnNDY25h//+Ee++tWv5pBDDik62iar5tf7arxeyZqRAnvuuWfRMVrcnnvumWHDhuXXv/51Pve5z6WhoaFqRu81NjamT58+OeaYY1JfX990/Prrry8wFdXCmgJAxfztb3/LU089lSR53/vel86dOxecqGX0798/3/ve93LBBRdk8uTJSZJTTz01P/nJT4oNBmz1zj777FxxxRVNUz+efPLJfOlLX8qECROKDbaZqvX1vlqvV7VqaGjIY489lu7du2evvfbKq6++mj/+8Y857rjjio622d5qraLTTz99CyehGhkpAFTEz372swwdOjSHHnpoGhsbc9VVV+W6666riv+Y27Ztm+23336dY7AlDRw4cJ1Vtdd3jK3LG2+80WwtiPe973154403igvUAqr59b4ar1eSLF26NLfeemt+9atfJUl69uyZ//zP/2z2CXRrVFtb22y3iy5duqRLly4FJmo53vxTSUoBoCLGjh2b//7v/85ee+2VJJk9e3a+8IUvVMUPibvssktmzZrVNE9x/PjxTc8TtpQ5c+asc2ztvGe2Xp06dcqDDz6Y3r17J0keeuihppXtW6tqfr2vxuuVJNdcc03q6upy3XXXJUnuvvvuDB8+PDfeeGPByXgr8+fPz8iRI/Ob3/wmSXLMMcdk6NCh1higRSgFgIpYuXJlszfKe+21V1auXFlgopZz9dVX54orrshf/vKXHHHEETnwwAMzevToomNREnfccUfuuOOOvPbaa+nVq1fT8aVLl+aEE04oMBkb4pprrsngwYNz9dVXJ1nz2tjaXz+q+fW+Gq9XksycOTP33HNP0+2rrroqffv2LTAR7+TSSy/N8ccfny996UtJkh/96Ee59NJLc8cddxScjGqgFAAqYvfdd8+3v/3tnH322UmSH/7wh9ltt90KTtUyunbtmu9+97tZunRpGhsb0759+6IjUSL9+/dPr169ct111+XKK69sOt6hQ4eq+ASzmq1atSq/+c1vMnHixCxevDjJmuvW2lXr6321Xq9kzaJ1CxcubHrNWLhwYdUsyFetXn/99fzHf/xH0+1PfOIT+dGPflRgIqqJhQaBiqj2YW5PPPFEZs+enVWrVjUdO+2004oLRClV41Zp1a5///6ZOHFi0TFaVDW/3lfj9UrWFDe33XZbTjrppCTJtGnT8pnPfCYf+chHCk7GW7n44otz4YUXNm2FPGPGjNx+++256aabCk5GNVAKAGykoUOH5qmnnkqPHj2aLTBoWyC2pGrdKq3afe1rX8tOO+2Ufv36pa6urug4vINqvl6zZs3Kb3/72yTJUUcdlf3337/gRKzP+eefn5qamixbtizPPPNM03X64x//mIMPPjh33XVXwQmpBkoBoCJWrFiRhx56KLNnz242t3TAgAEFpmoZvXv3zn333edTWQplq7TWqXv37k2/r6mpSWNjY2pqajJz5swCU22ean69r8brRevy+OOPv+39Rx111BZKQjXzEy1QEf/1X/+VVatW5cADD0ybNm2KjtOi9txzz6xcuVIpQKGqdau0ajdr1qyiI7S4an69r8brlSQPP/xwRo0alblz52bVqlXKjq2YN/1sCX6iBSpi7ty5ue+++4qOURG77LJLzjrrrBx//PFp165d0/Fq+FSM1qNat0qrdr/73e+y//77Ny1Yt3jx4vzpT3/K4YcfXnCyTVfNr/fVeL2S5LrrrsuXv/zlHHjggc2mwbH1ueqqqzJixIimaQT/7Pvf/34Bqag2SgGgIg488MDMnj272TZV1WLPPffMnnvuWXQMSm59W6XZY3zrN2LEiGYL19XX12fkyJGtejG7an69r8brlSS77rprDjvssKJjsAE++tGPJkkGDhxYcBKqmVIAqIhPfOIT+chHPpJ3v/vdzT5Nr4ZG24gAtgb77LNPVW6VVu0aGxubDbFv06ZNs3n4rVE1v95X4/VKks985jP50pe+lH/9139tds3e//73F5iK9Rk5cmT++7//Oz/96U8zdOjQouNQpZQCQEVceumlueiii9ZZob8ajBs3br3HlQVsCWtXC38rfqjfunXq1Cm/+tWv0rNnzyTJL3/5y1Y/7aOaX++r8Xolaxavu++++/Lss882lR41NTVVUeRUmwULFuT//u//8qtf/SqvvPJK/nmN+N13372gZFQTpQBQEdttt10++clPFh2j4pYtW5ZHH320ad9gqLSbb745yZoV35966qlm21Mdcsghtqfayg0dOjQDBw5MXV1dGhsbs2zZstxyyy1Fx9os1fx6X43XK0kefPDBTJs2LbW1tUVH4R2cd955GTBgQF566aV87GMfa3ZfTU1Npk2bVlAyqoktCYGK+OY3v5ndd989vXv3zrbbblt0nIpasmRJBgwYkO9+97tFR6FELr744nzqU5/KwQcfnCR55pln8p3vfCc33XRTwcl4JytXrszzzz+fJNl7771b/U4m1f56X23XK0k+9alP5etf/3qzqQNs3S677LKMGjWq6BhUKaUAUBFr93Zeu1JuNW93tGrVqpxyyil54IEHio5CiZx66qn5yU9+0uxYnz59cu+99xaUiI3x+uuvZ9myZU23W/MQ4DK83lfT9UrWvMH84x//mH/9139tVuSYBrd1+9vf/pannnoqyZptaDt37lxwIqpF6686ga1Ste7tnCRXXHFF0+8bGxszc+bMHHHEEQUmoow6d+6cO+64I2eccUaS5Mc//nF22GGHYkPxjh577LEMGzYsr732Wurr6/OPf/wju+22Wx5++OGio22yan69r8brlazZraQad4uoZj/72c8ydOjQHHrooWlsbMxVV12V6667Lscdd1zR0agCRgoAbKRJkyY1/b5t27bZa6+9bO3EFjdv3rxcd911+c1vfpOampocffTR+eIXv5iuXbsWHY23cdppp+Ub3/hGPvvZz2by5Ml54IEH8vvf/z5f/OIXi47GepT1et1xxx35+Mc/XnQM3qR///4ZO3ZsU5kze/bsfOELX2j122OydTBSAKiI7t27p6ampmkY6VrVMJz09NNPLzoCpGvXrlWx4FnZtGnTJl27dm3a1u7DH/5wbrvttoJTbZ5qfr2vxuu1ISZPnqwU2MqsXLmy2eiOvfbaqyq2x2TroBQAKuLNw0mXLVuW//mf/8n8+fMLTNRynnzyydx8882ZM2dOs/+QrQDMlrRixYo89NBDmT17drO/h+YEb9222267rFq1Kvvuu29uvfXW7Lbbbs3mqrdG1fx6X43Xa0MYSLz12X333fPtb387Z599dpLkhz/8YXbbbbeCU1EtTB8Atpj+/ftXxTC33r17Z+DAgTnwwAOb7cn9rne9q8BUlM3nPve5rFixIgcffHCzv4dKga3brFmz8q53vSuLFy/OmDFjsnjx4lx00UVNu0hUi2p5vS/L9fpnp59+erOpchRv/vz5GTlyZH7zm98kSY455pgMHTo0u+66a8HJqAZGCgAV8fLLLzf9fvXq1XnqqafS0NBQYKKWs/322+fUU08tOgYl9+KLL+Z//ud/io7BRlq7Un99fX2uv/76gtO0jGp+va/G60XrtOuuu+bmm28uOgZVSikAVMR5553XNMd0m222yV577ZUbbrih6Fgt4qyzzsq3vvWtfOhDH2q2x3Nr36KK1mWfffbJ3/72t+y4445FR2EjvPTSS7n99tvXmX70/e9/v8BUm6eaX++r8XptiDZt2hQdgX/Sq1evnHXWWTnzzDOz0047FR2HKqMUACpi5513zg9/+MNmx84+++xMmDChoEQt54033sitt96a8ePHNy2qVVNTY00BtqiVK1emb9++Ofroo5uVUz7N3LoNGDAgp5xySk4++eRm0z5as2p+va/G6/XPfvCDH+RjH/tYs2M//vGPC0rDW7njjjty991354wzzsghhxySs88+Ox/84AeLjkWVUAoAFbFixYpmt5csWZJ//OMfBaVpWd/73vfy0EMPZZdddik6CiXWu3fv9O7du+kT2iTNVn5n67TNNtvkM5/5TNExWlQ1v95X2/WaPHnyOsfGjRuX9u3bJ1mzBSNbpz333DODBg3KwIEDM3Xq1Hzxi19Mu3bt8tGPfjTnnntu6urqio5IK6YUAFrUuHHjMm7cuCRJjx49kqxZxbhDhw5Vs73RHnvskZ133rnoGJTcIYcckqFDh2b+/Pl5+OGHM3PmzDz00ENFx+IdnHzyyfnJT36S3r17Z9ttty06zmYpw+t9NV2vJPniF7+Y4447Lp07d2461tDQ0LR4nVJg67ZgwYJMmjQpd999d3r06JEzzjgj06dPzyc/+cn893//d9HxaMXsPgBUxMiRI3PllVcWHaMirr322syePXudNQX8MMWWdP755+eSSy7J8OHDM3ny5DQ2NubUU0/NfffdV3Q03sb999+fL37xi00L8TU2NqampiYzZ84sONmmq+bX+2q7XtOnT8+Xv/zlnHvuuenbt2+S5MQTT8zDDz9ccDLeySWXXJLf//736du3b84+++xm6xj9+7//u4Vn2SxGCgAVUa0/ICZr1hTYeeed84c//KHZcaUAW9LSpUtz6KGHNt2uqanJNtv4b31rN3r06Nx555054IADqmYxt2p+va+263XkkUfmjjvuyNixY3Pffffl6quvNu2olTj++ONzww03rHfEypQpUwpIRDXx0wPARrKQG1uD2traLFq0qOkH+hkzZqS+vr7gVLyTXXfdNQcddFDRMdhA1Xi9tttuuwwZMiRPPfVUBg0alKVLlxYdibexdsvPI444Iq+99to69+++++5VMbWFYpk+ALCRVqxYkYceeiizZ89utkXVgAEDCkxF2UyfPj033nhjXnzxxRx22GGZOXNmxo4d22z0AFuf0aNHZ9GiRendu3ez6Ufvf//7C0zFW6n267Vy5cq89tpr2W233YqOwlvo3r17unbtmrZt2+af37bZ+YiWohQA2EgXXXRRVq1alQMPPLDZcNKLL764uFCU0sKFC/PEE0+ksbExhx56aHbYYYeiI/EOzj///HWO1dTUVP2+961Vma7XI488khNOOKHoGPyTK6+8Mr/97W9zwgkn5LTTTkv37t2LjkQVUgoAbKRTTjnFYm5ARfzud7/LEUccUXQMNlA1Xa/jjz8+jz76aNExWI9ly5Zl6tSpmTx5cl5//fX07ds3/fr1a7aLBGwOawoAbKQDDzwws2fPzl577VV0FKDKjBw5MpMmTSo6BhuotV2vK6644i3vW7hw4RZMwsbYbrvtcsopp+SUU07JtGnTMnTo0KxcuTKf/vSni45GlVAKAGykT3ziE/nIRz6Sd7/73c3mmFbjcFJgyzKAs3VpbdfrgQceyOWXX97s/65kzfOwLeHW69VXX83kyZNz3333Zc8998w111xjqgctSikAsJEuvfTSXHTRRenRo0fatm1bdBygitgernVpbdfrgAMOSPfu3fO+971vnfvGjh1bQCLeySc+8YksXrw4/fr1yx133GHKABWhFADYSNttt10++clPFh0DADbKl770pXTs2HG99917771bOA0b4te//nWS5JlnnsmXvvSlpuONjY2pqanJzJkzi4pGFVEKAGykD3/4w/nJT36S3r172xsYaFGtbTh62bW269WtW7e3vG/77bffgknYULNmzSo6AiVg9wGAjbR2O6C1w0a19UBLmTVrli3HWpHWeL3uv//+3H777XnuuedSU1OTfffdN5/61Kfy4Q9/uOhoQEGUAgAAFbZw4cLccssteeWVV3Lcccfl7LPPbrrv0ksvzejRowtMx8a44IILWu3Csj/96U8zYsSIDBw4MAcffHAaGxvzzDPPZNy4cbnqqqty0kknFR0RKIDpAwAAFXbVVVflXe96V/r165cJEybksccey5gxY7LtttvmL3/5S9Hx+Ccvv/zyeo83Njbm+eef38JpWs73v//93HLLLc0WGuzRo0f233//jB49WikAJaUUANhAp59+eiZNmpTu3bunpqamadqA6QPAO3nxxRdz8803J0lOPvnkjBo1Kp/61KfyjW98o9XNSy+DE088MXvsscd6r83f//73AhK1jPnz569354FDDjkk8+fPLyARsDVQCgBsoEmTJiWx6A+w8ZYtW9bs9mWXXZZvfvObueCCC7J06dKCUvFW9txzz/y///f/0rVr13Xu+9d//dcCErWM9u3bv+V99fX1WzAJsDVRCgAAVNh+++2XRx99NMcff3zTsYsuuijt27fPyJEjiwvGep122mmZP3/+ekuB/v37F5CoZcyfPz/jxo1b732vvfbaFk4DbC0sNAgAUGFrf9xau2vJmy1ZsuRtP8GFlvJWhcBaAwYM2EJJgK2JkQIAABX2yiuvvO39SoGty1stNLjW7rvvvoWStKwOHTqkrq6u2e4XSTJhwoQsX768oFRA0YwUAACosO7du6dr165p27btOovX1dTUZNq0aQUlY32q9XqdeeaZGT9+fNq1a9fs+PLly3PWWWdl8uTJxQQDCmWkAABAhZ155pn57W9/mxNPPDH9+vVL9+7di47E26jW67Vq1ap1CoEkadeuXVavXl1AImBrYKQAAMAWsGzZskydOjWTJ0/O66+/nr59+6Zfv37p3Llz0dFYj2q8XieffHJ+8pOfrFMMNDQ0pE+fPvnpT39aUDKgSEoBAIAtbNq0aRk6dGg+/elP59Of/nTRcXgH1XK9Ro0alVdffTXXXnttOnTokCRZvHhxhg8fnl122SWXXXZZwQmBIigFAAC2gFdffTWTJ0/Offfdlz333DP9+vXLCSecsN7h3BSvGq/X8uXLM2TIkPzsZz/Lu9/97iTJiy++mGOPPTajR49u1c8N2HRKAQCACvvEJz6RxYsXp1+/fjn11FNb9RD0Mqj26/XCCy9k5syZSZIePXo0FQRAOSkFAAAq7M0L1dXU1DT9vrGxMTU1NU1v0Ng6uF5AmSgFAAAAoKTaFB0AAAAAKIZSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUv8/nWhFDgifC/sAAAAASUVORK5CYII=\n",
+                        "image/png": "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AAAAAFvahu8+YE0BAAAAqCobPlLAmgIAAABQVTZiTQHTBwAAAKCa2H0AAAAASsruAwAAAFBSG7H7gFIAAAAAqol3+gAAAFBSdh+ACnnuuecyZMiQLF68OF26dMmXv/zl7Lrrrs3OWbJkSS677LL86U9/Srt27bLTTjsVlBYAACijDX+nX+OXXyX8tRmGDRuWz33uc3nwwQfTq1evfOUrX1nnnG9/+9vZfffd89BDD2XUqFF56qmnsnr16s37xgAAABtoI0qBGr/8Kt+vTfTXv/41L7zwQk466aQkyZlnnpmf/vSn65z3wAMP5Oyzz06SHHjggWnXrl2eeeaZTf6+AAAAG2PDpw9ACfXq1ett7582bdp6j8+bNy+77bZb0+327dtnu+22y9///vd07ty56fgrr7ySPfbYo+l2bW1tXnnllRxyyCGbmRwAAOCdbUQpsOmfmgIAAABbnw0uBRormQK2Um81EuCddO3aNa+88krT7SVLlmTZsmXNRgkkyW677Za5c+fmPe95T5KkoaGh2QgDAACASrKlAFTAzjvvnG7dumXq1KlJkh/96EdN6wu8We/evTNhwoQkybPPPpvly5fnoIMO2qJZAQCA8trwkQKGCsBGGT58eC677LLceOONTVsSJkm/fv3yzW9+M126dMmnPvWpDBkyJCeffHK23XbbHHLIIWnTRlcHAABsGRtcCqzWCsBG2W+//TJx4sR1jk+ZMqXp9x06dMitt97adHvQoEFbJBsAAEBi+gAAAACU1gaPFFi12kgBAAAAqCYbsaaAUgAAAACqiYUGAQAAoKQsNAgAAAAlZfoAAAAAlNSGLzS4anUlcwAAAABbmOkDAAAAUFIbXgrYkhAAAACqit0HAAAAoKQ2uBRYaU0BAAAAqCptig4AAAAAFGPDdx9YbaQAAAAAVBO7DwAAAEBJbfhCg3YfAAAAgKpipAAAAACU1IavKbBKKQAtafr06Rk+fHiWL1+e9773vRk1atR6zzv//PMzb9681NfXJ0kuu+yyfOADH9iSUQEAgCplpAAUYPXq1bniiivy1a9+NQceeGC+9KUv5dvf/vZbnj9y5MgcffTRWzAhAABQBhu+poBSgBLq1avX294/bdq0TXrcZ555Jp07d86BBx6YJDn77LMzcODA7L///pv0eAAAAJvCSAEowCuvvJLdd9+96fbuu++eV155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eAfPP/98Hn300Vx77bWpq6tLktTW1uacc85pdt7ll1+eiRMnNt0+//zz85vf/CZJMnbs2Jxyyinp06dPzj///CTJyJEj88wzz6Rfv3655pprkiTTp0/Pueeem/79++djH/tY/vKXvyRJJk6cmAsvvDAXXXRRTjnllCxYsCCHHnpodt99901+XqYPAAAAUCq9evV62/unTZu2zrGZM2emW7du2X777Tfpey5YsCAPPPBA7rvvvrRp0yYLFy5Mklx55ZUZN25c7rzzzqbzRo0aldtvvz2dOnXKH/7whwwdOjQTJkxIkjz55JO555570rVr103K8c+UAq3QFVdckYaGhqJjlMKYMWOKjgAAAFSBjh07pr6+PkOHDk3Pnj1zwgknrPe8J554Ii+++GIuuOCCpmNrC4QkOeaYY1qsEEiUAq1SQ0ODN6sAAACbaH0jAd5Jjx498tJLL2XRokXp2LHjW57Xtm3brF69uun2smXLmo7fddddmT59eh577LGMGTNmvWsJNDY25rDDDsttt9223sevr6/f6Oxvx5oCAAAA8A723nvvHHvssRk+fHjeeOONJGve8N91113Nzttrr73y9NNPJ0mee+65zJo1K0myePHiLFiwID179szgwYNTW1ubefPmpUOHDlm8eHHT1x966KGZMWNGnn322SRrFhScMWNGxZ6XkQIAAACwAUaPHp0xY8akT58+qaurS01NTc4444xm55x11lkZMGBATj311HTv3j3du3dPsqYUGDhwYBoaGtLY2Jjjjz8++++/f1atWpUdd9wxffr0yZFHHplhw4Zl7NixGTFiRJYuXZoVK1bk5JNPzgEHHLDeTF/96lczceLE/PWvf81HP/rR7L333k3rE2yImsbGxsZN/yNpbtCgQYa1bwH+nLesCQ88UXSEimh73cVFR6iI1y++segIFfPawhVFR6iI7nt2KDpCRXRq367oCBWzU6e6oiNUxJI3qvPf2KG7tC06QsX8fv7KoiNURLeunYqOUDFddqzO1/yG5dX5d7Ftm+odWL79Dm89/L9sqvcqAwAAAG9LKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCktik6AGztjnzjL0VHqIiFX/9e0REqou8+uxYdoWJqVq8qOkJFzFvQUHSEitiuXduiI1TMgkXVec267Nih6AgVMeu1fxQdoWL23XPHoiNUxMLF1flvLEn+9NJfi45QEdtuU72v+dXqgB06Fh1hq2GkAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpLYpOgAAAAC0BsuXL8+YMWMyderU1NfXp23btunbt28WLVqUJBk4cOBGP+acOXPy+OOPp3///hv9tatXr87nP//5/PnPf067du3SrVu3jBgxIp07d97gxzBSAAAAADbAkCFD8sorr+See+7JlClTMn78+Gy33Xab9Zhz587NpEmTNvrrVq9encbGxvTv3z8PPPBA7r333nTr1i3jxo3bqMcxUgAAAIBS6dWr19veP23atHWOPf/883n00Ufz85//PHV1dUmS2tranHPOObnllluazrv88stz1FFHNX3yf/7552fAgAE5+uijM3bs2Dz00ENp06ZNdthhh9x5550ZOXJk5syZk379+uXwww/PsGHDMn369Nx0001paGhIXV1drrnmmuy7776ZOHFi7r///tTU1GT27NkZP358TjzxxKbvfcghh2Ty5Mkb9WehFGCrcMUVV6ShoaHoGOsYM2ZM0REAAICtwMyZM9OtW7dsv/32m/T1CxYsyAMPPJD77rsvbdq0ycKFC5MkV155ZcaNG5c777yz6bxRo0bl9ttvT6dOnfKHP/whQ4cOzYQJE5IkTz75ZO6555507dq12eM3NjZmwoQJ+dCHPrRRuZQCbBUaGhq8AQcAALaI9Y0EqLSOHTumvr4+Q4cOTc+ePXPCCSes97wnnngiL774Yi644IKmY2sLhCQ55phj1ikEkuTGG29MbW1tPvrRj25ULqUAAAAAvIMePXrkpZdeyqJFi9KxY8e3PK9t27ZZvXp10+1ly5Y1Hb/rrrsyffr0PPbYYxkzZsx61xJobGzMYYcdlttuu229j19fX7/OsW9+85t55plncvvtt6empmajnpeFBgEAAOAd7L333jn22GMzfPjwvPHGG0nWvOG/6667mp2311575emnn06SPPfcc5k1a1aSZPHixVmwYEF69uyZwYMHp7a2NvPmzUuHDh2yePHipq8/9NBDM2PGjDz77LNJ1iwoOGPGjLfM9YMf/CAPPvhgvv71r2/SoodGCgAAAMAGGD16dMaMGZM+ffqkrq4uNTU1OeOMM5qdc9ZZZ2XAgAE59dRT071793Tv3j3JmlJg4MCBaWhoSGNjY44//vjsv//+WbVqVXbcccf06dMnRx55ZIYNG5axY8dmxIgRWbp0aVasWJGTTz45BxxwwDp5Fi9enBEjRmTPPffMxz72sSTJvvvum6985Ssb/JyUAgAAALABtttuu1x++eW5/PLL3/KcHXfcMePHj1/vfXffffc6x7bZZpt8+9vfbnbs8MMPX2cEQpL079+/aVeDJOnQoUPTSIRNZfoAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBS27Tkg9XW1mbQoEEt+ZCsx/z584uOAAAAQBVo0VLg+uuvb8mH4y0oXgAAAGgJpg8AAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBS2xQdgK3PFVdckYaGhi36PefPn79Fv9/GeO7Hk4qOUBE7Djmi6AgVcc8v/lx0hIqpbde26AgVsWp1Y9ERKqJNTU3RESqm6471RUeoiFdeX1x0hIqobVe9P+6tWLmq6AgVsWr16qIjVExjdb7kZ/mK6vy72LB8ZdER2AKq938JNllDQ0PGjBmzRb/noEGDtuj3AwAAwPQBAAAAKC2lAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJLapugAAAAA0BosX748Y8aMydSpU1NfX5+2bdumb9++WbRoUZJk4MCBG/2Yc+bMyeOPP57+/ftvUqb//M//zJw5c5Iku+yyS0aOHJnddtttg79eKQAAAAAbYMiQIUmSe+65J3V1dWloaMikSZOaSoFNMXfu3EyaNGmjS4HVq1enpqYmo0aNSseOHZMk3//+93PTTTdl9OjRG/w4SgEAAABKpVevXm97/7Rp09Y59vzzz+fRRx/Nz3/+89TV1SVJamtrc8455+SWW25pOu/yyy/PUUcd1fQm//zzz8+AAQNy9NFHZ+zYsXnooYfSpk2b7LDDDrnzzjszcuTIzJkzJ/369cvhhx+eYcOGZfr06bnpppvS0NCQurq6XHPNNdl3330zceLE3H///ampqcns2bMzfvz4dO7cuel7L1myJDU1NRv1Z6EUYKtQW1ubQYMGFR1jHWPGjCk6AgAAsBWYOXNmunXrlu23336Tvn7BggV54IEHct9996VNmzZZuHBhkuTKK6/MuHHjcueddzadN2rUqNx+++3p1KlT/vCHP2To0KGZMGFCkuTJJ5/MPffck65duzY99pAhQ/LLX/4yO+ywQ7773e9uVC6lAFuF66+/vugIAABASaxvJECldezYMfX19Rk6dGh69uyZE044Yb3nPfHEE3nxxRdzwQUXNB1bWyAkyTHHHNOsEEiSG2+8MUnyve99L1/72tcyfPjwDc5l9wEAAAB4Bz169MhLL730jusHtG3bNqtXr266vWzZsqbjd911V/r27ZtZs2alb9++WbBgwTpf39jYmMMOOyxTpkxp+vXoo4823V9fX/+W3/sjH/lIpkyZslHPSykAAAAA72DvvffOsccem+HDh+eNN95IsuYN/1133dXsvL322itPP/10kuS5557LrFmzkiSLFy/OggUL0rNnzwwePDi1tbWZN29eOnTokMWLFzd9/aGHHpoZM2bk2WefTbJmQcEZM2asN9PSpUvz8ssvN91+4IEHst9++23U8zJ9AAAAADbA6NGjM2bMmPTp0yd1dXWpqanJGWec0eycs846KwMGDMipp56a7t27p3v37knWlAIDBw5MQ0NDGhsbc/zxx2f//ffPqlWrsuOOO6ZPnz458sgjM2zYsIwdOzYjRozI0qVLs2LFipx88sk54IAD1snT0NCQiy++OG+88UZqamrStWvXjdp5IElqGhsbGzf9j4QiDBo0qKIL4FX68Vubh877WNERKmLHISOLjlARL8z7R9ERKqa2XduiI1TEqtXV+d9Qm41c+bc16brjWw9bbM2WLltZdISKqG1XvZ8BddmxfdERKmLR0mVFR6iYVauq8zW/WjUsr87XxSQ55rD3FB1hq2H6AAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJbVN0ADZebW1tBg0aVLHHnz9/fsUeuzVq859XFR2BjVB367CiI1TMobfeXnSEiti1fXX+VzR7QUPRESqmYdnKoiNURH3ttkVHqIjFb6woOgIbadWqxqIjQJKkfV11vi7SXHX+JFblrr/++oo+fiULBwAAALYepg8AAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlNQ2RQcAAACA1mD58uUZM2ZMpk6dmvr6+rRt2zZ9+/bNokWLkiQDBw7c6MecM2dOHn/88fTv33+TMp1//vmZN29e6uvrkySXXXZZPvCBD2zw1ysFAAAAYAMMGTIkSXLPPfekrq4uDQ0NmTRpUlMpsCnmzp2bSZMmbXQpsHr16tTU1CRJRo4cmaOPPnqTvr9SAAAAgFLp1avX294/bdq0dY49//zzefTRR/Pzn/88dXV1SZLa2tqcc845ueWWW5rOu/zyy3PUUUc1vck///zzM2DAgBx99NEZO3ZsHnroobRp0yY77LBD7rzzzowcOTJz5sxJv379cvjhh2fYsGGZPn16brrppjQ0NKSuri7XXHNN9t1330ycODH3339/ampqMnv27IwfP36z/yyUAmySK664Ig0NDUXHqLgxY8YUHQEAANgKzJw5M926dcv222+/SV+/YMGCPPDAA7nvvvvSpk2bLFy4MEly5ZVXZty4cbnzzjubzhs1alRuv/32dOrUKX/4wx8ydOjQTJgwIUny5JNP5p577knXrl2bHvvaa69NmzZtcsQRR2Tw4MHp0KHDBudSCrBJGhoavGEGAABapfWNBKi0jh07pr6+PkOHDk3Pnj1zwgknrPe8J554Ii+++GIuuOCCpmNrC4QkOeaYY5oVAqNHj07Xrl2zfPnyXH/99bnhhhsycuTIDc6lFAAAAIB30KNHj7z00ktZtGhROnbs+JbntW3bNqtXr266vWzZsqbjd911V6ZPn57HHnssY8aMyaRJk9b5+sbGxhx22GG57bbb1vv4axcUXGttQdCuXbucc845ueSSSzbqedmSEAAAAN7B3nvvnWOPPTbDhw/PG2+8kWTNG/677rqr2Xl77bVXnn766STJc889l1mzZiVJFi9enAULFqRnz54ZPHhwamtrM2/evHTo0CGLFy9u+vpDDz00M2bMyLPPPptkzYKCM2bMWG+mlStX5vXXX2+6ff/99+e9733vRj0vIwUAAABgA4wePTpjxoxJnz59UldXl5qampxxxhnNzjnrrLMyYMCAnHrqqenevXu6d++eZE0pMHDgwDQ0NKSxsTHHH3989t9//6xatSo77rhj+vTpkyOPPDLDhg3L2LFjM2LEiCxdujQrVqzIySefnAMOOGCdPMuXL8+FF16YFStWpLGxMfvss0+GDRu2Uc+pprGxsXHT/0ioRoMGDXrH9QI25JxqMfWXs4qOUBE7dNiu6AgV8erVg4qOUDGH3np70REqYtf21dlPz15QvYuxNixbWXSEiqjWH4kWv7Gi6AgV02XH9kVHqIgFi6r39YPWpW3bmqIjVMzB3d9VdISthukDAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASmqbogOw9amtrc2gQYPe9pz58+dvoTTF23OXjkVHqIily1YUHaEiTrztG0VHqJjHr72q6AgVsevorxQdoSJ2r19WdISKWb1j56IjVMS2bYtOUBm//9OrRUeomKUN1fl/2S6d2xcdoWL+9o+lRUeoiO22rc63VW3b1BQdgS2gOv/2slmuv/76dzznnUoDAAAAtn6mDwAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACUlFIAAAAASkopAAAAACWlFAAAAICSUgoAAABASSkFAAAAoKSUAgAAAFBSSgEAAAAoKaUAAAAAlJRSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUkoBAAAAKCmlAAAAAJSUUgAAAABKSikAAAAAJaUUAAAAgJJSCgAAAEBJKQUAAACgpJQCAAAAUFJKAQAAACgppQAAAACU1DZFBwAAAIDWYPny5RkzZkymTp2a+vr6tG3bNn379s2iRYuSJAMHDtzox5wzZ04ef/zx9O/ff5MyrVq1KmPGjMlPf/rTtGvXLgcddFCuv/76Df56pQAAAABsgCFDhiRJ7rnnntTV1aWhoSGTJk1qKgU2xdy5czNp0qSNLgVWr16dmpqafPe7381f//rX/M///E/atm2bv/71rxv1OEoBAAAASqVXr15ve/+0adPWOfb888/n0Ucfzc9//vPU1dUlSWpra3POOefklltuaTrv8ssvz1FHHdX0Jv/888/PgAEDcvTRR2fs2LF56KGH0qZNm+ywww658847M3LkyMyZMyf9+vXL4YcfnmHDhmX69Om56aab0tDQkLq6ulxzzTXZd999M3HixNx///2pqanJ7NmzM378+Nxxxx2ZNGlS2rZtmyTZeeedN+rPQinAJqmtrc2gQYOKjlFxY8aMKToCAACwFZg5c2a6deuW7bfffpO+fsGCBXnggQdy3333pU2bNlm4cGGS5Morr8y4ceNy5513Np03atSo3H777enUqVP+8Ic/ZOjQoZkwYUKS5Mknn8w999yTrl27ZtGiRVm2bFnuuuuuPPLII6mtrc0XvvCFHHXUURucSynAJtmYOSoAAABbk/WNBKi0jh07pr6+PkOHDk3Pnj1zwgknrPe8J554Ii+++GIuuOCCpmNrC4QkOeaYY9K1a9ckycqVK7Nw4cJ07NgxP/7xjzNr1qx8+tOfzv3335+OHTtuUC6lAAAAALyDHj165KWXXsqiRYve9g1327Zts3r16qbby5Ytazp+1113Zfr06XnssccyZsyYTJo0aZ2vb2xszGGHHZbbbrttvY9fX1/f9PvOnTunvr4+ffr0SZJ07949Xbt2zQsvvJCDDz54g56XLQkBAADgHey999459thjM3z48LzxxhtJ0jR0/8322muvPP3000mS5557LrNmzUqSLF68OAsWLEjPnj0zePDg1NbWZt68eenQoUMWL17c9PWHHnpoZsyYkWeffTbJmgUFZ8yY8Za5/u3f/i2/+MUvkqxZtHDevHl517vetcHPy0gBAAAA2ACjR4/OmDFj0qdPn9TV1aWmpiZnnHFGs3POOuus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npvTTz89J510UpLk4YcfznnnnVdwqpZRrXNMaV26deuWL37xi7n00kuTJI2NjampqcnMmTMLTrZpLr300nz84x/P1KlTc8ghhyRJnnrqqfzyl7/MHXfcUXC6lnPhhRfmwgsvzGuvvZaRI0dm2rRpGTZsWNGxNsk/j8Kpq6tLv3790q9fv1b/Rmytarpeb3b11VfniiuuyF/+8pccccQROfDAAzN69OiiY222vfbaKwsXLsyHP/zhnHfeeenYsWP22WefomO1iP/7v//LQQcdlI4dO2bYsGF5+umnc+mll7b6omD16tX50Y9+lJdeeimDBw/OnDlz8uqrr+aII44oOlqp1DS+1WRLYIv629/+lh133LHoGC1q1qxZefzxx5OsmVbQvXv3ghO1jAsvvLBpjuk999yTlStX5vTTT8+9995bdLSNdvPNN+fzn/980TEqopqfW5KceOKJufnmm3PAAQdUxXDmZM3ikOPHj28qNnr06JFzzjknXbt2LThZy3rxxRfzi1/8IknygQ98IHvvvXfBiTbNz372s/zrv/5r0TEqrlqu1/osXbo0jY2Nad++fdFRWtxvf/vbLFq0KMcee2xVjKbq06dP7r333jz++OO57bbbMmDAgIwYMSITJ04sOtpmWVuyPf7447n//vuzcOHCfPKTn8yPf/zjgpOVi5ECULDf/e53GTJkSFatWtW09db48eNz3XXXFR1ts3Xv3r1qioA3q6Y5put70zxkyJDceOONBaRpWRdddFHGjx+fLl26pFevXrnvvvvyu9/9Lvvuu2/OPvvsVj9/dtddd81BBx1UdIwW1a5du3zoQx/Kpz/96aapR9WoW7du6datW9ExNlsZCoGkeq7Xm5199tmZMGFCs4Xd1h5r7VavXp3XXnutaXHj1157rdUvLJukadrKr371q/Tr1y+HHXZYVq9eXXCqzffkk09m8uTJTds9d+rUKStWrCg2VAkpBaBgo0aNyve///3813/9V5LkwAMPzBNPPFFsqBYwe/bsfPnLX86f//znZtsCtfbF3ZLqmmN6xRVXrHNs6tSpTcevv/76LR2pxQwdOjQrV65MQ0NDfvrTn2b+/PlN8zJnzpyZESNGFB1xsxxxxBG5+uqr07t377Rr167peGtdsfnee+/NlVdemQ4dOqShoSE333xzq95q662ceOKJ66wn07FjxxxyyCG5+OKLq2bE2GWXXZZRo0YVHWOzVev1+udV6xcvXlwV6/6MHz8+N910U+rq6prK+pqamjz66KPFBmsB22+/fb75zW/mwQcfzA9+8IOsXLkyq1atKjrWZnvz/19J8sYbb7zlrkFUTuv8KRaqyOrVq9fZqq8ahrl98YtfzHnnnZebb745X//61zNhwoR07ty56FgtoprmmD722GP5l3/5lxxzzDFN/wk/8sgjVbE7xp/+9Kfce++9WbFiRf7lX/4ljz32WNq1a5ezzz676ROJ1uypp55KknzjG99oOtaaV2y+7bbb8sMf/jD7779/pk+fnjFjxlRlKdC3b98sXbq0abvWyZMnp6amJh06dMjQoUPz9a9/veCELePNq6S3ZtV2vcaNG5dx48YlWTM9Z6327dvn4x//eFGxWsy3v/3t/OQnP6m6KUdJctNNN+Xee+/NyJEj07lz58ydOzf/8R//UXSszXbcccflxhtvbFqo9Ac/+EH69OlTdKzSUQpAwbbffvvMmzev6ZOIn/3sZ632k4c3W7JkSXr37p1x48blve99b6666qqceeaZVbFy/0knnZT99tuvaY7pd77znVY7x/S+++7Ll770pUyfPj2XXXZZOnbsmHHjxuX0008vOtpmW1tyrFq1qtmnKW3atKmKIZfVtmJz27Zts//++ydJjjzyyKrahvDNHnvssWZzZS+//PL0798/EydOzCmnnFJgso335jeVb7Z20ctqUE3XK1mze86AAQMycuTIXHnllUXHaXG77757unTpUnSMithpp53yiU98oun2Hnvs0VRWtWYDBgzIpEmTMnfu3PzkJz/JaaedVhU/g7Q2SgEo2Be/+MUMHDgwL7zwQvr06ZMVK1bk1ltvLTrWZls7X7tz586ZPn16dtttt/ztb38rOFXLqZY5pp06dcqoUaPy6KOP5j/+4z/yqU99quhILeaDH/xgPvrRj2b58uU588wzM3jw4PTs2TO//vWv3/LNTGvyVtu9tdbpA2+88UamT5/eVOYsXbq02XNsrc/rny1evDjz58/PrrvummTNbiZLlixJ0vpGie2yyy6ZPHnyeovsallvoJqu15t17Ngx8+bNq7pP1AcPHpwvfOEL+Zd/+Zdmw9KrYXRYNU/LPP300xUBBVMKQMH23Xff3HXXXXn++efT2NiYvffeu9XOT3+zj33sY1m4cGEGDRqUwYMHZ/HixU1bp7V2jzzySG644YbMnTs3q1atavVbwSXJ8ccfnyOPPDI33nhjOnToUHScFnHFFVfkf//3f9OmTZv07NkzTz/9dCZPnpxDDjkkH/vYx4qOt9luvvnmpt8vX748s2bNSo8ePXLXXXcVmGrTdenSJWPHjm26veuuu+bmm29OTU1Nli5dmh/96EcFpms5X/jCF9K/f/8cfvjhaWxszBNPPJHLL788S5YsSa9evYqOt1GOP/74/N///d96S4EPfOADBSRqedV0vd6sbdu2Offcc/Pe9743Z599do4//viqGN3x/e9/Py+++GJqa2ubLSZbDaVAtU7LnD17dr71rW9lzpw5WblyZdPx1joVrrWyJSEU7IEHHsgHPvCBbL/99kmShQsX5je/+U1OPvnkgpPxVj70oQ9l9OjROeSQQ1rtrgNUn+eeey633XZbVewcsdavfvWrTJ48OdOmTcv06dOLjtNiXn/99aYFZd/3vvdl5513LjYQb6tar9fq1avzs5/9LBMmTMif/vSnnHHGGfnIRz7SNCqiNerdu3ceeOCBqig4/tnaaStrtyZMkjPPPLPVF6ann356/u3f/i0HH3xwsyKnGtY2ak38NAsF+/rXv95UCCRrhnNXw/SBL3/5y1m4cGHT7QULFuQrX/lKgYlaTufOnXPooYdWTSFw//3354wzzsihhx6aww47LB/5yEfywAMPFB2rRdx///0588wzq/K5/bP3vOc9rXq0ylrPP/98xowZkxNOOCGf/exn8773vS8PPvhg0bFa1E477ZRevXqlV69eVfEGc33Dl7/3ve9t+SAVUm3Xa602bdrk4IMPzqGHHprGxsY888wzOffcc5u2222N9t1336rYRWF9/nla5ty5c6tiWubq1atz0UUXpWfPnjnqqKOafrFltf4xytDKrW+wTjVsMfOLX/wigwcPbrq9ww475Be/+EUuueSSAlNtnpdffjnJmpVyv/a1r+Xf//3fs9122zXd3xr3Qf7pT3+a66+/PgMHDszBBx/c9IPh9ddfn2222SYnnXRS0RE3WTU/t2TNKuhrrV69Ok8//XSzgrG1GT9+fKZMmZLXXnst/fr1y3e+85186lOfyrnnnlt0tBb17LPPZtiwYfnzn//cbFu41lzo3Hrrrdlhhx1yxBFHJFlTCEybNq3ZomitVTVeryT53//930yYMCEzZ85M//79c/fdd2fnnXdOQ0ND/u3f/i0XXnhh0RE3yapVq3LqqafmqKOOaramQGveXnettdMyL7744lx66aVVMy2zZ8+emT59eo488siio5SaUgAKtvvuu+dHP/pRzjzzzCTJ3Xffnd12263gVJvvn4uN1atXr7Mvcmtz3nnnpaampqnIefOK1DU1Na1ysZ/vf//7ueWWW/K+972v6ViPHj2y//77Z/To0a36jXM1P7ek+ZZvbdu2zV577ZXPf/7zBSbaPNdee22OPvrofPe7321axLMahwAPHz48w4cPz5VXXpkf/OAHueuuu1p9Efy1r30tF110UUaPHp1f//rXmTp1aqv+tPnNqvF6JWu27jv33HPz1a9+tdmot9ra2lx++eUFJts8vXv3Tu/evYuOURFr10U4/PDDW+XPG//sxBNPbPqZ6nvf+1523nnnbLfddk3rNFXDc2xNrCkABXvllVcyePDg/OlPf0qSpjcsrb0YGDFiRJYuXZoLLrggyZo3aHV1dbn66qsLTsab9e7d+y2HZr/dfa1BNT+3avTSSy9l8uTJmTJlSnbZZZf07ds33/rWt/LII48UHa1FrW9e8Npjrdlzzz2Xz372s+natWu++c1vpq6uruhILaJar9fixYtTW1vbtLDxypUr09DQUDULzVaTN48KW5/Wuoji3Llz3/b+PfbYYwslITFSAAq322675Qc/+EHTFkft27cvOFHLuOyyy3LrrbfmyiuvTE1NTY499th89rOfLTpWixg4cGBuueWWdzzWGrzd37f6+votmKTlVetzmzBhQs4+++yMGzduvfcPGDBgCydqGe9617vy+c9/Pp///Ofz+OOPZ9KkSVm0aFH+8z//M//+7/+eU089teiILWLtNna77757pkyZkt122y2LFi0qONWmOf/885uN5li1alWWLl2az3zmM0mqY/Xwarpeb/bJT34y3/3ud5tKgYaGhnz6059utbuXrPX6669nxIgR+fWvf51kzdD0K6+8MjvttFPByTbdm0eFrU9rLQXWvum/7bbbml4z1lrfMSpLKQAFWrJkSbbddtu0a9cuL7zwQn7zm9/k3e9+d0488cSio222du3a5eKLL87FF19cdJQWN2fOnHWOPf/88wUk2Xzz589/yzeXr7322hZO07Kq9bmVYYDf2oWmrr766jz44IOZOHFi1ZQCn//857No0aIMGTIk11xzTRYvXpwrr7yy6FibZODAgUVHqLhqul5vtmzZsmbFaYcOHfLGG28UmKhlXHnllTn88MMzYsSINDY25oc//GGuvPLKfP3rXy862iarhvUQ3s4DDzywTgGwvmNUlukDUJDx48fny1/+curq6vLZz3423/ve93LIIYdkxowZ+fCHP5xBgwYVHXGzzJ8/P6NGjcq8efPygx/8IH/84x/z+9//Puecc07R0TbZHXfckTvuuCOvvfZasy2bli5dmhNOOCFf+tKXCky3ad7qTfNarfVT56S6nxtsTRYvXpy6urqm1dENRd/6nX766fnGN76RLl26JEnmzZuXz3zmM5kyZUrByTZPv3791nkO6zvWGq1cuTITJkxoGjlwzDHH5Kyzzmoa7dHaTJ06NdOmTcvDDz/c7MOwxYsXZ/78+ZkwYUKB6cqndf4tgiowfvz4TJ06NUuWLMkpp5ySRx55JDvttFOWLFmSj3zkI62+FBg6dGhOO+203HbbbUnWbJc2ePDgVl0K9O/fP7169cp1113X7JOiDh06pFOnTgUm23QdOnRIXV1dzj777GbHJ0yY0OoXhqzW56bsaN0WLFiQH/7wh5k9e3ZWrlzZdLw1fxq4dij62k+eq2UoelKd1ytJPvvZz+ajH/1oTjrppDQ2Nubhhx9u1QsMrlVTU5O5c+c2DU2fO3du1SxYOnz48Pz9739P//79k6xZa2DGjBkZOXJkwck2zZ577pmjjjoqv/71r3P00Uc3He/QoUOz22wZSgEoyDbbbJMdd9wxO+64Y7p169Y03619+/bNttFprV5//fWccsopTStQb7PNNs1WOG6NOnbsmI4dO+brX/96Vq5c2TRlYO0nLa3RT37yk4wfP36d46effnrOOuusnH/++QWkahnV/Nxovf7rv/4r73nPe/K+972v6ZP11q5ah6In1Xm9kjWLre67775Nc+9vv/327LPPPgWn2nwDBw7MWWedlcMOOyyNjY158sknM2LEiKJjtYjf/e53uf/++5tun3DCCTnllFMKTLR5unfvnu7du+fYY4/NyJEj86tf/So1NTXp2bNnDjvssKLjlY5SAAry5ub6n4d+VUOrve2222b58uVNz2Xu3LmtdojbP3vqqady8cUXp1OnTmlsbMw//vGPfPWrX80hhxxSdLSNtmrVqvWWUO3atcvq1asLSNRyqvW5GQnQuv3jH//ItddeW3SMFtWmTZu8+uqrzYaiV4tqvF5rdevWrem18F3velfBaTbf6tWrs8cee+See+7Jk08+mWTNVqeteZHBN9tpp52yaNGidOzYMcmadamq4bldddVVTetAJGtG87X2dSBao+r4CR1aoZkzZ6ZHjx5J1iwc9ubfV0MpcOGFF+bCCy/Ma6+9lpEjR2batGkZNmxY0bFaxHXXXZebbrophx56aJLkySefzHXXXdcq578tWbIky5cvX+fNc0NDQ6v/pK+an1tSnet2lMGBBx6YF154Ie9+97uLjtJi3jwUPUmmTZtWFUPRk+q8Xkl1ldtrtWnTJkOGDMk999xTFQs2r7V2ythuu+2W0047LR/60IeSrPl3Vg2fqL/88svNCoBPf/rTTdt/suUoBaAgs2bNKjpCRZ100knZb7/98otf/CJJ8p3vfCd77713walaxhtvvNFUCCTJ+973vlb7JrNXr165/PLLc+211zYtCrZ48eIMHz686Qf81qqan1tSnet2VLO12/ctX748p512Wrp3796ssGrN2/f17t07++23X371q18lqY6h6NV8vZLqKrffbL/99suf/vSnvPe97y06Sovr1q1bunXr1nS7X79+BaZpOdW8DkRrohQAKuaf/wN7s49//OO54447tnCiltGpU6c8+OCD6d27d5LkoYcearULDQ4aNChDhgzJscce2/RJ2Isvvphjjz221S92Wc3PLanOdTuqWbVv37fPPvu8ZRHQGl/vq/16VVO5/WazZ89O//79071799TX1zcdb80lTrVPGavmdSBaE6UAUIiFCxcWHWGTXXPNNRk8eHCuvvrqJMlee+2V0aNHF5xq07Rr1y5f/epX88ILL2TmzJlJkh49elTFUNlqfm5Jda/bUY2OOuqoZreXLFmSJM0W6KtWrfH1vtqvVzWV2282ePDgoiNUzNKlS3Prrbc2jcjp2bNn/vM//7NZ+dEa9erVK4ceemhVrgPRmtQ0NjY2Fh0CKJ/TTz89kyZNKjrGZlm8eHGSrLMX9+9+97scccQRRUSiRKZOnZo777wzzz33XD784Q83rdtx/PHHFx2Nt/Hcc89lyJAhmTNnTpI1peKoUaPynve8p+BkldOaX++r9Xr93//9XwYPHpy5c+cmWfO8brzxxlY/7WPSpEk5/fTT3/FYa3TZZZelrq4uH/3oR5Mkd999dxYtWpQbb7yx4GRUA6UAUIjW/EPiO6nm58bW5cUXX2xat+MDH/hA1azbUc0+8pGP5MILL8zJJ5+cZE25c9ttt+Xuu+8uOFnltObXxGq/Xm9VbrdW6/u71r9//0ycOLGgRC2nb9++ueeee97xGGwK4wyBQlRzH1nNz42ty9ut28HWqaGhoekNZrJmUdaxY8cWmKjyWvNrYjVfryeeeCKzZ8/OqlWrmo6ddtppxQXaDI8//ngef/zxvPbaa02r9SdrSo/WvAXtmzU2NmbhwoVN0zwWLlzYqv9tsXVRCgAtbtWqVfnhD3/4tqugr91SpxpZNZct4ZFHHskNN9yQuXPnZtWqVU3bma5dP4Gt0xFHHJGpU6c2277v/e9/f8GpNl21v95X2/Vaa+jQoXnqqafSo0ePtG3btul4ay0F3krXrl1zyy23FB2jRZx//vnp379/s7+Ln/nMZwpORbUwfQCoiGoZrrcpWvNQWVqPD33oQxk9enQOOeQQuw60IieeeGJefvnlZp/27b777knWFIrTpk0rMt4mqebX+2q8XsmabSTvu+++qluc9Atf+EJGjhyZ9u3b58ILL8wzzzyTq6++OqecckrR0TbbwoUL88orr+S3v/1tkjWLYe6///4Fp6JaVNcrAbDV6NWrV+66667069cvdXV1RcfZonStbAmdO3dutqUYrcOdd95ZdIQWV82v99V4vZJkzz33zMqVK6uuFHj++efTsWPH/OxnP8sOO+yQe++9NxdeeGGrLwUaGxtz7rnn5r777kv37t2LjkMVqq5XAmCrsXa43vDhw1NTU1N1Q5sXLVqUl156KQceeOA6991www0FJKIsXn755STJcccdl6997Wv593//92y33XZN96/9FJOt0x577JGVK1fm+eefT5Lsvfferf6NWTW/3lfj9UqSXXbZJWeddVaOP/74tGvXrun4gAEDCky1+daOmnr88cfTu3fv7LrrrlUxpa+mpiZ77rln5s+fn1133bXoOFSh1v+qBmyVZs2aVXSEipk6dWpGjRqVVatW5eGHH86MGTPy1a9+Nd/85jeTRItPRZ133nlNb7yS5Mc//nHTfa15OHNZPPXUU7n44ovTqVOnNDY25h//+Ee++tWv5pBDDik62iar5tf7arxeyZqRAnvuuWfRMVrcnnvumWHDhuXXv/51Pve5z6WhoaFqRu81NjamT58+OeaYY1JfX990/Prrry8wFdXCmgJAxfztb3/LU089lSR53/vel86dOxecqGX0798/3/ve93LBBRdk8uTJSZJTTz01P/nJT4oNBmz1zj777FxxxRVNUz+efPLJfOlLX8qECROKDbaZqvX1vlqvV7VqaGjIY489lu7du2evvfbKq6++mj/+8Y857rjjio622d5qraLTTz99CyehGhkpAFTEz372swwdOjSHHnpoGhsbc9VVV+W6666riv+Y27Ztm+23336dY7AlDRw4cJ1Vtdd3jK3LG2+80WwtiPe973154403igvUAqr59b4ar1eSLF26NLfeemt+9atfJUl69uyZ//zP/2z2CXRrVFtb22y3iy5duqRLly4FJmo53vxTSUoBoCLGjh2b//7v/85ee+2VJJk9e3a+8IUvVMUPibvssktmzZrVNE9x/PjxTc8TtpQ5c+asc2ztvGe2Xp06dcqDDz6Y3r17J0keeuihppXtW6tqfr2vxuuVJNdcc03q6upy3XXXJUnuvvvuDB8+PDfeeGPByXgr8+fPz8iRI/Ob3/wmSXLMMcdk6NCh1higRSgFgIpYuXJlszfKe+21V1auXFlgopZz9dVX54orrshf/vKXHHHEETnwwAMzevToomNREnfccUfuuOOOvPbaa+nVq1fT8aVLl+aEE04oMBkb4pprrsngwYNz9dVXJ1nz2tjaXz+q+fW+Gq9XksycOTP33HNP0+2rrroqffv2LTAR7+TSSy/N8ccfny996UtJkh/96Ee59NJLc8cddxScjGqgFAAqYvfdd8+3v/3tnH322UmSH/7wh9ltt90KTtUyunbtmu9+97tZunRpGhsb0759+6IjUSL9+/dPr169ct111+XKK69sOt6hQ4eq+ASzmq1atSq/+c1vMnHixCxevDjJmuvW2lXr6321Xq9kzaJ1CxcubHrNWLhwYdUsyFetXn/99fzHf/xH0+1PfOIT+dGPflRgIqqJhQaBiqj2YW5PPPFEZs+enVWrVjUdO+2004oLRClV41Zp1a5///6ZOHFi0TFaVDW/3lfj9UrWFDe33XZbTjrppCTJtGnT8pnPfCYf+chHCk7GW7n44otz4YUXNm2FPGPGjNx+++256aabCk5GNVAKAGykoUOH5qmnnkqPHj2aLTBoWyC2pGrdKq3afe1rX8tOO+2Ufv36pa6urug4vINqvl6zZs3Kb3/72yTJUUcdlf3337/gRKzP+eefn5qamixbtizPPPNM03X64x//mIMPPjh33XVXwQmpBkoBoCJWrFiRhx56KLNnz242t3TAgAEFpmoZvXv3zn333edTWQplq7TWqXv37k2/r6mpSWNjY2pqajJz5swCU22ean69r8brRevy+OOPv+39Rx111BZKQjXzEy1QEf/1X/+VVatW5cADD0ybNm2KjtOi9txzz6xcuVIpQKGqdau0ajdr1qyiI7S4an69r8brlSQPP/xwRo0alblz52bVqlXKjq2YN/1sCX6iBSpi7ty5ue+++4qOURG77LJLzjrrrBx//PFp165d0/Fq+FSM1qNat0qrdr/73e+y//77Ny1Yt3jx4vzpT3/K4YcfXnCyTVfNr/fVeL2S5LrrrsuXv/zlHHjggc2mwbH1ueqqqzJixIimaQT/7Pvf/34Bqag2SgGgIg488MDMnj272TZV1WLPPffMnnvuWXQMSm59W6XZY3zrN2LEiGYL19XX12fkyJGtejG7an69r8brlSS77rprDjvssKJjsAE++tGPJkkGDhxYcBKqmVIAqIhPfOIT+chHPpJ3v/vdzT5Nr4ZG24gAtgb77LNPVW6VVu0aGxubDbFv06ZNs3n4rVE1v95X4/VKks985jP50pe+lH/9139tds3e//73F5iK9Rk5cmT++7//Oz/96U8zdOjQouNQpZQCQEVceumlueiii9ZZob8ajBs3br3HlQVsCWtXC38rfqjfunXq1Cm/+tWv0rNnzyTJL3/5y1Y/7aOaX++r8Xolaxavu++++/Lss882lR41NTVVUeRUmwULFuT//u//8qtf/SqvvPJK/nmN+N13372gZFQTpQBQEdttt10++clPFh2j4pYtW5ZHH320ad9gqLSbb745yZoV35966qlm21Mdcsghtqfayg0dOjQDBw5MXV1dGhsbs2zZstxyyy1Fx9os1fx6X43XK0kefPDBTJs2LbW1tUVH4R2cd955GTBgQF566aV87GMfa3ZfTU1Npk2bVlAyqoktCYGK+OY3v5ndd989vXv3zrbbblt0nIpasmRJBgwYkO9+97tFR6FELr744nzqU5/KwQcfnCR55pln8p3vfCc33XRTwcl4JytXrszzzz+fJNl7771b/U4m1f56X23XK0k+9alP5etf/3qzqQNs3S677LKMGjWq6BhUKaUAUBFr93Zeu1JuNW93tGrVqpxyyil54IEHio5CiZx66qn5yU9+0uxYnz59cu+99xaUiI3x+uuvZ9myZU23W/MQ4DK83lfT9UrWvMH84x//mH/9139tVuSYBrd1+9vf/pannnoqyZptaDt37lxwIqpF6686ga1Ste7tnCRXXHFF0+8bGxszc+bMHHHEEQUmoow6d+6cO+64I2eccUaS5Mc//nF22GGHYkPxjh577LEMGzYsr732Wurr6/OPf/wju+22Wx5++OGio22yan69r8brlazZraQad4uoZj/72c8ydOjQHHrooWlsbMxVV12V6667Lscdd1zR0agCRgoAbKRJkyY1/b5t27bZa6+9bO3EFjdv3rxcd911+c1vfpOampocffTR+eIXv5iuXbsWHY23cdppp+Ub3/hGPvvZz2by5Ml54IEH8vvf/z5f/OIXi47GepT1et1xxx35+Mc/XnQM3qR///4ZO3ZsU5kze/bsfOELX2j122OydTBSAKiI7t27p6ampmkY6VrVMJz09NNPLzoCpGvXrlWx4FnZtGnTJl27dm3a1u7DH/5wbrvttoJTbZ5qfr2vxuu1ISZPnqwU2MqsXLmy2eiOvfbaqyq2x2TroBQAKuLNw0mXLVuW//mf/8n8+fMLTNRynnzyydx8882ZM2dOs/+QrQDMlrRixYo89NBDmT17drO/h+YEb9222267rFq1Kvvuu29uvfXW7Lbbbs3mqrdG1fx6X43Xa0MYSLz12X333fPtb387Z599dpLkhz/8YXbbbbeCU1EtTB8Atpj+/ftXxTC33r17Z+DAgTnwwAOb7cn9rne9q8BUlM3nPve5rFixIgcffHCzv4dKga3brFmz8q53vSuLFy/OmDFjsnjx4lx00UVNu0hUi2p5vS/L9fpnp59+erOpchRv/vz5GTlyZH7zm98kSY455pgMHTo0u+66a8HJqAZGCgAV8fLLLzf9fvXq1XnqqafS0NBQYKKWs/322+fUU08tOgYl9+KLL+Z//ud/io7BRlq7Un99fX2uv/76gtO0jGp+va/G60XrtOuuu+bmm28uOgZVSikAVMR5553XNMd0m222yV577ZUbbrih6Fgt4qyzzsq3vvWtfOhDH2q2x3Nr36KK1mWfffbJ3/72t+y4445FR2EjvPTSS7n99tvXmX70/e9/v8BUm6eaX++r8XptiDZt2hQdgX/Sq1evnHXWWTnzzDOz0047FR2HKqMUACpi5513zg9/+MNmx84+++xMmDChoEQt54033sitt96a8ePHNy2qVVNTY00BtqiVK1emb9++Ofroo5uVUz7N3LoNGDAgp5xySk4++eRm0z5as2p+va/G6/XPfvCDH+RjH/tYs2M//vGPC0rDW7njjjty991354wzzsghhxySs88+Ox/84AeLjkWVUAoAFbFixYpmt5csWZJ//OMfBaVpWd/73vfy0EMPZZdddik6CiXWu3fv9O7du+kT2iTNVn5n67TNNtvkM5/5TNExWlQ1v95X2/WaPHnyOsfGjRuX9u3bJ1mzBSNbpz333DODBg3KwIEDM3Xq1Hzxi19Mu3bt8tGPfjTnnntu6urqio5IK6YUAFrUuHHjMm7cuCRJjx49kqxZxbhDhw5Vs73RHnvskZ133rnoGJTcIYcckqFDh2b+/Pl5+OGHM3PmzDz00ENFx+IdnHzyyfnJT36S3r17Z9ttty06zmYpw+t9NV2vJPniF7+Y4447Lp07d2461tDQ0LR4nVJg67ZgwYJMmjQpd999d3r06JEzzjgj06dPzyc/+cn893//d9HxaMXsPgBUxMiRI3PllVcWHaMirr322syePXudNQX8MMWWdP755+eSSy7J8OHDM3ny5DQ2NubUU0/NfffdV3Q03sb999+fL37xi00L8TU2NqampiYzZ84sONmmq+bX+2q7XtOnT8+Xv/zlnHvuuenbt2+S5MQTT8zDDz9ccDLeySWXXJLf//736du3b84+++xm6xj9+7//u4Vn2SxGCgAVUa0/ICZr1hTYeeed84c//KHZcaUAW9LSpUtz6KGHNt2uqanJNtv4b31rN3r06Nx555054IADqmYxt2p+va+263XkkUfmjjvuyNixY3Pffffl6quvNu2olTj++ONzww03rHfEypQpUwpIRDXx0wPARrKQG1uD2traLFq0qOkH+hkzZqS+vr7gVLyTXXfdNQcddFDRMdhA1Xi9tttuuwwZMiRPPfVUBg0alKVLlxYdibexdsvPI444Iq+99to69+++++5VMbWFYpk+ALCRVqxYkYceeiizZ89utkXVgAEDCkxF2UyfPj033nhjXnzxxRx22GGZOXNmxo4d22z0AFuf0aNHZ9GiRendu3ez6Ufvf//7C0zFW6n267Vy5cq89tpr2W233YqOwlvo3r17unbtmrZt2+af37bZ+YiWohQA2EgXXXRRVq1alQMPPLDZcNKLL764uFCU0sKFC/PEE0+ksbExhx56aHbYYYeiI/EOzj///HWO1dTUVP2+961Vma7XI488khNOOKHoGPyTK6+8Mr/97W9zwgkn5LTTTkv37t2LjkQVUgoAbKRTTjnFYm5ARfzud7/LEUccUXQMNlA1Xa/jjz8+jz76aNExWI9ly5Zl6tSpmTx5cl5//fX07ds3/fr1a7aLBGwOawoAbKQDDzwws2fPzl577VV0FKDKjBw5MpMmTSo6BhuotV2vK6644i3vW7hw4RZMwsbYbrvtcsopp+SUU07JtGnTMnTo0KxcuTKf/vSni45GlVAKAGykT3ziE/nIRz6Sd7/73c3mmFbjcFJgyzKAs3VpbdfrgQceyOWXX97s/65kzfOwLeHW69VXX83kyZNz3333Zc8998w111xjqgctSikAsJEuvfTSXHTRRenRo0fatm1bdBygitgernVpbdfrgAMOSPfu3fO+971vnfvGjh1bQCLeySc+8YksXrw4/fr1yx133GHKABWhFADYSNttt10++clPFh0DADbKl770pXTs2HG99917771bOA0b4te//nWS5JlnnsmXvvSlpuONjY2pqanJzJkzi4pGFVEKAGykD3/4w/nJT36S3r172xsYaFGtbTh62bW269WtW7e3vG/77bffgknYULNmzSo6AiVg9wGAjbR2O6C1w0a19UBLmTVrli3HWpHWeL3uv//+3H777XnuuedSU1OTfffdN5/61Kfy4Q9/uOhoQEGUAgAAFbZw4cLccssteeWVV3Lcccfl7LPPbrrv0ksvzejRowtMx8a44IILWu3Csj/96U8zYsSIDBw4MAcffHAaGxvzzDPPZNy4cbnqqqty0kknFR0RKIDpAwAAFXbVVVflXe96V/r165cJEybksccey5gxY7LtttvmL3/5S9Hx+Ccvv/zyeo83Njbm+eef38JpWs73v//93HLLLc0WGuzRo0f233//jB49WikAJaUUANhAp59+eiZNmpTu3bunpqamadqA6QPAO3nxxRdz8803J0lOPvnkjBo1Kp/61KfyjW98o9XNSy+DE088MXvsscd6r83f//73AhK1jPnz569354FDDjkk8+fPLyARsDVQCgBsoEmTJiWx6A+w8ZYtW9bs9mWXXZZvfvObueCCC7J06dKCUvFW9txzz/y///f/0rVr13Xu+9d//dcCErWM9u3bv+V99fX1WzAJsDVRCgAAVNh+++2XRx99NMcff3zTsYsuuijt27fPyJEjiwvGep122mmZP3/+ekuB/v37F5CoZcyfPz/jxo1b732vvfbaFk4DbC0sNAgAUGFrf9xau2vJmy1ZsuRtP8GFlvJWhcBaAwYM2EJJgK2JkQIAABX2yiuvvO39SoGty1stNLjW7rvvvoWStKwOHTqkrq6u2e4XSTJhwoQsX768oFRA0YwUAACosO7du6dr165p27btOovX1dTUZNq0aQUlY32q9XqdeeaZGT9+fNq1a9fs+PLly3PWWWdl8uTJxQQDCmWkAABAhZ155pn57W9/mxNPPDH9+vVL9+7di47E26jW67Vq1ap1CoEkadeuXVavXl1AImBrYKQAAMAWsGzZskydOjWTJ0/O66+/nr59+6Zfv37p3Llz0dFYj2q8XieffHJ+8pOfrFMMNDQ0pE+fPvnpT39aUDKgSEoBAIAtbNq0aRk6dGg+/elP59Of/nTRcXgH1XK9Ro0alVdffTXXXnttOnTokCRZvHhxhg8fnl122SWXXXZZwQmBIigFAAC2gFdffTWTJ0/Offfdlz333DP9+vXLCSecsN7h3BSvGq/X8uXLM2TIkPzsZz/Lu9/97iTJiy++mGOPPTajR49u1c8N2HRKAQCACvvEJz6RxYsXp1+/fjn11FNb9RD0Mqj26/XCCy9k5syZSZIePXo0FQRAOSkFAAAq7M0L1dXU1DT9vrGxMTU1NU1v0Ng6uF5AmSgFAAAAoKTaFB0AAAAAKIZSAAAAAEpKKQAAAAAlpRQAAACAklIKAAAAQEkpBQAAAKCklAIAAABQUv8/nWhFDgifC/sAAAAASUVORK5CYII=",
                         "text/plain": [
                             "<Figure size 1000x1000 with 4 Axes>"
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 }
             ],
             "source": [
                 "visualize.draw_heatmap(data=num_cell_type_per_cluster.apply(zscore).values,\n",
                 "                       x_labels=num_cell_type_per_cluster.index.values,\n",
                 "                       y_labels=num_cell_type_per_cluster.columns.values,\n",
-                "                       center_val=0)"
+                "                       center_val=0, save_dir=kmeans_out_dir, save_file='cell_type_heatmap')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.3 Cluster composition by mean marker expression\n",
                 "Finally, we want to examine the average marker expression of the cells assigned to each kmeans neighborhood cluster (z-scored for each marker)."
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 17,
+            "execution_count": null,
             "metadata": {
                 "tags": []
             },
             "outputs": [
                 {
                     "data": {
-                        "image/png": "iVBORw0KGgoAAAANSUhEUgAABAUAAAPiCAYAAAAHH2TAAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy88F64QAAAACXBIWXMAAA9hAAAPYQGoP6dpAABvN0lEQVR4nOzdebiUdcE//vc5IBwQRNQUNcIdXFMzcQnTIH2elMU1LbcsbVOLR0IQE1AL9xNqi1uKJqEWm5m4kKZZZpSaa5m5oSIugGwHBOb3Bz/mK4EEBjMT9+t1XVwX5545c7/PnDnnzLzns9SVSqVSAAAAgMKpr3YAAAAAoDqUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEE1X9kr3rrXp9ZkDqhJRz38u2pHAAAAWGOMFAAAAICCWumRAnXNmq3JHAAAAECFrXwpUF+3JnMAAAAAFWakAAAAABSUkQIAAABQUCtfCtQpBWBlTZs2Ld/5znfyyiuvpEWLFtlpp50ydOjQtGjRYqnrTZ06Nf369csbb7yRNm3a5KKLLsrWW29dpdQAAEDR1JVKpdLKXHHsQf+zprNAzelz14QP9XnTp0/Pc889l09+8pNZtGhR+vXrl5122iknnXTSUtc788wzs8MOO+SEE07IvffemxtuuCE/+9nPVkd0AACAf8tIAViB7t27r/DyiRMnLvf4+uuvn09+8pNJkvr6+uy000557bXXlrnePffck3POOad8riFDhuTtt9/Ohhtu+B8mBwAA+PdWYU2B+jWZA9Za8+bNy5gxY/Kd73xnqePTpk1LQ0ND1l133SSLi7cOHTrk9ddf/9ClwMCBA9PU1PQfZwaopoaGhgwbNqzaMQCgEIwUgBX4oJEAK2vRokU588wz07Vr1+y3336rKdUHa2pqSmNj4xo/D8Ca1Ldv32pHAIDCsCUhrEFDhw5NfX19zjrrrGUua9++fZqamjJnzpy0bt06pVIpU6ZMyaabblqFpAAAQBHZkhDWkIsuuihTpkzJlVdemfoPmH7To0eP3HbbbTnhhBMyceLEdOrUyXoCAABAxVhTANaA5557Ltddd1222mqrHHHEEUmSffbZJyeeeGJOOeWUjBs3LklyxhlnpF+/fhk5cmTWXXfdXHTRRdWMDQAAFMwqTB9QCsDK2nbbbfO3v/1tuZctKQSSZJNNNslNN91UqVgAAABLWYWFBpUCAAAAsDYxUgAAAAAKyit9AAAAKCgLDQIAAEBBrcL0gWZrMgcAAABQYauw0GDdmswBAAAAVJiRAgAAAFBQq7CmgJECAAAAsDYxUgAAAAAKypoCAAAAUFD2GQQAAICCMn0AAAAACmoVFho0qAAAAADWJkYKwBpyzjnn5L777svUqVPzt7/9bbnXOe644zJlypS0bt06SXLmmWdmn332qWRMAACgwCw0CGtIz549c/rpp2ffffdd4fXOP//8dO3atUKpAAAA/p+VLgVSrxSAVfHJT36y2hEAAABWaKVLgXrTByig7t27r/DyiRMn/sfnOPfcc1NfX59PfOIT6devX9q0afMf3yYAAMDKWPmRAnUWGoTV7eKLL06HDh0yf/78DBs2LBdccEHOP//8ascCAAAKYhV2HzB9gOJZHSMBVqRDhw5JkhYtWuSYY47JGWecsUbPBwAA8H6rsNCgkQKwOi1YsCAzZszIhhtumCS58847s91221U5FQAAUCS2JIQ1ZMCAAfn973+fJNlvv/3StWvX9OvXL6ecckrGjRuX+fPn5+STT857772XUqmUrbbaKoMHD65yagAAoEjsPgBryAUXXLDc4+PGjUuStG7dOqNHj65kJAAAgKWYPgAAAAAFtQrTB5QCAAAAsDZZhd0HlAIAAACwNrHQIAAAABSUt/8BAACgoFZh+oCRAgAsbeDAgWlqaqp2DNYyU6dOTd++fasdg7VQQ0NDhg0bVu0YADVlFUoBWxICsLSmpqY0NjZWOwbASlE2ASzLloQAAABQUBYaBAAAgIIyfQAAAAAKykgBAAAAKKiVLgViTQEAAABYq5g+AAAAAAVl9wEAAAAoqJWfPmCkAKySc845J/fdd1+mTp2av/3tb8u9ztSpU9OvX7+88cYbadOmTS666KJsvfXWFU4KAAAUlYUGYQ3p2bNnTj/99Oy7774feJ1LL7003bt3zwknnJB77703gwcPzs9+9rMKpgQAAIpsFdYUMH2A4unevfsKL584ceIHXvbJT37y397+Pffck3POOad8riFDhuTtt9/OhhtuuGpBAQAAPgQjBaBKpk2bloaGhqy77rpJkrq6unTo0CGvv/66UgAAAKiIVVho0JoCFM+KRgIAAAD8tzN9AKqkffv2aWpqypw5c9K6deuUSqVMmTIlm266abWjAQAABbHyuw/YkhBWux49euS2227LCSeckIkTJ6ZTp06mDgAAABWzCiMFTB+AVTFgwID8/ve/T5Lst99+6dq1a/r165dTTjkl48aNS5KcccYZ6devX0aOHJl11103F110UTUjAwAABWOhQVhDLrjgguUeX1IIJMkmm2ySm266qVKRAAAAlrIKCw2aPgAAAABrk5VfU8D0AQCAmjBw4MA0NTVVO8Z/nalTp6Zv377VjvFfp6GhIcOGDat2DGANWelSoN70AQCAmtDU1JTGxsZqx6AgFCmwdrP7AAAAABSUhQYBAACgoFZhS0IjBQAAAGBtsgqlgIUGAQAAYG1iTQEAAAAoKCMFAAAAoKBWYaHBlR9UAAAAANS+lS8F6owUAAAAgLWJLQmBwhs4cGCampqqHeO/0tSpU9O3b99qx/iv09DQkGHDhlU7BgCALQkBmpqa0tjYWO0YFIgiBQCoFUoBAAAAKKhV2JLQmgKwKp5//vn0798/s2bNyiabbJJLLrkkG2+88VLXGTBgQB5++OG0a9cuSfKlL30pffr0qUJaAACgiIwUgDVk8ODB+frXv54ePXpkxIgRufTSS3PhhRcuc73TTz89hx12WBUSAgAARbfSpUC9hQYpoO7du6/w8okTJy73+FtvvZUXX3wxPXr0SJIcccQR6dat23JLAQAAgGpZ+ekDRgrASpsyZUo23XTT8sfrrrtuWrZsmWnTpqV9+/ZLXfcnP/lJrr/++nTu3Dnf+c53sskmm1Q6LgAAUFBGCsAKfNBIgNWlb9++2XjjjVMqlXLNNddkwIABuf7669foOQEAAJZYhYUGjRSAldWhQ4e8/vrr5Y9nz56defPmLTNKYMmogLq6uhx77LH5yU9+UtGcAABAsa3CQoN2H4CVtdFGG6VTp065995706NHj/ziF78ory/wfm+88Ua5GPj1r3+dzp07VzoqAABQYKYPwBoyZMiQnHnmmbnooovKWxImSe/evXP11Vdnk002yZlnnpm33347SbLxxhvnggsuqGZkAACgYFZ++gCwSrbddtuMHj16mePjxo0r//+GG26oYCIAAIClrfz0gWb6AwAAAFibWFMAAAAACspIAQAAACgoIwUAAACgoFa+FKirX5M5AAAAgApb+VKguS0JAQAAYG1ipAAAAAAUlDUFAAAAoKBWfksBIwUAACi4gQMHpqmpqdoxKmrq1Knp27dvtWNUVENDQ4YNG1btGFARRgoAAMBKampqSmNjY7VjsIYVrQSh2FahFLDQIAAAAKxNVmGhQSMFAAAAYG2y8msKNDNSAAAAANYmK18KxEgBWBXPP/98+vfvn1mzZmWTTTbJJZdcko033nip68yePTtnnnlm/v73v6dFixYZOnRoPvGJT1QpMQAAUDQrXwpYaBBWyeDBg/P1r389PXr0yIgRI3LppZfmwgsvXOo61113XTbbbLNceeWVeeqpp/Ltb387d911V+rr7fYBAACseaswUgCKp3v37iu8fOLEics9/tZbb+XFF19Mjx49kiRHHHFEunXrtkwpMGHChFxxxRVJkh133DHt27fPk08+mV122WU1pAcAAFgxb0fCGjBlypRsuumm5Y/XXXfdtGzZMtOmTVvqeq+//no233zz8sebbrppXn/99YrlBAAAis2aArACHzQSAAAAYG2w0qVAaU2mgLVMhw4dlnrHf/bs2Zk3b17at2+/1PU23XTTvPrqq9l6662TLB458P4RBgAAAGvSypcCWgFYaRtttFE6deqUe++9Nz169MgvfvGL8voC73fQQQfllltuyVlnnZWnnnoq77zzTnbaaacqJIY1b+DAgWlqaqp2jJowderU9O3bt9oxakJDQ0OGDRtW7RgAUFirMFJAKwCrYsiQITnzzDNz0UUXlbckTJLevXvn6quvziabbJIvf/nL6d+/fw488MCss846ueCCC+w8wFqrqakpjY2N1Y5BjVGOAEB1GSkAa8i2226b0aNHL3N83Lhx5f+3adMmP/rRjyoZCwAAoGylS4GFi7QCAAAAsDZZhd0HAABYkUqtnVGpdSms+QCw9lvpUmCRkQIAACu0tq2dYc0HgLXfypcCFhUAAACAtcrKrymwcNGazAEAAABU2CrsPmCkAAAAAKxNTB8AAACAglqF6QNKAQAAAFibGCkAAAAABWVLQgAAACgoCw0CAABAQa10KbBgkS0JAQAAYG2y8iMFTB8AAN5n4MCBaWpq+o9uY+rUqenbt+9/nKWhoSHDhg37j28HAIrGQoMAwIfS1NSUxsbGasdIktVSLABAEdmSEKpk0qRJGTJkSObPn5/tttsuF154YdZdd91lrnfcccdlypQpad26dZLkzDPPzD777FPpuAAAwFrISAGogkWLFmXgwIH5wQ9+kB133DHf//73c9111+X0009f7vXPP//8dO3atcIpAQBWzuqYTlRLVtfUplpgehX/zsqPFLDQIAXUvXv3FV4+ceLED3W7Tz75ZNq3b58dd9wxSfL5z38+p5122geWAgAAtayWphOxtLWl3GDNWelSAFh9Xn/99Wy22WbljzfbbLO8/vrrH3j9c889N/X19fnEJz6Rfv36pU2bNpWICQAArOVWfvqA3QcooA87EiBJDj300Lz22mvLHN9pp51y1FFHrfTtXHzxxenQoUPmz5+fYcOG5YILLsj555//oXMBAAAssQrTB5QCsCrGjBnzgZf99a9/XaoweO2117Lpppsu97odOnRIkrRo0SLHHHNMzjjjjNUbFAAAKCwjBaAKdtppp7zzzjt56qmnsuOOO+aWW27JQQcdtMz1FixYkBkzZmTDDTdMktx5553ZbrvtKh0XAABYSxkpAFVQX1+fYcOGpX///nnvvfey7bbb5sILL0ySvPHGGznllFMybty4zJ8/PyeffHLee++9lEqlbLXVVhk8eHCV0wPw32B1rAa/ulZgt/o5QO1a6VKgZEtC+NA+6InZ+9/1/+53v1v+/1ZbbVV+EtapU6elPmdF6wlUavscT+4Aal8trQZv9XOA2rXSpcCChbYkhA+rlp6YrQ6e3AEAwNphFUYKrMkYAAAAQKWt/EKDWgGAmrc65hCvKZWa3vJhmBIDABSVNQUA1iJr21SVSqnVsgIAYE2zJSEAAAAUlC0JAahZlZoOYecOKAbbNAIsy5oCANSstW06hGkKUF219DvF7wOgVth9AAAAYDWrlcV/a2mhXyNkatNKlwILFi5akzkAAADWGrU0MqVW1Eo5wdKMFAAAAICCsqYAAAAAFNQqjBRQCgAAAMDaZBXWFFAKAAAAwNrEmgJQJV/72tfy2GOPpXXr1vnNb37zgdd7/vnn079//8yaNSubbLJJLrnkkmy88cYVTAoAAKytrCkAVXL88cfn9NNPz6mnnrrC6w0ePDhf//rX06NHj4wYMSKXXnppLrzwwgqlBADWZqtr27zVse2d7eqgOla6FFi4SCkAq9M+++yTyZMnr/A6b731Vl588cX06NEjSXLEEUekW7duSgEAYLWopW3zbFcH1WGkAKxA9+7dV3j5xIkT1+j5p0yZkk033bT88brrrpuWLVtm2rRpad++/Ro9NwAAsPZb+ZECFhqEVXLooYfmtddeS5LMnj07Xbt2TZLstNNOue6666oZDQAAIImFBmGF/pORAGPGjCn/v2/fvh9qaF6HDh3y+uuvlz+ePXt25s2bZ5QAAACwWpg+ADVso402SqdOnXLvvfemR48e+cUvflFeXwAAAOA/tQqlwJqMAcVz4okn5h//+Efeeeed7Lfffundu3fOOOOMPPHEE7n88stzzTXXJEmGDBmSM888MxdddFF5S0IAAIDVYRWmD2gFYHW64YYblnt85513LhcCSbLttttm9OjRFUoFAAAUiS0JAQAAoKBWfvqAUgAAAADWKqswUmBNxgCA2jZw4MA0NTX9R7cxderU9O3b9z/O0tDQkGHDhv3HtwMAYPcBAFgJTU1NH2pr0TVhdRQLAADJKi00uCZjAAAAAJVmpABAjTA8HQCASluFUmBNxgDA8HQAACrNloQAAABQUKuwpoBSAAAAANYmK10KLFi4JmMAAAAAlWakAAAAABSUhQYBAACgoCw0CAAA8D61sk1wLW0R7D5Ze610KQAAAFAEtbJNcC1tEew+WXut/EKDRgrAavW1r30tjz32WFq3bp3f/OY3H3i9z3zmM2loaMg666yTJLn00kuzzTbbfKhzro6GN9HyAgDA2mIVFhpckzGgeI4//vicfvrpOfXUU//tda+++up89KMf/Y/PWSsNb6LlBQCAWmChQViB7t27r/DyiRMnfujb3meffTJ58uQP/fkAAAD/KQsNwn+BU089NYsWLcqnP/3pnH766eWpBAAAAP8JIwVgBf6TkQCHHnpoXnvttSTJ7Nmz07Vr1yTJTjvtlOuuu26lb2fkyJHp0KFDZs+enf79++faa6/N17/+9Q+dCwAAYAkjBWANGTNmTPn/ffv2/dBz+Tt06JAkWXfddXPEEUfklltuWS35AAAAVn6kwKI1GQNYnjlz5mTRokVp06ZNFixYkLvvvjudO3eudiwAAGAtYfoAVMmJJ56Yf/zjH3nnnXey3377pXfv3jnjjDPyxBNP5PLLL88111yTt99+u7yewMKFC7Pbbrvla1/7WrWjAwAAa4lV2JJQKwCr0w033LDc4zvvvHOuueaaJEnHjh0zbty4CqYCAACKxEgBAAAAKKhVWGhwTcYAAAAAKm0VRgoYKgAAAABrk5UuBRYYKQAAAABrFWsKAAAAQEGtwu4DazIGAAAAUGlGCgAAAEBBWWgQAAAACqquVPJqH1bk9p49qx0hSTL3zWnVjlBWv85K94lrVO+7fl3tCGWzmt6rdoQkSYs571Y7QtlfXm+qdoSytq1bVDtCkmTG7HnVjlC24V/uqXaEJMkGO+5U7Qhlo16ujcdJkjz7Wm38/MyaVztPE4/ttkm1IyRJOm7SttoRyr5323PVjlC2zca18fPT9F7trI4+d35t/Px0aFcbz9uSpG2r2sny7S/sVe0INaO+2gEAAACA6lAKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABdW82gEAAADgv8H8+fPT2NiYe++9N61bt06zZs3Sq1evzJw5M0ly2mmnrfJtTp48OY888kgOO+ywD5XpiiuuyNixYzN58uRMnDgxH/3oR1fp840UAAAAgJXQv3//vP766xk/fnzGjRuXkSNHpmXLlv/Rbb766qsZM2bMKn/eokWLUiqV0q1bt9x0003ZfPPNP9T5jRQAAACgULp3777CyydOnLjMsRdeeCH3339/HnjggbRq1SpJ0tDQkGOOOSZXXHFF+XoDBgzInnvuWX7n/7jjjsupp56arl27Zvjw4bn77rtTX1+f9ddfPzfddFPOP//8TJ48Ob17987uu++ewYMHZ9KkSbnsssvS1NSUVq1aZejQodlmm20yevTo3Hnnnamrq8srr7ySkSNHZtddd/2P7ovVWgoMHDgwTU1Nq/MmoaoaGxurHQEAAKgBzzzzTDp16pT11lvvQ33+9OnTM2HChNxxxx2pr6/PjBkzkiRnn312rrzyytx0003l61144YW59tpr065duzz66KMZNGhQbrnlliTJ448/nvHjx6dDhw6r5etaraVAU1OTF1EAAADUtOWNBFjT2rZtm9atW2fQoEHZe++9c8ABByz3eo899lheeumlHH/88eVjSwqEJNlrr71WWyGQmD4AAAAA/9b222+fl19+OTNnzkzbtm0/8HrNmjXLokWLyh/PmzevfHzUqFGZNGlSHnzwwTQ2Ni53LYFSqZTddtstV1111XJvv3Xr1v/hV7I0Cw0CAADAv7HlllumW7duGTJkSObOnZtk8Qv+UaNGLXW9jh075oknnkiSPP/883n22WeTJLNmzcr06dOz9957p1+/fmloaMiUKVPSpk2bzJo1q/z5u+66a55++uk89dRTSRYvKPj000+vsa/LSAEAAABYCRdffHEaGxvTs2fPtGrVKnV1dTn88MOXus5RRx2VU089NYcccki6dOmSLl26JFlcCpx22mlpampKqVTK/vvvn86dO2fhwoXZYIMN0rNnz+yxxx4ZPHhwhg8fnvPOOy9z5szJe++9lwMPPDA77LDDcjP94Ac/yOjRo/PWW2/l6KOPzpZbbllen2Bl1JVKpdKHv0uW1rdvX2sKsNa5vWfPakdIksx9c1q1I5TVr1MbfWLvu35d7Qhls5req3aEJEmLOe9WO0LZX16vnYVn27ZuUe0ISZIZs+dVO0LZhn+5p9oRkiQb7LhTtSOUjXq5Nh4nSfLsa7Xx8zNr3mp7mvgfO7bbJtWOkCTpuMkHDxmutO/d9ly1I5Rts3Ft/Pw0vbfo31+pQubOr42fnw7tauN5W5K0bVU7Wb79hb2qHaFmmD4AAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACio5tUOALWux89HVTtCkqRZfV21I5Qtmj2z2hGSJJPvvavaEcr+9P1Lqx0hSbLOuq2qHaFs0cJF1Y5QNnfzTaodIUky5613qh2hbJ2P71jtCEmSWS+/Uu0IZTv87/HVjlDW51NbVjtCkqTttNeqHaHsnScnVTtCkqT9uttXO0LZoA2eqnaEsmbr1Mbfnw1q5HdbkrTeeONqR0iSNLXZoNoRylo3tKh2BJbDSAEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUM2rHQAAAAD+G8yfPz+NjY25995707p16zRr1iy9evXKzJkzkySnnXbaKt/m5MmT88gjj+Swww77j7L96Ec/yvDhwzNx4sR89KMfXenPUwoAAADASujfv3+SZPz48WnVqlWampoyZsyYcinwYbz66qsZM2bMKpcCixYtSl1dXerq6vKPf/wjf/7zn7PZZput8vmVAgAAABRK9+7dV3j5xIkTlzn2wgsv5P77788DDzyQVq1aJUkaGhpyzDHH5Iorrihfb8CAAdlzzz3LL/KPO+64nHrqqenatWuGDx+eu+++O/X19Vl//fVz00035fzzz8/kyZPTu3fv7L777hk8eHAmTZqUyy67LE1NTWnVqlWGDh2abbbZJqNHj86dd96Zurq6vPLKKxk5cmTatWuXoUOH5rzzzstJJ520yvdFTZYCAwcOTFNTU7VjQBobG6sdAQAAqAHPPPNMOnXqlPXWW+9Dff706dMzYcKE3HHHHamvr8+MGTOSJGeffXauvPLK3HTTTeXrXXjhhbn22mvTrl27PProoxk0aFBuueWWJMnjjz+e8ePHp0OHDkmS66+/Pvvuu2+22GKLD5WrJkuBpqYmL8YAAABYI5Y3EmBNa9u2bVq3bp1BgwZl7733zgEHHLDc6z322GN56aWXcvzxx5ePLSkQkmSvvfYqFwIvv/xy7rzzztx8880fOldNlgIAAABQS7bffvu8/PLLmTlzZtq2bfuB12vWrFkWLVpU/njevHnl46NGjcqkSZPy4IMPprGxMWPGjFnm80ulUnbbbbdcddVVy7391q1bl///+OOP59VXX81BBx2UJJkyZUq+8IUv5Ic//GF23nnnlfq6bEkIAAAA/8aWW26Zbt26ZciQIZk7d26SxS/4R40atdT1OnbsmCeeeCJJ8vzzz+fZZ59NksyaNSvTp0/P3nvvnX79+qWhoSFTpkxJmzZtMmvWrPLn77rrrnn66afz1FNPJVm8oODTTz+93Ew9e/bMQw89lN/85jf5zW9+kw4dOmTkyJErXQgkRgoAAADASrn44ovT2NiYnj17plWrVqmrq8vhhx++1HWOOuqonHrqqTnkkEPSpUuXdOnSJcniUuC0005LU1NTSqVS9t9//3Tu3DkLFy7MBhtskJ49e2aPPfbI4MGDM3z48Jx33nmZM2dO3nvvvRx44IHZYYcd1sjXpBQAAACAldCyZcsMGDAgAwYM+MDrbLDBBhk5cuRyL7vtttuWOda8efNcd911Sx3bfffdlxmBkCSHHXbYCrcu/M1vfvOBl30Q0wcAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAXVvNoBoNY1zV9Q7QhJkslTZ1Q7Qtk6zZpVO0KS5NUxY6sdoWy/seOqHaHmvLdgUbUjlG2ybm08Zheu07LaEcqa19dVO0KSZFHTnGpHKPvzBcOqHaFs3g47VDtCkmSdjh2rHaFs/c5dqh0hSTJ10p+qHaFsi4MPqXaEspbrt692hCTJO02187en1XoN1Y6w2JTXq52g7L135lc7wv+zXm38nq0FRgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAgmpe7QAAAADw32D+/PlpbGzMvffem9atW6dZs2bp1atXZs6cmSQ57bTTVvk2J0+enEceeSSHHXbYKn/uokWLcvrpp+e5555LixYt0qlTp5x33nlp3779St+GkQIAAACwEvr375/XX38948ePz7hx4zJy5Mi0bNnyP7rNV199NWPGjFnlz1u0aFFKpVIOO+ywTJgwIbfffns6deqUK6+8cpVuRykAAAAA/8YLL7yQ+++/P+eee25atWqVJGloaMgxxxyz1PUGDBiQ0aNHlz8+7rjj8sc//jFJMnz48Bx88MHp2bNnjjvuuCTJ+eefnyeffDK9e/fO0KFDkySTJk3KF77whRx22GH54he/mH/84x9JktGjR+fkk0/OKaeckoMPPjjvvvtuPvOZz6Suri5Jsssuu+S1115bpa/L9AEAAAAKpXv37iu8fOLEicsce+aZZ9KpU6est956H+qc06dPz4QJE3LHHXekvr4+M2bMSJKcffbZufLKK3PTTTeVr3fhhRfm2muvTbt27fLoo49m0KBBueWWW5Ikjz/+eMaPH58OHTosdfulUim33HJLPvvZz65SLqXAf4mBAwemqamp2jEKp7GxsdoRAACAtUDbtm3TunXrDBo0KHvvvXcOOOCA5V7vsccey0svvZTjjz++fGxJgZAke+211zKFQJJcdNFFaWhoyNFHH71KuZQC/yWampq8QAUAAFgNljcS4N/Zfvvt8/LLL2fmzJlp27btB16vWbNmWbRoUfnjefPmlY+PGjUqkyZNyoMPPpjGxsblriVQKpWy22675aqrrlru7bdu3XqZY1dffXWefPLJXHvtteWpBCvLmgIAAADwb2y55Zbp1q1bhgwZkrlz5yZZ/IJ/1KhRS12vY8eOeeKJJ5Ikzz//fJ599tkkyaxZszJ9+vTsvffe6devXxoaGjJlypS0adMms2bNKn/+rrvumqeffjpPPfVUksULCj799NMfmOvmm2/OXXfdlR//+McfatFDIwUAAABgJVx88cVpbGxMz54906pVq9TV1eXwww9f6jpHHXVUTj311BxyyCHp0qVLunTpkmRxKXDaaaelqakppVIp+++/fzp37pyFCxdmgw02SM+ePbPHHntk8ODBGT58eM4777zMmTMn7733Xg488MDssMMOy+SZNWtWzjvvvHz0ox/NF7/4xSTJNttsk0svvXSlvyalAAAAAKyEli1bZsCAARkwYMAHXmeDDTbIyJEjl3vZbbfdtsyx5s2b57rrrlvq2O67777MCIQkOeyww3LYYYeVP27Tpk15JMKHZfoAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFFTz1XljDQ0N6du37398O1OnTl0NaQAAAIAVWa2lwLBhw1bL7ayOYgEAAABYMdMHAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFFTzageoNQMHDkxTU1O1Yyxj6tSp1Y5QWG0a1ql2hCRJs/ra6fDq6+uqHSFJsunA71U7QlnrhhbVjpAkmTlnXrUjlHXYYN1qRyh7889/qnaEJEmbzTevdoSyJ2fWxu+Uzm0XVTtC2e79B1Q7QtnTP72u2hGSJK023qTaEcpennBntSMkSZq3alXtCGWv/e7BakcoWzB7TrUjJEmmPftstSOU/bNFbTw3mFtDryMWNNXO85SDfj6q2hFqhlLgXzQ1NaWxsbHaMZbRt2/fakcAAABgLVMbbxMAAAAAFacUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUVPNqBwAAAID/BvPnz09jY2PuvffetG7dOs2aNUuvXr0yc+bMJMlpp522yrc5efLkPPLIIznssMM+VKaFCxemsbEx99xzT1q0aJGddtopw4YNW+nPVwoAAADASujfv3+SZPz48WnVqlWampoyZsyYcinwYbz66qsZM2bMKpcCixYtSl1dXa6//vq89dZb+fWvf51mzZrlrbfeWqXbUQoAAABQKN27d1/h5RMnTlzm2AsvvJD7778/DzzwQFq1apUkaWhoyDHHHJMrrriifL0BAwZkzz33LL/IP+6443Lqqaema9euGT58eO6+++7U19dn/fXXz0033ZTzzz8/kydPTu/evbP77rtn8ODBmTRpUi677LI0NTWlVatWGTp0aLbZZpuMHj06d955Z+rq6vLKK69k5MiRGTFiRMaMGZNmzZolSTbaaKNVui+UAv8lGhoa0rdv32rHKJzGxsZqRwAAAGrAM888k06dOmW99db7UJ8/ffr0TJgwIXfccUfq6+szY8aMJMnZZ5+dK6+8MjfddFP5ehdeeGGuvfbatGvXLo8++mgGDRqUW265JUny+OOPZ/z48enQoUNmzpyZefPmZdSoUbnvvvvS0NCQb33rW9lzzz1XOpdS4L/EqswJAQAA4IMtbyTAmta2bdu0bt06gwYNyt57750DDjhgudd77LHH8tJLL+X4448vH1tSICTJXnvtlQ4dOiRJFixYkBkzZqRt27b55S9/mWeffTZf+cpXcuedd6Zt27YrlUspAAAAAP/G9ttvn5dffjkzZ85c4QvuZs2aZdGiReWP582bVz4+atSoTJo0KQ8++GAaGxszZsyYZT6/VCplt912y1VXXbXc22/dunX5/+3bt0/r1q3Ts2fPJEmXLl3SoUOHvPjii9l5551X6uuyJSEAAAD8G1tuuWW6deuWIUOGZO7cuUlSHrr/fh07dswTTzyRJHn++efz7LPPJklmzZqV6dOnZ++9906/fv3S0NCQKVOmpE2bNpk1a1b583fdddc8/fTTeeqpp5IsXlDw6aef/sBc//u//5vf/e53SRYvWjhlypR87GMfW+mvy0gBAAAAWAkXX3xxGhsb07Nnz7Rq1Sp1dXU5/PDDl7rOUUcdlVNPPTWHHHJIunTpki5duiRZXAqcdtppaWpqSqlUyv7775/OnTtn4cKF2WCDDdKzZ8/sscceGTx4cIYPH57zzjsvc+bMyXvvvZcDDzwwO+yww3IznXHGGTnzzDNzzTXXpFmzZjnvvPPSrl27lf6alAIAAACwElq2bJkBAwZkwIABH3idDTbYICNHjlzuZbfddtsyx5o3b57rrrtuqWO77777MiMQkuSwww5bZuvCDTfcMNdee+3KxF8u0wcAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAXVvNoBlqehoSF9+/atyrmnTp1alfNSu+bOX1jtCEmS2XPnVztC2Wtvz652hCTJ7KYF1Y5Q9tpbs6odIUny7pzaeZzMnls7358W67SrdoQkyTr/nFPtCGVPvzyz2hGSJE9s0LLaEcr2eue+akco26p372pHSJJM/8c/qh2h7Neb9qh2hCRJx40aqh2hbLuP1sbvtiSZ9Pe3qx0hSbJN727VjlBWKlU7wWLvLVxU7Qhl89+rjefVLK0mS4Fhw4ZV7dzVKiMAAACg0kwfAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACqp5tQMAAADAf4P58+ensbEx9957b1q3bp1mzZqlV69emTlzZpLktNNOW+XbnDx5ch555JEcdthhHyrTN77xjUyePDlJ8pGPfCTnn39+Nt1005X+fKUAAAAArIT+/fsnScaPH59WrVqlqakpY8aMKZcCH8arr76aMWPGrHIpsGjRotTV1eXCCy9M27ZtkyQ33nhjLrvsslx88cUrfTtKAQAAAAqle/fuK7x84sSJyxx74YUXcv/99+eBBx5Iq1atkiQNDQ055phjcsUVV5SvN2DAgOy5557lF/nHHXdcTj311HTt2jXDhw/P3Xffnfr6+qy//vq56aabcv7552fy5Mnp3bt3dt999wwePDiTJk3KZZddlqamprRq1SpDhw7NNttsk9GjR+fOO+9MXV1dXnnllYwcOTLt27cvn3v27Nmpq6tbpftCKVCjBg4cmKampmrHKLzGxsZqRwAAAGrAM888k06dOmW99db7UJ8/ffr0TJgwIXfccUfq6+szY8aMJMnZZ5+dK6+8MjfddFP5ehdeeGGuvfbatGvXLo8++mgGDRqUW265JUny+OOPZ/z48enQoUP5tvv375/f//73WX/99XP99devUi6lQI1qamryghQAAGANWN5IgDWtbdu2ad26dQYNGpS99947BxxwwHKv99hjj+Wll17K8ccfXz62pEBIkr322mupQiBJLrrooiTJDTfckB/+8IcZMmTISuey+wAAAAD8G9tvv31efvnlf7t+QLNmzbJo0aLyx/PmzSsfHzVqVHr16pVnn302vXr1yvTp05f5/FKplN122y3jxo0r/7v//vvLl7du3foDz33kkUdm3Lhxq/R1KQUAAADg39hyyy3TrVu3DBkyJHPnzk2y+AX/qFGjlrpex44d88QTTyRJnn/++Tz77LNJklmzZmX69OnZe++9069fvzQ0NGTKlClp06ZNZs2aVf78XXfdNU8//XSeeuqpJIsXFHz66aeXm2nOnDl57bXXyh9PmDAh22677Sp9XaYPAAAAwEq4+OKL09jYmJ49e6ZVq1apq6vL4YcfvtR1jjrqqJx66qk55JBD0qVLl3Tp0iXJ4lLgtNNOS1NTU0qlUvbff/907tw5CxcuzAYbbJCePXtmjz32yODBgzN8+PCcd955mTNnTt57770ceOCB2WGHHZbJ09TUlG9/+9uZO3du6urq0qFDh1XaeSBRCgAAAMBKadmyZQYMGJABAwZ84HU22GCDjBw5crmX3Xbbbcsca968ea677rqlju2+++7LjEBIksMOO2yprQs32GCD3HrrrSsbf7lMHwAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFFTzageoNQ0NDenbt2+1Y2Tq1KnVjsD/74JRj1Y7QpLk0L0/Wu0IZZttuG61IyRJHv/nO9WOUHPWaVY7Xe9Rn+lS7QhlN9/zdLUjJEm23bxdtSOUfWbX1tWOkCQZ+4dXqx2hbNs99692hLJ359TGz/JLzTpWO0JZ911r42/Pw8++Ve0IZV132KzaEcp2aD2v2hGSJAvmzKl2hLIFc+dWO0KSpOVG61c7Qtl6H9uy2hFYDqXAvxg2bFi1IyRJTRQTAAAArN1qo4YGAAAAKk4pAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoqObVDgAAAAD/DebPn5/Gxsbce++9ad26dZo1a5ZevXpl5syZSZLTTjttlW9z8uTJeeSRR3LYYYd9qEzHHXdcpkyZktatWydJzjzzzOyzzz4r/flKAQAAAFgJ/fv3T5KMHz8+rVq1SlNTU8aMGVMuBT6MV199NWPGjFnlUmDRokWpq6tLkpx//vnp2rXrhzq/UgAAAIBC6d69+wovnzhx4jLHXnjhhdx///154IEH0qpVqyRJQ0NDjjnmmFxxxRXl6w0YMCB77rln+UX+cccdl1NPPTVdu3bN8OHDc/fdd6e+vj7rr79+brrpppx//vmZPHlyevfund133z2DBw/OpEmTctlll6WpqSmtWrXK0KFDs80222T06NG58847U1dXl1deeSUjR478j+8LpUCNamhoSN++fasdo/AaGxurHQEAAKgBzzzzTDp16pT11lvvQ33+9OnTM2HChNxxxx2pr6/PjBkzkiRnn312rrzyytx0003l61144YW59tpr065duzz66KMZNGhQbrnlliTJ448/nvHjx6dDhw7l2z733HNTX1+fT3ziE+nXr1/atGmz0rmUAjVq2LBh1Y4AAACwVlreSIA1rW3btmndunUGDRqUvffeOwcccMByr/fYY4/lpZdeyvHHH18+tqRASJK99tprqULg4osvTocOHTJ//vwMGzYsF1xwQc4///yVzqUUAAAAgH9j++23z8svv5yZM2embdu2H3i9Zs2aZdGiReWP582bVz4+atSoTJo0KQ8++GAaGxszZsyYZT6/VCplt912y1VXXbXc21+yoOASSwqCFi1a5JhjjskZZ5yxSl+XLQkBAADg39hyyy3TrVu3DBkyJHPnzk2y+AX/qFGjlrpex44d88QTTyRJnn/++Tz77LNJklmzZmX69OnZe++9069fvzQ0NGTKlClp06ZNZs2aVf78XXfdNU8//XSeeuqpJIsXFHz66aeXm2nBggV5++23yx/feeed2W677Vbp6zJSAAAAAFbCxRdfnMbGxvTs2TOtWrVKXV1dDj/88KWuc9RRR+XUU0/NIYccki5duqRLly5JFpcCp512WpqamlIqlbL//vunc+fOWbhwYTbYYIP07Nkze+yxRwYPHpzhw4fnvPPOy5w5c/Lee+/lwAMPzA477LBMnvnz5+fkk0/Oe++9l1KplK222iqDBw9epa+prlQqlT78XQJrv7N+8kC1IyRJDt37o9WOUHMe/+c71Y5QtsUmK7+Yy5o0d96CakcoO3DPraodoezme5bfrlfatpu3q3aEsmbN6qodIUky9g+vVjtCWc89N6t2hLJ1mtfGYM6X3vjwW2ytbptvtG61IyRJHn72rWpHKPvWYbtUO0LZzBdfqHaEJMmCOXOqHaFswf//TnK1tVx//WpHKFvvY52qHaFsnXbrVztCzaiNvzgAAABAxSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFVVcqlUrVDgEAAABUnpECAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAFDz5s6dW+0IwGrw/PPPVzsCAP9CKQAV8vOf/7zi53z00UfzrW99KwcffHAOOeSQfPvb385jjz1W8Rw33XRT3nrrrYqfd3lmz56dyy+/PFdccUXmzp2ba6+9Nj179swZZ5yRd955p9rxkiSNjY1VO/djjz2W22+/PWPHji3/q6aHH344Z555Zvbbb7+q5kiSm2++uWrnfu+993LHHXfkJz/5Sa688sryv0rq2rVrhg4dmscff7yi512R448/PjNmzCh/PH369HzpS1+qaIY5c+ZkwoQJueGGG3LDDTdkwoQJmT17dkUzfJD33zeV9te//jUTJkwo/179+9//ntNPPz3HHXdcxTK88cYb6d+/fwYMGJC33347Q4cOzW677Zajjz46r7zySsVy/DvPPvtsRc/3/PPPl/8mv/rqq5kwYUL+8Y9/VDRDksybNy8jR47MxIkTkyR33HFHzj333IwcOTILFy6seJ7lmTZtWsXP+cILL2TgwIE5/PDDc/jhh2fgwIF54YUXKp7jlVdeKf+cvPjii7n++uvzu9/9ruI5lqd///7VjrDWqSuVSqVqh4Ai2H///XP//fdX7HyPPPJITj311BxzzDHZeeedkyRPPPFERo0alSuvvDKf/OQnK5Zl1113TbNmzbLbbrvl0EMPzWc/+9m0aNGiYud/v29/+9vp0KFD5syZkxdffDE77bRTDj300Nx111154YUXcumll1Yl1/tV+rGyxKBBg/LXv/4122+/fZo1a1Y+PmzYsIrmeOGFFzJ27NiMHz8+77zzTs4888wcdNBB2XDDDSuWYXllyIUXXpgzzzwzSdKnT5+KZUmSU045JQsXLsyOO+6Y+vr/1+d/+9vfrliGHj165OCDD87tt9+eli1bpk+fPundu3c6dOhQsQz/qnfv3hk3btxSxw499NCMGTOmIue/9957c95552WPPfYo3w+vv/56/vznP+e73/1uevToUZEcSXLNNdfk5JNPTrL4Z+hrX/taZsyYkYaGhvzwhz/MjjvuWLEsV155ZW688cZsscUWmTZtWo488sj8+Mc/zgknnJCvfOUradOmTUVyfOUrX8mnP/3pzJ49O3fccUeOPPLIHHHEEbnzzjtzzz335Cc/+UlFcvw7lfyd/+Mf/zi33XZbmjdvnpNPPjk//vGPs8suu+SJJ57ISSedlC9+8YsVyZEkZ5xxRhYsWJCmpqa0b98+U6dOTY8ePfKHP/wh66+/fs4777yKZfkglf57/Ic//CH/93//l6OOOmqp52633XZbLr300uy9994VyXHzzTfnuuuuy6JFi/LlL385d9xxR3bbbbf8/ve/z+GHH57jjz++IjmSZODAgcscu+uuu3LQQQclqfxzlLVV82oHgLXJB/2SLJVKFX8X+pprrsnFF1+cT3/60+VjPXr0yB577JGrrrqqoqXAFltskZ/97Ge58847M2rUqAwdOjQHHXRQ+vTpk0984hMVy5EsfofkBz/4QRYtWpR99tknI0aMSF1dXbbddtv06tWrYjm6d+++3OOlUqlqoyomTZqUO+64I82bV+dPw8iRIzNu3Li8+eab6d27d37605/my1/+cr7whS9UPMtZZ52V/fbbL+3bty8fa2pqyh//+McklS8FXn311dxxxx0VPee/atu2bfr27Zu+ffvm4Ycfzrhx49KzZ8/stNNO6d27d8XvkyRZtGhRZs6cmbZt2yZJ3n333SxYsKBi57/00kszatSobLrppksdf+2113LSSSdVtBT49a9/XS4FLrnkkpx66qnp2bNnfv/73+f73/9+RUe6/OpXv8qdd96ZDTfcMC+//HI+97nP5ZZbbqloMZEkb775Znlkws0331z+G3344YfnpptuqmiWFY3smTVrVsVy/OpXv8odd9yRuXPnpnv37rnzzjvToUOHzJgxI1/84hcrWgr8/e9/z+2335733nsvn/rUp/Lggw+mRYsW+fznP1/R3ycfNCKuVCpVfOraZZddlquuuiq77LJL+ViPHj3SvXv3nHvuufnFL35RkRy33HJL+XHymc98Jvfee2822mijvPvuuznuuOMqWgo8+OCD+dSnPpW99torS97Lvu+++7LnnntWLEMRKAVgNXr66adz6aWXplWrVksdL5VK6du3b0WzvPzyy0sVAkt069Yt559/fkWz1NXVpU2bNjnyyCNz5JFH5tVXX824ceNy1llnZdGiRbnnnnsqlmXJC976+vpsv/32qaurWypnpcyZMyfXX399+cXMEqVSKcccc0zFcrzfRz/60SxYsKBqpcC5556brl275vrrr0+nTp2SVPZ78n433nhjLrnkknzuc58rl0V//OMfq/aOxI477phXXnklHTt2rMr5/9Vee+2VvfbaK4MHD87dd9+dcePGVaUUOOaYY3Lsscfm0EMPTZKMGTOmoj8/CxcuXKYQSJLNNtusqsOfJ0+enJ49eyZJ9tlnn1x44YUVPX+rVq3KI3s+9rGPZcstt6x4IZAs/ftjn332WeqyRYsWVTTLVVddla985StLjcKqhubNm6dVq1Zp1apV1l133fIIl3bt2i01CqkSlrzAW7hw4VI/L/X19RX9/gwaNCg9e/Zc7t+b+fPnVyxHsniK4/sLgSV22WWXik5LatasWflx0rFjx2y00UZJkvXWW6/if5fvuOOOfP/738+kSZNy5plnpm3btrnyyivLv/dZPZQCsBrtvPPOad269XLfhV9vvfUqmqV169Yf6rI14V9nKW2++eb5xje+kW984xsVX+OgZcuWmT17dtZdd91cf/315ePTpk2r6JO1j3/845k2bVq6dOmyzGXbbLNNxXK830c+8pEcddRR2X///Zea3nHqqadW5Px33313xo4dm5NOOikf+chH0qtXr4o/cV9ijz32yIgRIzJ8+PDccccdOeecc6pWUCTJiSeemCOPPDJbbLHFUt+bG2+8sWIZlveCoaGhIb169aroKJv3+8IXvpAtt9wyDzzwQJJkwIABFRtemywuR04//fQcddRR2WyzzZIsHiVw6623pmvXrhXLkSx+V3zJu9EzZ87MokWLyt+zSs8UnT59+lLvvs6ePXupjytVIG2++eaZNWtW2rRps1Qx8vrrry9T3q9pXbp0yYEHHpjtt99+mctuu+22iuXo0KFDLrnkksyePTtbb711Lr/88hx88MF56KGH0q5du4rlSJJ99903Rx99dObPn58jjjgi/fr1y957752HH354uffTmrLNNtvk5JNPztZbb73MZb///e8rliNJeTpFQ0PDUsfnzJlT0VFQixYtSqlUSl1dXc4999yljr/33nsVy5EsLqwuvPDC3H///fnSl76UL3/5yxU9f1FYUwBWo3fffTctWrRY5pd5NRxwwAH51re+tczxUqmUK664Ir/5zW8qluW2227LkUceWbHzrciSP3L/atq0aXn77ber9oK8FnzQ8NZKlQLv98gjj2TMmDG55557sueee+Zzn/tcDjnkkIrnSBYvmHb++efnlVdeyR/+8IeqZDj44INz+OGHL7Peg+GT1bVo0aKMHTs2EyZMyOuvv55k8SiBAw88MH369Klo0fivP7/HHHNMNtxww0ydOjWXXnppRUcLLG8O8PtVew7w3LlzM3fu3GywwQYVO+df/vKXbLrppssdWfK3v/0tnTt3rkiO6dOn5/rrr09dXV15rvjNN9+czTffPAMGDMgWW2xRkRxLPPTQQ6mvr8/ee++dJ554ImPHjs1mm22WL37xixV7LnXvvfdm6623zpZbbrnMZb/97W+XO+pyTRk+fHj++te/ZsiQIeWRYS+//HKGDh2anXfeuWLryDz44IPZY489linPXnzxxdx3330VX9B1iVmzZuWiiy7K448/vsx6MvxnlAKwGn33u9+tiYVxktp/UlYL/vnPf+af//xnevTokVmzZmXBggVZf/31qx2L95k7d27uuuuujBs3bqmRHZW2YMGCvPnmm8t9Ql8Jhx12WEaPHl2Vc6+MadOmLbX+QqVMnz49V199dZ577rnMmzevfLySIyj47/GnP/0pTz75ZDp37rzMdAKoBYsWLcrll1+e66+/vlyKzJs3LyeeeGJOO+20qk8/Ye2lFIDVqJKrXv8nXn311Wy++eYVO99tt92W7t27Z4MNNshrr72WAQMGlJ+YDRs2rOLvTCSLF9EZNWpUZs6cmXvvvTcvvfRSvvvd71b8xcR9992XCy64IK+++moWLlxYHsnwzDPPVCzDLbfcks9//vM1NVKglt1333054IADKnrOq6++OptttlkOOuigrLPOOhU998qo1o4ZX/3qV9O1a9fccsstGTBgQH7xi19k6623zv/93/9VLMPbb7+dN998M9tss81S63H8+c9/rvhCqv+qf//+ueiii6py7ldeeSU///nP849//CN1dXXZZpttcvTRR1d0XYxDDz001113XTbYYIP8/Oc/z8iRI7PffvvlT3/6U3r06JFTTjmlYlmSxdsE33DDDUvdJyeeeGJ23XXXimV4+umn87GPfSxt2rTJ/Pnzc8011+SJJ55I586d87Wvfa3i0yruvPPOXHfddUvdJ1/+8pfzP//zPxXNsWTrvY4dO5bfDd92223zqU99qqI5lpg3b15eeumlJEmnTp3SsmXLime48847c+211+b555+v6vem1rKsrawpAAUxe/bsTJgwIWPGjMk//vGPPPzwwxU794gRI8rTBy644IL07NkzV199dR544IGcc845VXlX7+c//3luvfXWHHXUUUkW/9Gtxn7E3//+93PxxRdnl112qfgiT0vUSjfcpUuX8tSOJZnq6uqqUpSsyNChQyteClx22WVJku985ztJUpX7pJZW6F5iypQpOemkkzJmzJgccMAB2W+//Sq60OCvfvWrDBs2LBtssEHmzJmTSy+9tPwC7/zzz69oSby80WH33ntv+XglR4c9++yzOe644/LpT386++67b0qlUp566qkcfvjhufHGG5e7lsqasGDBgvIUgV/+8pf52c9+lnbt2mXevHk54ogjKloKvH+b4CWLQD7xxBP56le/WtFtgvv3718edXTJJZfk3XffzTHHHJMHH3ww55xzTi6++OKK5EiSe+65J8OGDctpp52WnXfeOaVSKU8++WSGDRuW5s2bV2z3jg/afm/s2LH55z//WdGV9pPFowUefvjhPPfcc6mrq8uUKVPyqU99qqLPEWrle1NrWdZmSgFYjZ555pnlLo5TrRc1pVIpDz30UMaMGZPf/e53ee+999LY2Jh99923ojnevzjO5MmTywXBgQcemB/96EcVzbJEixYtllqwrVrat29f0XeJlufoo49Okhx00EHZdtttl7rsueeeq1iOvffeOzNnzkzv3r1zyCGHVGU4+hIrmn4zY8aMCiZZ7Nlnn634Of9VLa3QvcSSn+F11103L730UjbaaKOKbul5zTXXZMyYMdl4443zpz/9Kf/3f/+Xc845J/vvv3/Fy7Za2rbrRz/6Uc4666xlVgcfN25cfvjDH+aKK66oSI5SqZR333036623Xlq0aFHe7aVly5YVX8S0lrYJXvJzM2nSpPziF79IfX19Pv3pT1d8wdAbb7wxV1xxRT7+8Y+Xj22//fbp3LlzLr744oq92Kul7femTZuWE044IbNmzcr222+fUqmUm2++OW3atMmIESMq9nexVr43tZZlbaYUgNWoS5cuH/huWqVdfPHF+dWvfpWOHTumd+/eGTp0aHr16lXRBXOW6Ny5c0aPHp3DDjss22yzTZ566qnsuOOOefnll6s2P65Tp065//77U1dXl+nTp+faa6/NTjvtVPEc++23X374wx/mc5/73FLDA5esZF5J/fv3X+adzeUdW1Ouv/76vPHGGxk3blxOOOGEdOzYMYceemj233//im+TOGHChAwYMGCZ4qhUKlV0kc5aUksrdC9x4IEHZsaMGTnllFNy5JFHplQq5aSTTqrY+UulUjbeeOMkySc/+cmMGDEiJ598cmbNmlXobbv+9re/5fLLL1/meO/evStaBH/1q1/NiSeemFNOOSX77LNP+vXrl4MOOigPPfRQRXepSGpnm+C2bduWFzZs37593n333ay//vppamqqeFEyderUpV7oLbHLLrtk6tSpFctRS9vvXXHFFfnkJz+Zs846q/z8aOHChRk2bFiuuOKKnHPOORXJUSvfm1rLsjZTCsBaauTIkdl5553z9a9/vfzkp1pbqg0ZMiQDBgzIT3/603zkIx/J0UcfnS222CL19fVVW5jxu9/9boYNG5YpU6bkf//3f7P//vvnrLPOqniOJcM4f/nLX5aP1dXVZeLEiRXL8Nprr+XVV1/NnDlz8qc//al8fObMmWlqaqpYjiTZZJNNcsopp+SUU07JxIkTM2jQoHzlK1/JV77ylYrm2GGHHdKlS5flPhEZPnx4xXIcdNBBueuuu8pTK5aMOqrG6KPTTjvtA4evvn/Lqko6+eSTkySf+cxn8rvf/S7z589PmzZtKnb+5s2b56233iq/iOjYsWNGjBiRr3zlK5k8eXLFciS1tW3XiualV3LOes+ePdOpU6eMGDEi//znP7NgwYLMnj07n/vc58pD+CulVrYJHjRoUE4//fTsu+++6dixY44++ujsu+++efTRRyu+ovy66677gZdV8j6ppe33/vCHP2TcuHFLvWHSrFmz9O/fP717965Yjlr53iS1lWVtphSA1aga7zR/kN/97neZMGFCfvSjH2XgwIE5+OCDK7rH7fu1b98+V111VV588cU8//zzOeaYY7Lppptm5513rkqeZPE7ALWwA0MtvOv8xz/+MaNHj87UqVOXenevTZs25TnslTJ//vzcfffdGTt2bN5+++2ccsopFdvT/P2+//3vl4ca/6vbb7+9YjneeuutDBgwIDfccEO6du1atWIvSfbZZ58PfAK2ySabVDhN0tTUlAceeCCvvfZamjdvnq233rri7/5+85vfzOuvv14uBZLF98WIESNy7bXXVjTLEvvvv3/22GOPXHTRRRUtSN5vzpw5mTRp0nKnUFR6/Ylddtkll156aUXPuTzTp09f7kjCUqlU0SlJO+20U8aMGZNf/epXef755/OpT30qm266aU466aSKLkCcLH4H+IMWuH3zzTcrlqNfv35pampKq1atsttuu5WPv/zyyzniiCMqliNZXDQub2pjixYtKjpirla+N7WWZW1m9wFYjcaMGbPMk/YNNtggu+yyS1W3ups8eXLGjh2bcePGpXXr1vnc5z6Xr371q1XLUwvee++93H333XnllVeWKkuqsdL+Qw89lBdeeCHHHnts3n777bz77rvL3S95TRs7dmxVXoAvMWjQoEyaNCkHHHBA+vTpU7HFyGrZm2++mfHjx2fcuHGZNWtWevXqlT59+lRlx47jjjsu11133TJPWP/617/mm9/8Zh588MGKZXnggQfy3e9+NxtuuGGef/757L777nnzzTdTV1eXH/3oRxVd4Z5lHXfccSu8/KabbqpQkg9W6V1EbBO8rA96obdEEXe+WdEuVpXc4aqWvje1lGVtphSA1Wh5f/SnTZuWp59+OhdeeGHF38VankmTJmXs2LEVncP41a9+NVdddVU+85nPLFWaLBmuV8mh8kuccsopWbhwYXbcccelhkR/+9vfrmiOK664Ik888UReeuml3HXXXXnjjTfyrW99K6NGjapojmTxE/VevXqlXbt2SRa/s/WrX/0qxx57bEXO36VLl2yyySZp1qxZTTxOam0LpKeffjrjxo3LHXfckc033zx9+vSp6Er7l156aZ588slcddVV5WLgL3/5S04//fRccMEFFd26q2fPnvnxj3+cj370o3n22Wdz9dVX57LLLsv48eMzZsyYXH/99RXLUkuPk1rK8kHmzp1b8W3vlqda22jWglrZBvCGG25Iq1at8vnPf36p47fcckvmz5//b8ul1alWfnbevwvP+1V6ylgtfW9qKctarQSscS+//HLpyCOPrOg5//rXv5buv//+ZY7fd999pSeffLKiWd54441SqVQqTZ48eZl/r7zySkWzLPG5z32uKuf9V7179y4tXLiw1Lt37/KxQw45pCpZevXqtcyx9+da0/71sfHCCy+UnnrqqdLjjz9emjx5csVylEql0t13313q1q1b6dZbby0988wzpaeffrp06623lvbbb7/SPffcU9Es/+qZZ54pHXrooaUuXbpU/Nzf+973Sl/5yldK8+fPLz388MOlfffdt/Twww9XPMe/Plb79OlT/v9BBx1UsRy19DippSzL84c//KHUv3//0h577FGxcw4YMOAD/+26664Vy1EqlUpPPfVUqU+fPqVdd9219IUvfKH00ksvVfT8S9TS4+Twww8vzZs3b5nj8+bNq+jfnlq6T2pFrXxvai3L2syaAlABHTt2rPhiNY2NjRkyZMgyx7faaqsMHTo01113XcWyPProoznooIOWma9YKpVy9tln53vf+17Fsiyx44475pVXXqn6MOMWLVosNVJh4cKFVcuyvJWnK7kOxc0335w+ffpku+22y9y5c3P00Ufntddey4IFC3LRRRdVdL5rrW2B9Pbbb+f222/P+PHj8+6776ZXr175wQ9+UNEMSXLWWWdlyJAhOfHEE/PSSy/liiuuWGoObqVsuummGTFiRLp165Y77rgjW221VZL/t2BYpdTS46SWsizxwgsvZOzYsRk/fnzeeeednHnmmenfv3/Fzl9Lu4gMHTo0RxxxRPbaa6/cddddueCCC6qyJW8tPU4WLlz4gfPnK7kTQi3dJ7WiVr43tZZlbaYUgAp45513Kn7OmTNn5mMf+9gyxz/2sY9VfGGWSy65JC1atFhq/mapVMp3vvOdquz5niQnnnhijjzyyGyxxRZL/bG58cYbK5pjl112yc0335wFCxbkqaeeyvXXX5999923ohmW6Ny5c4YPH56TTjoppVIp119/fTp37lyx899///3lhQ3Hjh2bhoaG/P73v88///nPDBw4MJ/97GcrlqVWtkC64447Mnbs2Pz1r39N9+7dM2DAgKrsO5/8v3mdG264Ye68887svvvueeihh/LQQw8lqey8znPPPTcXXHBBbrvttuywww4ZNGhQkuTdd9/9t3O3V6daeZzUWpaRI0dm3LhxefPNN9O7d+/89Kc/zZe//OV84QtfqGiOWtlFJFk8beKLX/xikuQb3/hGRVeSf79aepzMnj078+fPX+YFX1NTU0UXpKyl++T9O80sUY0dZ2rle1NrWdZmSgFYjZa3GMr06dPz29/+Nt/85jcrmmX69OkfeNmcOXMqFyTJNddck5NOOinrrLNOPvWpT2XBggX5v//7vyxYsCA//OEPK5plie985zs55ZRTsv322y+19U+l9e/fP1dffXUaGhpyzjnn5IADDsgpp5xSlSzf/e53873vfS+f/exnU1dXl/32269ieyInScuWLctzKR955JEccsghWWedddK5c+eKvxtQK1sg/eIXv0ifPn1y+eWX18Q87GTxE9Rqz+Gsr6/PZZddtszx9ddfP+uss07FctTK4ySprSznnntuunbtmuuvvz6dOnVKUp0tcWtlF5Eky/yd+aDtPde0WnqcLCk6zz333PJOGbNmzcqQIUMq+u58Ld0nzz77bEXP90Fq5XtTa1nWZkoBWMO23HLLHH300eUnRpU874QJE5ZZJOfuu++u+MrlW2yxRa655pqcfPLJGTx4cH7+85+nRYsWufzyyyu6xc77tWzZMieddFJVzv1+LVq0yKmnnloTq+e2a9cuF110UdXOXyqVMm3atKy77rp55JFH8rWvfa182bx58yqapVa2QKrkgnn/Tps2bVa42FMlfelLX8qNN96Y9u3bL3X8vvvuyznnnFOxnRBq5XFSa1mWbCt60kkn5SMf+Uh69epVlWG+K/q7u95661UwSfLMM89k++23L39cKpWy/fbbV/wd4Fp6nPTt2zf9+/dPt27dys9LXnrppXTr1i19+/atWI5auk9qRa18b2oty9rM7gNQIZVe6fi5557LCSeckH322Se77LJLksVbh/3+97/PiBEjsu2221YsyxJ/+9vfcsIJJ2S//fbLhRdeWNU916+++upsttlmOeiggyr6zuK/Wt4TkbZt2+bjH/94dt1114pmmT17dq666qq8+uqrufTSS/PPf/4zzz//fMWG7d9+++255JJL0rJly2y11Vb5yU9+kmTx4/YHP/hBfvrTn1YkR2ILpOU54ogjMnLkyGWGcM6fPz9HHXXUcvdgX1NGjhyZW2+9NTfeeGP5xd1dd92V733ve7nqqquWevG1JtXS46SWsrzfI488kjFjxuSee+7Jnnvumc997nM55JBDKnb+WllVvlbU4uPkxRdfLJci22+/fcXfuKjF+6RWVPt7U6tZ1kZGCkCFVLp/23bbbTNmzJiMHDkyv/vd75Is/iU6evTodOjQoaJZ3r/FTqlUyvjx43P77bdX/B2S91sy9HjJHPZqZXnppZfyl7/8pTwEbuLEidlxxx0zZsyYHHzwwTn55JMrluXss8/O9ttvn7/97W9JFi/m1rdv34qVAj179kzXrl3z9ttvp0uXLuXjm2yySUW30Exq613xWlFLiz194QtfyPz58/OlL30pI0aMyH333ZdLLrkk1113XUULz1p6nNRSlvfbc889s+eee+acc87JXXfdldGjR1esFLjnnnsybNiwnHbaadl5551TKpXy5JNPZtiwYWnevHkhhx7X4uNkiy22qOoLvFq8T2pFtb8371dLWdZKFd/vAArq05/+dLUjUIOOP/740owZM8ofz5gxo3TssceWZs2aVfrf//3fimY59NBDS6XS0tsQLm+bwiKwBdKyPvvZzy73Ppk7d26pR48eVUhUKl111VWlAw88sHTAAQeUXnjhhYqfv5YeJ7WUZUXOPffcip3r2GOPLT322GPLHH/88cdLxx57bMVy1JL/lsdJJblPoFSqzionsJb605/+tNx/jzzySMXb5m984xvl///rln/HHHNMRbPUknfffbfaEZby5ptvLjW3db311stbb72Vddddd7nvyq5J9fX1WbRoUXlUx7Rp0yp6/lpSS++K14oliz3NmjWrfGzWrFk5++yzK/6O68CBAzNw4MC88MILmT59ejbffPNcddVV5eOVUkuPk1rKsiITJ06s2LlqaVX5WvHf8jipJPcJmD4Aq9Xll1++zLElW8lsvfXWFc3y2muvlf8/adKkpS4r8hYu++yzT/bZZ5/06dMnPXr0qPgL73/18Y9/PN/+9rfL21ONHz8+H//4xzN37tyKL8J4xBFHpF+/fpkxY0auv/76jB49Ol/60pcqmqFW2AJpWbW02NP7t2Ws1haNSW09Tmopy4qUKjiVrpZWla8V/y2Pk0pyn4BSAFarH/3oR3nzzTez1VZbJUl+/etfZ968eamrq0u3bt2qlutfn4RVc4G/auvYsWM++9nP5uabb86QIUPyP//zP+nTp0923333quQ599xzM2rUqPzyl79MsvgFztFHH50WLVpk1KhRFc1y9NFHZ6uttkqHDh0yderUnH322enatWtFM9QKWyAtq0WLFvnBD35QE4s9HXrooRU/5/LU0uOklrKsSCX//lhVfln/LY+TSnKfgN0HYLUaOnRoOnfunKOPPjpJ0qNHj3zyk5/M3Llzs9FGG+Xss8+uWJZDDz00Y8aMWeb/y/u4SN7/tb/yyisZN25cxo8fn7q6uvTq1Svf/OY3q5yQWjB//vz0798/v/3tb5d5V/ziiy+u+giTolu4cGHGjh2burq69OnTJxMmTMj48eOz3Xbb5Zvf/GZatmxZkRy19DippSyf+cxnlvviv1QqZerUqXnyyScrksOq8suqpcdJrXCfgFIAVqs+ffpk9OjRqa+vL3+8ZJuuY445Jj//+c8rluVfV/z/1/9XY8X/WvBBhcif//znjBs3Lueee25F88yfPz+/+MUv8ve//z3z5s0rHx82bFhFcySLt/4bPnx4Jk+enAULFpQfK5WcA1xrauFdcZY1ePDgTJs2LfPmzUubNm1SX1+fgw8+OPfcc0/WWWedDBkypKJ5aulxUgtZXn311RVevvnmm1ckxw033LDCVeWPO+64iuSoRbXwOKk17hOKzPQBWI0WLVpULgSSpF+/fuX/z5kzp6JZnn322Yqe77/FB23H+IlPfCKf+MQnKpwmOeuss9KuXbs88MADOemkkzJu3LjlLoxVCQMGDMg3v/nN7LLLLks9jovMFki16S9/+Utuv/32zJ8/P/vuu28eeuihtGjRIp/61KeqMrWglh4ntZClUi/6/51f/epXGTly5DLHDz300Bx11FGFLgVq4XFSa9wnFJlSAFajpqamNDU1paGhIUnyqU99Ksnihf0qXQqwfD/+8Y+rHWEpf/vb33L77bfnkUceybHHHpvDDz88X/7yl6uSpaGhIQcffHBVzg2rYskinC1atMjmm29eHt7bvHlzhVYNWNH0gUqOPrKqPMDKUQrAatSjR48MGjQo5557bnnV49mzZ1uspsaUSqXMmjUrbdu2Xer4K6+8ko4dO1Y0y5ICqUWLFnn77bfTrl27qi2A9T//8z8ZN25c/vd//9ccSmpafX19ebXw2267rXx89uzZVUzFEjfddFOSxb9rv/rVr+bqq6+uSg6rygOsHKUArEbf/va3c8YZZ6Rbt27p1KlTksWL1ey7774V37KL5fvDH/6Qvn37ZuHChdl6661z0UUX5WMf+1iS5PTTT6/4Aoy77bZbZsyYkWOOOSaHHnpoWrVqlb333ruiGZa47LLLkiRnnnlmeSvNIq8/Qe36yU9+Uh4RsM4665SPz5o1KwMHDqxWLP5/758+sGQ0RzVYVR5g5VhoENaAF154oTynv3PnzuUtCqm+ww8/PMOGDct2222XcePGZfjw4bn88suz0047LbUwZDW8+uqrmTVrVjp37ly1DACrUzV3u7GqPMDKMVIA1oAtt9wyW265ZbVjsBwLFizIdtttlyTp3bt3ttxyy3zrW9/KsGHDKrp/9muvvbbMsbq6urRt2zavvfZaNttss4pleb933nknf/3rX5MkH//4x9O+ffuq5IAVqZU569S2Fi1a5Ac/+IFV5QH+DSMFgELp2bNnfv7zn5eHkibJc889l69//euZOXNm/vjHP1Ykx5IXNcv7FVytFzW//e1vM2jQoOy6664plUr561//mu9973vZb7/9Kp4FVmTJlncfNGe9Vla/Lypb4gL8dzFSACiU4447Ls8++2z22GOP8rFtt902P/3pT3PppZdWLMdvfvObip1rZQ0fPjw///nPy4stvvLKK/nWt76lFKDm1MqcdZbPlrgA/12UAkChfOYzn8lGG220zPGPfexjOeqooyqWY3nTB96vGtMHFixYsNTuCx07dsyCBQsqngMAgMpRCgCF8qUvfSk33njjMnPl77vvvpxzzjl58MEHK5Lj2GOPrbnpA5tttlmuu+66fP7zn0+S3Hrrrdl0000rngMAgMqxpgBQKCNHjsytt96aG2+8Meutt16S5K677sr3vve9XHXVVdl+++2rnLB6pk6dmvPPP7+8rsJee+2VQYMGZeONN65yMliaOesAsPooBYDCueGGG3L77bdnxIgRue+++3LJJZfk2muvzbbbbluVPM8991weeeSRJEnXrl2zzTbbVDzDwoULc+WVV+Zb3/pWxc8NAED11Fc7AEClnXjiiTnooINy+OGHp7GxMSNGjKhaIfDLX/4yX/3qV/PSSy/lpZdeyle/+tWq7OndrFmzik2dAACgdhgpABTKwIEDy///zW9+k+222y4f/ehHy8eGDRtW0Ty9evXKiBEjymscTJs2LSeccELGjx9f0RxJ0tjYmIULF6ZPnz5p3bp1+Xg1Fj0EAKAyLDQIFMqee+653P9XS6lUWmrRw/bt2y938cFKuP3225Mkv/71r8vHqrXoIQAAlWGkAEAV9evXL+utt155O8TbbrstM2bMyCWXXFLlZAAAFIFSACiUhQsXZuzYsamrq0ufPn0yYcKEjB8/Ptttt12++c1vpmXLlhXNM2vWrPzwhz9casX/b37zm1l33XUrmmOJv//97+VFD/faa6+qLHoIAEDlKAWAQhk8eHCmTZuWefPmpU2bNqmvr8/BBx+ce+65J+uss06GDBlSkRwjRoxIQ0NDPv/5zy91/JZbbsn8+fNz3HHHVSTH+/3sZz/L9ddfnx49eiRZvObCiSeemC9+8YsVzwIAQGUoBYBC6dmzZ26//fbMnz8/++67bx566KG0aNEiCxYsyKGHHlqeV7+mHXHEERk5cmRatGix1PH58+fnqKOOytixYyuS4/0OOuig3HrrrWnXrl2SZMaMGTnqqKNy1113VTwLAACVYUtCoFCaN1+8vmqLFi2y+eabl1+UN2/ePPX1lfuVuHDhwmUKgSW5Fi1aVLEc79emTZtyIZAk6623Xtq0aVOVLAAAVIbdB4BCqa+vz/z589OiRYvcdttt5eOzZ8+uaI7Zs2eXc7xfU1NT5s6dW9Esf/rTn5Is3o3htNNOy6GHHpokGTt2bE3s0AAAwJpj+gBQKG+++Wbat29fHjGwxBtvvJEXXnghe+21V0VyXHjhhXnjjTdy7rnnlt+NnzVrVoYMGZKPfOQjOfPMMyuSI8kK1y+oq6vLjTfeWLEsAABUllIAoArmz5+f/v3757e//W222GKLJMlLL72Ubt265eKLL17u1AIAAFjdlAJAoXzmM59JXV3dMsdLpVLq6uoyceLEiuZ58cUX88wzzyRJtt9++3JBUEn/X3t3bCIhGIQBdCzACmxAMTa0lU2twsgiBFNrsoStYAvYC44TTzZW2HkvGjCZ1A/m+7dti7Zt9zOCs67rLt4IAICrCAWAVJ7PZ0T8hgDDMMSyLP++V1V1x1q3Gscxpmn6eEbgfAAA4LspGgRSOf70/71AkF3f9xERsa5rvF6vKMvy5o0AALiKJwkBkpvneZ8fj8eNmwAAcDWhAEByxysyF2UAALk4HwBSqet6Lxp8v9/RNM0+F0Wxl/5lcixe/FTCCADA91I0CJDcOSg5zxmDEgCALIQCAAAAkJROAQAAAEhKKAAAAABJCQUAAAAgKaEAAAAAJCUUAAAAgKSEAgAAAJCUUAAAAACS+gF93DWV5PTkmgAAAABJRU5ErkJggg==\n",
+                        "image/png": "iVBORw0KGgoAAAANSUhEUgAABAUAAAPiCAYAAAAHH2TAAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMCwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy88F64QAAAACXBIWXMAAA9hAAAPYQGoP6dpAABvN0lEQVR4nOzdebiUdcE//vc5IBwQRNQUNcIdXFMzcQnTIH2elMU1LbcsbVOLR0IQE1AL9xNqi1uKJqEWm5m4kKZZZpSaa5m5oSIugGwHBOb3Bz/mK4EEBjMT9+t1XVwX5545c7/PnDnnzLzns9SVSqVSAAAAgMKpr3YAAAAAoDqUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEE1X9kr3rrXp9ZkDqhJRz38u2pHAAAAWGOMFAAAAICCWumRAnXNmq3JHAAAAECFrXwpUF+3JnMAAAAAFWakAAAAABSUkQIAAABQUCtfCtQpBWBlTZs2Ld/5znfyyiuvpEWLFtlpp50ydOjQtGjRYqnrTZ06Nf369csbb7yRNm3a5KKLLsrWW29dpdQAAEDR1JVKpdLKXHHsQf+zprNAzelz14QP9XnTp0/Pc889l09+8pNZtGhR+vXrl5122iknnXTSUtc788wzs8MOO+SEE07IvffemxtuuCE/+9nPVkd0AACAf8tIAViB7t27r/DyiRMnLvf4+uuvn09+8pNJkvr6+uy000557bXXlrnePffck3POOad8riFDhuTtt9/Ohhtu+B8mBwAA+PdWYU2B+jWZA9Za8+bNy5gxY/Kd73xnqePTpk1LQ0ND1l133SSLi7cOHTrk9ddf/9ClwMCBA9PU1PQfZwaopoaGhgwbNqzaMQCgEIwUgBX4oJEAK2vRokU588wz07Vr1+y3336rKdUHa2pqSmNj4xo/D8Ca1Ldv32pHAIDCsCUhrEFDhw5NfX19zjrrrGUua9++fZqamjJnzpy0bt06pVIpU6ZMyaabblqFpAAAQBHZkhDWkIsuuihTpkzJlVdemfoPmH7To0eP3HbbbTnhhBMyceLEdOrUyXoCAABAxVhTANaA5557Ltddd1222mqrHHHEEUmSffbZJyeeeGJOOeWUjBs3LklyxhlnpF+/fhk5cmTWXXfdXHTRRdWMDQAAFMwqTB9QCsDK2nbbbfO3v/1tuZctKQSSZJNNNslNN91UqVgAAABLWYWFBpUCAAAAsDYxUgAAAAAKyit9AAAAKCgLDQIAAEBBrcL0gWZrMgcAAABQYauw0GDdmswBAAAAVJiRAgAAAFBQq7CmgJECAAAAsDYxUgAAAAAKypoCAAAAUFD2GQQAAICCMn0AAAAACmoVFho0qAAAAADWJkYKwBpyzjnn5L777svUqVPzt7/9bbnXOe644zJlypS0bt06SXLmmWdmn332qWRMAACgwCw0CGtIz549c/rpp2ffffdd4fXOP//8dO3atUKpAAAA/p+VLgVSrxSAVfHJT36y2hEAAABWaKVLgXrTByig7t27r/DyiRMn/sfnOPfcc1NfX59PfOIT6devX9q0afMf3yYAAMDKWPmRAnUWGoTV7eKLL06HDh0yf/78DBs2LBdccEHOP//8ascCAAAKYhV2HzB9gOJZHSMBVqRDhw5JkhYtWuSYY47JGWecsUbPBwAA8H6rsNCgkQKwOi1YsCAzZszIhhtumCS58847s91221U5FQAAUCS2JIQ1ZMCAAfn973+fJNlvv/3StWvX9OvXL6ecckrGjRuX+fPn5+STT857772XUqmUrbbaKoMHD65yagAAoEjsPgBryAUXXLDc4+PGjUuStG7dOqNHj65kJAAAgKWYPgAAAAAFtQrTB5QCAAAAsDZZhd0HlAIAAACwNrHQIAAAABSUt/8BAACgoFZh+oCRAgAsbeDAgWlqaqp2DNYyU6dOTd++fasdg7VQQ0NDhg0bVu0YADVlFUoBWxICsLSmpqY0NjZWOwbASlE2ASzLloQAAABQUBYaBAAAgIIyfQAAAAAKykgBAAAAKKiVLgViTQEAAABYq5g+AAAAAAVl9wEAAAAoqJWfPmCkAKySc845J/fdd1+mTp2av/3tb8u9ztSpU9OvX7+88cYbadOmTS666KJsvfXWFU4KAAAUlYUGYQ3p2bNnTj/99Oy7774feJ1LL7003bt3zwknnJB77703gwcPzs9+9rMKpgQAAIpsFdYUMH2A4unevfsKL584ceIHXvbJT37y397+Pffck3POOad8riFDhuTtt9/OhhtuuGpBAQAAPgQjBaBKpk2bloaGhqy77rpJkrq6unTo0CGvv/66UgAAAKiIVVho0JoCFM+KRgIAAAD8tzN9AKqkffv2aWpqypw5c9K6deuUSqVMmTIlm266abWjAQAABbHyuw/YkhBWux49euS2227LCSeckIkTJ6ZTp06mDgAAABWzCiMFTB+AVTFgwID8/ve/T5Lst99+6dq1a/r165dTTjkl48aNS5KcccYZ6devX0aOHJl11103F110UTUjAwAABWOhQVhDLrjgguUeX1IIJMkmm2ySm266qVKRAAAAlrIKCw2aPgAAAABrk5VfU8D0AQCAmjBw4MA0NTVVO8Z/nalTp6Zv377VjvFfp6GhIcOGDat2DGANWelSoN70AQCAmtDU1JTGxsZqx6AgFCmwdrP7AAAAABSUhQYBAACgoFZhS0IjBQAAAGBtsgqlgIUGAQAAYG1iTQEAAAAoKCMFAAAAoKBWYaHBlR9UAAAAANS+lS8F6owUAAAAgLWJLQmBwhs4cGCampqqHeO/0tSpU9O3b99qx/iv09DQkGHDhlU7BgCALQkBmpqa0tjYWO0YFIgiBQCoFUoBAAAAKKhV2JLQmgKwKp5//vn0798/s2bNyiabbJJLLrkkG2+88VLXGTBgQB5++OG0a9cuSfKlL30pffr0qUJaAACgiIwUgDVk8ODB+frXv54ePXpkxIgRufTSS3PhhRcuc73TTz89hx12WBUSAgAARbfSpUC9hQYpoO7du6/w8okTJy73+FtvvZUXX3wxPXr0SJIcccQR6dat23JLAQAAgGpZ+ekDRgrASpsyZUo23XTT8sfrrrtuWrZsmWnTpqV9+/ZLXfcnP/lJrr/++nTu3Dnf+c53sskmm1Q6LgAAUFBGCsAKfNBIgNWlb9++2XjjjVMqlXLNNddkwIABuf7669foOQEAAJZYhYUGjRSAldWhQ4e8/vrr5Y9nz56defPmLTNKYMmogLq6uhx77LH5yU9+UtGcAABAsa3CQoN2H4CVtdFGG6VTp065995706NHj/ziF78ory/wfm+88Ua5GPj1r3+dzp07VzoqAABQYKYPwBoyZMiQnHnmmbnooovKWxImSe/evXP11Vdnk002yZlnnpm33347SbLxxhvnggsuqGZkAACgYFZ++gCwSrbddtuMHj16mePjxo0r//+GG26oYCIAAIClrfz0gWb6AwAAAFibWFMAAAAACspIAQAAACgoIwUAAACgoFa+FKirX5M5AAAAgApb+VKguS0JAQAAYG1ipAAAAAAUlDUFAAAAoKBWfksBIwUAACi4gQMHpqmpqdoxKmrq1Knp27dvtWNUVENDQ4YNG1btGFARRgoAAMBKampqSmNjY7VjsIYVrQSh2FahFLDQIAAAAKxNVmGhQSMFAAAAYG2y8msKNDNSAAAAANYmK18KxEgBWBXPP/98+vfvn1mzZmWTTTbJJZdcko033nip68yePTtnnnlm/v73v6dFixYZOnRoPvGJT1QpMQAAUDQrXwpYaBBWyeDBg/P1r389PXr0yIgRI3LppZfmwgsvXOo61113XTbbbLNceeWVeeqpp/Ltb387d911V+rr7fYBAACseaswUgCKp3v37iu8fOLEics9/tZbb+XFF19Mjx49kiRHHHFEunXrtkwpMGHChFxxxRVJkh133DHt27fPk08+mV122WU1pAcAAFgxb0fCGjBlypRsuumm5Y/XXXfdtGzZMtOmTVvqeq+//no233zz8sebbrppXn/99YrlBAAAis2aArACHzQSAAAAYG2w0qVAaU2mgLVMhw4dlnrHf/bs2Zk3b17at2+/1PU23XTTvPrqq9l6662TLB458P4RBgAAAGvSypcCWgFYaRtttFE6deqUe++9Nz169MgvfvGL8voC73fQQQfllltuyVlnnZWnnnoq77zzTnbaaacqJIY1b+DAgWlqaqp2jJowderU9O3bt9oxakJDQ0OGDRtW7RgAUFirMFJAKwCrYsiQITnzzDNz0UUXlbckTJLevXvn6quvziabbJIvf/nL6d+/fw488MCss846ueCCC+w8wFqrqakpjY2N1Y5BjVGOAEB1GSkAa8i2226b0aNHL3N83Lhx5f+3adMmP/rRjyoZCwAAoGylS4GFi7QCAAAAsDZZhd0HAABYkUqtnVGpdSms+QCw9lvpUmCRkQIAACu0tq2dYc0HgLXfypcCFhUAAACAtcrKrymwcNGazAEAAABU2CrsPmCkAAAAAKxNTB8AAACAglqF6QNKAQAAAFibGCkAAAAABWVLQgAAACgoCw0CAABAQa10KbBgkS0JAQAAYG2y8iMFTB8AAN5n4MCBaWpq+o9uY+rUqenbt+9/nKWhoSHDhg37j28HAIrGQoMAwIfS1NSUxsbGasdIktVSLABAEdmSEKpk0qRJGTJkSObPn5/tttsuF154YdZdd91lrnfcccdlypQpad26dZLkzDPPzD777FPpuAAAwFrISAGogkWLFmXgwIH5wQ9+kB133DHf//73c9111+X0009f7vXPP//8dO3atcIpAQBWzuqYTlRLVtfUplpgehX/zsqPFLDQIAXUvXv3FV4+ceLED3W7Tz75ZNq3b58dd9wxSfL5z38+p5122geWAgAAtayWphOxtLWl3GDNWelSAFh9Xn/99Wy22WbljzfbbLO8/vrrH3j9c889N/X19fnEJz6Rfv36pU2bNpWICQAArOVWfvqA3QcooA87EiBJDj300Lz22mvLHN9pp51y1FFHrfTtXHzxxenQoUPmz5+fYcOG5YILLsj555//oXMBAAAssQrTB5QCsCrGjBnzgZf99a9/XaoweO2117Lpppsu97odOnRIkrRo0SLHHHNMzjjjjNUbFAAAKCwjBaAKdtppp7zzzjt56qmnsuOOO+aWW27JQQcdtMz1FixYkBkzZmTDDTdMktx5553ZbrvtKh0XAABYSxkpAFVQX1+fYcOGpX///nnvvfey7bbb5sILL0ySvPHGGznllFMybty4zJ8/PyeffHLee++9lEqlbLXVVhk8eHCV0wPw32B1rAa/ulZgt/o5QO1a6VKgZEtC+NA+6InZ+9/1/+53v1v+/1ZbbVV+EtapU6elPmdF6wlUavscT+4Aal8trQZv9XOA2rXSpcCChbYkhA+rlp6YrQ6e3AEAwNphFUYKrMkYAAAAQKWt/EKDWgGAmrc65hCvKZWa3vJhmBIDABSVNQUA1iJr21SVSqnVsgIAYE2zJSEAAAAUlC0JAahZlZoOYecOKAbbNAIsy5oCANSstW06hGkKUF219DvF7wOgVth9AAAAYDWrlcV/a2mhXyNkatNKlwILFi5akzkAAADWGrU0MqVW1Eo5wdKMFAAAAICCsqYAAAAAFNQqjBRQCgAAAMDaZBXWFFAKAAAAwNrEmgJQJV/72tfy2GOPpXXr1vnNb37zgdd7/vnn079//8yaNSubbLJJLrnkkmy88cYVTAoAAKytrCkAVXL88cfn9NNPz6mnnrrC6w0ePDhf//rX06NHj4wYMSKXXnppLrzwwgqlBADWZqtr27zVse2d7eqgOla6FFi4SCkAq9M+++yTyZMnr/A6b731Vl588cX06NEjSXLEEUekW7duSgEAYLWopW3zbFcH1WGkAKxA9+7dV3j5xIkT1+j5p0yZkk033bT88brrrpuWLVtm2rRpad++/Ro9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5Mi0bNnyP7rNV199NWPGjFnlz1u0aFFKpVIOO+ywTJgwIbfffns6deqUK6+8cpVuRykAAAAA/8YLL7yQ+++/P+eee25atWqVJGloaMgxxxyz1PUGDBiQ0aNHlz8+7rjj8sc//jFJMnz48Bx88MHp2bNnjjvuuCTJ+eefnyeffDK9e/fO0KFDkySTJk3KF77whRx22GH54he/mH/84x9JktGjR+fkk0/OKaeckoMPPjjvvvtuPvOZz6Suri5Jsssuu+S1115bpa/L9AEAAAAKpXv37iu8fOLEicsce+aZZ9KpU6est956H+qc06dPz4QJE3LHHXekvr4+M2bMSJKcffbZufLKK3PTTTeVr3fhhRfm2muvTbt27fLoo49m0KBBueWWW5Ikjz/+eMaPH58OHTosdfulUim33HJLPvvZz65SLqXAf4mBAwemqamp2jEKp7GxsdoRAACAtUDbtm3TunXrDBo0KHvvvXcOOOCA5V7vsccey0svvZTjjz++fGxJgZAke+211zKFQJJcdNFFaWhoyNFHH71KuZQC/yWampq8QAUAAFgNljcS4N/Zfvvt8/LLL2fmzJlp27btB16vWbNmWbRoUfnjefPmlY+PGjUqkyZNyoMPPpjGxsblriVQKpWy22675aqrrlru7bdu3XqZY1dffXWefPLJXHvtteWpBCvLmgIAAADwb2y55Zbp1q1bhgwZkrlz5yZZ/IJ/1KhRS12vY8eOeeKJJ5Ikzz//fJ599tkkyaxZszJ9+vTsvffe6devXxoaGjJlypS0adMms2bNKn/+rrvumqeffjpPPfVUksULCj799NMfmOvmm2/OXXfdlR//+McfatFDIwUAAABgJVx88cVpbGxMz54906pVq9TV1eXwww9f6jpHHXVUTj311BxyyCHp0qVLunTpkmRxKXDaaaelqakppVIp+++/fzp37pyFCxdmgw02SM+ePbPHHntk8ODBGT58eM4777zMmTMn7733Xg488MDssMMOy+SZNWtWzjvvvHz0ox/NF7/4xSTJNttsk0svvXSlvyalAAAAAKyEli1bZsCAARkwYMAHXmeDDTbIyJEjl3vZbbfdtsyx5s2b57rrrlvq2O67777MCIQkOeyww3LYYYeVP27Tpk15JMKHZfoAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFFTz1XljDQ0N6du37398O1OnTl0NaQAAAIAVWa2lwLBhw1bL7ayOYgEAAABYMdMHAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFFTzageoNQMHDkxTU1O1Yyxj6tSp1Y5QWG0a1ql2hCRJs/ra6fDq6+uqHSFJsunA71U7QlnrhhbVjpAkmTlnXrUjlHXYYN1qRyh7889/qnaEJEmbzTevdoSyJ2fWxu+Uzm0XVTtC2e79B1Q7QtnTP72u2hGSJK023qTaEcpennBntSMkSZq3alXtCGWv/e7BakcoWzB7TrUjJEmmPftstSOU/bNFbTw3mFtDryMWNNXO85SDfj6q2hFqhlLgXzQ1NaWxsbHaMZbRt2/fakcAAABgLVMbbxMAAAAAFacUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUVPNqBwAAAID/BvPnz09jY2PuvffetG7dOs2aNUuvXr0yc+bMJMlpp522yrc5efLkPPLIIznssMM+VKaFCxemsbEx99xzT1q0aJGddtopw4YNW+nPVwoAAADASujfv3+SZPz48WnVqlWampoyZsyYcinwYbz66qsZM2bMKpcCixYtSl1dXa6//vq89dZb+fWvf51mzZrlrbfeWqXbUQoAAABQKN27d1/h5RMnTlzm2AsvvJD7778/DzzwQFq1apUkaWhoyDHHHJMrrriifL0BAwZkzz33LL/IP+6443Lqqaema9euGT58eO6+++7U19dn/fXXz0033ZTzzz8/kydPTu/evbP77rtn8ODBmTRpUi677LI0NTWlVatWGTp0aLbZZpuMHj06d955Z+rq6vLKK69k5MiRGTFiRMaMGZNmzZolSTbaaKNVui+UAv8lGhoa0rdv32rHKJzGxsZqRwAAAGrAM888k06dOmW99db7UJ8/ffr0TJgwIXfccUfq6+szY8aMJMnZZ5+dK6+8MjfddFP5ehdeeGGuvfbatGvXLo8++mgGDRqUW265JUny+OOPZ/z48enQoUNmzpyZefPmZdSoUbnvvvvS0NCQb33rW9lzzz1XOpdS4L/EqswJAQAA4IMtbyTAmta2bdu0bt06gwYNyt57750DDjhgudd77LHH8tJLL+X4448vH1tSICTJXnvtlQ4dOiRJFixYkBkzZqRt27b55S9/mWeffTZf+cpXcuedd6Zt27YrlUspAAAAAP/G9ttvn5dffjkzZ85c4QvuZs2aZdGiReWP582bVz4+atSoTJo0KQ8++GAaGxszZsyYZT6/VCplt912y1VXXbXc22/dunX5/+3bt0/r1q3Ts2fPJEmXLl3SoUOHvPjii9l5551X6uuyJSEAAAD8G1tuuWW6deuWIUOGZO7cuUlSHrr/fh07dswTTzyRJHn++efz7LPPJklmzZqV6dOnZ++9906/fv3S0NCQKVOmpE2bNpk1a1b583fdddc8/fTTeeqpp5IsXlDw6aef/sBc//u//5vf/e53SRYvWjhlypR87GMfW+mvy0gBAAAAWAkXX3xxGhsb07Nnz7Rq1Sp1dXU5/PDDl7rOUUcdlVNPPTWHHHJIunTpki5duiRZXAqcdtppaWpqSqlUyv7775/OnTtn4cKF2WCDDdKzZ8/sscceGTx4cIYPH57zzjsvc+bMyXvvvZcDDzwwO+yww3IznXHGGTnzzDNzzTXXpFmzZjnvvPPSrl27lf6alAIAAACwElq2bJkBAwZkwIABH3idDTbYICNHjlzuZbfddtsyx5o3b57rrrtuqWO77777MiMQkuSwww5bZuvCDTfcMNdee+3KxF8u0wcAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAXVvNoBlqehoSF9+/atyrmnTp1alfNSu+bOX1jtCEmS2XPnVztC2Wtvz652hCTJ7KYF1Y5Q9tpbs6odIUny7pzaeZzMnls7358W67SrdoQkyTr/nFPtCGVPvzyz2hGSJE9s0LLaEcr2eue+akco26p372pHSJJM/8c/qh2h7Neb9qh2hCRJx40aqh2hbLuP1sbvtiSZ9Pe3qx0hSbJN727VjlBWKlU7wWLvLVxU7Qhl89+rjefVLK0mS4Fhw4ZV7dzVKiMAAACg0kwfAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACqp5tQMAAADAf4P58+ensbEx9957b1q3bp1mzZqlV69emTlzZpLktNNOW+XbnDx5ch555JEcdthhHyrTN77xjUyePDlJ8pGPfCTnn39+Nt1005X+fKUAAAAArIT+/fsnScaPH59WrVqlqakpY8aMKZcCH8arr76aMWPGrHIpsGjRotTV1eXCCy9M27ZtkyQ33nhjLrvsslx88cUrfTtKAQAAAAqle/fuK7x84sSJyxx74YUXcv/99+eBBx5Iq1atkiQNDQ055phjcsUVV5SvN2DAgOy5557lF/nHHXdcTj311HTt2jXDhw/P3Xffnfr6+qy//vq56aabcv7552fy5Mnp3bt3dt999wwePDiTJk3KZZddlqamprRq1SpDhw7NNttsk9GjR+fOO+9MXV1dXnnllYwcOTLt27cvn3v27Nmpq6tbpftCKVCjBg4cmKampmrHKLzGxsZqRwAAAGrAM888k06dOmW99db7UJ8/ffr0TJgwIXfccUfq6+szY8aMJMnZZ5+dK6+8MjfddFP5ehdeeGGuvfbatGvXLo8++mgGDRqUW265JUny+OOPZ/z48enQoUP5tvv375/f//73WX/99XP99devUi6lQI1qamryghQAAGANWN5IgDWtbdu2ad26dQYNGpS99947BxxwwHKv99hjj+Wll17K8ccfXz62pEBIkr322mupQiBJLrrooiTJDTfckB/+8IcZMmTISuey+wAAAAD8G9tvv31efvnlf7t+QLNmzbJo0aLyx/PmzSsfHzVqVHr16pVnn302vXr1yvTp05f5/FKplN122y3jxo0r/7v//vvLl7du3foDz33kkUdm3Lhxq/R1KQUAAADg39hyyy3TrVu3DBkyJHPnzk2y+AX/qFGjlrpex44d88QTTyRJnn/++Tz77LNJklmzZmX69OnZe++9069fvzQ0NGTKlClp06ZNZs2aVf78XXfdNU8//XSeeuqpJIsXFHz66aeXm2nOnDl57bXXyh9PmDAh22677Sp9XaYPAAAAwEq4+OKL09jYmJ49e6ZVq1apq6vL4YcfvtR1jjrqqJx66qk55JBD0qVLl3Tp0iXJ4lLgtNNOS1NTU0qlUvbff/907tw5CxcuzAYbbJCePXtmjz32yODBgzN8+PCcd955mTNnTt57770ceOCB2WGHHZbJ09TUlG9/+9uZO3du6urq0qFDh1XaeSBRCgAAAMBKadmyZQYMGJABAwZ84HU22GCDjBw5crmX3Xbbbcsca968ea677rqlju2+++7LjEBIksMOO2yprQs32GCD3HrrrSsbf7lMHwAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFFTzageoNQ0NDenbt2+1Y2Tq1KnVjsD/74JRj1Y7QpLk0L0/Wu0IZZttuG61IyRJHv/nO9WOUHPWaVY7Xe9Rn+lS7QhlN9/zdLUjJEm23bxdtSOUfWbX1tWOkCQZ+4dXqx2hbNs99692hLJ359TGz/JLzTpWO0JZ911r42/Pw8++Ve0IZV132KzaEcp2aD2v2hGSJAvmzKl2hLIFc+dWO0KSpOVG61c7Qtl6H9uy2hFYDqXAvxg2bFi1IyRJTRQTAAAArN1qo4YGAAAAKk4pAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoqObVDgAAAAD/DebPn5/Gxsbce++9ad26dZo1a5ZevXpl5syZSZLTTjttlW9z8uTJeeSRR3LYYYd9qEzHHXdcpkyZktatWydJzjzzzOyzzz4r/flKAQAAAFgJ/fv3T5KMHz8+rVq1SlNTU8aMGVMuBT6MV199NWPGjFnlUmDRokWpq6tLkpx//vnp2rXrhzq/UgAAAIBC6d69+wovnzhx4jLHXnjhhdx///154IEH0qpVqyRJQ0NDjjnmmFxxxRXl6w0YMCB77rln+UX+cccdl1NPPTVdu3bN8OHDc/fdd6e+vj7rr79+brrpppx//vmZPHlyevfund133z2DBw/OpEmTctlll6WpqSmtWrXK0KFDs80222T06NG58847U1dXl1deeSUjR478j+8LpUCNamhoSN++fasdo/AaGxurHQEAAKgBzzzzTDp16pT11lvvQ33+9OnTM2HChNxxxx2pr6/PjBkzkiRnn312rrzyytx0003l61144YW59tpr065duzz66KMZNGhQbrnlliTJ448/nvHjx6dDhw7l2z733HNTX1+fT3ziE+nXr1/atGmz0rmUAjVq2LBh1Y4AAACwVlreSIA1rW3btmndunUGDRqUvffeOwcccMByr/fYY4/lpZdeyvHHH18+tqRASJK99tprqULg4osvTocOHTJ//vwMGzYsF1xwQc4///yVzqUUAAAAgH9j++23z8svv5yZM2embdu2H3i9Zs2aZdGiReWP582bVz4+atSoTJo0KQ8++GAaGxszZsyYZT6/VCplt912y1VXXbXc21+yoOASSwqCFi1a5JhjjskZZ5yxSl+XLQkBAADg39hyyy3TrVu3DBkyJHPnzk2y+AX/qFGjlrpex44d88QTTyRJnn/++Tz77LNJklmzZmX69OnZe++9069fvzQ0NGTKlClp06ZNZs2aVf78XXfdNU8//XSeeuqpJIsXFHz66aeXm2nBggV5++23yx/feeed2W677Vbp6zJSAAAAAFbCxRdfnMbGxvTs2TOtWrVKXV1dDj/88KWuc9RRR+XUU0/NIYccki5duqRLly5JFpcCp512WpqamlIqlbL//vunc+fOWbhwYTbYYIP07Nkze+yxRwYPHpzhw4fnvPPOy5w5c/Lee+/lwAMPzA477LBMnvnz5+fkk0/Oe++9l1KplK222iqDBw9epa+prlQqlT78XQJrv7N+8kC1IyRJDt37o9WOUHMe/+c71Y5QtsUmK7+Yy5o0d96CakcoO3DPraodoezme5bfrlfatpu3q3aEsmbN6qodIUky9g+vVjtCWc89N6t2hLJ1mtfGYM6X3vjwW2ytbptvtG61IyRJHn72rWpHKPvWYbtUO0LZzBdfqHaEJMmCOXOqHaFswf//TnK1tVx//WpHKFvvY52qHaFsnXbrVztCzaiNvzgAAABAxSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAAAAQEEpBQAAAKCglAIAAABQUEoBAAAAKCilAAAAABSUUgAAAAAKSikAAAAABaUUAAAAgIJSCgAAAEBBKQUAAACgoJQCAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFVVcqlUrVDgEAAABUnpECAAAAUFBKAQAAACgopQAAAAAUlFIAAAAACkopAAAAAAWlFAAAAICCUgoAAABAQSkFAAAAoKCUAgAAAFBQSgEAAAAoKKUAAAAAFJRSAAAAAApKKQAAAAAFpRQAAACAglIKAFDz5s6dW+0IwGrw/PPPVzsCAP9CKQAV8vOf/7zi53z00UfzrW99KwcffHAOOeSQfPvb385jjz1W8Rw33XRT3nrrrYqfd3lmz56dyy+/PFdccUXmzp2ba6+9Nj179swZZ5yRd955p9rxkiSNjY1VO/djjz2W22+/PWPHji3/q6aHH344Z555Zvbbb7+q5kiSm2++uWrnfu+993LHHXfkJz/5Sa688sryv0rq2rVrhg4dmscff7yi512R448/PjNmzCh/PH369HzpS1+qaIY5c+ZkwoQJueGGG3LDDTdkwoQJmT17dkUzfJD33zeV9te//jUTJkwo/179+9//ntNPPz3HHXdcxTK88cYb6d+/fwYMGJC33347Q4cOzW677Zajjz46r7zySsVy/DvPPvtsRc/3/PPPl/8mv/rqq5kwYUL+8Y9/VDRDksybNy8jR47MxIkTkyR33HFHzj333IwcOTILFy6seJ7lmTZtWsXP+cILL2TgwIE5/PDDc/jhh2fgwIF54YUXKp7jlVdeKf+cvPjii7n++uvzu9/9ruI5lqd///7VjrDWqSuVSqVqh4Ai2H///XP//fdX7HyPPPJITj311BxzzDHZeeedkyRPPPFERo0alSuvvDKf/OQnK5Zl1113TbNmzbLbbrvl0EMPzWc/+9m0aNGiYud/v29/+9vp0KFD5syZkxdffDE77bRTDj300Nx111154YUXcumll1Yl1/tV+rGyxKBBg/LXv/4122+/fZo1a1Y+PmzYsIrmeOGFFzJ27NiMHz8+77zzTs4888wcdNBB2XDDDSuWYXllyIUXXpgzzzwzSdKnT5+KZUmSU045JQsXLsyOO+6Y+vr/1+d/+9vfrliGHj165OCDD87tt9+eli1bpk+fPundu3c6dOhQsQz/qnfv3hk3btxSxw499NCMGTOmIue/9957c95552WPPfYo3w+vv/56/vznP+e73/1uevToUZEcSXLNNdfk5JNPTrL4Z+hrX/taZsyYkYaGhvzwhz/MjjvuWLEsV155ZW688cZsscUWmTZtWo488sj8+Mc/zgknnJCvfOUradOmTUVyfOUrX8mnP/3pzJ49O3fccUeOPPLIHHHEEbnzzjtzzz335Cc/+UlFcvw7lfyd/+Mf/zi33XZbmjdvnpNPPjk//vGPs8suu+SJJ57ISSedlC9+8YsVyZEkZ5xxRhYsWJCmpqa0b98+U6dOTY8ePfKHP/wh66+/fs4777yKZfkglf57/Ic//CH/93//l6OOOmqp52633XZbLr300uy9994VyXHzzTfnuuuuy6JFi/LlL385d9xxR3bbbbf8/ve/z+GHH57jjz++IjmSZODAgcscu+uuu3LQQQclqfxzlLVV82oHgLXJB/2SLJVKFX8X+pprrsnFF1+cT3/60+VjPXr0yB577JGrrrqqoqXAFltskZ/97Ge58847M2rUqAwdOjQHHXRQ+vTpk0984hMVy5EsfofkBz/4QRYtWpR99tknI0aMSF1dXbbddtv06tWrYjm6d+++3OOlUqlqoyomTZqUO+64I82bV+dPw8iRIzNu3Li8+eab6d27d37605/my1/+cr7whS9UPMtZZ52V/fbbL+3bty8fa2pqyh//+McklS8FXn311dxxxx0VPee/atu2bfr27Zu+ffvm4Ycfzrhx49KzZ8/stNNO6d27d8XvkyRZtGhRZs6cmbZt2yZJ3n333SxYsKBi57/00kszatSobLrppksdf+2113LSSSdVtBT49a9/XS4FLrnkkpx66qnp2bNnfv/73+f73/9+RUe6/OpXv8qdd96ZDTfcMC+//HI+97nP5ZZbbqloMZEkb775Znlkws0331z+G3344YfnpptuqmiWFY3smTVrVsVy/OpXv8odd9yRuXPnpnv37rnzzjvToUOHzJgxI1/84hcrWgr8/e9/z+2335733nsvn/rUp/Lggw+mRYsW+fznP1/R3ycfNCKuVCpVfOraZZddlquuuiq77LJL+ViPHj3SvXv3nHvuufnFL35RkRy33HJL+XHymc98Jvfee2822mijvPvuuznuuOMqWgo8+OCD+dSnPpW99torS97Lvu+++7LnnntWLEMRKAVgNXr66adz6aWXplWrVksdL5VK6du3b0WzvPzyy0sVAkt069Yt559/fkWz1NXVpU2bNjnyyCNz5JFH5tVXX824ceNy1llnZdGiRbnnnnsqlmXJC976+vpsv/32qaurWypnpcyZMyfXX399+cXMEqVSKcccc0zFcrzfRz/60SxYsKBqpcC5556brl275vrrr0+nTp2SVPZ78n433nhjLrnkknzuc58rl0V//OMfq/aOxI477phXXnklHTt2rMr5/9Vee+2VvfbaK4MHD87dd9+dcePGVaUUOOaYY3Lsscfm0EMPTZKMGTOmoj8/CxcuXKYQSJLNNtusqsOfJ0+enJ49eyZJ9tlnn1x44YUVPX+rVq3KI3s+9rGPZcstt6x4IZAs/ftjn332WeqyRYsWVTTLVVddla985StLjcKqhubNm6dVq1Zp1apV1l133fIIl3bt2i01CqkSlrzAW7hw4VI/L/X19RX9/gwaNCg9e/Zc7t+b+fPnVyxHsniK4/sLgSV22WWXik5LatasWflx0rFjx2y00UZJkvXWW6/if5fvuOOOfP/738+kSZNy5plnpm3btrnyyivLv/dZPZQCsBrtvPPOad269XLfhV9vvfUqmqV169Yf6rI14V9nKW2++eb5xje+kW984xsVX+OgZcuWmT17dtZdd91cf/315ePTpk2r6JO1j3/845k2bVq6dOmyzGXbbLNNxXK830c+8pEcddRR2X///Zea3nHqqadW5Px33313xo4dm5NOOikf+chH0qtXr4o/cV9ijz32yIgRIzJ8+PDccccdOeecc6pWUCTJiSeemCOPPDJbbLHFUt+bG2+8sWIZlveCoaGhIb169aroKJv3+8IXvpAtt9wyDzzwQJJkwIABFRtemywuR04//fQcddRR2WyzzZIsHiVw6623pmvXrhXLkSx+V3zJu9EzZ87MokWLyt+zSs8UnT59+lLvvs6ePXupjytVIG2++eaZNWtW2rRps1Qx8vrrry9T3q9pXbp0yYEHHpjtt99+mctuu+22iuXo0KFDLrnkksyePTtbb711Lr/88hx88MF56KGH0q5du4rlSJJ99903Rx99dObPn58jjjgi/fr1y957752HH354uffTmrLNNtvk5JNPztZbb73MZb///e8rliNJeTpFQ0PDUsfnzJlT0VFQixYtSqlUSl1dXc4999yljr/33nsVy5EsLqwuvPDC3H///fnSl76UL3/5yxU9f1FYUwBWo3fffTctWrRY5pd5NRxwwAH51re+tczxUqmUK664Ir/5zW8qluW2227LkUceWbHzrciSP3L/atq0aXn77ber9oK8FnzQ8NZKlQLv98gjj2TMmDG55557sueee+Zzn/tcDjnkkIrnSBYvmHb++efnlVdeyR/+8IeqZDj44INz+OGHL7Peg+GT1bVo0aKMHTs2EyZMyOuvv55k8SiBAw88MH369Klo0fivP7/HHHNMNtxww0ydOjWXXnppRUcLLG8O8PtVew7w3LlzM3fu3GywwQYVO+df/vKXbLrppssdWfK3v/0tnTt3rkiO6dOn5/rrr09dXV15rvjNN9+czTffPAMGDMgWW2xRkRxLPPTQQ6mvr8/ee++dJ554ImPHjs1mm22WL37xixV7LnXvvfdm6623zpZbbrnMZb/97W+XO+pyTRk+fHj++te/ZsiQIeWRYS+//HKGDh2anXfeuWLryDz44IPZY489linPXnzxxdx3330VX9B1iVmzZuWiiy7K448/vsx6MvxnlAKwGn33u9+tiYVxktp/UlYL/vnPf+af//xnevTokVmzZmXBggVZf/31qx2L95k7d27uuuuujBs3bqmRHZW2YMGCvPnmm8t9Ql8Jhx12WEaPHl2Vc6+MadOmLbX+QqVMnz49V199dZ577rnMmzevfLySIyj47/GnP/0pTz75ZDp37rzMdAKoBYsWLcrll1+e66+/vlyKzJs3LyeeeGJOO+20qk8/Ye2lFIDVqJKrXv8nXn311Wy++eYVO99tt92W7t27Z4MNNshrr72WAQMGlJ+YDRs2rOLvTCSLF9EZNWpUZs6cmXvvvTcvvfRSvvvd71b8xcR9992XCy64IK+++moWLlxYHsnwzDPPVCzDLbfcks9//vM1NVKglt1333054IADKnrOq6++OptttlkOOuigrLPOOhU998qo1o4ZX/3qV9O1a9fccsstGTBgQH7xi19k6623zv/93/9VLMPbb7+dN998M9tss81S63H8+c9/rvhCqv+qf//+ueiii6py7ldeeSU///nP849//CN1dXXZZpttcvTRR1d0XYxDDz001113XTbYYIP8/Oc/z8iRI7PffvvlT3/6U3r06JFTTjmlYlmSxdsE33DDDUvdJyeeeGJ23XXXimV4+umn87GPfSxt2rTJ/Pnzc8011+SJJ55I586d87Wvfa3i0yruvPPOXHfddUvdJ1/+8pfzP//zPxXNsWTrvY4dO5bfDd92223zqU99qqI5lpg3b15eeumlJEmnTp3SsmXLime48847c+211+b555+v6vem1rKsrawpAAUxe/bsTJgwIWPGjMk//vGPPPzwwxU794gRI8rTBy644IL07NkzV199dR544IGcc845VXlX7+c//3luvfXWHHXUUUkW/9Gtxn7E3//+93PxxRdnl112qfgiT0vUSjfcpUuX8tSOJZnq6uqqUpSsyNChQyteClx22WVJku985ztJUpX7pJZW6F5iypQpOemkkzJmzJgccMAB2W+//Sq60OCvfvWrDBs2LBtssEHmzJmTSy+9tPwC7/zzz69oSby80WH33ntv+XglR4c9++yzOe644/LpT386++67b0qlUp566qkcfvjhufHGG5e7lsqasGDBgvIUgV/+8pf52c9+lnbt2mXevHk54ogjKloKvH+b4CWLQD7xxBP56le/WtFtgvv3718edXTJJZfk3XffzTHHHJMHH3ww55xzTi6++OKK5EiSe+65J8OGDctpp52WnXfeOaVSKU8++WSGDRuW5s2bV2z3jg/afm/s2LH55z//WdGV9pPFowUefvjhPPfcc6mrq8uUKVPyqU99qqLPEWrle1NrWdZmSgFYjZ555pnlLo5TrRc1pVIpDz30UMaMGZPf/e53ee+999LY2Jh99923ojnevzjO5MmTywXBgQcemB/96EcVzbJEixYtllqwrVrat29f0XeJlufoo49Okhx00EHZdtttl7rsueeeq1iOvffeOzNnzkzv3r1zyCGHVGU4+hIrmn4zY8aMCiZZ7Nlnn634Of9VLa3QvcSSn+F11103L730UjbaaKOKbul5zTXXZMyYMdl4443zpz/9Kf/3f/+Xc845J/vvv3/Fy7Za2rbrRz/6Uc4666xlVgcfN25cfvjDH+aKK66oSI5SqZR333036623Xlq0aFHe7aVly5YVX8S0lrYJXvJzM2nSpPziF79IfX19Pv3pT1d8wdAbb7wxV1xxRT7+8Y+Xj22//fbp3LlzLr744oq92Kul7femTZuWE044IbNmzcr222+fUqmUm2++OW3atMmIESMq9nexVr43tZZlbaYUgNWoS5cuH/huWqVdfPHF+dWvfpWOHTumd+/eGTp0aHr16lXRBXOW6Ny5c0aPHp3DDjss22yzTZ566qnsuOOOefnll6s2P65Tp065//77U1dXl+nTp+faa6/NTjvtVPEc++23X374wx/mc5/73FLDA5esZF5J/fv3X+adzeUdW1Ouv/76vPHGGxk3blxOOOGEdOzYMYceemj233//im+TOGHChAwYMGCZ4qhUKlV0kc5aUksrdC9x4IEHZsaMGTnllFNy5JFHplQq5aSTTqrY+UulUjbeeOMkySc/+cmMGDEiJ598cmbNmlXobbv+9re/5fLLL1/meO/evStaBH/1q1/NiSeemFNOOSX77LNP+vXrl4MOOigPPfRQRXepSGpnm+C2bduWFzZs37593n333ay//vppamqqeFEyderUpV7oLbHLLrtk6tSpFctRS9vvXXHFFfnkJz+Zs846q/z8aOHChRk2bFiuuOKKnHPOORXJUSvfm1rLsjZTCsBaauTIkdl5553z9a9/vfzkp1pbqg0ZMiQDBgzIT3/603zkIx/J0UcfnS222CL19fVVW5jxu9/9boYNG5YpU6bkf//3f7P//vvnrLPOqniOJcM4f/nLX5aP1dXVZeLEiRXL8Nprr+XVV1/NnDlz8qc//al8fObMmWlqaqpYjiTZZJNNcsopp+SUU07JxIkTM2jQoHzlK1/JV77ylYrm2GGHHdKlS5flPhEZPnx4xXIcdNBBueuuu8pTK5aMOqrG6KPTTjvtA4evvn/Lqko6+eSTkySf+cxn8rvf/S7z589PmzZtKnb+5s2b56233iq/iOjYsWNGjBiRr3zlK5k8eXLFciS1tW3XiualV3LOes+ePdOpU6eMGDEi//znP7NgwYLMnj07n/vc58pD+CulVrYJHjRoUE4//fTsu+++6dixY44++ujsu+++efTRRyu+ovy66677gZdV8j6ppe33/vCHP2TcuHFLvWHSrFmz9O/fP717965Yjlr53iS1lWVtphSA1aga7zR/kN/97neZMGFCfvSjH2XgwIE5+OCDK7rH7fu1b98+V111VV588cU8//zzOeaYY7Lppptm5513rkqeZPE7ALWwA0MtvOv8xz/+MaNHj87UqVOXenevTZs25TnslTJ//vzcfffdGTt2bN5+++2ccsopFdvT/P2+//3vl4ca/6vbb7+9YjneeuutDBgwIDfccEO6du1atWIvSfbZZ58PfAK2ySabVDhN0tTUlAceeCCvvfZamjdvnq233rri7/5+85vfzOuvv14uBZLF98WIESNy7bXXVjTLEvvvv3/22GOPXHTRRRUtSN5vzpw5mTRp0nKnUFR6/Ylddtkll156aUXPuTzTp09f7kjCUqlU0SlJO+20U8aMGZNf/epXef755/OpT30qm266aU466aSKLkCcLH4H+IMWuH3zzTcrlqNfv35pampKq1atsttuu5WPv/zyyzniiCMqliNZXDQub2pjixYtKjpirla+N7WWZW1m9wFYjcaMGbPMk/YNNtggu+yyS1W3ups8eXLGjh2bcePGpXXr1vnc5z6Xr371q1XLUwvee++93H333XnllVeWKkuqsdL+Qw89lBdeeCHHHnts3n777bz77rvL3S95TRs7dmxVXoAvMWjQoEyaNCkHHHBA+vTpU7HFyGrZm2++mfHjx2fcuHGZNWtWevXqlT59+lRlx47jjjsu11133TJPWP/617/mm9/8Zh588MGKZXnggQfy3e9+NxtuuGGef/757L777nnzzTdTV1eXH/3oRxVd4Z5lHXfccSu8/KabbqpQkg9W6V1EbBO8rA96obdEEXe+WdEuVpXc4aqWvje1lGVtphSA1Wh5f/SnTZuWp59+OhdeeGHF38VankmTJmXs2LEVncP41a9+NVdddVU+85nPLFWaLBmuV8mh8kuccsopWbhwYXbcccelhkR/+9vfrmiOK664Ik888UReeuml3HXXXXnjjTfyrW99K6NGjapojmTxE/VevXqlXbt2SRa/s/WrX/0qxx57bEXO36VLl2yyySZp1qxZTTxOam0LpKeffjrjxo3LHXfckc033zx9+vSp6Er7l156aZ588slcddVV5WLgL3/5S04//fRccMEFFd26q2fPnvnxj3+cj370o3n22Wdz9dVX57LLLsv48eMzZsyYXH/99RXLUkuPk1rK8kHmzp1b8W3vlqda22jWglrZBvCGG25Iq1at8vnPf36p47fcckvmz5//b8ul1alWfnbevwvP+1V6ylgtfW9qKctarQSscS+//HLpyCOPrOg5//rXv5buv//+ZY7fd999pSeffLKiWd54441SqVQqTZ48eZl/r7zySkWzLPG5z32uKuf9V7179y4tXLiw1Lt37/KxQw45pCpZevXqtcyx9+da0/71sfHCCy+UnnrqqdLjjz9emjx5csVylEql0t13313q1q1b6dZbby0988wzpaeffrp06623lvbbb7/SPffcU9Es/+qZZ54pHXrooaUuXbpU/Nzf+973Sl/5yldK8+fPLz388MOlfffdt/Twww9XPMe/Plb79OlT/v9BBx1UsRy19DippSzL84c//KHUv3//0h577FGxcw4YMOAD/+26664Vy1EqlUpPPfVUqU+fPqVdd9219IUvfKH00ksvVfT8S9TS4+Twww8vzZs3b5nj8+bNq+jfnlq6T2pFrXxvai3L2syaAlABHTt2rPhiNY2NjRkyZMgyx7faaqsMHTo01113XcWyPProoznooIOWma9YKpVy9tln53vf+17Fsiyx44475pVXXqn6MOMWLVosNVJh4cKFVcuyvJWnK7kOxc0335w+ffpku+22y9y5c3P00Ufntddey4IFC3LRRRdVdL5rrW2B9Pbbb+f222/P+PHj8+6776ZXr175wQ9+UNEMSXLWWWdlyJAhOfHEE/PSSy/liiuuWGoObqVsuummGTFiRLp165Y77rgjW221VZL/t2BYpdTS46SWsizxwgsvZOzYsRk/fnzeeeednHnmmenfv3/Fzl9Lu4gMHTo0RxxxRPbaa6/cddddueCCC6qyJW8tPU4WLlz4gfPnK7kTQi3dJ7WiVr43tZZlbaYUgAp45513Kn7OmTNn5mMf+9gyxz/2sY9VfGGWSy65JC1atFhq/mapVMp3vvOdquz5niQnnnhijjzyyGyxxRZL/bG58cYbK5pjl112yc0335wFCxbkqaeeyvXXX5999923ohmW6Ny5c4YPH56TTjoppVIp119/fTp37lyx899///3lhQ3Hjh2bhoaG/P73v88///nPDBw4MJ/97GcrlqVWtkC64447Mnbs2Pz1r39N9+7dM2DAgKrsO5/8v3mdG264Ye68887svvvueeihh/LQQw8lqey8znPPPTcXXHBBbrvttuywww4ZNGhQkuTdd9/9t3O3V6daeZzUWpaRI0dm3LhxefPNN9O7d+/89Kc/zZe//OV84QtfqGiOWtlFJFk8beKLX/xikuQb3/hGRVeSf79aepzMnj078+fPX+YFX1NTU0UXpKyl++T9O80sUY0dZ2rle1NrWdZmSgFYjZa3GMr06dPz29/+Nt/85jcrmmX69OkfeNmcOXMqFyTJNddck5NOOinrrLNOPvWpT2XBggX5v//7vyxYsCA//OEPK5plie985zs55ZRTsv322y+19U+l9e/fP1dffXUaGhpyzjnn5IADDsgpp5xSlSzf/e53873vfS+f/exnU1dXl/32269ieyInScuWLctzKR955JEccsghWWedddK5c+eKvxtQK1sg/eIXv0ifPn1y+eWX18Q87GTxE9Rqz+Gsr6/PZZddtszx9ddfP+uss07FctTK4ySprSznnntuunbtmuuvvz6dOnVKUp0tcWtlF5Eky/yd+aDtPde0WnqcLCk6zz333PJOGbNmzcqQIUMq+u58Ld0nzz77bEXP90Fq5XtTa1nWZkoBWMO23HLLHH300eUnRpU874QJE5ZZJOfuu++u+MrlW2yxRa655pqcfPLJGTx4cH7+85+nRYsWufzyyyu6xc77tWzZMieddFJVzv1+LVq0yKmnnloTq+e2a9cuF110UdXOXyqVMm3atKy77rp55JFH8rWvfa182bx58yqapVa2QKrkgnn/Tps2bVa42FMlfelLX8qNN96Y9u3bL3X8vvvuyznnnFOxnRBq5XFSa1mWbCt60kkn5SMf+Uh69epVlWG+K/q7u95661UwSfLMM89k++23L39cKpWy/fbbV/wd4Fp6nPTt2zf9+/dPt27dys9LXnrppXTr1i19+/atWI5auk9qRa18b2oty9rM7gNQIZVe6fi5557LCSeckH322Se77LJLksVbh/3+97/PiBEjsu2221YsyxJ/+9vfcsIJJ2S//fbLhRdeWNU916+++upsttlmOeiggyr6zuK/Wt4TkbZt2+bjH/94dt1114pmmT17dq666qq8+uqrufTSS/PPf/4zzz//fMWG7d9+++255JJL0rJly2y11Vb5yU9+kmTx4/YHP/hBfvrTn1YkR2ILpOU54ogjMnLkyGWGcM6fPz9HHXXUcvdgX1NGjhyZW2+9NTfeeGP5xd1dd92V733ve7nqqquWevG1JtXS46SWsrzfI488kjFjxuSee+7Jnnvumc997nM55JBDKnb+WllVvlbU4uPkxRdfLJci22+/fcXfuKjF+6RWVPt7U6tZ1kZGCkCFVLp/23bbbTNmzJiMHDkyv/vd75Is/iU6evTodOjQoaJZ3r/FTqlUyvjx43P77bdX/B2S91sy9HjJHPZqZXnppZfyl7/8pTwEbuLEidlxxx0zZsyYHHzwwTn55JMrluXss8/O9ttvn7/97W9JFi/m1rdv34qVAj179kzXrl3z9ttvp0uXLuXjm2yySUW30Exq613xWlFLiz194QtfyPz58/OlL30pI0aMyH333ZdLLrkk1113XUULz1p6nNRSlvfbc889s+eee+acc87JXXfdldGjR1esFLjnnnsybNiwnHbaadl5551TKpXy5JNPZtiwYWnevHkhhx7X4uNkiy22qOoLvFq8T2pFtb8371dLWdZKFd/vAArq05/+dLUjUIOOP/740owZM8ofz5gxo3TssceWZs2aVfrf//3fimY59NBDS6XS0tsQLm+bwiKwBdKyPvvZzy73Ppk7d26pR48eVUhUKl111VWlAw88sHTAAQeUXnjhhYqfv5YeJ7WUZUXOPffcip3r2GOPLT322GPLHH/88cdLxx57bMVy1JL/lsdJJblPoFSqzionsJb605/+tNx/jzzySMXb5m984xvl///rln/HHHNMRbPUknfffbfaEZby5ptvLjW3db311stbb72Vddddd7nvyq5J9fX1WbRoUXlUx7Rp0yp6/lpSS++K14oliz3NmjWrfGzWrFk5++yzK/6O68CBAzNw4MC88MILmT59ejbffPNcddVV5eOVUkuPk1rKsiITJ06s2LlqaVX5WvHf8jipJPcJmD4Aq9Xll1++zLElW8lsvfXWFc3y2muvlf8/adKkpS4r8hYu++yzT/bZZ5/06dMnPXr0qPgL73/18Y9/PN/+9rfL21ONHz8+H//4xzN37tyKL8J4xBFHpF+/fpkxY0auv/76jB49Ol/60pcqmqFW2AJpWbW02NP7t2Ws1haNSW09Tmopy4qUKjiVrpZWla8V/y2Pk0pyn4BSAFarH/3oR3nzzTez1VZbJUl+/etfZ968eamrq0u3bt2qlutfn4RVc4G/auvYsWM++9nP5uabb86QIUPyP//zP+nTp0923333quQ599xzM2rUqPzyl79MsvgFztFHH50WLVpk1KhRFc1y9NFHZ6uttkqHDh0yderUnH322enatWtFM9QKWyAtq0WLFvnBD35QE4s9HXrooRU/5/LU0uOklrKsSCX//lhVfln/LY+TSnKfgN0HYLUaOnRoOnfunKOPPjpJ0qNHj3zyk5/M3Llzs9FGG+Xss8+uWJZDDz00Y8aMWeb/y/u4SN7/tb/yyisZN25cxo8fn7q6uvTq1Svf/OY3q5yQWjB//vz0798/v/3tb5d5V/ziiy+u+giTolu4cGHGjh2burq69OnTJxMmTMj48eOz3Xbb5Zvf/GZatmxZkRy19DippSyf+cxnlvviv1QqZerUqXnyyScrksOq8suqpcdJrXCfgFIAVqs+ffpk9OjRqa+vL3+8ZJuuY445Jj//+c8rluVfV/z/1/9XY8X/WvBBhcif//znjBs3Lueee25F88yfPz+/+MUv8ve//z3z5s0rHx82bFhFcySLt/4bPnx4Jk+enAULFpQfK5WcA1xrauFdcZY1ePDgTJs2LfPmzUubNm1SX1+fgw8+OPfcc0/WWWedDBkypKJ5aulxUgtZXn311RVevvnmm1ckxw033LDCVeWPO+64iuSoRbXwOKk17hOKzPQBWI0WLVpULgSSpF+/fuX/z5kzp6JZnn322Yqe77/FB23H+IlPfCKf+MQnKpwmOeuss9KuXbs88MADOemkkzJu3LjlLoxVCQMGDMg3v/nN7LLLLks9jovMFki16S9/+Utuv/32zJ8/P/vuu28eeuihtGjRIp/61KeqMrWglh4ntZClUi/6/51f/epXGTly5DLHDz300Bx11FGFLgVq4XFSa9wnFJlSAFajpqamNDU1paGhIUnyqU99Ksnihf0qXQqwfD/+8Y+rHWEpf/vb33L77bfnkUceybHHHpvDDz88X/7yl6uSpaGhIQcffHBVzg2rYskinC1atMjmm29eHt7bvHlzhVYNWNH0gUqOPrKqPMDKUQrAatSjR48MGjQo5557bnnV49mzZ1uspsaUSqXMmjUrbdu2Xer4K6+8ko4dO1Y0y5ICqUWLFnn77bfTrl27qi2A9T//8z8ZN25c/vd//9ccSmpafX19ebXw2267rXx89uzZVUzFEjfddFOSxb9rv/rVr+bqq6+uSg6rygOsHKUArEbf/va3c8YZZ6Rbt27p1KlTksWL1ey7774V37KL5fvDH/6Qvn37ZuHChdl6661z0UUX5WMf+1iS5PTTT6/4Aoy77bZbZsyYkWOOOSaHHnpoWrVqlb333ruiGZa47LLLkiRnnnlmeSvNIq8/Qe36yU9+Uh4RsM4665SPz5o1KwMHDqxWLP5/758+sGQ0RzVYVR5g5VhoENaAF154oTynv3PnzuUtCqm+ww8/PMOGDct2222XcePGZfjw4bn88suz0047LbUwZDW8+uqrmTVrVjp37ly1DACrUzV3u7GqPMDKMVIA1oAtt9wyW265ZbVjsBwLFizIdtttlyTp3bt3ttxyy3zrW9/KsGHDKrp/9muvvbbMsbq6urRt2zavvfZaNttss4pleb933nknf/3rX5MkH//4x9O+ffuq5IAVqZU569S2Fi1a5Ac/+IFV5QH+DSMFgELp2bNnfv7zn5eHkibJc889l69//euZOXNm/vjHP1Ykx5IXNcv7FVytFzW//e1vM2jQoOy6664plUr561//mu9973vZb7/9Kp4FVmTJlncfNGe9Vla/Lypb4gL8dzFSACiU4447Ls8++2z22GOP8rFtt902P/3pT3PppZdWLMdvfvObip1rZQ0fPjw///nPy4stvvLKK/nWt76lFKDm1MqcdZbPlrgA/12UAkChfOYzn8lGG220zPGPfexjOeqooyqWY3nTB96vGtMHFixYsNTuCx07dsyCBQsqngMAgMpRCgCF8qUvfSk33njjMnPl77vvvpxzzjl58MEHK5Lj2GOPrbnpA5tttlmuu+66fP7zn0+S3Hrrrdl0000rngMAgMqxpgBQKCNHjsytt96aG2+8Meutt16S5K677sr3vve9XHXVVdl+++2rnLB6pk6dmvPPP7+8rsJee+2VQYMGZeONN65yMliaOesAsPooBYDCueGGG3L77bdnxIgRue+++3LJJZfk2muvzbbbbluVPM8991weeeSRJEnXrl2zzTbbVDzDwoULc+WVV+Zb3/pWxc8NAED11Fc7AEClnXjiiTnooINy+OGHp7GxMSNGjKhaIfDLX/4yX/3qV/PSSy/lpZdeyle/+tWq7OndrFmzik2dAACgdhgpABTKwIEDy///zW9+k+222y4f/ehHy8eGDRtW0Ty9evXKiBEjymscTJs2LSeccELGjx9f0RxJ0tjYmIULF6ZPnz5p3bp1+Xg1Fj0EAKAyLDQIFMqee+653P9XS6lUWmrRw/bt2y938cFKuP3225Mkv/71r8vHqrXoIQAAlWGkAEAV9evXL+utt155O8TbbrstM2bMyCWXXFLlZAAAFIFSACiUhQsXZuzYsamrq0ufPn0yYcKEjB8/Ptttt12++c1vpmXLlhXNM2vWrPzwhz9casX/b37zm1l33XUrmmOJv//97+VFD/faa6+qLHoIAEDlKAWAQhk8eHCmTZuWefPmpU2bNqmvr8/BBx+ce+65J+uss06GDBlSkRwjRoxIQ0NDPv/5zy91/JZbbsn8+fNz3HHHVSTH+/3sZz/L9ddfnx49eiRZvObCiSeemC9+8YsVzwIAQGUoBYBC6dmzZ26//fbMnz8/++67bx566KG0aNEiCxYsyKGHHlqeV7+mHXHEERk5cmRatGix1PH58+fnqKOOytixYyuS4/0OOuig3HrrrWnXrl2SZMaMGTnqqKNy1113VTwLAACVYUtCoFCaN1+8vmqLFi2y+eabl1+UN2/ePPX1lfuVuHDhwmUKgSW5Fi1aVLEc79emTZtyIZAk6623Xtq0aVOVLAAAVIbdB4BCqa+vz/z589OiRYvcdttt5eOzZ8+uaI7Zs2eXc7xfU1NT5s6dW9Esf/rTn5Is3o3htNNOy6GHHpokGTt2bE3s0AAAwJpj+gBQKG+++Wbat29fHjGwxBtvvJEXXnghe+21V0VyXHjhhXnjjTdy7rnnlt+NnzVrVoYMGZKPfOQjOfPMMyuSI8kK1y+oq6vLjTfeWLEsAABUllIAoArmz5+f/v3757e//W222GKLJMlLL72Ubt265eKLL17u1AIAAFjdlAJAoXzmM59JXV3dMsdLpVLq6uoyceLEiuZ58cUX88wzzyRJtt9++3JBUEn/X3t3bCIhGIQBdCzACmxAMTa0lU2twsgiBFNrsoStYAvYC44TTzZW2HkvGjCZ1A/m+7dti7Zt9zOCs67rLt4IAICrCAWAVJ7PZ0T8hgDDMMSyLP++V1V1x1q3Gscxpmn6eEbgfAAA4LspGgRSOf70/71AkF3f9xERsa5rvF6vKMvy5o0AALiKJwkBkpvneZ8fj8eNmwAAcDWhAEByxysyF2UAALk4HwBSqet6Lxp8v9/RNM0+F0Wxl/5lcixe/FTCCADA91I0CJDcOSg5zxmDEgCALIQCAAAAkJROAQAAAEhKKAAAAABJCQUAAAAgKaEAAAAAJCUUAAAAgKSEAgAAAJCUUAAAAACS+gF93DWV5PTkmgAAAABJRU5ErkJggg==",
                         "text/plain": [
                             "<Figure size 1000x1000 with 4 Axes>"
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 }
             ],
             "source": [
                 "visualize.draw_heatmap(data=mean_marker_exp_per_cluster.apply(zscore).values,\n",
                 "                       x_labels=mean_marker_exp_per_cluster.index.values,\n",
                 "                       y_labels=mean_marker_exp_per_cluster.columns.values,\n",
-                "                       center_val=0)"
+                "                       center_val=0, save_dir=kmeans_out_dir, save_file='marker_expression_heatmap')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.4 Overlay segmentation with neighborhood clusters"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "It may be helpful to view a few example overlays to assess clustering. For example, for a dataset of lymph nodes, we would expect to see neighborhoods corresponding to the T cell zone, B cell zone, germinal centers, etc."
             ]
         },
         {
@@ -579,15 +617,15 @@
             "execution_count": null,
             "metadata": {
                 "tags": []
             },
             "outputs": [],
             "source": [
                 "# Directory to save overlays\n",
-                "overlay_out_dir = os.path.join(spatial_analysis_dir, \"overlays\")\n",
+                "overlay_out_dir = os.path.join(kmeans_out_dir, \"overlays\")\n",
                 "if not os.path.exists(overlay_out_dir):\n",
                 "    os.makedirs(overlay_out_dir)"
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
@@ -607,22 +645,22 @@
                 "    segmentation_dir,\n",
                 "    name_suffix='_neighborhood_mask'\n",
                 ")"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 20,
+            "execution_count": null,
             "metadata": {
                 "tags": []
             },
             "outputs": [
                 {
                     "data": {
-                        "image/png": "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\n",
+                        "image/png": "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",
                         "text/plain": [
                             "<Figure size 1000x1000 with 2 Axes>"
                         ]
                     },
                     "metadata": {},
                     "output_type": "display_data"
                 }
@@ -639,51 +677,56 @@
                 "        xr_channel_names=None,\n",
                 "    )\n",
                 "\n",
                 "    plot_utils.plot_neighborhood_cluster_result(neighborhood_mask, [fov], k=k, save_dir=None)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 5. Save data"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 5.1 Save data"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
-                "After running k-means using the optimal k, re-save the cell table with neighborhood cluster ID appended. If a cell has no other cells within the distance specfied by `dist_lim`, that cell is excluded from this table."
+                "After running k-means using the optimal k, re-save the cell table with neighborhood cluster ID appended. All cells from the original table are contained within the new one, even if they had no neighbors and were excluded from k-means clustering. "
             ]
         },
         {
             "cell_type": "code",
             "execution_count": null,
             "metadata": {},
             "outputs": [],
             "source": [
                 "#  Save cell table\n",
-                "new_table_path = cell_table_path.replace(\".csv\", \"_kmeans_nh.csv\")\n",
+                "new_table_name = os.path.basename(cell_table_path).replace(\".csv\", \"_kmeans_nh.csv\")\n",
+                "new_table_path = os.path.join(kmeans_out_dir, new_table_name)\n",
                 "cell_table_new = all_data.merge(all_data_cluster_labeled, on=list(all_data.columns), how='left')\n",
                 "cell_table_new.to_csv(new_table_path, index=False)\n",
                 "\n",
                 "# Save number of each cell type and mean marker expression per neighborhood\n",
-                "num_cell_type_per_cluster.to_csv(os.path.join(spatial_analysis_dir, \"neighborhood_cell_type.csv\"), index=True, index_label=settings.KMEANS_CLUSTER)\n",
-                "mean_marker_exp_per_cluster.to_csv(os.path.join(spatial_analysis_dir, \"neighborhood_marker.csv\"), index=True, index_label=settings.KMEANS_CLUSTER)"
+                "num_cell_type_per_cluster.to_csv(os.path.join(kmeans_out_dir, \"neighborhood_cell_type.csv\"), index=True, index_label=settings.KMEANS_CLUSTER)\n",
+                "mean_marker_exp_per_cluster.to_csv(os.path.join(kmeans_out_dir, \"neighborhood_marker.csv\"), index=True, index_label=settings.KMEANS_CLUSTER)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 5.2 Save overlay for all FOVs"
             ]
         },
         {
@@ -714,16 +757,15 @@
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
-            "pygments_lexer": "ipython3",
-            "version": "3.8.16"
+            "pygments_lexer": "ipython3"
         },
         "vscode": {
             "interpreter": {
                 "hash": "31e90e2a7155cbaa93471c58eaf30b3c41423e5d17fccea222aec5e482389189"
             }
         }
     },
```

### Comparing `ark-analysis-0.6.3/templates/example_visualization.ipynb` & `ark-analysis-0.6.4/templates/example_visualization.ipynb`

 * *Files 2% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9864955357142857%*

 * *Differences: {"'cells'": "{0: {'execution_count': None}, 2: {'execution_count': None}, 3: {'execution_count': "*

 * *            "None}, 4: {'execution_count': None, 'outputs': {0: {'execution_count': None}}}, 6: "*

 * *            "{'execution_count': None}, 8: {'execution_count': None}, 9: {'execution_count': "*

 * *            "None}, 10: {'execution_count': None}, 12: {'execution_count': None}, 13: "*

 * *            "{'execution_count': None}}",*

 * * "'metadata'": "{'language_info': {delete: ['version']}}"}*

```diff
@@ -1,12 +1,12 @@
 {
     "cells": [
         {
             "cell_type": "code",
-            "execution_count": 1,
+            "execution_count": null,
             "metadata": {
                 "scrolled": true
             },
             "outputs": [],
             "source": [
                 "# Imports\n",
                 "import os\n",
@@ -25,38 +25,38 @@
             },
             "source": [
                 "## Load Data from a CSV"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 2,
+            "execution_count": null,
             "metadata": {},
             "outputs": [],
             "source": [
                 "# Setup filepaths\n",
                 "base_dir = \"../data/example_dataset/\"\n",
                 "data_dir = os.path.join(base_dir,\"spatial_enrichment_input_data\")\n",
                 "viz_dir = os.path.join(base_dir, 'visualizations')"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 3,
+            "execution_count": null,
             "metadata": {},
             "outputs": [],
             "source": [
                 "# create viz_dir directory if it does not already exist\n",
                 "if not os.path.exists(viz_dir):\n",
                 "    os.mkdir(viz_dir)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 4,
+            "execution_count": null,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "text/html": [
                             "<div>\n",
                             "<style scoped>\n",
@@ -246,15 +246,15 @@
                             "2  gran_lung        1.0  endothelial  endothelial    nonimmune            5  \n",
                             "3  gran_lung        1.0       immune    imm_other        other            4  \n",
                             "4  gran_lung        1.0       immune    CD14_Mono      myeloid            1  \n",
                             "\n",
                             "[5 rows x 53 columns]"
                         ]
                     },
-                    "execution_count": 4,
+                    "execution_count": null,
                     "metadata": {},
                     "output_type": "execute_result"
                 }
             ],
             "source": [
                 "all_data = pd.read_csv(os.path.join(data_dir, \"select_cell_data.csv\"))\n",
                 "targets = ['C', 'Na', 'Si', 'HH3',\n",
@@ -276,15 +276,15 @@
             },
             "source": [
                 "## Visualize Patient-Population Distribution Examples"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 5,
+            "execution_count": null,
             "metadata": {
                 "pycharm": {
                     "name": "#%%\n"
                 }
             },
             "outputs": [
                 {
@@ -334,15 +334,15 @@
             "metadata": {},
             "source": [
                 "## Visualize Distribution of Channel Values"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 13,
+            "execution_count": null,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "image/png": "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",
                         "text/plain": [
                             "<Figure size 432x288 with 1 Axes>"
@@ -356,15 +356,15 @@
             ],
             "source": [
                 "visualize.draw_boxplot(all_data, \"CD3\")"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 14,
+            "execution_count": null,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "image/png": "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",
                         "text/plain": [
                             "<Figure size 432x288 with 1 Axes>"
@@ -378,15 +378,15 @@
             ],
             "source": [
                 "visualize.draw_boxplot(all_data, \"CD3\", \"PatientID\")"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 15,
+            "execution_count": null,
             "metadata": {},
             "outputs": [
                 {
                     "data": {
                         "image/png": "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",
                         "text/plain": [
                             "<Figure size 432x288 with 1 Axes>"
@@ -411,15 +411,15 @@
             },
             "source": [
                 "## Dimensionality Reduction Examples"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 16,
+            "execution_count": null,
             "metadata": {},
             "outputs": [
                 {
                     "name": "stderr",
                     "output_type": "stream",
                     "text": [
                         "/usr/local/lib/python3.6/site-packages/matplotlib/figure.py:459: UserWarning: matplotlib is currently using a non-GUI backend, so cannot show the figure\n",
@@ -442,15 +442,15 @@
             "source": [
                 "# tSNE Projection of data, with all the Target categories, and Cell Lineage as the label. Saves image into visualizations folder.\n",
                 "dimensionality_reduction.visualize_dimensionality_reduction(all_data, targets, \"cell_lin\",algorithm=\"tSNE\", save_dir=viz_dir)"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 17,
+            "execution_count": null,
             "metadata": {
                 "pycharm": {
                     "name": "#%%\n"
                 }
             },
             "outputs": [
                 {
@@ -491,14 +491,13 @@
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
-            "pygments_lexer": "ipython3",
-            "version": "3.6.10"
+            "pygments_lexer": "ipython3"
         }
     },
     "nbformat": 4,
     "nbformat_minor": 4
 }
```

### Comparing `ark-analysis-0.6.3/templates/generic_cell_clustering.ipynb` & `ark-analysis-0.6.4/templates/generic_cell_clustering.ipynb`

 * *Files 4% similar despite different names*

#### Pretty-printed

 * *Similarity: 0.9735498663751214%*

 * *Differences: {"'cells'": "{0: {'attachments': OrderedDict()}, 1: {'execution_count': None, 'source': {insert: "*

 * *            "[(6, 'from alpineer import load_utils, misc_utils\\n'), (9, 'from ark.phenotyping "*

 * *            "import (cell_cluster_utils, cell_meta_clustering,\\n'), (10, "*

 * *            "'                             cell_som_clustering)\\n'), (12, 'from "*

 * *            "ark.utils.metacluster_remap_gui import (MetaClusterGui,\\n'), (14, "*

 * *            "'                                             metaclusterdata_ […]*

```diff
@@ -1,53 +1,49 @@
 {
     "cells": [
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {
                 "tags": []
             },
             "source": [
                 "# Generic cell clustering notebook"
             ]
         },
         {
             "cell_type": "code",
-            "execution_count": 1,
+            "execution_count": null,
             "metadata": {
                 "tags": [
                     "import"
                 ]
             },
             "outputs": [],
             "source": [
                 "# import required packages\n",
-                "import json\n",
                 "import os\n",
-                "import subprocess\n",
                 "from datetime import datetime as dt\n",
                 "\n",
-                "import feather\n",
                 "import matplotlib.pyplot as plt\n",
-                "import numpy as np\n",
                 "import pandas as pd\n",
-                "import scipy.stats as stats\n",
-                "import seaborn as sns\n",
-                "import xarray as xr\n",
+                "from alpineer import load_utils, misc_utils\n",
                 "from matplotlib import rc_file_defaults\n",
-                "from alpineer import io_utils, load_utils, misc_utils\n",
                 "\n",
-                "from ark.analysis import visualize\n",
-                "from ark.phenotyping import cell_cluster_utils, cell_som_clustering, cell_meta_clustering\n",
+                "from ark.phenotyping import (cell_cluster_utils, cell_meta_clustering,\n",
+                "                             cell_som_clustering)\n",
                 "from ark.utils import data_utils, example_dataset, plot_utils\n",
-                "from ark.utils.metacluster_remap_gui import (MetaClusterData, MetaClusterGui,\n",
+                "from ark.utils.metacluster_remap_gui import (MetaClusterGui,\n",
                 "                                             colormap_helper,\n",
-                "                                             metaclusterdata_from_files)"
+                "                                             metaclusterdata_from_files)\n",
+                "from ark import settings"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {
                 "tags": []
             },
             "source": [
                 "## 0: Set root directory and download the example dataset\n",
                 "\n",
@@ -67,14 +63,15 @@
             "outputs": [],
             "source": [
                 "# define the home directory containing pixel_output_dir\n",
                 "base_dir = \"../data/example_dataset/\""
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "If you would like to test the features in Ark with an example dataset, run the cell below. It will download a dataset consisting of 11 FOVs with 22 channels. You may find more information about the example dataset in the [README](../README.md#example-dataset).\n",
                 "\n",
                 "If you are using your own data, skip the cell below.\n",
                 "\n",
@@ -91,23 +88,25 @@
             },
             "outputs": [],
             "source": [
                 "example_dataset.get_example_dataset(dataset=\"cluster_cells\", save_dir = base_dir, overwrite_existing = True)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {
                 "tags": []
             },
             "source": [
                 "## 1: Set input paths"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Define the following paths:\n",
                 "\n",
                 "- `cell_som_input_path`: for generic cell clustering, place your input file in `base_dir` and set the name of the file accordingly. The structure of this file is defined <a href=https://ark-analysis.readthedocs.io/en/latest/_rtd/data_types.html>here</a>. At the end of the pipeline, this file will contain the SOM and meta labels.\n",
                 "- `tiff_dir`: the path to the directory with extracted image data\n",
@@ -129,14 +128,15 @@
                 "cell_table_path = os.path.join(base_dir, 'segmentation', 'cell_table', 'cell_table_size_normalized.csv')\n",
                 "\n",
                 "# load cell SOM input data\n",
                 "cell_som_input_data = pd.read_csv(cell_som_input_path)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Define the list of FOVs and expression columns to use for cell SOM clustering"
             ]
         },
         {
@@ -164,14 +164,15 @@
                 ")\n",
                 "\n",
                 "# extract the set of FOVs used in the dataset\n",
                 "fovs = list(cell_som_input_data['fov'].unique())"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Set a prefix to be applied to all data directories/files created by pixel and cell clustering. If the prefix is not set, a default of the datetime at the start of the run is used."
             ]
         },
         {
@@ -188,14 +189,15 @@
                 "cell_cluster_prefix = \"example\"\n",
                 "\n",
                 "if cell_cluster_prefix is None:\n",
                 "    cell_cluster_prefix = dt.now().strftime('%Y-%m-%dT%H:%M:%S')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The following folders/files will be created with names prefixed by `cell_cluster_prefix`:\n",
                 "\n",
                 "* `cell_output_dir`: the name of the folder to store the cell clustering directories/files\n",
                 "* `cell_som_weights_name`: file name to place the cell SOM weights\n",
@@ -223,28 +225,31 @@
                 "cell_som_weights_name = os.path.join(\"pixie\", cell_output_dir, 'cell_som_weights.feather')\n",
                 "cell_som_expr_col_avg_name = os.path.join(\"pixie\", cell_output_dir, 'cell_som_expr_col_avg.csv')\n",
                 "cell_meta_expr_col_avg_name = os.path.join(\"pixie\", cell_output_dir, 'cell_meta_expr_col_avg.csv')\n",
                 "cell_meta_cluster_remap_name = os.path.join(\"pixie\", cell_output_dir, 'cell_meta_cluster_mapping.csv')"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 2: Cell clustering"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 2.1: train cell SOM"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Train the cell SOM on the expression values provided per cell (the data stored in `cell_som_input_name`).  Training is done using the `FlowSOM` algorithm. Note that each of the `cell_som_cluster_cols` are normalized by their 99.9% value prior to training.\n",
                 "\n",
                 "For a full set of parameters you can customize for `train_cell_som`, please consult: <a href=https://ark-analysis.readthedocs.io/en/latest/_markdown/ark.phenotyping.html#ark.phenotyping.cell_cluster_utils.train_cell_som>cell training docs</a>."
             ]
@@ -268,21 +273,23 @@
                 "    cell_som_input_data,\n",
                 "    som_weights_name=cell_som_weights_name,\n",
                 "    num_passes=1\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 2.2: assign cell SOM clusters"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Use the weights learned from `train_cell_som` to assign cell clusters to the cell dataset. As with `train_pixel_som`, each of the columns are normalized by their 99.9% value prior to assigning a cell SOM cluster label.\n",
                 "\n",
                 "`generate_som_avg_files` will then compute the average values of all columns in `cell_som_cluster_cols` per cell SOM cluster as well as the number of cells in each cell SOM cluster (the data placed in `cell_som_expr_col_avg_name`). This is needed for cell consensus clustering."
             ]
@@ -310,35 +317,38 @@
                 "    cell_som_input_data,\n",
                 "    cell_som_cluster_cols=cell_som_cluster_cols,\n",
                 "    cell_som_expr_col_avg_name=cell_som_expr_col_avg_name\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 2.3: run cell consensus clustering"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "With the SOM cluster labels assigned to the cell data, assign consensus cluster labels. The consensus clusters are trained on the average values of all columns in `cell_som_cluster_cols` per cell SOM cluster (the data stored in `cell_som_expr_col_avg_name`). These values are z-scored and capped at the value specified in the `cap` argument prior to training: this helps improve the meta clustering process.\n",
                 "\n",
                 "After consensus clustering, the following are also computed by `generate_meta_avg_files`:\n",
                 "\n",
                 "* The average values of all columns in `cell_som_cluster_cols` per cell meta cluster, and the number of cells per meta cluster (the data placed in `cell_meta_expr_col_avg_name`)\n",
                 "* The meta cluster mapping for each cell SOM cluster in `cell_som_expr_col_avg_name` (data is resaved, same data except with an associated meta cluster column)\n",
                 "\n",
                 "For a full set of parameters you can customize for `cell_consensus_cluster`, please consult: <a href=https://ark-analysis.readthedocs.io/en/latest/_markdown/ark.phenotyping.html#ark.phenotyping.cell_cluster_utils.cell_consensus_cluster>cell consensus clustering docs</a>. Do note that weighted cell channel computations are unsupported as it is outside the scope of generic cell clustering."
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "* `max_k`: the number of consensus clusters desired\n",
                 "* `cap`: used to clip z-scored values prior to consensus clustering (in the range `[-cap, cap]`)"
             ]
         },
@@ -373,28 +383,31 @@
                 "    cell_som_input_data=cell_som_input_data,\n",
                 "    cell_som_expr_col_avg_name=cell_som_expr_col_avg_name,\n",
                 "    cell_meta_expr_col_avg_name=cell_meta_expr_col_avg_name\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "## 3: visualize results"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 3.1: use the interactive reclustering results to relabel cell meta clusters"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The visualization shows the z-scored average `cell_som_cluster_cols` expression per cell SOM and meta cluster. The heatmaps are faceted by cell SOM clusters on the left and cell meta clusters on the right.\n",
                 "\n",
                 "## Usage\n",
                 "\n",
@@ -438,14 +451,15 @@
                 "    cluster_type='cell'\n",
                 ")\n",
                 "cell_mcd.output_mapping_filename = os.path.join(base_dir, cell_meta_cluster_remap_name)\n",
                 "cell_mcg = MetaClusterGui(cell_mcd, width=17)"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Relabel the cell meta clusters using the mapping."
             ]
         },
         {
@@ -473,14 +487,15 @@
                 "    cell_som_cluster_cols,\n",
                 "    cell_som_expr_col_avg_name,\n",
                 "    cell_meta_expr_col_avg_name,\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Generate the color scheme returned by the interactive reclustering process. This will be for visualizing the weighted channel average heatmaps and the cell cluster overlay."
             ]
         },
         {
@@ -497,14 +512,15 @@
                 "    cell_mcd.output_mapping_filename,\n",
                 "    cell_mcg.im_cl.cmap,\n",
                 "    cluster_type='cell'\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 3.2: cell cluster overlay (cell meta clusters only)\n",
                 "\n",
                 "This will take your FOVs and generate cell cluster images in batches. Run this cell if you wish to create a significant amount of cell cluster mask images for downstream analysis.\n",
                 "\n",
@@ -537,27 +553,60 @@
                 "tags": [
                     "cell_mask_gen_save"
                 ]
             },
             "outputs": [],
             "source": [
                 "# generate and save the cell cluster masks for each fov in subset_cell_fovs\n",
+                "\n",
+                "\n",
                 "data_utils.generate_and_save_cell_cluster_masks(\n",
                 "    fovs=subset_cell_fovs,\n",
-                "    base_dir=base_dir,\n",
                 "    save_dir=os.path.join(base_dir, \"pixie\", cell_output_dir),\n",
                 "    seg_dir=os.path.join(base_dir, segmentation_dir),\n",
                 "    cell_data=cell_som_input_data,\n",
+                "    fov_col = settings.FOV_ID,\n",
+                "    label_col = settings.CELL_LABEL,\n",
+                "    cell_cluster_col=settings.CELL_TYPE,\n",
                 "    seg_suffix=seg_suffix,\n",
                 "    sub_dir='cell_masks',\n",
                 "    name_suffix='_cell_mask'\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
+            "cell_type": "markdown",
+            "metadata": {},
+            "source": [
+                "Save the colored cell masks for each FOV in `subset_cell_fovs`."
+            ]
+        },
+        {
+            "cell_type": "code",
+            "execution_count": null,
+            "metadata": {
+                "tags": [
+                    "save_cell_masks"
+                ]
+            },
+            "outputs": [],
+            "source": [
+                "plot_utils.save_colored_masks(\n",
+                "    fovs=subset_cell_fovs,\n",
+                "    mask_dir=os.path.join(base_dir, \"pixie\",cell_output_dir, \"cell_masks\"),\n",
+                "    save_dir=os.path.join(base_dir, \"pixie\",cell_output_dir, \"cell_mask_colored\"),\n",
+                "    cluster_id_to_name_path=os.path.join(base_dir, cell_meta_cluster_remap_name),\n",
+                "    metacluster_colors=raw_cmap,\n",
+                "    cluster_type=\"cell\"\n",
+                ")"
+            ]
+        },
+        {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "Load a subset of the cell cluster masks that you would like to preview."
             ]
         },
         {
@@ -586,21 +635,23 @@
                 "        os.path.join(base_dir, cell_meta_cluster_remap_name),\n",
                 "        metacluster_colors=raw_cmap,\n",
                 "        cluster_type='cell'\n",
                 "    )"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 3.3: save consensus cluster labels to cell table"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "The cell table with consensus cluster labels is saved to `{cell_table_path}_cell_labels.csv`"
             ]
         },
         {
@@ -615,21 +666,23 @@
             "source": [
                 "cell_cluster_utils.add_consensus_labels_cell_table(\n",
                 "    base_dir, cell_table_path, cell_som_input_data\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 4.6: save the full results of Pixie cell clustering"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "`cell_som_input_data` with the SOM, meta, and renamed meta cluster labels, is resaved to `cell_som_input_path` as a `.csv` file."
             ]
         },
         {
@@ -645,14 +698,15 @@
                 "cell_som_input_data.to_csv(\n",
                 "    cell_som_input_path,\n",
                 "    index=False\n",
                 ")"
             ]
         },
         {
+            "attachments": {},
             "cell_type": "markdown",
             "metadata": {},
             "source": [
                 "### 3.4: Save Images a Mantis Viewer Project\n",
                 "\n",
                 "Mantis Viewer is a visualization tool for multi-dimensional imaging in pathology. Learn more about Mantis Viewer in the [README](../README.md#mantis-viewer)."
             ]
@@ -692,16 +746,15 @@
                 "name": "ipython",
                 "version": 3
             },
             "file_extension": ".py",
             "mimetype": "text/x-python",
             "name": "python",
             "nbconvert_exporter": "python",
-            "pygments_lexer": "ipython3",
-            "version": "3.8.15"
+            "pygments_lexer": "ipython3"
         },
         "vscode": {
             "interpreter": {
                 "hash": "9cd428f2623867f362c6ffd1805d28fe273bb79d15f4a3a73107e7f51d98be79"
             }
         }
     },
```

### Comparing `ark-analysis-0.6.3/tests/analysis/dimensionality_reduction_test.py` & `ark-analysis-0.6.4/tests/analysis/dimensionality_reduction_test.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,20 @@
 import os
 import tempfile
 
 import pytest
+import test_utils
 
 import ark.settings as settings
 from ark.analysis import dimensionality_reduction
-import test_utils
 
 
 def test_plot_dim_reduced_data():
     # this only tests errors, test_dimensionality_reduction tests the meat of this function
-    random_cell_data = test_utils.make_cell_table(300)
+    random_cell_data = test_utils.make_cell_table(50)
 
     with pytest.raises(FileNotFoundError):
         # trying to save to a non-existant directory
         dimensionality_reduction.plot_dim_reduced_data(component_one=random_cell_data.iloc[:, 0],
                                                        component_two=random_cell_data.iloc[:, 1],
                                                        fig_id=1,
                                                        hue=random_cell_data.iloc[:, 2],
@@ -30,15 +30,15 @@
                                                        hue=random_cell_data.iloc[:, 2],
                                                        cell_data=random_cell_data,
                                                        title="Title",
                                                        save_dir=".")
 
 
 def test_dimensionality_reduction():
-    random_cell_data = test_utils.make_cell_table(300)
+    random_cell_data = test_utils.make_cell_table(50)
     test_cols = test_utils.TEST_MARKERS
 
     test_algorithms = ['PCA', 'tSNE', 'UMAP']
 
     with pytest.raises(ValueError):
         # trying to specify an algorithm not in test_algorithms
         dimensionality_reduction.visualize_dimensionality_reduction(random_cell_data,
```

### Comparing `ark-analysis-0.6.3/tests/analysis/neighborhood_analysis_test.py` & `ark-analysis-0.6.4/tests/analysis/neighborhood_analysis_test.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,18 +1,18 @@
+import math
 import os
 import tempfile
-import math
 
 import numpy as np
 import pandas as pd
 import pytest
+import test_utils
 
 import ark.settings as settings
 from ark.analysis import neighborhood_analysis
-import test_utils
 
 
 def test_create_neighborhood_matrix():
     # get positive expression and distance matrices
     all_data_pos, dist_mat_pos = test_utils._make_dist_exp_mats_spatial_test(
         enrichment_type="positive", dist_lim=51)
 
@@ -238,22 +238,20 @@
         settings.CELL_LABEL: list(range(1, 8)),
         settings.CELL_TYPE: ['cell1', 'cell2', 'cell1', 'cell1', 'cell2', 'cell2', 'cell1'],
         'cell1': [1, 0, 2, 2, 1, 2, 0],
         'cell2': [1, 2, 1, 1, 2, 2, 0]
     })
     ratios = neighborhood_analysis.compute_cell_ratios(
         cell_neighbors_mat, ['cell1'], ['cell2'], ['fov1'])
-    assert ratios.equals(pd.DataFrame({'fov': 'fov1', 'pop1_pop2_ratio': [4/3],
-                                       'pop2_pop1_ratio': [3/4]}))
+    assert ratios.equals(pd.DataFrame({'fov': 'fov1', 'cell_ratio': [4/3]}))
 
     # check zero denom
     ratios = neighborhood_analysis.compute_cell_ratios(
         cell_neighbors_mat, ['cell1'], ['cell3'], ['fov1'])
-    assert ratios.equals(pd.DataFrame({'fov': 'fov1', 'pop1_pop2_ratio': [np.nan],
-                                       'pop2_pop1_ratio': [np.nan]}))
+    assert ratios.equals(pd.DataFrame({'fov': 'fov1', 'cell_ratio': [np.nan]}))
 
 
 def test_compute_mixing_score():
     cell_neighbors_mat = pd.DataFrame({
         settings.FOV_ID: ['fov1', 'fov1', 'fov1', 'fov1', 'fov1', 'fov1', 'fov1'],
         settings.CELL_LABEL: list(range(1, 8)),
         settings.CELL_TYPE: ['cell1', 'cell2', 'cell1', 'cell1', 'cell2', 'cell2', 'cell3'],
@@ -263,54 +261,58 @@
         'cell4': [0, 0, 0, 0, 0, 0, 0]
     })
 
     # check cell type validation
     with pytest.raises(ValueError, match='The following cell types were included in both '
                                          'the target and reference populations'):
         neighborhood_analysis.compute_mixing_score(
-            cell_neighbors_mat, 'fov1', target_cells=['cell1'], reference_cells=['cell1'],
+            cell_neighbors_mat, target_cells=['cell1'], reference_cells=['cell1'],
             mixing_type='homogeneous')
 
     with pytest.raises(ValueError, match='Not all values given in list provided column'):
         neighborhood_analysis.compute_mixing_score(
-            cell_neighbors_mat, 'fov1', target_cells=['cell1'], reference_cells=['cell2'],
+            cell_neighbors_mat, target_cells=['cell1'], reference_cells=['cell2'],
             mixing_type='homogeneous', cell_col='bad_column')
     with pytest.raises(ValueError, match='Please provide a valid mixing_type'):
         neighborhood_analysis.compute_mixing_score(
-            cell_neighbors_mat, 'fov1', target_cells=['cell1'], reference_cells=['cell2'],
+            cell_neighbors_mat, target_cells=['cell1'], reference_cells=['cell2'],
             mixing_type='bad')
 
     # check that extra cell type is ignored
-    score = neighborhood_analysis.compute_mixing_score(
-        cell_neighbors_mat, 'fov1', target_cells=['cell1', 'cell3', 'cell_not_in_fov'],
-        reference_cells=['cell2'], mixing_type='homogeneous')
+    score, cell_count = neighborhood_analysis.compute_mixing_score(
+        cell_neighbors_mat, target_cells=['cell1', 'cell3', 'cell_not_in_fov'],
+        reference_cells=['cell2'], cell_count_thresh=0, mixing_type='homogeneous')
     assert score == 3 / 12
+    assert cell_count == 7
 
     # test homogeneous mixing
-    score = neighborhood_analysis.compute_mixing_score(
-        cell_neighbors_mat, 'fov1', target_cells=['cell1', 'cell3'], reference_cells=['cell2'],
-        mixing_type='homogeneous')
+    score, _ = neighborhood_analysis.compute_mixing_score(
+        cell_neighbors_mat, target_cells=['cell1', 'cell3'], reference_cells=['cell2'],
+        cell_count_thresh=0, mixing_type='homogeneous')
     assert score == 3/12
+    assert cell_count == 7
 
     # test percent mixing
-    score = neighborhood_analysis.compute_mixing_score(
-        cell_neighbors_mat, 'fov1', target_cells=['cell1', 'cell3'], reference_cells=['cell2'],
-        mixing_type='percent')
+    score, _ = neighborhood_analysis.compute_mixing_score(
+        cell_neighbors_mat, target_cells=['cell1', 'cell3'], reference_cells=['cell2'],
+        cell_count_thresh=0, mixing_type='percent')
     assert score == 3 / 9
 
     # test ratio threshold
-    cold_score = neighborhood_analysis.compute_mixing_score(
-        cell_neighbors_mat, 'fov1', target_cells=['cell1'], reference_cells=['cell2'],
-        ratio_threshold=0.5, mixing_type='homogeneous')
+    cold_score, cell_count = neighborhood_analysis.compute_mixing_score(
+        cell_neighbors_mat, target_cells=['cell1'], reference_cells=['cell2'],
+        cell_count_thresh=0, ratio_threshold=0.5, mixing_type='homogeneous')
     assert math.isnan(cold_score)
+    assert cell_count == 6
 
     # test cell count threshold
-    cold_score = neighborhood_analysis.compute_mixing_score(
-        cell_neighbors_mat, 'fov1', target_cells=['cell1'], reference_cells=['cell2'],
-        cell_count_thresh=5, mixing_type='homogeneous')
+    cold_score, _ = neighborhood_analysis.compute_mixing_score(
+        cell_neighbors_mat, target_cells=['cell1'], reference_cells=['cell2'],
+        cell_count_thresh=10, mixing_type='homogeneous')
     assert math.isnan(cold_score)
 
     # check zero cells denominator
-    cold_score = neighborhood_analysis.compute_mixing_score(
-        cell_neighbors_mat, 'fov1', target_cells=['cell4'], reference_cells=['cell2'],
+    cold_score, cell_count = neighborhood_analysis.compute_mixing_score(
+        cell_neighbors_mat, target_cells=['cell4'], reference_cells=['cell2'],
         cell_count_thresh=0, mixing_type='homogeneous')
     assert math.isnan(cold_score)
+    assert cell_count == 3
```

### Comparing `ark-analysis-0.6.3/tests/analysis/spatial_analysis_utils_test.py` & `ark-analysis-0.6.4/tests/analysis/spatial_analysis_utils_test.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,34 +1,34 @@
 import os
 import tempfile
 
 import numpy as np
 import pandas as pd
 import pytest
+import test_utils
 import xarray as xr
 from alpineer.test_utils import _write_labels
 
 import ark.settings as settings
 from ark.analysis import spatial_analysis_utils
-import test_utils
 
 
 def test_calc_dist_matrix():
     with tempfile.TemporaryDirectory() as base_dir:
         # create sample label_dir and save_path folders
         label_dir = os.path.join(base_dir, 'sample_label_dir')
         save_path = os.path.join(base_dir, 'sample_save_path')
         os.mkdir(label_dir)
         os.mkdir(save_path)
 
         # generate sample label data
         # NOTE: this function should support varying FOV sizes
-        _write_labels(label_dir, ["fov8"], ["segmentation_label"], (10, 10),
+        _write_labels(label_dir, ["fov8"], ["label"], (10, 10),
                       '', True, np.uint8, suffix='_whole_cell')
-        _write_labels(label_dir, ["fov9"], ["segmentation_label"], (5, 5),
+        _write_labels(label_dir, ["fov9"], ["label"], (5, 5),
                       '', True, np.uint8, suffix='_whole_cell')
 
         # generate the distance matrices
         spatial_analysis_utils.calc_dist_matrix(label_dir, save_path)
 
         # assert the fov8 and fov9 .xr files exist
         assert os.path.exists(os.path.join(save_path, 'fov8_dist_mat.xr'))
```

### Comparing `ark-analysis-0.6.3/tests/analysis/spatial_enrichment_test.py` & `ark-analysis-0.6.4/tests/analysis/spatial_enrichment_test.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,18 @@
 import tempfile
 
 import numpy as np
 import pandas as pd
 import pytest
+import test_utils
 from alpineer import load_utils
 from alpineer.test_utils import _write_labels
 
 import ark.settings as settings
-from ark.analysis import spatial_enrichment, spatial_analysis_utils
-import test_utils
-
+from ark.analysis import spatial_analysis_utils, spatial_enrichment
 
 EXCLUDE_CHANNELS = [
     "Background",
     "HH3",
     "summed_channel",
 ]
 
@@ -38,20 +37,20 @@
 def test_generate_channel_spatial_enrichment_stats():
     # since the functionality of channel spatial enrichment is tested later,
     # only the number of elements returned and the included_fovs argument needs testing
     marker_thresholds = test_utils._make_threshold_mat(in_utils=False)
 
     with tempfile.TemporaryDirectory() as label_dir, \
          tempfile.TemporaryDirectory() as dist_mat_dir:
-        _write_labels(label_dir, ["fov8", "fov9"], ["segmentation_label"], (10, 10),
+        _write_labels(label_dir, ["fov8", "fov9"], ["label"], (10, 10),
                       '', True, np.uint8, suffix='_whole_cell')
 
         spatial_analysis_utils.calc_dist_matrix(label_dir, dist_mat_dir)
         label_maps = load_utils.load_imgs_from_dir(label_dir, trim_suffix="_whole_cell",
-                                                   xr_channel_names=["segmentation_label"])
+                                                   xr_channel_names=["label"])
         all_data = test_utils.spoof_cell_table_from_labels(label_maps)
 
         vals_pos, stats_pos = \
             spatial_enrichment.generate_channel_spatial_enrichment_stats(
                 label_dir, dist_mat_dir, marker_thresholds, all_data,
                 excluded_channels=EXCLUDE_CHANNELS,
                 bootstrap_num=100, dist_lim=100
@@ -75,20 +74,20 @@
 
 
 def test_generate_cluster_spatial_enrichment_stats():
     # since the functionality if channel spatial enrichment is tested later,
     # only the number of elements returned and the included_fovs argument needs testing
     with tempfile.TemporaryDirectory() as label_dir, \
          tempfile.TemporaryDirectory() as dist_mat_dir:
-        _write_labels(label_dir, ["fov8", "fov9"], ["segmentation_label"], (10, 10),
+        _write_labels(label_dir, ["fov8", "fov9"], ["label"], (10, 10),
                       '', True, np.uint8, suffix='_whole_cell')
 
         spatial_analysis_utils.calc_dist_matrix(label_dir, dist_mat_dir)
         label_maps = load_utils.load_imgs_from_dir(label_dir, trim_suffix="_whole_cell",
-                                                   xr_channel_names=["segmentation_label"])
+                                                   xr_channel_names=["label"])
         all_data = test_utils.spoof_cell_table_from_labels(label_maps)
 
         vals_pos, stats_pos = \
             spatial_enrichment.generate_cluster_spatial_enrichment_stats(
                 label_dir, dist_mat_dir, all_data,
                 bootstrap_num=100, dist_lim=100
             )
```

### Comparing `ark-analysis-0.6.3/tests/analysis/visualize_test.py` & `ark-analysis-0.6.4/tests/analysis/visualize_test.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 import os
 import tempfile
 import timeit
 
 import numpy as np
 import pytest
+import test_utils
 import xarray as xr
 
 import ark.settings as settings
 import ark.spLDA.processing as pros
 from ark.analysis import visualize
-import test_utils
 
 
 def test_draw_heatmap():
     # Create random Z score
     z = np.random.uniform(low=-5, high=5, size=(26, 26))
     # Assign random phenotype titles
     pheno_titles = [chr(i) for i in range(ord('a'), ord('z') + 1)]
```

### Comparing `ark-analysis-0.6.3/tests/phenotyping/cell_cluster_utils_test.py` & `ark-analysis-0.6.4/tests/phenotyping/cell_cluster_utils_test.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import os
 import tempfile
 
 import feather
 import numpy as np
 import pandas as pd
 import pytest
-from sklearn.utils import shuffle
 from alpineer import misc_utils
+from sklearn.utils import shuffle
 
 import ark.phenotyping.cell_cluster_utils as cell_cluster_utils
 
 
 def test_compute_cell_som_cluster_cols_avg():
     # define the cluster columns
     pixel_som_clusters = ['pixel_som_cluster_%d' % i for i in np.arange(3)]
@@ -35,15 +35,15 @@
                 columns=cluster_col_arr[i]
             )
 
             # add metadata, for cell cluster averaging the values don't matter
             cluster_data['fov'] = 'fov'
             cluster_data['row_index'] = -1
             cluster_data['column_index'] = -1
-            cluster_data['segmentation_label'] = -1
+            cluster_data['label'] = -1
 
             # assign cell cluster labels
             cluster_data['cell_som_cluster'] = np.repeat(np.arange(10), 100)
             cluster_data['cell_meta_cluster'] = np.repeat(np.arange(5), 200)
 
             # test for both keep_count settings
             for keep_count in [False, True]:
@@ -136,15 +136,15 @@
         # create dummy data for each fov
         for fov in ['fov1', 'fov2']:
             # assume each label has 10 pixels, create dummy data for each of them
             fov_table = pd.DataFrame(np.random.rand(50, 3), columns=chans)
 
             # assign the fovs and labels
             fov_table['fov'] = fov
-            fov_table['segmentation_label'] = np.repeat(np.arange(5), 10)
+            fov_table['label'] = np.repeat(np.arange(5), 10)
 
             # assign dummy pixel/meta labels
             # pixel: 0-1 for fov1 and 1-2 for fov2
             # meta: 0-1 for both fov1 and fov2
             if fov == 'fov1':
                 fov_table['pixel_som_cluster'] = np.repeat(np.arange(2), 25)
             else:
@@ -248,15 +248,15 @@
         # create new FOVs that has some cluster labels that aren't in the cell table
         for fov in ['fov3', 'fov4']:
             # assume each label has 10 pixels, create dummy data for each of them
             fov_table = pd.DataFrame(np.random.rand(50, 3), columns=chans)
 
             # assign the fovs and labels
             fov_table['fov'] = fov
-            fov_table['segmentation_label'] = np.repeat(np.arange(10), 5)
+            fov_table['label'] = np.repeat(np.arange(10), 5)
 
             fov_table['pixel_som_cluster'] = np.repeat(np.arange(5), 10)
             fov_table['pixel_meta_cluster_rename'] = np.repeat(np.arange(5), 10)
 
             # write fov data to feather
             feather.write_dataframe(fov_table, os.path.join(pixel_data_path,
                                                             fov + '.feather'))
@@ -387,15 +387,15 @@
 
         cell_consensus_data = {
             'cell_size': np.repeat(1, 300),
             'fov': np.repeat(['fov0', 'fov1', 'fov2'], 100),
             'pixel_meta_cluster_rename_1': np.random.rand(300),
             'pixel_meta_cluster_rename_2': np.random.rand(300),
             'pixel_meta_cluster_rename_3': np.random.rand(300),
-            'segmentation_label': np.tile(np.arange(1, 101), 3),
+            'label': np.tile(np.arange(1, 101), 3),
             'cell_som_cluster': np.tile(np.arange(1, 101), 3),
             'cell_meta_cluster': np.tile(np.arange(1, 21), 15),
             'cell_meta_cluster_rename': np.tile(
                 ['cell_meta_%d' % i for i in np.arange(1, 21)], 15
             )
         }
```

### Comparing `ark-analysis-0.6.3/tests/phenotyping/cell_meta_clustering_test.py` & `ark-analysis-0.6.4/tests/phenotyping/cell_meta_clustering_test.py`

 * *Files 12% similar despite different names*

```diff
@@ -10,27 +10,27 @@
 import ark.phenotyping.cell_meta_clustering as cell_meta_clustering
 import ark.phenotyping.cluster_helpers as cluster_helpers
 
 parametrize = pytest.mark.parametrize
 
 
 @parametrize('pixel_cluster_prefix', ['pixel_som_cluster', 'pixel_meta_cluster_rename'])
-def test_cell_consensus_cluster(pixel_cluster_prefix):
+def test_cell_consensus_cluster(pixel_cluster_prefix, capsys):
     with tempfile.TemporaryDirectory() as temp_dir:
         # define the cluster column names
         cluster_cols = [f'{pixel_cluster_prefix}_' + str(i) for i in range(3)]
 
         # create a dummy cluster_data file
         cluster_data = pd.DataFrame(
             np.random.randint(0, 100, (1000, 3)),
             columns=cluster_cols
         )
 
         cluster_data['fov'] = np.repeat(['fov0', 'fov1'], repeats=500)
-        cluster_data['segmentation_label'] = np.tile(np.arange(1, 501), reps=2)
+        cluster_data['label'] = np.tile(np.arange(1, 501), reps=2)
         cluster_data['cell_som_cluster'] = np.repeat(np.arange(100), 10)
 
         # compute average values of all cluster_cols for cell SOM clusters
         cluster_avg = cell_cluster_utils.compute_cell_som_cluster_cols_avg(
             cluster_data, cell_som_cluster_cols=cluster_cols,
             cell_cluster_col='cell_som_cluster'
         )
@@ -61,28 +61,61 @@
         # assert the correct labels have been assigned
         cell_mapping = cell_consensus_data[
             ['cell_som_cluster', 'cell_meta_cluster']
         ].drop_duplicates().sort_values(by='cell_som_cluster')
 
         assert np.all(sample_mapping.values == cell_mapping.values)
 
+        # assert running without overwrite flag on same cell_pysom object returns immediately
+        capsys.readouterr()
+
+        cell_cc, cell_consensus_data_repeat = cell_meta_clustering.cell_consensus_cluster(
+            base_dir=temp_dir,
+            cell_som_cluster_cols=cluster_cols,
+            cell_som_input_data=cluster_data,
+            cell_som_expr_col_avg_name='cell_som_cluster_avg.csv'
+        )
+
+        output = capsys.readouterr().out
+        desired_status_updates = \
+            "Meta clusters already assigned to each cell\n"
+        assert desired_status_updates in output
+        assert np.all(cell_consensus_data_repeat.values == cell_consensus_data.values)
+
+        # assert running with overwrite flag re-runs pipeline
+        capsys.readouterr()
+
+        cell_cc, cell_consensus_data_repeat = cell_meta_clustering.cell_consensus_cluster(
+            base_dir=temp_dir,
+            cell_som_cluster_cols=cluster_cols,
+            cell_som_input_data=cluster_data,
+            cell_som_expr_col_avg_name='cell_som_cluster_avg.csv',
+            overwrite=True
+        )
+
+        output = capsys.readouterr().out
+        desired_status_updates = \
+            "Overwrite flag set, reassigning meta cluster labels\n"
+        assert desired_status_updates in output
+        assert np.all(cell_consensus_data_repeat.values == cell_consensus_data.values)
+
 
 def test_generate_meta_avg_files(capsys):
     with tempfile.TemporaryDirectory() as temp_dir:
         # define the cluster column names
         cluster_cols = [f'pixel_meta_cluster_' + str(i) for i in range(3)]
 
         # create a dummy cluster_data file
         cluster_data = pd.DataFrame(
             np.random.randint(0, 100, (1000, 3)),
             columns=cluster_cols
         )
 
         cluster_data['fov'] = np.repeat(['fov0', 'fov1'], repeats=500)
-        cluster_data['segmentation_label'] = np.tile(np.arange(1, 501), reps=2)
+        cluster_data['label'] = np.tile(np.arange(1, 501), reps=2)
         cluster_data['cell_som_cluster'] = np.repeat(np.arange(100), 10)
         cluster_data['cell_meta_cluster'] = np.repeat(np.arange(20), 50)
 
         # compute average values of all cluster_cols for cell SOM clusters
         cluster_avg = cell_cluster_utils.compute_cell_som_cluster_cols_avg(
             cluster_data, cell_som_cluster_cols=cluster_cols,
             cell_cluster_col='cell_som_cluster'
@@ -178,14 +211,20 @@
 
         # ensure we reach the overwrite functionality logic
         output = capsys.readouterr().out
         desired_status_updates = \
             "Overwrite flag set, regenerating average expression file for cell meta clusters\n"
         assert desired_status_updates in output
 
+        # ensure that the cell meta cluster column in the SOM average file gets written properly
+        som_cluster_avg = pd.read_csv(
+            os.path.join(temp_dir, 'cell_som_cluster_avg.csv')
+        )
+        assert 'cell_meta_cluster' in som_cluster_avg.columns.values
+
 
 @parametrize('weighted_cell_channel_exists', [True, False])
 def test_apply_cell_meta_cluster_remapping(weighted_cell_channel_exists):
     with tempfile.TemporaryDirectory() as temp_dir:
         # define the pixel cluster cols
         pixel_cluster_cols = ['%s_%s' % ('pixel_meta_cluster_rename', str(i))
                               for i in np.arange(3)]
@@ -204,16 +243,16 @@
         cluster_data['cell_meta_cluster'] = np.repeat(np.arange(10), 100)
 
         # assign dummy fovs
         cluster_data.loc[0:499, 'fov'] = 'fov1'
         cluster_data.loc[500:999, 'fov'] = 'fov2'
 
         # assign dummy segmentation labels, 50 cells for each
-        cluster_data.loc[0:499, 'segmentation_label'] = np.arange(500)
-        cluster_data.loc[500:999, 'segmentation_label'] = np.arange(500)
+        cluster_data.loc[0:499, 'label'] = np.arange(500)
+        cluster_data.loc[500:999, 'label'] = np.arange(500)
 
         # define a dummy remap scheme and save
         # NOTE: cell mappings don't have the same issue of having more SOM clusters defined
         # than there are in the cell table there is only one cell table (as opposed to
         # multiple pixel tabels per FOV)
         sample_cell_remapping = {
             'cell_som_cluster': [i for i in np.arange(100)],
@@ -240,14 +279,35 @@
 
             cell_meta_clustering.apply_cell_meta_cluster_remapping(
                 temp_dir,
                 cluster_data,
                 'bad_sample_cell_remapping.csv'
             )
 
+        # duplicate cell_meta_cluster_rename values found across cell_meta_clusters
+        with pytest.raises(ValueError):
+            sample_cell_remapping = pd.read_csv(
+                os.path.join(temp_dir, 'sample_cell_remapping.csv')
+            )
+            bad_sample_cell_remapping = sample_cell_remapping.copy()
+            bad_sample_cell_remapping.loc[
+                bad_sample_cell_remapping['cell_meta_cluster_rename'] == 'meta1',
+                'cell_meta_cluster_rename'
+            ] = 'meta0'
+            bad_sample_cell_remapping.to_csv(
+                os.path.join(temp_dir, 'bad_sample_cell_remapping.csv'),
+                index=False
+            )
+
+            cell_meta_clustering.apply_cell_meta_cluster_remapping(
+                temp_dir,
+                cluster_data,
+                'bad_sample_cell_remapping.csv'
+            )
+
         # error check: mapping does not contain every SOM label
         with pytest.raises(ValueError):
             bad_sample_cell_remapping = {
                 'cell_som_cluster': [1, 2],
                 'cell_meta_cluster': [1, 2],
                 'cell_meta_cluster_rename': ['m1', 'm2']
             }
@@ -319,16 +379,16 @@
         cluster_data['cell_meta_cluster'] = np.repeat(np.arange(10), 100)
 
         # assign dummy fovs
         cluster_data.loc[0:499, 'fov'] = 'fov1'
         cluster_data.loc[500:999, 'fov'] = 'fov2'
 
         # assign dummy segmentation labels, 50 cells for each
-        cluster_data.loc[0:499, 'segmentation_label'] = np.arange(500)
-        cluster_data.loc[500:999, 'segmentation_label'] = np.arange(500)
+        cluster_data.loc[0:499, 'label'] = np.arange(500)
+        cluster_data.loc[500:999, 'label'] = np.arange(500)
 
         # create an example cell SOM pixel counts table
         som_pixel_counts = pd.DataFrame(
             np.repeat([[1, 2, 3]], repeats=100, axis=0),
             columns=pixel_cluster_cols
         )
         som_pixel_counts['cell_som_cluster'] = np.arange(100)
```

### Comparing `ark-analysis-0.6.3/tests/phenotyping/cell_som_clustering_test.py` & `ark-analysis-0.6.4/tests/phenotyping/cell_som_clustering_test.py`

 * *Files 4% similar despite different names*

```diff
@@ -45,15 +45,15 @@
         # create dummy data for each fov
         for fov in fovs:
             # assume each label has 10 pixels, create dummy data for each of them
             fov_table = pd.DataFrame(np.random.rand(1000, 4), columns=chan_list)
 
             # assign the fovs and labels
             fov_table['fov'] = fov
-            fov_table['segmentation_label'] = np.repeat(np.arange(50), 20)
+            fov_table['label'] = np.repeat(np.arange(50), 20)
 
             # assign dummy pixel/meta labels
             # pixel: 0-9 for fov1 and 5-14 for fov2
             # meta: 0-1 for both fov1 and fov2
             if fov == 'fov1':
                 fov_table['pixel_som_cluster'] = np.repeat(np.arange(10), 100)
             else:
@@ -127,27 +127,27 @@
         # assert the shape
         assert cell_weights.shape == (100, 2)
 
 
 # NOTE: overwrite functionality tested in cluster_helpers_test.py
 @parametrize('pixel_cluster_prefix', ['pixel_som_cluster', 'pixel_meta_cluster_rename'])
 @parametrize('existing_som_col', [False, True])
-def test_cluster_cells(pixel_cluster_prefix, existing_som_col):
+def test_cluster_cells(pixel_cluster_prefix, existing_som_col, capsys):
     with tempfile.TemporaryDirectory() as temp_dir:
         # define the cluster column names
         cluster_cols = [f'{pixel_cluster_prefix}_' + str(i) for i in range(3)]
 
         # create a sample cluster counts file
         cluster_counts = pd.DataFrame(np.random.randint(0, 100, (100, 3)),
                                       columns=cluster_cols)
 
         # add metadata
         cluster_counts['fov'] = -1
         cluster_counts['cell_size'] = -1
-        cluster_counts['segmentation_label'] = -1
+        cluster_counts['label'] = -1
 
         if existing_som_col:
             cluster_counts['cell_som_cluster'] = -1
 
         # write cluster counts
         cluster_counts_path = os.path.join(temp_dir, 'cluster_counts.feather')
         feather.write_dataframe(cluster_counts, cluster_counts_path)
@@ -187,28 +187,59 @@
             cell_som_cluster_cols=cluster_cols
         )
 
         # assert we didn't assign any cluster 100 or above
         cluster_ids = cell_data_som_labels['cell_som_cluster']
         assert np.all(cluster_ids < 100)
 
+        # assert running without overwrite flag on same cell_pysom object returns immediately
+        capsys.readouterr()
+
+        cell_data_som_labels_repeat = cell_som_clustering.cluster_cells(
+            base_dir=temp_dir,
+            cell_pysom=cell_pysom,
+            cell_som_cluster_cols=cluster_cols
+        )
+
+        output = capsys.readouterr().out
+        desired_status_updates = \
+            "SOM clusters already assigned to each cell\n"
+        assert desired_status_updates in output
+        assert np.all(cell_data_som_labels.values == cell_data_som_labels_repeat.values)
+
+        # assert running with overwrite flag re-runs pipeline
+        capsys.readouterr()
+
+        cell_data_som_labels_repeat = cell_som_clustering.cluster_cells(
+            base_dir=temp_dir,
+            cell_pysom=cell_pysom,
+            cell_som_cluster_cols=cluster_cols,
+            overwrite=True
+        )
+
+        output = capsys.readouterr().out
+        desired_status_updates = \
+            "Overwrite flag set, reassigning SOM cluster labels\n"
+        assert desired_status_updates in output
+        assert np.all(cell_data_som_labels.values == cell_data_som_labels_repeat.values)
+
 
 def test_generate_som_avg_files(capsys):
     with tempfile.TemporaryDirectory() as temp_dir:
         # define the cluster column names
         cluster_cols = [f'pixel_meta_cluster_' + str(i) for i in range(3)]
 
         # create a sample cluster counts file
         cluster_counts = pd.DataFrame(np.random.randint(0, 100, (100, 3)),
                                       columns=cluster_cols)
 
         # add metadata
         cluster_counts['fov'] = -1
         cluster_counts['cell_size'] = -1
-        cluster_counts['segmentation_label'] = -1
+        cluster_counts['label'] = -1
 
         # add dummy SOM cluster assignments
         cluster_counts['cell_som_cluster'] = np.repeat(np.arange(1, 5), repeats=25)
 
         # write cluster counts
         cluster_counts_path = os.path.join(temp_dir, 'cluster_counts.feather')
         feather.write_dataframe(cluster_counts, cluster_counts_path)
```

### Comparing `ark-analysis-0.6.3/tests/phenotyping/cluster_helpers_test.py` & `ark-analysis-0.6.4/tests/phenotyping/cluster_helpers_test.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,15 +7,36 @@
 import feather
 import numpy as np
 import pandas as pd
 import pytest
 from alpineer.misc_utils import verify_same_elements
 
 from ark.phenotyping.cluster_helpers import (CellSOMCluster, PixelSOMCluster,
-                                             PixieConsensusCluster)
+                                             PixieConsensusCluster,
+                                             verify_unique_meta_clusters)
+
+parametrize = pytest.mark.parametrize
+
+
+@parametrize("meta_cluster_type", ["pixel", "cell"])
+def test_verify_unique_meta_clusters(meta_cluster_type):
+    # assert proper mapping validates
+    meta_mapping = pd.DataFrame({
+        f"{meta_cluster_type}_meta_cluster": [1, 2, 3],
+        f"{meta_cluster_type}_meta_cluster_rename": ["meta_1", "meta_2", "meta_3"]
+    })
+    verify_unique_meta_clusters(meta_mapping, meta_cluster_type)
+
+    # assert improper mapping raises error
+    meta_mapping = pd.DataFrame({
+        f"{meta_cluster_type}_meta_cluster": [1, 2, 3],
+        f"{meta_cluster_type}_meta_cluster_rename": ["meta_1", "meta_2", "meta_2"]
+    })
+    with pytest.raises(ValueError):
+        verify_unique_meta_clusters(meta_mapping, meta_cluster_type)
 
 
 @pytest.fixture(scope="session")
 def pixel_som_base_dir(tmp_path_factory) -> Iterator[pathlib.Path]:
     """Creates the directory to hold all the test data needed for pixel SOM clustering
 
     Args:
@@ -75,20 +96,20 @@
 
     # generate dummy data directories
     os.mkdir(pixel_sub_path)
     for fov in fovs:
         # generate dummy sub data for fov
         fov_data = pd.DataFrame(
             np.random.rand(500, 10),
-            columns=channels + ['fov', 'row_index', 'column_index', 'segmentation_label']
+            columns=channels + ['fov', 'row_index', 'column_index', 'label']
         )
         fov_data['fov'] = fov
         fov_data['row_index'] = np.repeat(np.arange(1, 51), 10)
         fov_data['col_index'] = np.tile(np.arange(1, 11), 50)
-        fov_data['segmentation_label'] = np.arange(1, 501)
+        fov_data['label'] = np.arange(1, 501)
 
         feather.write_dataframe(fov_data, os.path.join(pixel_sub_path, fov + '.feather'))
 
     # generate dummy norm vals data
     norm_vals = pd.DataFrame(np.expand_dims(np.repeat(0.5, 6), 0), columns=channels)
     feather.write_dataframe(norm_vals, norm_vals_path)
 
@@ -133,20 +154,20 @@
 
     # define the pixel count count expression columns to use
     count_cols = [f'pixel_meta_cluster_{i}' for i in np.arange(1, 7)]
 
     # define dummy cell data
     cluster_counts_size_norm = pd.DataFrame(
         np.random.randint(1, 10, (500, 9)),
-        columns=['cell_size', 'fov'] + count_cols + ['segmentation_label']
+        columns=['cell_size', 'fov'] + count_cols + ['label']
     )
     cluster_counts_size_norm['cell_size'] = 150
     cluster_counts_size_norm.loc[0:249, 'fov'] = 'fov0'
     cluster_counts_size_norm.loc[250:499, 'fov'] = 'fov1'
-    cluster_counts_size_norm['segmentation_label'] = np.arange(1, 501)
+    cluster_counts_size_norm['label'] = np.arange(1, 501)
 
     # generate dummy weights data, this will be used to test loading in an existing weights file
     weights_vals = pd.DataFrame(np.random.rand(200, 6), columns=count_cols)
     feather.write_dataframe(weights_vals, weights_path)
 
     # define a CellSOMCluster object with weights
     cell_som_with_weights = CellSOMCluster(
@@ -260,15 +281,15 @@
         # NOTE: we'll be working with pixel_pysom_nonweights mostly
         # pixel_pysom_weights is to check case where user already loaded data
         self.pixel_pysom_weights = pixel_pyflowsom_object[0]
         self.pixel_pysom_nonweights = pixel_pyflowsom_object[1]
 
     def test_normalize_data(self):
         # create a random dataset with the same columns
-        meta_cols = ['fov', 'row_index', 'column_index', 'segmentation_label']
+        meta_cols = ['fov', 'row_index', 'column_index', 'label']
         sample_external_data = pd.DataFrame(
             np.random.rand(1000, 10),
             columns=self.pixel_pysom_nonweights.columns + meta_cols
         )
 
         # normalize sample_external_data
         normalized_data = self.pixel_pysom_weights.normalize_data(sample_external_data)
@@ -348,15 +369,15 @@
         self.pixel_pysom_nonweights.columns = old_columns
 
     def test_assign_som_clusters(self):
         # generate sample external data
         # NOTE: test on shuffled data to ensure column matching
         col_shuffle = deepcopy(self.pixel_pysom_nonweights.columns)
         random.shuffle(col_shuffle)
-        meta_cols = ['fov', 'row_index', 'column_index', 'segmentation_label']
+        meta_cols = ['fov', 'row_index', 'column_index', 'label']
         sample_external_data = pd.DataFrame(
             np.random.rand(1000, 10),
             columns=col_shuffle + meta_cols
         )
 
         # assign SOM labels to sample_external_data
         som_label_data = self.pixel_pysom_nonweights.assign_som_clusters(sample_external_data)
```

### Comparing `ark-analysis-0.6.3/tests/phenotyping/pixel_cluster_utils_test.py` & `ark-analysis-0.6.4/tests/phenotyping/pixel_cluster_utils_test.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,16 +5,16 @@
 
 import feather
 import numpy as np
 import pandas as pd
 import pytest
 import scipy.ndimage as ndimage
 import skimage.io as io
-from skimage.draw import disk
 from alpineer import image_utils, misc_utils, test_utils
+from skimage.draw import disk
 
 import ark.phenotyping.pixel_cluster_utils as pixel_cluster_utils
 
 parametrize = pytest.mark.parametrize
 
 
 def test_calculate_channel_percentiles():
@@ -115,35 +115,35 @@
         columns=chans
     )
 
     # add dummy metadata
     fov_pixel_matrix['fov'] = 'fov0'
     fov_pixel_matrix['row_index'] = -1
     fov_pixel_matrix['column_index'] = -1
-    fov_pixel_matrix['segmentation_label'] = -1
+    fov_pixel_matrix['label'] = -1
 
     # define the meta cols for ease of use
-    meta_cols = ['fov', 'row_index', 'column_index', 'segmentation_label']
+    meta_cols = ['fov', 'row_index', 'column_index', 'label']
 
-    # TEST 1: normalize the matrix and keep the segmentation_label column
-    # NOTE: this test errors out if 'segmentation_label' is not included in fov_pixel_matrix_sub
+    # TEST 1: normalize the matrix and keep the label column
+    # NOTE: this test errors out if 'label' is not included in fov_pixel_matrix_sub
     fov_pixel_matrix_sub = pixel_cluster_utils.normalize_rows(fov_pixel_matrix, chan_sub)
 
     # assert the same channels we subsetted on are found in fov_pixel_matrix_sub
     misc_utils.verify_same_elements(
         provided_chans=chan_sub,
         fov_pixel_chans=fov_pixel_matrix_sub.drop(columns=meta_cols).columns.values
     )
 
     # assert all the rows sum to 0.5, 0.5
     # this also checks that all the zero-sum rows have been removed
     assert np.all(fov_pixel_matrix_sub.drop(columns=meta_cols).values == [1 / 3, 2 / 3])
 
-    # TEST 2: normalize the matrix and drop the segmentation_label column
-    meta_cols.remove('segmentation_label')
+    # TEST 2: normalize the matrix and drop the label column
+    meta_cols.remove('label')
 
     fov_pixel_matrix_sub = pixel_cluster_utils.normalize_rows(
         fov_pixel_matrix, chan_sub, include_seg_label=False
     )
 
     # assert the same channels we subsetted on are found in fov_pixel_matrix_sub
     misc_utils.verify_same_elements(
```

### Comparing `ark-analysis-0.6.3/tests/phenotyping/pixel_meta_clustering_test.py` & `ark-analysis-0.6.4/tests/phenotyping/pixel_meta_clustering_test.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 import tempfile
 from copy import deepcopy
 
 import feather
 import numpy as np
 import pandas as pd
 import pytest
-from alpineer import io_utils, misc_utils, test_utils
+from alpineer import io_utils, misc_utils
 
 import ark.phenotyping.cluster_helpers as cluster_helpers
 import ark.phenotyping.pixel_cluster_utils as pixel_cluster_utils
 import ark.phenotyping.pixel_meta_clustering as pixel_meta_clustering
 
 parametrize = pytest.mark.parametrize
 
@@ -18,15 +18,15 @@
 def test_run_pixel_consensus_assignment():
     with tempfile.TemporaryDirectory() as temp_dir:
         # define fovs and channels
         fovs = ['fov0', 'fov1', 'fov2']
         chans = ['Marker1', 'Marker2', 'Marker3', 'Marker4']
 
         # make it easy to name metadata columns
-        meta_colnames = ['fov', 'row_index', 'column_index', 'segmentation_label']
+        meta_colnames = ['fov', 'row_index', 'column_index', 'label']
 
         # create a dummy data directory
         os.mkdir(os.path.join(temp_dir, 'pixel_mat_data'))
 
         # create a dummy temp directory
         os.mkdir(os.path.join(temp_dir, 'pixel_mat_data_temp'))
 
@@ -103,15 +103,15 @@
         # assert the fov returned is fov1 and the status is 1
         assert fov_status == ('fov1', 1)
 
 
 def generate_test_pixel_consensus_cluster_data(temp_dir, fovs, chans,
                                                generate_temp=False):
     # make it easy to name metadata columns
-    meta_colnames = ['fov', 'row_index', 'column_index', 'segmentation_label']
+    meta_colnames = ['fov', 'row_index', 'column_index', 'label']
 
     # create a dummy clustered matrix
     os.mkdir(os.path.join(temp_dir, 'pixel_mat_data'))
 
     # create a dummy temp directory if specified
     if generate_temp:
         os.mkdir(os.path.join(temp_dir, 'pixel_mat_data_temp'))
@@ -127,15 +127,15 @@
             columns=chans
         )
 
         # assign dummy metadata labels
         fov_cluster_matrix['fov'] = fov
         fov_cluster_matrix['row_index'] = np.repeat(np.arange(1, 101), repeats=10)
         fov_cluster_matrix['column_index'] = np.tile(np.arange(1, 101), reps=10)
-        fov_cluster_matrix['segmentation_label'] = np.arange(1, 1001)
+        fov_cluster_matrix['label'] = np.arange(1, 1001)
 
         # assign dummy cluster labels
         fov_cluster_matrix['pixel_som_cluster'] = np.repeat(np.arange(100), repeats=10)
 
         # write the dummy data to pixel_mat_data
         feather.write_dataframe(fov_cluster_matrix, os.path.join(temp_dir,
                                                                  'pixel_mat_data',
@@ -265,15 +265,15 @@
 def test_generate_meta_avg_files(capsys):
     with tempfile.TemporaryDirectory() as temp_dir:
         # create list of markers and fovs we want to use
         chan_list = ['Marker1', 'Marker2', 'Marker3', 'Marker4']
         fovs = ['fov0', 'fov1', 'fov2']
 
         # make it easy to name columns
-        colnames = chan_list + ['fov', 'row_index', 'column_index', 'segmentation_label']
+        colnames = chan_list + ['fov', 'row_index', 'column_index', 'label']
 
         # define sample pixel data for each FOV
         pixel_data_path = os.path.join(temp_dir, 'pixel_data_dir')
         os.mkdir(pixel_data_path)
         for i, fov in enumerate(fovs):
             fov_cluster_data = pd.DataFrame(np.random.rand(100, len(colnames)), columns=colnames)
             fov_cluster_data['pixel_som_cluster'] = i + 1
@@ -290,16 +290,16 @@
         )
         pc_som_avg_data['pixel_som_cluster'] = np.arange(1, 4)
         pc_som_avg_data['count'] = 100
         pc_som_avg_data.to_csv(pc_som_avg_file, index=False)
 
         # define a sample SOM to meta cluster map
         som_to_meta_data = {
-            'pixel_som_cluster': np.arange(1, 4, dtype=np.int64),
-            'pixel_meta_cluster': np.arange(10, 40, 10, dtype=np.int64)
+            'pixel_som_cluster': np.arange(1, 4, dtype=int),
+            'pixel_meta_cluster': np.arange(10, 40, 10, dtype=int)
         }
         som_to_meta_data = pd.DataFrame.from_dict(som_to_meta_data)
 
         # define a sample ConsensusCluster object
         # define a dummy input file for data, we won't need it for expression average testing
         consensus_dummy_file = os.path.join(temp_dir, 'dummy_consensus_input.csv')
         pd.DataFrame().to_csv(consensus_dummy_file)
@@ -350,14 +350,18 @@
 
         # ensure we reach the overwrite functionality logic
         output = capsys.readouterr().out
         desired_status_updates = \
             "Overwrite flag set, regenerating meta cluster channel average file\n"
         assert desired_status_updates in output
 
+        # ensure that the pixel meta cluster column in the SOM average file gets written properly
+        pc_som_avg = pd.read_csv(pc_som_avg_file)
+        assert 'pixel_meta_cluster' in pc_som_avg.columns.values
+
         # remove average meta file for final test
         os.remove(pc_meta_avg_file)
 
         # ensure error gets thrown when not all meta clusters make it in
         with pytest.raises(ValueError):
             pixel_meta_clustering.generate_meta_avg_files(
                 fovs, chan_list, temp_dir, pixel_cc, 'pixel_data_dir', num_fovs_subset=1
@@ -367,15 +371,15 @@
 def test_update_pixel_meta_labels():
     with tempfile.TemporaryDirectory() as temp_dir:
         # define fovs and channels
         fovs = ['fov0', 'fov1', 'fov2']
         chans = ['Marker1', 'Marker2', 'Marker3', 'Marker4']
 
         # make it easy to name metadata columns
-        meta_colnames = ['fov', 'row_index', 'column_index', 'segmentation_label']
+        meta_colnames = ['fov', 'row_index', 'column_index', 'label']
 
         # create a dummy data directory
         os.mkdir(os.path.join(temp_dir, 'pixel_mat_data'))
 
         # create a dummy temp directory
         os.mkdir(os.path.join(temp_dir, 'pixel_mat_data_temp'))
 
@@ -447,15 +451,15 @@
         # assert the fov returned is fov1 and the status is 1
         assert fov_status == ('fov1', 1)
 
 
 def generate_test_apply_pixel_meta_cluster_remapping_data(temp_dir, fovs, chans,
                                                           generate_temp=False):
     # make it easy to name metadata columns
-    meta_colnames = ['fov', 'row_index', 'column_index', 'segmentation_label']
+    meta_colnames = ['fov', 'row_index', 'column_index', 'label']
 
     # create a dummy data directory
     os.mkdir(os.path.join(temp_dir, 'pixel_mat_data'))
 
     # create a dummy temp directory if specified
     if generate_temp:
         os.mkdir(os.path.join(temp_dir, 'pixel_mat_data_temp'))
@@ -577,14 +581,37 @@
                 fovs,
                 chans,
                 temp_dir,
                 'pixel_mat_data',
                 'bad_sample_pixel_remapping.csv'
             )
 
+        # duplicate pixel_meta_cluster_rename values found across pixel_meta_clusters
+        with pytest.raises(ValueError):
+            sample_pixel_remapping = pd.read_csv(
+                os.path.join(temp_dir, 'sample_pixel_remapping.csv')
+            )
+            bad_sample_pixel_remapping = sample_pixel_remapping.copy()
+            bad_sample_pixel_remapping.loc[
+                bad_sample_pixel_remapping['pixel_meta_cluster_rename'] == 'meta1',
+                'pixel_meta_cluster_rename'
+            ] = 'meta0'
+            bad_sample_pixel_remapping.to_csv(
+                os.path.join(temp_dir, 'bad_sample_pixel_remapping.csv'),
+                index=False
+            )
+
+            pixel_meta_clustering.apply_pixel_meta_cluster_remapping(
+                fovs,
+                chans,
+                temp_dir,
+                'pixel_mat_data',
+                'bad_sample_pixel_remapping.csv'
+            )
+
         # error check: mapping does not contain every SOM label
         with pytest.raises(ValueError):
             bad_sample_pixel_remapping = {
                 'pixel_som_cluster': [1, 2],
                 'pixel_meta_cluster': [1, 2],
                 'pixel_meta_cluster_rename': ['m1', 'm2']
             }
@@ -710,15 +737,15 @@
 def test_generate_remap_avg_files():
     with tempfile.TemporaryDirectory() as temp_dir:
         # create list of markers and fovs we want to use
         chan_list = ['Marker1', 'Marker2', 'Marker3', 'Marker4']
         fovs = ['fov0', 'fov1', 'fov2']
 
         # make it easy to name columns
-        colnames = chan_list + ['fov', 'row_index', 'column_index', 'segmentation_label']
+        colnames = chan_list + ['fov', 'row_index', 'column_index', 'label']
 
         # define sample pixel data for each FOV
         pixel_data_path = os.path.join(temp_dir, 'pixel_data_dir')
         os.mkdir(pixel_data_path)
         for i, fov in enumerate(fovs):
             fov_cluster_data = pd.DataFrame(np.random.rand(100, len(colnames)), columns=colnames)
             fov_cluster_data['pixel_som_cluster'] = i + 1
```

### Comparing `ark-analysis-0.6.3/tests/phenotyping/pixel_som_clustering_test.py` & `ark-analysis-0.6.4/tests/phenotyping/pixel_som_clustering_test.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,31 +1,31 @@
 import os
+import pathlib
 import tempfile
-from shutil import rmtree
 
 import feather
 import numpy as np
 import pandas as pd
 import pytest
-from alpineer import io_utils, misc_utils
+from alpineer import io_utils, misc_utils, test_utils
 
 import ark.phenotyping.cluster_helpers as cluster_helpers
 import ark.phenotyping.pixel_som_clustering as pixel_som_clustering
 
 parametrize = pytest.mark.parametrize
 
 
 def test_run_pixel_som_assignment():
     with tempfile.TemporaryDirectory() as temp_dir:
         # define fovs and channels
         fovs = ['fov0', 'fov1', 'fov2']
         chans = ['Marker1', 'Marker2', 'Marker3', 'Marker4']
 
         # make it easy to name metadata columns
-        meta_colnames = ['fov', 'row_index', 'column_index', 'segmentation_label']
+        meta_colnames = ['fov', 'row_index', 'column_index', 'label']
 
         # create a dummy data directory
         os.mkdir(os.path.join(temp_dir, 'pixel_mat_data'))
 
         # create a dummy temp directory
         os.mkdir(os.path.join(temp_dir, 'pixel_mat_data_temp'))
 
@@ -101,15 +101,15 @@
 
     with tempfile.TemporaryDirectory() as temp_dir:
         # create list of markers and fovs we want to use
         chan_list = ['Marker1', 'Marker2', 'Marker3', 'Marker4']
         fovs = ['fov0', 'fov1', 'fov2']
 
         # make it easy to name columns
-        colnames = chan_list + ['fov', 'row_index', 'column_index', 'segmentation_label']
+        colnames = chan_list + ['fov', 'row_index', 'column_index', 'label']
 
         # make a dummy sub directory
         os.mkdir(os.path.join(temp_dir, 'pixel_mat_subsetted'))
 
         for fov in fovs:
             # create the dummy data for each fov
             fov_sub_matrix = pd.DataFrame(np.random.rand(100, 8), columns=colnames)
@@ -154,15 +154,15 @@
         misc_utils.verify_same_elements(som_weights_channels=weights.columns.values,
                                         provided_channels=chan_list)
 
 
 def generate_test_pixel_som_cluster_data(temp_dir, fovs, chans,
                                          generate_temp=False):
     # make it easy to name metadata columns
-    meta_colnames = ['fov', 'row_index', 'column_index', 'segmentation_label']
+    meta_colnames = ['fov', 'row_index', 'column_index', 'label']
 
     # create a dummy clustered matrix
     os.mkdir(os.path.join(temp_dir, 'pixel_mat_data'))
 
     # create a dummy temp directory if specified
     if generate_temp:
         os.mkdir(os.path.join(temp_dir, 'pixel_mat_data_temp'))
@@ -178,15 +178,15 @@
             columns=chans
         )
 
         # assign dummy metadata labels
         fov_cluster_matrix['fov'] = fov
         fov_cluster_matrix['row_index'] = np.repeat(np.arange(1, 101), repeats=10)
         fov_cluster_matrix['column_index'] = np.tile(np.arange(1, 101), reps=10)
-        fov_cluster_matrix['segmentation_label'] = np.arange(1, 1001)
+        fov_cluster_matrix['label'] = np.arange(1, 1001)
 
         # write the dummy data to pixel_mat_data
         feather.write_dataframe(fov_cluster_matrix, os.path.join(temp_dir,
                                                                  'pixel_mat_data',
                                                                  fov + '.feather'))
 
         fov_data[fov] = fov_cluster_matrix
@@ -311,22 +311,46 @@
         # NOTE: fov1 should not be written because it was corrupted
         misc_utils.verify_same_elements(
             data_files=io_utils.list_files(os.path.join(temp_dir, 'pixel_mat_data')),
             written_files=['fov0.feather', 'fov2.feather']
         )
 
 
+def test__ignore_extended_attributes(tmp_path):
+    ignore_attrib_path: pathlib.Path = tmp_path / "ignore_attributes"
+    ignore_attrib_path.mkdir()
+    test_utils._make_blank_file(ignore_attrib_path, "._TEST_FILE.txt")
+    test_utils._make_blank_file(ignore_attrib_path, "TEST_FILE.txt")
+
+    # Raises a runtime error when the function is not `os.unlink` and the file is a hidden file
+    # prefixed with `._`
+    with pytest.raises(RuntimeError):
+        pixel_som_clustering._ignore_extended_attributes(
+            func=os.path.exists, filename="._TEST_FILE.txt", exc_info=(None, None, None))
+
+    # Raises a runtime error when the function is `os.unlink` and the file is not prefixed
+    # with `._`
+    with pytest.raises(RuntimeError):
+        pixel_som_clustering._ignore_extended_attributes(
+            func=os.unlink, filename="TEST_FILE.txt", exc_info=(None, None, None))
+
+    # Do not raise an erorr when the function is `os.unlink` and the file is a hidden file
+    # prefixed with `._`
+    pixel_som_clustering._ignore_extended_attributes(
+        func=os.unlink, filename="._TEST_FILE.txt", exc_info=(None, None, None))
+
+
 def test_generate_som_avg_files(capsys):
     with tempfile.TemporaryDirectory() as temp_dir:
         # create list of markers and fovs we want to use
         chan_list = ['Marker1', 'Marker2', 'Marker3', 'Marker4']
         fovs = ['fov0', 'fov1', 'fov2']
 
         # make it easy to name columns
-        colnames = chan_list + ['fov', 'row_index', 'column_index', 'segmentation_label']
+        colnames = chan_list + ['fov', 'row_index', 'column_index', 'label']
 
         # define sample pixel data for each FOV
         pixel_data_path = os.path.join(temp_dir, 'pixel_data_dir')
         os.mkdir(pixel_data_path)
         for i, fov in enumerate(fovs):
             fov_cluster_data = pd.DataFrame(np.random.rand(100, len(colnames)), columns=colnames)
             fov_cluster_data['pixel_som_cluster'] = i + 1
```

### Comparing `ark-analysis-0.6.3/tests/phenotyping/pixie_preprocessing_test.py` & `ark-analysis-0.6.4/tests/phenotyping/pixie_preprocessing_test.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,16 +3,16 @@
 from shutil import rmtree
 
 import feather
 import numpy as np
 import pandas as pd
 import pytest
 import skimage.io as io
-from pytest_cases import parametrize_with_cases
 from alpineer import image_utils, io_utils, load_utils, misc_utils, test_utils
+from pytest_cases import parametrize_with_cases
 
 # import ark.phenotyping.pixie_preprocessing as pixie_preprocessing
 import ark.phenotyping.pixie_preprocessing as pixie_preprocessing
 
 parametrize = pytest.mark.parametrize
 PIXEL_MATRIX_FOVS = ['fov0', 'fov1', 'fov2']
 PIXEL_MATRIX_CHANS = ['chan0', 'chan1', 'chan2']
@@ -409,53 +409,14 @@
                 axis=1
             ).values != 0)
 
             # assert the subsetted DataFrame size is 0.1 of the preprocessed DataFrame
             # NOTE: need to account for rounding if multiplying by 0.1 leads to non-int
             assert round(flowsom_data_fov.shape[0] * 0.1) == flowsom_sub_fov.shape[0]
 
-        # check that correct values are passed to helper function
-        mocker.patch(
-            'ark.phenotyping.pixie_preprocessing.preprocess_fov',
-            mocked_preprocess_fov
-        )
-
-        if sub_dir is None:
-            sub_dir = ''
-
-        # create fake data where all channels in each fov are the same
-        new_tiff_dir = os.path.join(temp_dir, 'new_tiff_dir')
-        os.makedirs(new_tiff_dir)
-        for fov in fovs:
-            img = (np.random.rand(100) * 100).reshape((10, 10))
-            fov_dir = os.path.join(new_tiff_dir, fov, sub_dir)
-            os.makedirs(fov_dir)
-            for chan in chans:
-                image_utils.save_image(os.path.join(fov_dir, chan + '.tiff'), img)
-
-        # recreate the output directory
-        rmtree(sample_pixel_output_dir)
-        os.mkdir(sample_pixel_output_dir)
-
-        # create normalization file
-        data_dir = os.path.join(temp_dir, 'pixel_mat_data')
-
-        # generate the data
-        mults = [(1 / 2) ** i for i in range(len(chans))]
-
-        pixie_preprocessing.create_pixel_matrix(
-            fovs=fovs,
-            channels=chans,
-            base_dir=temp_dir,
-            tiff_dir=new_tiff_dir,
-            img_sub_folder=sub_dir,
-            seg_dir=seg_dir,
-            multiprocess=multiprocess
-        )
-
 
 # TODO: clean up the following tests
 def generate_create_pixel_matrix_test_data(temp_dir):
     # create a directory to store the image data
     tiff_dir = os.path.join(temp_dir, 'sample_image_data')
     os.mkdir(tiff_dir)
 
@@ -493,18 +454,17 @@
         os.remove(os.path.join(temp_dir, 'pixel_mat_data', 'fov1.feather'))
         os.remove(os.path.join(temp_dir, 'pixel_mat_subsetted', 'fov1.feather'))
         sample_quant_data = pd.DataFrame(
             np.random.rand(3, 2),
             index=PIXEL_MATRIX_CHANS,
             columns=['fov0', 'fov2']
         )
-        feather.write_dataframe(
-            sample_quant_data,
-            os.path.join(temp_dir, 'pixel_output_dir', 'quant_dat.feather')
-        )
+        sample_quant_data.index.name = 'channel'
+        sample_quant_data.to_csv(
+            os.path.join(temp_dir, 'pixel_mat_data', 'channel_norm_post_rowsum_perfov.csv'))
 
         pixie_preprocessing.create_pixel_matrix(
             fovs=PIXEL_MATRIX_FOVS,
             channels=PIXEL_MATRIX_CHANS,
             base_dir=temp_dir,
             tiff_dir=tiff_dir,
             img_sub_folder=None,
@@ -527,18 +487,16 @@
         )
 
         capsys.readouterr()
 
         # test the case where we've written a FOV to data but not subset
         # NOTE: in this case, the value in quant_dat will also not have been written
         os.remove(os.path.join(temp_dir, 'pixel_mat_subsetted', 'fov1.feather'))
-        feather.write_dataframe(
-            sample_quant_data,
-            os.path.join(temp_dir, 'pixel_output_dir', 'quant_dat.feather')
-        )
+        sample_quant_data.to_csv(
+            os.path.join(temp_dir, 'pixel_mat_data', 'channel_norm_post_rowsum_perfov.csv'))
 
         pixie_preprocessing.create_pixel_matrix(
             fovs=PIXEL_MATRIX_FOVS,
             channels=PIXEL_MATRIX_CHANS,
             base_dir=temp_dir,
             tiff_dir=tiff_dir,
             img_sub_folder=None,
@@ -557,20 +515,18 @@
         )
         misc_utils.verify_same_elements(
             data_files=io_utils.list_files(os.path.join(temp_dir, 'pixel_mat_subsetted')),
             written_files=fov_files
         )
 
         # test the case where we've written a FOV to subset but not data (very rare)
-        # NOTE: in this case, the value in quant_dat will also not have been written
+        # NOTE: in this case, the value in quantile_dat will also not have been written
         os.remove(os.path.join(temp_dir, 'pixel_mat_data', 'fov1.feather'))
-        feather.write_dataframe(
-            sample_quant_data,
-            os.path.join(temp_dir, 'pixel_output_dir', 'quant_dat.feather')
-        )
+        sample_quant_data.to_csv(
+            os.path.join(temp_dir, 'pixel_mat_data', 'channel_norm_post_rowsum_perfov.csv'))
 
         pixie_preprocessing.create_pixel_matrix(
             fovs=PIXEL_MATRIX_FOVS,
             channels=PIXEL_MATRIX_CHANS,
             base_dir=temp_dir,
             tiff_dir=tiff_dir,
             img_sub_folder=None,
```

### Comparing `ark-analysis-0.6.3/tests/phenotyping/post_cluster_utils_test.py` & `ark-analysis-0.6.4/tests/phenotyping/post_cluster_utils_test.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 import os
 
 import numpy as np
 import pandas as pd
 import pytest
 import skimage.io as io
 from alpineer import image_utils, test_utils
+from ark import settings
 
 from ark.phenotyping import post_cluster_utils
 
 
 def test_plot_hist_thresholds():
     pops = np.repeat(['pop1', 'pop2', 'pop3'], 5)
     marker_1 = np.random.rand(len(pops))
@@ -36,52 +37,63 @@
     post_cluster_utils.plot_hist_thresholds(cell_table=cell_table,
                                             populations=['pop1', 'pop2'],
                                             marker='marker_1')
 
 
 def test_create_mantis_project(tmp_path):
     # create necessary directories
-    seg_dir = os.path.join(tmp_path, 'seg')
+    seg_dir = os.path.join(tmp_path, "seg")
     os.makedirs(seg_dir)
 
-    image_dir = os.path.join(tmp_path, 'images')
+    image_dir = os.path.join(tmp_path, "images")
     os.makedirs((image_dir))
 
-    mantis_dir = os.path.join(tmp_path, 'mantis')
+    mantis_dir = os.path.join(tmp_path, "mantis")
     os.makedirs((mantis_dir))
 
-    mask_dir = os.path.join(tmp_path, 'mask')
+    mask_dir = os.path.join(tmp_path, "mask")
 
     # create images
-    fovs, channels = test_utils.gen_fov_chan_names(num_fovs=3, num_chans=4,
-                                                   use_delimiter=False, return_imgs=False)
-    test_utils._write_tifs(image_dir, fovs, channels, (10, 10), '', False, int)
+    fovs, channels = test_utils.gen_fov_chan_names(
+        num_fovs=3, num_chans=4, use_delimiter=False, return_imgs=False
+    )
+    test_utils._write_tifs(image_dir, fovs, channels, (10, 10), "", False, int)
 
     # create random segmentation masks
     for fov in fovs:
         data = np.random.randint(0, 5, 100).reshape(10, 10)
-        image_utils.save_image(os.path.join(seg_dir, fov + '_whole_cell_test.tiff'), data)
+        image_utils.save_image(
+            os.path.join(seg_dir, fov + "_whole_cell_test.tiff"), data
+        )
 
     # create cell table with two clusters
     cell_label = np.tile(np.arange(1, 5), len(fovs))
-    cell_clusters = np.tile(['cluster1', 'cluster2'], 6)
+    cell_clusters = np.tile(["cluster1", "cluster2"], 6)
     fov_list = np.repeat(fovs, 4)
 
-    cell_table = pd.DataFrame({'fov': fov_list, 'label': cell_label,
-                               'cell_meta_cluster': cell_clusters})
-
-    post_cluster_utils.create_mantis_project(cell_table=cell_table, fovs=fovs,
-                                             seg_dir=seg_dir, pop_col='cell_meta_cluster',
-                                             mask_dir=mask_dir, image_dir=image_dir,
-                                             mantis_dir=mantis_dir,
-                                             seg_suffix_name="_whole_cell_test.tiff",
-                                             cluster_type='cell')
+    cell_table = pd.DataFrame(
+        {"fov": fov_list, "label": cell_label, "cell_meta_cluster": cell_clusters}
+    )
+
+    post_cluster_utils.create_mantis_project(
+        cell_table=cell_table,
+        fovs=fovs,
+        seg_dir=seg_dir,
+        mask_dir=mask_dir,
+        image_dir=image_dir,
+        mantis_dir=mantis_dir,
+        pop_col="cell_meta_cluster",
+        fov_col=settings.FOV_ID,
+        label_col=settings.CELL_LABEL,
+        seg_suffix_name="_whole_cell_test.tiff",
+        cluster_type="cell",
+    )
 
     # make sure that the mask found in each mantis directory is correct
     for fov in fovs:
         # mask should only include 0, 1, and 2 for background, population_1, and population_2
-        mask = io.imread(os.path.join(mask_dir, fov + '_cell_mask.tiff'))
+        mask = io.imread(os.path.join(mask_dir, fov + "_cell_mask.tiff"))
         assert set(np.unique(mask)) == set([0, 1, 2])
 
         # mask should be non-zero in the same places as original
-        seg = io.imread(os.path.join(seg_dir, fov + '_whole_cell_test.tiff'))
+        seg = io.imread(os.path.join(seg_dir, fov + "_whole_cell_test.tiff"))
         assert np.array_equal(mask > 0, seg > 0)
```

### Comparing `ark-analysis-0.6.3/tests/phenotyping/weighted_channel_comp_test.py` & `ark-analysis-0.6.4/tests/phenotyping/weighted_channel_comp_test.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,16 +4,16 @@
 
 import feather
 import numpy as np
 import pandas as pd
 import pytest
 
 import ark.phenotyping.cell_cluster_utils as cell_cluster_utils
-import ark.phenotyping.weighted_channel_comp as weighted_channel_comp
 import ark.phenotyping.cluster_helpers as cluster_helpers
+import ark.phenotyping.weighted_channel_comp as weighted_channel_comp
 
 
 def test_compute_p2c_weighted_channel_avg():
     fovs = ['fov1', 'fov2']
     chans = ['chan1', 'chan2', 'chan3']
 
     # create an example cell table
@@ -45,15 +45,15 @@
             fov_table = pd.DataFrame(
                 np.tile(np.array([0.1, 0.2, 0.4]), 50).reshape(50, 3),
                 columns=chans
             )
 
             # assign the fovs and labels
             fov_table['fov'] = fov
-            fov_table['segmentation_label'] = np.repeat(np.arange(5), 10)
+            fov_table['label'] = np.repeat(np.arange(5), 10)
 
             # assign dummy pixel/meta labels
             # pixel: 0-1 for fov1 and 1-2 for fov2
             # meta: 0-1 for both fov1 and fov2
             # note: defining them this way greatly simplifies testing
             if fov == 'fov1':
                 fov_table['pixel_som_cluster'] = np.repeat(np.arange(2), 25)
@@ -157,16 +157,16 @@
         )
 
         # assign dummy fovs
         weighted_cell_table.loc[0:4, 'fov'] = 'fov1'
         weighted_cell_table.loc[5:9, 'fov'] = 'fov2'
 
         # assign dummy segmentation labels, 5 cells for each
-        weighted_cell_table.loc[0:4, 'segmentation_label'] = np.arange(5)
-        weighted_cell_table.loc[5:9, 'segmentation_label'] = np.arange(5)
+        weighted_cell_table.loc[0:4, 'label'] = np.arange(5)
+        weighted_cell_table.loc[5:9, 'label'] = np.arange(5)
 
         # assign dummy cell sizes, these won't really matter for this test
         weighted_cell_table['cell_size'] = 5
 
         # write the data to feather
         feather.write_dataframe(
             weighted_cell_table, os.path.join(temp_dir, 'weighted_cell_channel.feather')
@@ -181,17 +181,17 @@
 
         # assign dummy cell cluster labels
         consensus_data['cell_som_cluster'] = np.repeat(np.arange(5), 2)
 
         # assign dummy consensus cluster labels
         consensus_data['cell_meta_cluster'] = np.repeat(np.arange(2), 5)
 
-        # assign the same FOV and segmentation_label data to consensus_data
-        consensus_data[['fov', 'segmentation_label']] = weighted_cell_table[
-            ['fov', 'segmentation_label']
+        # assign the same FOV and label data to consensus_data
+        consensus_data[['fov', 'label']] = weighted_cell_table[
+            ['fov', 'label']
         ].copy()
 
         # error check: bad cell_cluster_col provided
         with pytest.raises(ValueError):
             weighted_channel_comp.compute_cell_cluster_weighted_channel_avg(
                 fovs, chans, temp_dir, 'weighted_cell_channel.feather',
                 consensus_data, cell_cluster_col='bad_cluster_col'
@@ -232,24 +232,24 @@
         # create a dummy cluster_data file
         cluster_data = pd.DataFrame(
             np.random.randint(0, 100, (1000, 3)),
             columns=cluster_cols
         )
 
         cluster_data['fov'] = np.repeat(['fov0', 'fov1'], repeats=500)
-        cluster_data['segmentation_label'] = np.tile(np.arange(1, 501), reps=2)
+        cluster_data['label'] = np.tile(np.arange(1, 501), reps=2)
         cluster_data['cell_som_cluster'] = np.repeat(np.arange(100), 10)
         cluster_data['cell_meta_cluster'] = np.repeat(np.arange(20), 50)
 
         # create a dummy weighted channel average table
         weighted_cell_table = pd.DataFrame(
             np.random.rand(1000, 3), columns=['chan%d' % i for i in np.arange(3)]
         )
         weighted_cell_table['fov'] = np.repeat(['fov0', 'fov1'], repeats=500)
-        weighted_cell_table['segmentation_label'] = np.tile(np.arange(1, 501), reps=2)
+        weighted_cell_table['label'] = np.tile(np.arange(1, 501), reps=2)
 
         # write dummy weighted channel average table
         weighted_cell_path = os.path.join(temp_dir, 'weighted_cell_channel.feather')
         feather.write_dataframe(weighted_cell_table, weighted_cell_path)
 
         # define a sample SOM to meta cluster map
         som_to_meta_data = {
@@ -355,31 +355,31 @@
         cluster_data['cell_meta_cluster'] = np.repeat(np.arange(10), 100)
 
         # assign dummy fovs
         cluster_data.loc[0:499, 'fov'] = 'fov1'
         cluster_data.loc[500:999, 'fov'] = 'fov2'
 
         # assign dummy segmentation labels, 50 cells for each
-        cluster_data.loc[0:499, 'segmentation_label'] = np.arange(500)
-        cluster_data.loc[500:999, 'segmentation_label'] = np.arange(500)
+        cluster_data.loc[0:499, 'label'] = np.arange(500)
+        cluster_data.loc[500:999, 'label'] = np.arange(500)
 
         # create an example weighted cell table
         chans = ['chan0', 'chan1', 'chan2']
         weighted_cell_table = pd.DataFrame(
             np.repeat([[0.1, 0.2, 0.3]], repeats=1000, axis=0),
             columns=chans
         )
 
         # assign dummy fovs
         weighted_cell_table.loc[0:499, 'fov'] = 'fov1'
         weighted_cell_table.loc[500:999, 'fov'] = 'fov2'
 
         # assign dummy segmentation labels, 50 cells for each
-        weighted_cell_table.loc[0:499, 'segmentation_label'] = np.arange(500)
-        weighted_cell_table.loc[500:999, 'segmentation_label'] = np.arange(500)
+        weighted_cell_table.loc[0:499, 'label'] = np.arange(500)
+        weighted_cell_table.loc[500:999, 'label'] = np.arange(500)
 
         # assign dummy cell sizes, these won't really matter for this test
         weighted_cell_table['cell_size'] = 5
 
         # save weighted cell table
         weighted_cell_table_path = os.path.join(temp_dir, 'sample_weighted_cell_table.feather')
         feather.write_dataframe(weighted_cell_table, weighted_cell_table_path)
```

### Comparing `ark-analysis-0.6.3/tests/segmentation/marker_quantification_test.py` & `ark-analysis-0.6.4/tests/segmentation/marker_quantification_test.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,23 +1,23 @@
 import copy
 import os
 import tempfile
 
 import numpy as np
 import pytest
 import skimage.morphology as morph
+import test_utils
 import xarray as xr
-from skimage.morphology import erosion
 from alpineer import image_utils, misc_utils
 from alpineer.test_utils import (create_paired_xarray_fovs, gen_fov_chan_names,
                                  make_images_xarray, make_labels_xarray)
+from skimage.morphology import erosion
 
 import ark.settings as settings
 from ark.segmentation import marker_quantification
-import test_utils
 
 parametrize = pytest.mark.parametrize
 
 
 @parametrize('regionprops_single_comp',
              [copy.deepcopy(settings.REGIONPROPS_SINGLE_COMP), []])
 def test_get_single_compartment_props(regionprops_single_comp):
```

### Comparing `ark-analysis-0.6.3/tests/segmentation/regionprops_extraction_test.py` & `ark-analysis-0.6.4/tests/segmentation/regionprops_extraction_test.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/tests/segmentation/segmentation_utils_test.py` & `ark-analysis-0.6.4/tests/segmentation/segmentation_utils_test.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 import os
 import os.path
 import tempfile
 
 import numpy as np
 import pytest
+import test_utils
 import xarray as xr
-from skimage.measure import regionprops
 from alpineer import image_utils
 from alpineer.test_utils import make_images_xarray, make_labels_xarray
+from skimage.measure import regionprops
 
 import ark.settings as settings
 from ark.segmentation import segmentation_utils
-import test_utils
 
 
 def test_find_nuclear_mask_id():
     # create cell labels with 5 distinct cells
     cell_labels = np.zeros((60, 10), dtype='int')
     for i in range(6):
         cell_labels[(i * 10):(i * 10 + 8), :8] = i + 1
```

### Comparing `ark-analysis-0.6.3/tests/segmentation/signal_extraction_test.py` & `ark-analysis-0.6.4/tests/segmentation/signal_extraction_test.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 import numpy as np
+import synthetic_spatial_datagen
 import xarray as xr
 from skimage.measure import regionprops
 
 from ark.segmentation import signal_extraction
-import synthetic_spatial_datagen
 
 
 def test_positive_pixels_extraction():
     # sample params
     size_img = (1024, 1024)
     cell_radius = 10
     nuc_radius = 3
```

### Comparing `ark-analysis-0.6.3/tests/spLDA/processing_test.py` & `ark-analysis-0.6.4/tests/spLDA/processing_test.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 import numpy as np
 import pytest
-from sklearn.cluster import KMeans
 from alpineer import misc_utils
+from sklearn.cluster import KMeans
+from test_utils import make_cell_table
 
 import ark.settings as settings
 import ark.spLDA.processing as pros
 from ark.utils.spatial_lda_utils import within_cluster_sums
-from test_utils import make_cell_table
 
 # Generate a test cell table
 N_CELLS = 1000
 TEST_CELL_TABLE = make_cell_table(N_CELLS)
 
 
 def test_format_cell_table():
```

### Comparing `ark-analysis-0.6.3/tests/synthetic_spatial_datagen.py` & `ark-analysis-0.6.4/tests/synthetic_spatial_datagen.py`

 * *Files 0% similar despite different names*

```diff
@@ -229,15 +229,15 @@
     label_mat[point_x_coords, point_y_coords] = centroid_indices + 1
 
     # generate label mat
     sample_img = np.zeros((1, size_img[0], size_img[1], 1)).astype(np.int16)
     sample_img[0, :, :, 0] = deepcopy(label_mat)
     sample_img_xr = xr.DataArray(
         sample_img,
-        coords=[[1], range(size_img[0]), range(size_img[1]), ['segmentation_label']],
+        coords=[[1], range(size_img[0]), range(size_img[1]), ['label']],
         dims=['fovs', 'rows', 'cols', 'channels']
     )
 
     return sample_img_xr
 
 
 def generate_two_cell_seg_mask(size_img=(1024, 1024), cell_radius=10):
```

### Comparing `ark-analysis-0.6.3/tests/test_utils.py` & `ark-analysis-0.6.4/tests/test_utils.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 from copy import deepcopy
 from random import choices
 from string import ascii_lowercase
 
 import numpy as np
 import pandas as pd
+import synthetic_spatial_datagen
 import xarray as xr
 
 import ark.settings as settings
-import synthetic_spatial_datagen
 
 TEST_MARKERS = list('ABCDEFG')
 
 
 def make_cell_table(num_cells, extra_cols=None):
     """ Generate a cell table with default column names for testing purposes.
```

### Comparing `ark-analysis-0.6.3/tests/utils/data_utils_test.py` & `ark-analysis-0.6.4/tests/utils/data_utils_test.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,21 +1,24 @@
 import os
+import pathlib
+import random
 import shutil
 import tempfile
-from random import randint
 from shutil import rmtree
+from typing import Generator, Iterator, List, Tuple
 
 import feather
 import numpy as np
 import pandas as pd
 import pytest
 import skimage.io as io
 import xarray as xr
+import numba as nb
+import test_utils as ark_test_utils
 from alpineer import image_utils, io_utils, load_utils, test_utils
-
 from ark import settings
 from ark.utils import data_utils
 
 parametrize = pytest.mark.parametrize
 
 
 @parametrize('sub_dir', [None, 'test_sub_dir'])
@@ -51,234 +54,316 @@
         # assert image was saved as np.int16
         assert fov_img.dtype == np.dtype('int16')
 
         # assert the image dimensions are correct
         assert fov_img.shape == (40, 40)
 
 
-def test_relabel_segmentation():
-    x = y = 5
-    img_arr = np.arange(1, x * y + 1).reshape((x, y))
-    d = {i: i + 1 for i in range(1, x * y + 1)}
-    res = data_utils.relabel_segmentation(img_arr, d)
-
-    assert np.array_equal(img_arr + 1, res)
-
-    # some cells are not mapped to any cluster-label
-    d = {i: i + 1 for i in range(1, x * y - 5)}
-    res = data_utils.relabel_segmentation(img_arr, d)
-    # these cells should all get a default label
-    img_arr[img_arr >= x * y - 5] = x * y - 5
-
-    assert np.array_equal(img_arr + 1, res)
-
-    # test case for multiple pixels with the same label
-    data = np.array([[1, 2], [3, 4]])
-    data = np.repeat(data, 2)  # ([1, 1, 2, 2, 3, 3, 4, 4])
-    img_arr = data.reshape((4, 2))
-    d = {i: 10 * i for i in range(5)}
-    res = data_utils.relabel_segmentation(img_arr, d)
+@pytest.fixture(scope="module")
+def cell_table_cluster(rng: np.random.Generator) -> Generator[pd.DataFrame, None, None]:
+    """_summary_
+
+    Args:
+        rng (np.random.Generator): _description_
+
+    Yields:
+        Generator[pd.DataFrame, None, None]: _description_
+    """
+    ct: pd.DataFrame = ark_test_utils.make_cell_table(num_cells=100)
+    ct[settings.FOV_ID] = rng.choice(["fov0", "fov1"], size=100)
+    ct["label"] = ct.groupby(by=settings.FOV_ID)["fov"].transform(
+        lambda x: np.arange(start=1, stop=len(x) + 1, dtype=int)
+    )
+    ct[settings.CELL_TYPE] = rng.choice(np.arange(1, 3), size=100)
+    ct.reset_index(drop=True, inplace=True)
+    yield ct
+
+
+class TestCellClusterMaskData:
+    @pytest.fixture(autouse=True)
+    def _setup(self, cell_table_cluster: pd.DataFrame):
+        self.cell_table: pd.DataFrame = cell_table_cluster
+        self.label_column = "label"
+        self.cluster_column = settings.CELL_TYPE
+        self.fov_col = settings.FOV_ID
+
+        self.ccmd = data_utils.CellClusterMaskData(
+            data=self.cell_table,
+            fov_col=self.fov_col,
+            label_col=self.label_column,
+            cluster_col=self.cluster_column,
+        )
+
+    def test___init__(self):
+        # Test __init__
+        assert self.ccmd.label_column == self.label_column
+        assert self.ccmd.cluster_column == self.cluster_column
+        assert self.ccmd.fov_column == self.fov_col
+
+        # Test __post_init__ generated fields
+        assert set(self.ccmd.unique_fovs) == set(["fov0", "fov1"])
+        assert self.ccmd.unassigned_id == 3
+        assert isinstance(self.ccmd.mapping, pd.core.groupby.generic.DataFrameGroupBy)
+        assert self.ccmd.mapping.ngroups == 2
 
-    assert np.array_equal(img_arr * 10, res)
+    @parametrize(
+        "_fov", ["fov0", "fov1", pytest.param("fov2", marks=pytest.mark.xfail)]
+    )
+    def test_fov_mapping(self, _fov: str):
+        fov_mapping_df: pd.DataFrame = self.ccmd.fov_mapping(_fov)
 
+        true_df: pd.DataFrame = (
+            pd.concat(
+                [
+                    self.cell_table[self.cell_table[self.fov_col] == _fov][
+                        [self.fov_col, self.label_column, self.cluster_column]
+                    ],
+                    pd.DataFrame(
+                        {
+                            self.label_column: [0],
+                            self.cluster_column: [0],
+                            self.fov_col: [_fov],
+                        }
+                    ),
+                ]
+            )
+            .sort_values(by=self.label_column)
+            .reset_index(drop=True, inplace=False)
+            .astype({self.label_column: np.int32, self.cluster_column: np.int32})
+        )
+
+        pd.testing.assert_frame_equal(fov_mapping_df, true_df)
+
+
+@pytest.fixture(scope="function")
+def label_map_generator(
+    cell_table_cluster: pd.DataFrame, rng: np.random.Generator
+) -> Generator[Tuple[xr.DataArray, data_utils.CellClusterMaskData], None, None]:
+    """_summary_
+
+    Args:
+        cell_table_cluster (pd.DataFrame): _description_
+        rng (np.random.Generator): _description_
+
+    Yields:
+        Generator[Tuple[xr.DataArray, data_utils.CellClusterMaskData], None, None]: _description_
+    """
+    fov_size = 40
+
+    # Get the data for FOV 0
+    fov0_data: pd.DataFrame = cell_table_cluster[
+        cell_table_cluster[settings.FOV_ID] == "fov0"
+    ]
+
+    image_data: np.ndarray = rng.integers(
+        low=0,
+        high=fov0_data["label"].max() + 1,
+        size=(fov_size, fov_size),
+        dtype="int16",
+    )
 
-@parametrize('zero_pixels', [False, True])
-def test_label_cells_by_cluster(zero_pixels):
-    # define a sample FOV name
-    fov = 'fov0'
+    label_map = xr.DataArray(
+        data=image_data,
+        coords=[np.arange(fov_size), np.arange(fov_size)],
+        dims=["rows", "cols"],
+    )
 
-    # define the dimensions
-    x = y = 5
+    ccmd = data_utils.CellClusterMaskData(
+        data=cell_table_cluster,
+        fov_col=settings.FOV_ID,
+        label_col="label",
+        cluster_col=settings.CELL_TYPE,
+    )
+    yield (label_map, ccmd)
 
-    # define a sample all_data
-    cluster_labels = np.random.randint(1, 5, x * y)
-    labels = [i % (x * y) for i in range(x * y)]
-    data = list(zip(cluster_labels, labels, [fov for _ in range(x * y)]))
-    all_data = pd.DataFrame(data, columns=[
-        settings.KMEANS_CLUSTER,
-        settings.CELL_LABEL,
-        settings.FOV_ID,
-    ])
-
-    img_data = np.array(np.arange(1, x * y + 1).reshape((x, y)))
-    if zero_pixels:
-        img_data = 0
 
-    # define a label map for the FOV
-    label_map = xr.DataArray(
-        img_data, coords=[range(x), range(y)], dims=['rows', 'cols']
-    )
+def test_label_cells_by_cluster(label_map_generator):
+    label_map, ccmd = label_map_generator
 
-    # relabel the cells
-    res_data = data_utils.label_cells_by_cluster(fov, all_data, label_map, fov_col=settings.FOV_ID)
+    relabeled_image: np.ndarray = data_utils.label_cells_by_cluster(
+        fov="fov0", ccmd=ccmd, label_map=label_map)
 
-    # assert the shape is the same as the original label_map
-    assert res_data.shape == (x, y)
+    assert relabeled_image.max() <= ccmd.unassigned_id
+    assert relabeled_image.min() == 0
+    assert relabeled_image.shape == label_map.shape
 
-    # assert the pixels are zero or non-zero per the test
-    test_mask = res_data == 0 if zero_pixels else res_data > 0
-    assert np.all(test_mask)
 
+def test_relabel_segmentation(label_map_generator):
+    label_map, ccmd = label_map_generator
 
-def test_generate_cell_cluster_mask():
-    fov = 'fov0'
-    som_cluster_cols = ['pixel_som_cluster_%d' % i for i in np.arange(5)]
-    meta_cluster_cols = ['pixel_meta_cluster_%d' % i for i in np.arange(3)]
+    fov_clusters = ccmd.fov_mapping("fov0")
 
-    with tempfile.TemporaryDirectory() as temp_dir:
-        # bad segmentation path passed
-        with pytest.raises(FileNotFoundError):
-            data_utils.generate_cell_cluster_mask(
-                fov, temp_dir, 'bad_seg_dir', pd.DataFrame()
-            )
+    mapping: nb.typed.typeddict = nb.typed.Dict.empty(
+        key_type=nb.types.int64,
+        value_type=nb.types.int64,
+    )
 
-        # generate a sample segmentation mask
-        cell_mask = np.random.randint(low=0, high=5, size=(40, 40), dtype="int16")
-        image_utils.save_image(os.path.join(temp_dir, '%s_whole_cell.tiff' % fov), cell_mask)
+    for label, cluster in fov_clusters[[ccmd.label_column, ccmd.cluster_column]].itertuples(
+            index=False):
+        mapping[label] = cluster
+
+    # Test the pure python counterpart alongside the numba version
+    relabeled_image_py: np.ndarray = data_utils.relabel_segmentation.py_func(
+        mapping=mapping,
+        unassigned_id=ccmd.unassigned_id,
+        labeled_image=label_map.values,
+    )
+    relabeled_image_numba: np.ndarray = data_utils.relabel_segmentation(
+        mapping=mapping,
+        unassigned_id=ccmd.unassigned_id,
+        labeled_image=label_map.values,
+    )
+    for relabeled_image in [relabeled_image_py, relabeled_image_numba]:
+        assert relabeled_image.max() <= ccmd.unassigned_id
+        assert relabeled_image.min() == 0
+        assert relabeled_image.shape == label_map.shape
 
-        # create a sample cell consensus file based on SOM cluster assignments
-        consensus_data_som = pd.DataFrame(
-            np.random.randint(low=0, high=100, size=(20, 5)), columns=som_cluster_cols
-        )
 
-        consensus_data_som['fov'] = fov
-        consensus_data_som['segmentation_label'] = consensus_data_som.index.values + 1
-        consensus_data_som['cell_som_cluster'] = np.tile(np.arange(1, 6), 4)
-        consensus_data_som['cell_meta_cluster'] = np.tile(np.arange(1, 3), 10)
+def test_generate_cell_cluster_mask(tmp_path: pathlib.Path, label_map_generator):
+    _, ccmd = label_map_generator
+    fov = 'fov0'
+    som_cluster_cols = ['pixel_som_cluster_%d' % i for i in np.arange(5)]
+    meta_cluster_cols = ['pixel_meta_cluster_%d' % i for i in np.arange(3)]
 
-        # create a sample cell consensus file based on meta cluster assignments
-        consensus_data_meta = pd.DataFrame(
-            np.random.randint(low=0, high=100, size=(20, 3)), columns=meta_cluster_cols
+    with pytest.raises(ValueError):
+        data_utils.generate_cell_cluster_mask(
+            fov, tmp_path, ccmd, seg_suffix='bad_suffix'
         )
 
-        consensus_data_meta['fov'] = fov
-        consensus_data_meta['segmentation_label'] = consensus_data_meta.index.values + 1
-        consensus_data_meta['cell_som_cluster'] = np.tile(np.arange(1, 6), 4)
-        consensus_data_meta['cell_meta_cluster'] = np.tile(np.arange(1, 3), 10)
+    # generate a sample segmentation mask
+    cell_mask = np.random.randint(low=0, high=5, size=(40, 40), dtype="int16")
+    image_utils.save_image(os.path.join(tmp_path, '%s_whole_cell.tiff' % fov), cell_mask)
+
+    # create a sample cell consensus file based on SOM cluster assignments
+    consensus_data_som = pd.DataFrame(
+        np.random.randint(low=0, high=100, size=(20, 5)), columns=som_cluster_cols
+    )
 
-        # bad cluster column provided
-        with pytest.raises(ValueError):
-            data_utils.generate_cell_cluster_mask(
-                fov, temp_dir, temp_dir, consensus_data_som, 'bad_cluster'
-            )
+    consensus_data_som['fov'] = fov
+    consensus_data_som['label'] = consensus_data_som.index.values + 1
+    consensus_data_som['cell_som_cluster'] = np.tile(np.arange(1, 6), 4)
+    consensus_data_som['cell_meta_cluster'] = np.tile(np.arange(1, 3), 10)
+
+    # create a sample cell consensus file based on meta cluster assignments
+    consensus_data_meta = pd.DataFrame(
+        np.random.randint(low=0, high=100, size=(20, 3)), columns=meta_cluster_cols
+    )
 
-        # bad fov provided
-        with pytest.raises(ValueError):
-            data_utils.generate_cell_cluster_mask(
-                'fov1', temp_dir, temp_dir,
-                consensus_data_som, 'cell_som_cluster'
-            )
+    consensus_data_meta['fov'] = fov
+    consensus_data_meta['label'] = consensus_data_meta.index.values + 1
+    consensus_data_meta['cell_som_cluster'] = np.tile(np.arange(1, 6), 4)
+    consensus_data_meta['cell_meta_cluster'] = np.tile(np.arange(1, 3), 10)
 
-        # test on SOM assignments
-        cell_masks = data_utils.generate_cell_cluster_mask(
-            fov, temp_dir, temp_dir, consensus_data_som, 'cell_som_cluster'
+    # bad cluster column provided
+    with pytest.raises(ValueError):
+        data_utils.generate_cell_cluster_mask(
+            fov="fov0", seg_dir=tmp_path, ccmd=ccmd, seg_suffix='bad_cluster'
         )
 
-        # assert the image size is the same as the mask (40, 40)
-        assert cell_masks.shape == (40, 40)
-
-        # assert no value is greater than the highest SOM cluster value (5)
-        assert np.all(cell_masks <= 5)
-
-        # test on meta assignments
-        cell_masks = data_utils.generate_cell_cluster_mask(
-            fov, temp_dir, temp_dir, consensus_data_meta, 'cell_meta_cluster'
+    # bad fov provided
+    with pytest.raises(ValueError):
+        data_utils.generate_cell_cluster_mask(
+            fov="fov1", seg_dir=tmp_path, ccmd=ccmd, seg_suffix="_whole_cell.tiff"
         )
 
-        # assert the image size is the same as the mask (40, 40)
-        assert cell_masks.shape == (40, 40)
+    cell_masks = data_utils.generate_cell_cluster_mask(
+        fov, tmp_path, ccmd, seg_suffix="_whole_cell.tiff"
+    )
+
+    # assert the image size is the same as the mask (40, 40)
+    assert cell_masks.shape == (40, 40)
 
-        # assert no value is greater than the highest SOM cluster value (2)
-        assert np.all(cell_masks <= 2)
+    # assert no value is greater than the highest SOM cluster value (5)
+    assert np.all(cell_masks <= 5)
 
 
 @parametrize('sub_dir', [None, 'sub_dir'])
 @parametrize('name_suffix', ['', 'sample_suffix'])
-def test_generate_and_save_cell_cluster_masks(sub_dir, name_suffix):
+def test_generate_and_save_cell_cluster_masks(tmp_path: pathlib.Path, sub_dir, name_suffix):
     fov_count = 7
     fovs = [f"fov{i}" for i in range(fov_count)]
     som_cluster_cols = ['pixel_som_cluster_%d' % i for i in np.arange(5)]
     meta_cluster_cols = ['pixel_meta_cluster_%d' % i for i in np.arange(3)]
     fov_size_split = 4
 
-    with tempfile.TemporaryDirectory() as temp_dir:
-        # Create a save directory
-        os.mkdir(os.path.join(temp_dir, 'cell_masks'))
-
-        # generate sample segmentation masks
-        # NOTE: this function should work on variable image sizes
-        # TODO: condense cell mask generation into a helper function
-        cell_masks_40 = np.random.randint(
-            low=0, high=5, size=(fov_size_split, 40, 40, 1), dtype="int16"
-        )
-
-        cell_masks_20 = np.random.randint(
-            low=0, high=5, size=(fov_count - fov_size_split, 20, 20, 1), dtype="int16"
-        )
-
-        for fov in range(fov_count):
-            fov_index = fov if fov < fov_size_split else fov_size_split - fov
-            fov_mask = cell_masks_40 if fov < fov_size_split else cell_masks_20
-            fov_whole_cell = fov_mask[fov_index, :, :, 0]
-            image_utils.save_image(os.path.join(temp_dir, 'fov%d_whole_cell.tiff' % fov),
-                                   fov_whole_cell)
-
-        # create a sample cell consensus file based on SOM cluster assignments
-        consensus_data_som = pd.DataFrame()
-
-        # create a sample cell consensus file based on meta cluster assignments
-        consensus_data_meta = pd.DataFrame()
-
-        # generate sample cell data with SOM and meta cluster assignments for each fov
-        for fov in fovs:
-            som_data_fov = pd.DataFrame(
-                np.random.randint(low=0, high=100, size=(20, 5)), columns=som_cluster_cols
-            )
+    # Create a save directory
+    os.mkdir(os.path.join(tmp_path, 'cell_masks'))
 
-            som_data_fov['fov'] = fov
-            som_data_fov['segmentation_label'] = som_data_fov.index.values + 1
-            som_data_fov['cell_som_cluster'] = np.tile(np.arange(1, 6), 4)
-            som_data_fov['cell_meta_cluster'] = np.tile(np.arange(1, 3), 10)
+    # generate sample segmentation masks
+    # NOTE: this function should work on variable image sizes
+    # TODO: condense cell mask generation into a helper function
+    cell_masks_40 = np.random.randint(
+        low=0, high=5, size=(fov_size_split, 40, 40, 1), dtype="int16"
+    )
 
-            consensus_data_som = pd.concat([consensus_data_som, som_data_fov])
+    cell_masks_20 = np.random.randint(
+        low=0, high=5, size=(fov_count - fov_size_split, 20, 20, 1), dtype="int16"
+    )
 
-            meta_data_fov = pd.DataFrame(
-                np.random.randint(low=0, high=100, size=(20, 3)), columns=meta_cluster_cols
-            )
+    for fov in range(fov_count):
+        fov_index = fov if fov < fov_size_split else fov_size_split - fov
+        fov_mask = cell_masks_40 if fov < fov_size_split else cell_masks_20
+        fov_whole_cell = fov_mask[fov_index, :, :, 0]
+        image_utils.save_image(os.path.join(tmp_path, 'fov%d_whole_cell.tiff' % fov),
+                               fov_whole_cell)
+
+    # create a sample cell consensus file based on SOM cluster assignments
+    consensus_data_som = pd.DataFrame()
+
+    # create a sample cell consensus file based on meta cluster assignments
+    consensus_data_meta = pd.DataFrame()
+
+    # generate sample cell data with SOM and meta cluster assignments for each fov
+    for fov in fovs:
+        som_data_fov = pd.DataFrame(
+            np.random.randint(low=0, high=100, size=(20, 5)), columns=som_cluster_cols
+        )
 
-            meta_data_fov['fov'] = fov
-            meta_data_fov['segmentation_label'] = meta_data_fov.index.values + 1
-            meta_data_fov['cell_som_cluster'] = np.tile(np.arange(1, 6), 4)
-            meta_data_fov['cell_meta_cluster'] = np.tile(np.arange(1, 3), 10)
+        som_data_fov['fov'] = fov
+        som_data_fov['label'] = som_data_fov.index.values + 1
+        som_data_fov['cell_som_cluster'] = np.tile(np.arange(1, 6), 4)
+        som_data_fov['cell_meta_cluster'] = np.tile(np.arange(1, 3), 10)
 
-            consensus_data_meta = pd.concat([consensus_data_meta, meta_data_fov])
+        consensus_data_som = pd.concat([consensus_data_som, som_data_fov])
 
-        # test various batch_sizes, no sub_dir, name_suffix = ''.
-        data_utils.generate_and_save_cell_cluster_masks(
-            fovs=fovs,
-            base_dir=temp_dir,
-            save_dir=os.path.join(temp_dir, 'cell_masks'),
-            seg_dir=temp_dir,
-            cell_data=consensus_data_som,
-            cell_cluster_col='cell_som_cluster',
-            seg_suffix='_whole_cell.tiff',
-            sub_dir=sub_dir,
-            name_suffix=name_suffix
+        meta_data_fov = pd.DataFrame(
+            np.random.randint(low=0, high=100, size=(20, 3)), columns=meta_cluster_cols
         )
 
-        # open each cell mask and make sure the shape and values are valid
-        if sub_dir is None:
-            sub_dir = ''
+        meta_data_fov['fov'] = fov
+        meta_data_fov['label'] = meta_data_fov.index.values + 1
+        meta_data_fov['cell_som_cluster'] = np.tile(np.arange(1, 6), 4)
+        meta_data_fov['cell_meta_cluster'] = np.tile(np.arange(1, 3), 10)
+
+        consensus_data_meta = pd.concat([consensus_data_meta, meta_data_fov])
+
+    # test various batch_sizes, no sub_dir, name_suffix = ''.
+    data_utils.generate_and_save_cell_cluster_masks(
+        fovs=fovs,
+        save_dir=os.path.join(tmp_path, 'cell_masks'),
+        seg_dir=tmp_path,
+        cell_data=consensus_data_som,
+        fov_col=settings.FOV_ID,
+        label_col=settings.CELL_LABEL,
+        cell_cluster_col='cell_som_cluster',
+        seg_suffix='_whole_cell.tiff',
+        sub_dir=sub_dir,
+        name_suffix=name_suffix
+    )
 
-        for i, fov in enumerate(fovs):
-            fov_name = fov + name_suffix + ".tiff"
-            cell_mask = io.imread(os.path.join(temp_dir, 'cell_masks', sub_dir, fov_name))
-            actual_img_dims = (40, 40) if i < fov_size_split else (20, 20)
-            assert cell_mask.shape == actual_img_dims
-            assert np.all(cell_mask <= 5)
+    # open each cell mask and make sure the shape and values are valid
+    if sub_dir is None:
+        sub_dir = ''
+
+    for i, fov in enumerate(fovs):
+        fov_name = fov + name_suffix + ".tiff"
+        cell_mask = io.imread(os.path.join(tmp_path, 'cell_masks', sub_dir, fov_name))
+        actual_img_dims = (40, 40) if i < fov_size_split else (20, 20)
+        assert cell_mask.shape == actual_img_dims
+        assert np.all(cell_mask <= 5)
 
 
 def test_generate_pixel_cluster_mask():
     fov = 'fov0'
     chans = ['chan0', 'chan1', 'chan2', 'chan3']
 
     with tempfile.TemporaryDirectory() as temp_dir:
@@ -456,16 +541,19 @@
                 os.path.join(temp_dir, 'seg_dir', fov + '_whole_cell.tiff'),
                 sample_label_maps.loc[fov, ...].values,
             )
 
         data_utils.generate_and_save_neighborhood_cluster_masks(
             fovs=fovs,
             save_dir=os.path.join(temp_dir, 'neighborhood_masks'),
-            neighborhood_data=sample_neighborhood_data,
             seg_dir=os.path.join(temp_dir, 'seg_dir'),
+            neighborhood_data=sample_neighborhood_data,
+            fov_col=settings.FOV_ID,
+            label_col=settings.CELL_LABEL,
+            cluster_col=settings.KMEANS_CLUSTER,
             sub_dir=sub_dir,
             name_suffix=name_suffix
         )
 
         # set sub_dir to empty string if None
         if sub_dir is None:
             sub_dir = ''
@@ -524,20 +612,43 @@
         sample_chan_1 = io.imread(os.path.join(output_dir, "stack_sample", "chan0.tiff"))
         sample_chan_2 = io.imread(os.path.join(output_dir, "stack_sample", "chan1.tiff"))
 
         assert np.array_equal(sample_chan_1, data_xr[0, :, :, 0].values)
         assert np.array_equal(sample_chan_2, data_xr[0, :, :, 1].values)
 
 
+@pytest.fixture(scope="function", params=["no_prefix", "single_prefix", "multiple_prefixes"])
+def stitching_fovs(request: str) -> Iterator[List[str]]:
+    """
+    A Fixture which yields a list of FOVs.
+
+    Args:
+        request (str): Either `no_prefix` or `run_prefix`. If it is `run_prefix` then the run
+        will be prefixed with a random integer, `"run_i_RnCm"`. If it is `no_prefix`,
+        then the FOV will be of the form `"RnCm"`
+
+    Yields:
+        Iterator[List[str]]: Returns a list of FOVs
+    """
+    param = request.param
+
+    if param == "no_prefix":
+        fovs: List[str] = [f"R{n}C{m}" for n in range(1, 14) for m in range(1, 14)]
+    elif param == "single_prefix":
+        fovs = [f"run_1_R{n}C{m}" for n in range(1, 14) for m in range(1, 14)]
+    else:
+        fovs = [f"run_1_R{n}C{m}" for n in range(1, 14) for m in range(1, 14)]
+        fovs = fovs + [f"run_2_R{n}C{m}" for n in range(1, 14) for m in range(1, 14)]
+    yield fovs
+
+
 @pytest.mark.parametrize('segmentation, clustering, subdir',
                          [(False, False, 'TIFs'), (True, False, ''), (False, 'cell', ''),
                           (False, 'pixel', '')])
-@pytest.mark.parametrize('fovs', [['R1C1', 'R2C2', 'R3C1'],
-                         ['run_1_R1C1', 'run_1_R2C2', 'run_2_R3C1']])
-def test_stitch_images_by_shape(segmentation, clustering, subdir, fovs):
+def test_stitch_images_by_shape(segmentation, clustering, subdir, stitching_fovs):
 
     # validation checks (only once)
     if clustering == 'pixel':
         with tempfile.TemporaryDirectory() as temp_dir:
             data_dir = os.path.join(temp_dir, 'images')
             stitched_dir = os.path.join(temp_dir, 'stitched_images')
             os.makedirs(data_dir)
@@ -554,15 +665,15 @@
                 os.makedirs(os.path.join(data_dir, fov))
 
             # bad fov names should raise error
             with pytest.raises(ValueError, match="Invalid FOVs found in directory"):
                 data_utils.stitch_images_by_shape(data_dir, stitched_dir)
 
             # one valid fov name but not all should raise error
-            os.makedirs(os.path.join(temp_dir, 'R1C1'))
+            os.makedirs(os.path.join(temp_dir, 'R13C1'))
             with pytest.raises(ValueError, match="Invalid FOVs found in directory"):
                 data_utils.stitch_images_by_shape(data_dir, stitched_dir)
 
             # bad clustering arg should raise an error
             with pytest.raises(ValueError, match="If stitching images from the pixie pipeline"):
                 data_utils.stitch_images_by_shape(data_dir, stitched_dir,
                                                   segmentation=segmentation, clustering='not_cell')
@@ -579,45 +690,57 @@
         os.makedirs(data_dir)
 
         if segmentation:
             chans = ['nuclear', 'whole_cell']
         elif clustering:
             chans = [clustering + '_mask']
         else:
-            chans = [f'chan{i}' for i in range(5)]
+            chans = [f"chan{i}" for i in range(5)]
             # check that ignores toffy stitching in fov level dir
-            fovs.append('stitched_images')
+            stitching_fovs.append('stitched_images')
 
         filelocs, data_xr = test_utils.create_paired_xarray_fovs(
-            data_dir, fovs, chans,
+            data_dir, stitching_fovs, chans,
             img_shape=(10, 10), fills=True, sub_dir=subdir, dtype=np.float32,
             single_dir=any([segmentation, clustering])
         )
 
         # bad channel name should raise an error
         with pytest.raises(ValueError, match="Not all values given in list"):
             data_utils.stitch_images_by_shape(data_dir, stitched_dir, channels='bad_channel',
                                               img_sub_folder=subdir, segmentation=segmentation,
                                               clustering=clustering)
 
         # test successful stitching
+        if len(stitching_fovs) == 13*13*2:
+            prefixes = ["run_1", "run_2"]
+        elif stitching_fovs[0] == "R1C1":
+            prefixes = ["unnamed_tile"]
+        else:
+            prefixes = ["run_1"]
+
         data_utils.stitch_images_by_shape(data_dir, stitched_dir, img_sub_folder=subdir,
                                           segmentation=segmentation, clustering=clustering)
-        assert sorted(io_utils.list_files(stitched_dir)) == \
-            [chan + '_stitched.tiff' for chan in chans]
-
-        # stitched image is 3 x 2 fovs with max_img_size = 10
-        stitched_data = load_utils.load_imgs_from_dir(stitched_dir,
-                                                      files=[chans[0] + '_stitched.tiff'])
-        assert stitched_data.shape == (1, 30, 20, 1)
+        for prefix in prefixes:
+            stitched_subdir = os.path.join(stitched_dir, prefix)
+            assert sorted(io_utils.list_files(stitched_subdir)) == \
+                [chan + '_stitched.tiff' for chan in chans]
+
+            # stitched image is 13 x 13 fovs with max_img_size = 10, so the image is 130 x 130
+            stitched_data = load_utils.load_imgs_from_dir(stitched_subdir,
+                                                          files=[chans[0] + '_stitched.tiff'])
+            assert stitched_data.shape == (1, 130, 130, 1)
         shutil.rmtree(stitched_dir)
 
         # test successful stitching for select channels
-        random_channel = chans[randint(0, len(chans)-1)]
+        random_channel = chans[random.randint(0, len(chans) - 1)]
         data_utils.stitch_images_by_shape(data_dir, stitched_dir, img_sub_folder=subdir,
                                           channels=[random_channel], segmentation=segmentation,
                                           clustering=clustering)
-        assert sorted(io_utils.list_files(stitched_dir)) == [random_channel + '_stitched.tiff']
+        for prefix in prefixes:
+            stitched_subdir = os.path.join(stitched_dir, prefix)
+            assert sorted(io_utils.list_files(stitched_subdir)) == \
+                [random_channel + '_stitched.tiff']
 
         # remove stitched_images from fov list
         if not segmentation and not clustering:
-            fovs.pop()
+            stitching_fovs.pop()
```

### Comparing `ark-analysis-0.6.3/tests/utils/deepcell_service_utils_test.py` & `ark-analysis-0.6.4/tests/utils/deepcell_service_utils_test.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,19 +3,19 @@
 import pathlib
 import tempfile
 from zipfile import ZipFile
 
 import numpy as np
 import pytest
 import tifffile
-from pytest_mock import MockerFixture
 from alpineer import image_utils, test_utils
-from ark.utils import deepcell_service_utils
+from pytest_mock import MockerFixture
 from skimage import io
 
+from ark.utils import deepcell_service_utils
 from ark.utils.deepcell_service_utils import (_convert_deepcell_seg_masks,
                                               create_deepcell_output)
 
 
 def mocked_run_deepcell(in_zip_path, output_dir, host, job_type, scale, timeout):
     fov_data = np.ones(shape=(10, 10), dtype="float32")
     fov_seg_pairs = list(itertools.product(range(1, 4), ['feature_0', 'feature_1']))
@@ -73,14 +73,19 @@
 
             # DeepCell output .zip file should be extracted
             assert os.path.exists(os.path.join(output_dir, 'fov1_whole_cell.tiff'))
             assert os.path.exists(os.path.join(output_dir, 'fov1_nuclear.tiff'))
             assert os.path.exists(os.path.join(output_dir, 'fov2_whole_cell.tiff'))
             assert os.path.exists(os.path.join(output_dir, 'fov2_nuclear.tiff'))
 
+            # test for 2d shape
+            whole_cell_arr = io.imread(os.path.join(output_dir, 'fov1_whole_cell.tiff'))
+            nuclear_arr = io.imread(os.path.join(output_dir, 'fov1_nuclear.tiff'))
+            assert len(whole_cell_arr.shape) == len(nuclear_arr.shape) == 2
+
         with tempfile.TemporaryDirectory() as output_dir:
 
             # test parallel
             create_deepcell_output(deepcell_input_dir=input_dir, deepcell_output_dir=output_dir,
                                    fovs=['fov1', 'fov2'], zip_size=1, parallel=True)
 
             # make sure DeepCell (.zip's) output exists
```

### Comparing `ark-analysis-0.6.3/tests/utils/example_dataset_test.py` & `ark-analysis-0.6.4/tests/utils/example_dataset_test.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
-import os
 import pathlib
-from typing import Callable, Dict, Generator, Iterator, List
+import shutil
+from typing import Callable, Generator, Iterator, List
 
 import pytest
 from alpineer import test_utils
 
 from ark.settings import EXAMPLE_DATASET_REVISION
 from ark.utils.example_dataset import ExampleDataset, get_example_dataset
 
@@ -15,15 +15,15 @@
                                          "post_clustering",
                                          "fiber_segmentation",
                                          "LDA_preprocessing",
                                          "LDA_training_inference",
                                          "neighborhood_analysis",
                                          "pairwise_spatial_enrichment",
                                          "ome_tiff"])
-def dataset_download(request) -> Iterator[ExampleDataset]:
+def dataset_download(request, dataset_cache_dir) -> Iterator[ExampleDataset]:
     """
     A Fixture which instantiates and downloads the dataset with respect to each
     notebook.
 
     Args:
         request (pytest.FixtureRequest): The parameter, in this case it is the notebook to
             download the dataset for.
@@ -31,22 +31,29 @@
     Yields:
         Iterator[ExampleDataset]: The iterable Example Dataset.
     """
 
     # Set up ExampleDataset class
     example_dataset: ExampleDataset = ExampleDataset(
         dataset=request.param,
-        cache_dir=None,  # Use the default cache
+        cache_dir=dataset_cache_dir,
         revision=EXAMPLE_DATASET_REVISION
     )
     # Download example data for a particular notebook
     example_dataset.download_example_dataset()
     yield example_dataset
 
 
+@pytest.fixture(scope="function")
+def cleanable_tmp_path(tmp_path_factory: pytest.TempPathFactory) -> Iterator[pathlib.Path]:
+    data_path = tmp_path_factory.mktemp("data")
+    yield data_path
+    shutil.rmtree(data_path)
+
+
 class TestExampleDataset:
     @pytest.fixture(autouse=True)
     def _setup(self):
         """
         Sets up necessary information needed for assert statements.
         Sets up dictionary to call the functions which check each dataset that is downloaded.
         """
@@ -134,44 +141,51 @@
 
         for ds_n in dataset_names:
             dataset_cache_path = pathlib.Path(
                 dataset_download.dataset_paths[dataset_download.dataset][ds_n][0])
             self.dataset_test_fns[ds_n](dir_p=dataset_cache_path / ds_n)
 
     @pytest.mark.parametrize("_overwrite_existing", [True, False])
-    def test_move_example_dataset(self, tmp_path_factory, dataset_download: ExampleDataset,
+    def test_move_example_dataset(self, cleanable_tmp_path, dataset_download: ExampleDataset,
                                   _overwrite_existing: bool):
         """
         Tests to make sure the proper files are moved to the correct directories.
 
         Args:
-            tmp_path_factory (pytest.TempPathFactory): Factory for temporary directories under the
-                common base temp directory.
+            cleanable_tmp_path (pytest.TempPathFactory): Factory for temporary directories under
+                the common base temp directory.
             dataset_download (ExampleDataset): Fixture for the dataset, respective to each
                 partition (`segment_image_data`, `cluster_pixels`, `cluster_cells`,
                 `post_clustering`).
             _overwrite_existing (bool): If `True` the dataset will be overwritten. If `False` it
                 will not be.
         """
         dataset_download.overwrite_existing = _overwrite_existing
 
         # Move data if _overwrite_existing is `True`
         if _overwrite_existing:
 
             # Case 1: Move Path is empty
-            tmp_dir_c1 = tmp_path_factory.mktemp("move_example_data_c1")
-            move_dir_c1 = tmp_dir_c1 / "example_dataset"
+            tmp_dir_c1: pathlib.Path = cleanable_tmp_path / "move_example_data_c1"
+            tmp_dir_c1.mkdir(parents=True, exist_ok=False)
+
+            move_dir_c1: pathlib.Path = tmp_dir_c1 / "example_dataset"
+            move_dir_c1.mkdir(parents=True, exist_ok=False)
+
             dataset_download.move_example_dataset(move_dir=move_dir_c1)
 
             for dir_p, ds_n in self._suffix_paths(dataset_download, parent_dir=move_dir_c1):
                 self.dataset_test_fns[ds_n](dir_p)
 
             # Case 2: Move Path contains files
-            tmp_dir_c2 = tmp_path_factory.mktemp("move_example_data_c2")
-            move_dir_c2 = tmp_dir_c2 / "example_dataset"
+            tmp_dir_c2: pathlib.Path = cleanable_tmp_path / "move_example_data_c2"
+            tmp_dir_c2.mkdir(parents=True, exist_ok=False)
+
+            move_dir_c2: pathlib.Path = tmp_dir_c2 / "example_dataset"
+            move_dir_c2.mkdir(parents=True, exist_ok=False)
 
             # Add files for each config to test moving with files
             for dir_p, ds_n in self._suffix_paths(dataset_download, parent_dir=move_dir_c2):
                 # make directory
                 dir_p.mkdir(parents=True, exist_ok=False)
                 # make blank file
                 test_utils._make_blank_file(dir_p, "data_test.txt")
@@ -182,28 +196,32 @@
                 dataset_download.move_example_dataset(move_dir=move_dir_c2)
                 for dir_p, ds_n in self._suffix_paths(dataset_download, parent_dir=move_dir_c2):
                     self.dataset_test_fns[ds_n](dir_p)
 
         # Move data if _overwrite_existing is `False`
         else:
             # Case 1: Move Path is empty
-            tmp_dir_c1 = tmp_path_factory.mktemp("move_example_data_c1")
+            tmp_dir_c1: pathlib.Path = cleanable_tmp_path / "move_example_data_c1"
+            tmp_dir_c1.mkdir(parents=True, exist_ok=False)
             move_dir_c1 = tmp_dir_c1 / "example_dataset"
+            move_dir_c1.mkdir(parents=True, exist_ok=False)
 
             # Check that the files were moved to the empty directory
             # Make sure warning is raised
             with pytest.warns(UserWarning):
                 dataset_download.move_example_dataset(move_dir=move_dir_c1)
 
                 for dir_p, ds_n in self._suffix_paths(dataset_download, parent_dir=move_dir_c1):
                     self.dataset_test_fns[ds_n](dir_p)
 
             # Case 2: Move Path contains files
-            tmp_dir_c2 = tmp_path_factory.mktemp("move_example_data_c2")
+            tmp_dir_c2 = cleanable_tmp_path / "move_example_data_c2"
+            tmp_dir_c2.mkdir(parents=True, exist_ok=False)
             move_dir_c2 = tmp_dir_c2 / "example_dataset"
+            move_dir_c2.mkdir(parents=True, exist_ok=False)
 
             # Add files for each config to test moving with files
             for dir_p, ds_n in self._suffix_paths(dataset_download, parent_dir=move_dir_c2):
                 # make directory
                 dir_p.mkdir(parents=True, exist_ok=False)
                 # make blank file
                 test_utils._make_blank_file(dir_p, "data_test.txt")
@@ -212,22 +230,22 @@
             # Make sure warning is raised.
             with pytest.warns(UserWarning):
                 dataset_download.move_example_dataset(move_dir=move_dir_c2)
                 for dir_p, ds_n in self._suffix_paths(dataset_download, parent_dir=move_dir_c2):
                     assert len(list(dir_p.rglob("*"))) == 1
 
     # Will cause duplicate downloads
-    def test_get_example_dataset(self, tmp_path_factory):
+    def test_get_example_dataset(self, cleanable_tmp_path):
         """
         Tests to make sure that if an incorrect `dataset` is provided, the function
         errors out with an appropriate error message for the user.
         """
 
         with pytest.raises(ValueError):
-            get_example_dataset("incorrect_dataset", save_dir=tmp_path_factory)
+            get_example_dataset("incorrect_dataset", save_dir=cleanable_tmp_path)
 
     def test_check_empty_dst(self, tmp_path):
         """
         Tests to make sure that `ExampleDataset.check_empty_dst()` accurately
         reports if a directory contains files or not.
         """
```

### Comparing `ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/colormap_helper_test.py` & `ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/colormap_helper_test.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 import os
 import tempfile
 
 import numpy as np
 import pandas as pd
 import pytest
-from matplotlib.colors import ListedColormap
 from alpineer import misc_utils
+from matplotlib.colors import ListedColormap
 
-from ark.utils.metacluster_remap_gui.colormap_helper import (distinct_cmap, distinct_rgbs,
-                                                             generate_meta_cluster_colormap_dict)
+from ark.utils.metacluster_remap_gui.colormap_helper import (
+    distinct_cmap, distinct_rgbs, generate_meta_cluster_colormap_dict)
 
 
 def test_colormap_is_distinct():
     assert len(set(distinct_rgbs(200))) == 200
 
 
 def test_colormap_runs():
```

### Comparing `ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/conftest.py` & `ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/conftest.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/file_reader_test.py` & `ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/file_reader_test.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/metaclusterdata_test.py` & `ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/metaclusterdata_test.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/metaclustergui_test.py` & `ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/metaclustergui_test.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,17 +7,17 @@
 from ark.utils.metacluster_remap_gui.metaclustergui import MetaClusterGui
 
 THIS_DIR = Path(__file__).parent
 
 pytestmark = pytest.mark.filterwarnings("ignore:coroutine*:RuntimeWarning")
 
 
-@pytest.fixture
+@pytest.fixture(scope="function")
 def mcg(simple_metaclusterdata: MetaClusterData):
-    return MetaClusterGui(simple_metaclusterdata, enable_throttle=False)
+    yield MetaClusterGui(simple_metaclusterdata, enable_throttle=False)
 
 
 @pytest.fixture(autouse=True, scope='session')
 def use_pseudo_inverse():
     import matplotlib.transforms as f
     from numpy.linalg import inv, pinv
     f.inv = pinv
```

### Comparing `ark-analysis-0.6.3/tests/utils/metacluster_remap_gui/throttle_test.py` & `ark-analysis-0.6.4/tests/utils/metacluster_remap_gui/throttle_test.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/tests/utils/notebook_update_test.py` & `ark-analysis-0.6.4/tests/utils/notebook_update_test.py`

 * *Files identical despite different names*

### Comparing `ark-analysis-0.6.3/tests/utils/spatial_lda_utils_test.py` & `ark-analysis-0.6.4/tests/utils/spatial_lda_utils_test.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,19 +3,19 @@
 import tempfile
 
 import matplotlib.pyplot as plt
 import numpy as np
 import pandas as pd
 import pytest
 from sklearn.cluster import KMeans
+from test_utils import make_cell_table
 
 import ark.settings as settings
 import ark.spLDA.processing as pros
 import ark.utils.spatial_lda_utils as spu
-from test_utils import make_cell_table
 
 
 def test_check_format_cell_table_args():
     # Testing variables
     cols = copy.deepcopy(settings.BASE_COLS)
     for i in ["Au", "CD4", "CD8"]:
         cols.append(i)
@@ -47,19 +47,19 @@
     # Markers/Clusters Checks
     with pytest.raises(ValueError, match=r"cannot both be None"):
         spu.check_format_cell_table_args(valid_df, None, None)
     with pytest.raises(ValueError):
         spu.check_format_cell_table_args(valid_df, invalid_markers1, None)
     with pytest.raises(ValueError):
         spu.check_format_cell_table_args(valid_df, invalid_markers2, None)
-    with pytest.raises(ValueError, match=r"List arguments cannot be empty"):
+    with pytest.raises(ValueError, match=r"The markers list is empty."):
         spu.check_format_cell_table_args(valid_df, invalid_markers3, None)
     with pytest.raises(ValueError):
         spu.check_format_cell_table_args(valid_df, valid_markers, invalid_clusters1)
-    with pytest.raises(ValueError, match=r"List arguments cannot be empty"):
+    with pytest.raises(ValueError, match=r"The clusters list is empty."):
         spu.check_format_cell_table_args(valid_df, valid_markers, invalid_clusters2)
 
 
 def test_check_featurize_cell_table_args():
     # Testing variables
     valid_cell_table = {1: pd.DataFrame(columns=["CD4", "CD8", "is_index"])}
```

### Comparing `ark-analysis-0.6.3/tests/utils/synthetic_spatial_datagen_test.py` & `ark-analysis-0.6.4/tests/utils/synthetic_spatial_datagen_test.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import numpy as np
-
 import synthetic_spatial_datagen
 
 
 def test_generate_test_dist_matrix():
     # use default parameters
     sample_dist_mat = synthetic_spatial_datagen.generate_test_dist_matrix()
```

### Comparing `ark-analysis-0.6.3/update_notebooks.sh` & `ark-analysis-0.6.4/update_notebooks.sh`

 * *Files identical despite different names*

