# Comparing `tmp/azure-mgmt-storagemover-1.0.0b1.zip` & `tmp/azure-mgmt-storagemover-2.0.0b1.zip`

## zipinfo {}

```diff
@@ -1,61 +1,61 @@
-Zip file size: 106330 bytes, number of entries: 59
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/
--rw-rw-r--  2.0 unx     1074 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/LICENSE
--rw-rw-r--  2.0 unx     3055 b- defN 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/PKG-INFO
--rw-rw-r--  2.0 unx     2830 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/setup.py
--rw-rw-r--  2.0 unx      218 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/MANIFEST.in
--rw-rw-r--  2.0 unx       62 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/CHANGELOG.md
--rw-rw-r--  2.0 unx      665 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/_meta.json
--rw-rw-r--  2.0 unx     2094 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/README.md
--rw-rw-r--  2.0 unx       38 b- defN 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/setup.cfg
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/
--rw-rw-r--  2.0 unx       65 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_patch.py
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_vendor.py
--rw-rw-r--  2.0 unx    78824 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_serialization.py
--rw-rw-r--  2.0 unx     5673 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_storage_mover_mgmt_client.py
--rw-rw-r--  2.0 unx     3764 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_configuration.py
--rw-rw-r--  2.0 unx       26 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/py.typed
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_version.py
--rw-rw-r--  2.0 unx      907 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/_patch.py
--rw-rw-r--  2.0 unx     2784 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/_storage_mover_mgmt_client_enums.py
--rw-rw-r--  2.0 unx    65564 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/_models_py3.py
--rw-rw-r--  2.0 unx     3995 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_patch.py
--rw-rw-r--  2.0 unx    37074 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_endpoints_operations.py
--rw-rw-r--  2.0 unx     6885 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_operations.py
--rw-rw-r--  2.0 unx    36349 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_agents_operations.py
--rw-rw-r--  2.0 unx    14139 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_job_runs_operations.py
--rw-rw-r--  2.0 unx    36827 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_projects_operations.py
--rw-rw-r--  2.0 unx    39759 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_storage_movers_operations.py
--rw-rw-r--  2.0 unx    50558 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_job_definitions_operations.py
--rw-rw-r--  2.0 unx     1265 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/_patch.py
--rw-rw-r--  2.0 unx     5828 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/_storage_mover_mgmt_client.py
--rw-rw-r--  2.0 unx     3812 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/_configuration.py
--rw-rw-r--  2.0 unx      854 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    29146 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_endpoints_operations.py
--rw-rw-r--  2.0 unx     6133 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_operations.py
--rw-rw-r--  2.0 unx    28493 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_agents_operations.py
--rw-rw-r--  2.0 unx    10599 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_job_runs_operations.py
--rw-rw-r--  2.0 unx    28923 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_projects_operations.py
--rw-rw-r--  2.0 unx    31489 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_storage_movers_operations.py
--rw-rw-r--  2.0 unx    38325 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_job_definitions_operations.py
--rw-rw-r--  2.0 unx     1265 b- defN 23-Feb-20 07:59 azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/__init__.py
--rw-rw-r--  2.0 unx        1 b- defN 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx     3055 b- defN 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx        6 b- defN 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/top_level.txt
--rw-rw-r--  2.0 unx     2126 b- defN 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/not-zip-safe
--rw-rw-r--  2.0 unx      116 b- defN 23-Feb-20 08:00 azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/requires.txt
-59 files, 589891 bytes uncompressed, 93442 bytes compressed:  84.2%
+Zip file size: 106599 bytes, number of entries: 59
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure/
+-rw-rw-r--  2.0 unx      631 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/CHANGELOG.md
+-rw-rw-r--  2.0 unx     2850 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/setup.py
+-rw-rw-r--  2.0 unx       38 b- defN 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/setup.cfg
+-rw-rw-r--  2.0 unx      632 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/_meta.json
+-rw-rw-r--  2.0 unx      218 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/MANIFEST.in
+-rw-rw-r--  2.0 unx     3697 b- defN 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/PKG-INFO
+-rw-rw-r--  2.0 unx     2167 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/README.md
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/LICENSE
+-rw-rw-r--  2.0 unx     2126 b- defN 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx      124 b- defN 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/requires.txt
+-rw-rw-r--  2.0 unx        6 b- defN 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/top_level.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx     3697 b- defN 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/PKG-INFO
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/
+-rw-rw-r--  2.0 unx       26 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/py.typed
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_vendor.py
+-rw-rw-r--  2.0 unx     3507 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_configuration.py
+-rw-rw-r--  2.0 unx      488 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_version.py
+-rw-rw-r--  2.0 unx      907 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/__init__.py
+-rw-rw-r--  2.0 unx     5692 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_storage_mover_mgmt_client.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_patch.py
+-rw-rw-r--  2.0 unx    78836 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_serialization.py
+-rw-rw-r--  2.0 unx    79937 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/_models_py3.py
+-rw-rw-r--  2.0 unx     4654 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/__init__.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/_patch.py
+-rw-rw-r--  2.0 unx     3021 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/_storage_mover_mgmt_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 02:31 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/
+-rw-rw-r--  2.0 unx     3555 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/_configuration.py
+-rw-rw-r--  2.0 unx      854 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/__init__.py
+-rw-rw-r--  2.0 unx     5852 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/_storage_mover_mgmt_client.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/_patch.py
+-rw-rw-r--  2.0 unx    31117 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_storage_movers_operations.py
+-rw-rw-r--  2.0 unx    28792 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_endpoints_operations.py
+-rw-rw-r--  2.0 unx     5885 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx    10329 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_job_runs_operations.py
+-rw-rw-r--  2.0 unx    28569 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_projects_operations.py
+-rw-rw-r--  2.0 unx    28139 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_agents_operations.py
+-rw-rw-r--  2.0 unx     1265 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    37927 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_job_definitions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    39147 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_storage_movers_operations.py
+-rw-rw-r--  2.0 unx    36520 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_endpoints_operations.py
+-rw-rw-r--  2.0 unx     6597 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_operations.py
+-rw-rw-r--  2.0 unx    13789 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_job_runs_operations.py
+-rw-rw-r--  2.0 unx    36273 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_projects_operations.py
+-rw-rw-r--  2.0 unx    35795 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_agents_operations.py
+-rw-rw-r--  2.0 unx     1265 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/__init__.py
+-rw-rw-r--  2.0 unx    49880 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_job_definitions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 02:30 azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_patch.py
+59 files, 600682 bytes uncompressed, 93711 bytes compressed:  84.4%
```

## zipnote {}

```diff
@@ -1,178 +1,178 @@
-Filename: azure-mgmt-storagemover-1.0.0b1/
+Filename: azure-mgmt-storagemover-2.0.0b1/
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/
+Filename: azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/LICENSE
+Filename: azure-mgmt-storagemover-2.0.0b1/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/PKG-INFO
+Filename: azure-mgmt-storagemover-2.0.0b1/setup.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/setup.py
+Filename: azure-mgmt-storagemover-2.0.0b1/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/MANIFEST.in
+Filename: azure-mgmt-storagemover-2.0.0b1/_meta.json
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/CHANGELOG.md
+Filename: azure-mgmt-storagemover-2.0.0b1/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/_meta.json
+Filename: azure-mgmt-storagemover-2.0.0b1/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/README.md
+Filename: azure-mgmt-storagemover-2.0.0b1/README.md
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/setup.cfg
+Filename: azure-mgmt-storagemover-2.0.0b1/LICENSE
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/
+Filename: azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/SOURCES.txt
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/__init__.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/dependency_links.txt
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/
+Filename: azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/requires.txt
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/__init__.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/top_level.txt
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/
+Filename: azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/not-zip-safe
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/
+Filename: azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_patch.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_vendor.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_serialization.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_storage_mover_mgmt_client.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_configuration.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/py.typed
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_version.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/py.typed
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/__init__.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/_patch.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/_storage_mover_mgmt_client_enums.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_version.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/_models_py3.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/__init__.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/__init__.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_storage_mover_mgmt_client.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_patch.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_patch.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_endpoints_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_agents_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_job_runs_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_projects_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/_storage_mover_mgmt_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_storage_movers_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_job_definitions_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/__init__.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/_storage_mover_mgmt_client.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/_patch.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/_storage_mover_mgmt_client.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_storage_movers_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/_configuration.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/__init__.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_patch.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_job_runs_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_endpoints_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_projects_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_agents_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_agents_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_job_runs_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_job_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_projects_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_storage_movers_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_storage_movers_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_job_definitions_operations.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_endpoints_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/__init__.py
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/dependency_links.txt
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_job_runs_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/PKG-INFO
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_projects_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/top_level.txt
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_agents_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/SOURCES.txt
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/not-zip-safe
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_job_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/requires.txt
+Filename: azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_patch.py
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/LICENSE` & `azure-mgmt-storagemover-2.0.0b1/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/PKG-INFO` & `azure-mgmt-storagemover-2.0.0b1/README.md`

 * *Files 14% similar despite different names*

```diff
@@ -1,30 +1,7 @@
-Metadata-Version: 2.1
-Name: azure-mgmt-storagemover
-Version: 1.0.0b1
-Summary: Microsoft Azure Storagemover Management Client Library for Python
-Home-page: https://github.com/Azure/azure-sdk-for-python
-Author: Microsoft Corporation
-Author-email: azpysdkhelp@microsoft.com
-License: MIT License
-Keywords: azure,azure sdk
-Classifier: Development Status :: 4 - Beta
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3 :: Only
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: License :: OSI Approved :: MIT License
-Requires-Python: >=3.7
-Description-Content-Type: text/markdown
-License-File: LICENSE
-
 # Microsoft Azure SDK for Python
 
 This is the Microsoft Azure Storagemover Management Client Library.
 This package has been tested with Python 3.7+.
 For a more complete view of Azure libraries, see the [azure sdk python release](https://aka.ms/azsdk/python/all).
 
 ## _Disclaimer_
@@ -55,39 +32,33 @@
 
 In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
 
 With above configuration, client can be authenticated by following code:
 
 ```python
 from azure.identity import DefaultAzureCredential
-from azure.mgmt.storagemover import 
+from azure.mgmt.storagemover import StorageMoverMgmtClient
 import os
 
 sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
-client = (credential=DefaultAzureCredential(), subscription_id=sub_id)
+client = StorageMoverMgmtClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
 ```
 
 ## Examples
 
-
-Code samples for this package can be found at [Storagemover Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com and [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+Code samples for this package can be found at:
+- [Search Storagemover Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
 
 ## Troubleshooting
 
 ## Next steps
 
 ## Provide Feedback
 
 If you encounter any bugs or have suggestions, please file an issue in the
 [Issues](https://github.com/Azure/azure-sdk-for-python/issues)
 section of the project. 
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-storagemover%2FREADME.png)
-
-
-# Release History
-
-## 1.0.0b1 (2023-02-20)
-
-* Initial Release
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/setup.py` & `azure-mgmt-storagemover-2.0.0b1/setup.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,79 +1,83 @@
 #!/usr/bin/env python
 
-#-------------------------------------------------------------------------
+# -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
-#--------------------------------------------------------------------------
+# --------------------------------------------------------------------------
 
 import re
 import os.path
 from io import open
 from setuptools import find_packages, setup
 
 # Change the PACKAGE_NAME only to change folder and different name
 PACKAGE_NAME = "azure-mgmt-storagemover"
 PACKAGE_PPRINT_NAME = "Storagemover Management"
 
 # a-b-c => a/b/c
-package_folder_path = PACKAGE_NAME.replace('-', '/')
+package_folder_path = PACKAGE_NAME.replace("-", "/")
 # a-b-c => a.b.c
-namespace_name = PACKAGE_NAME.replace('-', '.')
+namespace_name = PACKAGE_NAME.replace("-", ".")
 
 # Version extraction inspired from 'requests'
-with open(os.path.join(package_folder_path, 'version.py')
-          if os.path.exists(os.path.join(package_folder_path, 'version.py'))
-          else os.path.join(package_folder_path, '_version.py'), 'r') as fd:
-    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]',
-                        fd.read(), re.MULTILINE).group(1)
+with open(
+    os.path.join(package_folder_path, "version.py")
+    if os.path.exists(os.path.join(package_folder_path, "version.py"))
+    else os.path.join(package_folder_path, "_version.py"),
+    "r",
+) as fd:
+    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]', fd.read(), re.MULTILINE).group(1)
 
 if not version:
-    raise RuntimeError('Cannot find version information')
+    raise RuntimeError("Cannot find version information")
 
-with open('README.md', encoding='utf-8') as f:
+with open("README.md", encoding="utf-8") as f:
     readme = f.read()
-with open('CHANGELOG.md', encoding='utf-8') as f:
+with open("CHANGELOG.md", encoding="utf-8") as f:
     changelog = f.read()
 
 setup(
     name=PACKAGE_NAME,
     version=version,
-    description='Microsoft Azure {} Client Library for Python'.format(PACKAGE_PPRINT_NAME),
-    long_description=readme + '\n\n' + changelog,
-    long_description_content_type='text/markdown',
-    license='MIT License',
-    author='Microsoft Corporation',
-    author_email='azpysdkhelp@microsoft.com',
-    url='https://github.com/Azure/azure-sdk-for-python',
+    description="Microsoft Azure {} Client Library for Python".format(PACKAGE_PPRINT_NAME),
+    long_description=readme + "\n\n" + changelog,
+    long_description_content_type="text/markdown",
+    license="MIT License",
+    author="Microsoft Corporation",
+    author_email="azpysdkhelp@microsoft.com",
+    url="https://github.com/Azure/azure-sdk-for-python",
     keywords="azure, azure sdk",  # update with search keywords relevant to the azure service / product
     classifiers=[
-        'Development Status :: 4 - Beta',
-        'Programming Language :: Python',
-        'Programming Language :: Python :: 3 :: Only',
-        'Programming Language :: Python :: 3',
-        'Programming Language :: Python :: 3.7',
-        'Programming Language :: Python :: 3.8',
-        'Programming Language :: Python :: 3.9',
-        'Programming Language :: Python :: 3.10',
-        'Programming Language :: Python :: 3.11',
-        'License :: OSI Approved :: MIT License',
+        "Development Status :: 4 - Beta",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 3 :: Only",
+        "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+        "License :: OSI Approved :: MIT License",
     ],
     zip_safe=False,
-    packages=find_packages(exclude=[
-        'tests',
-        # Exclude packages that will be covered by PEP420 or nspkg
-        'azure',
-        'azure.mgmt',
-    ]),
+    packages=find_packages(
+        exclude=[
+            "tests",
+            # Exclude packages that will be covered by PEP420 or nspkg
+            "azure",
+            "azure.mgmt",
+        ]
+    ),
     include_package_data=True,
     package_data={
-        'pytyped': ['py.typed'],
+        "pytyped": ["py.typed"],
     },
     install_requires=[
-        "msrest>=0.7.1",
+        "isodate<1.0.0,>=0.6.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
-    python_requires=">=3.7"
+    python_requires=">=3.7",
 )
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/_meta.json` & `azure-mgmt-storagemover-2.0.0b1/_meta.json`

 * *Files 17% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/storagemover/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 '*

 * *                       "--version=3.9.2 --version-tolerant=False'",*

 * * "'commit'": "'b5cc3096fff46e18cffd9b506823b30a21114b71'",*

 * * "'use'": "{in [â€¦]*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/storagemover/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --tag=package-2022-07-01-preview --use=@autorest/python@6.4.0 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "2f545bf51d046c377a7957a7c53e1d260c9d7343",
+    "autorest_command": "autorest specification/storagemover/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "b5cc3096fff46e18cffd9b506823b30a21114b71",
     "readme": "specification/storagemover/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.4.0",
+        "@autorest/python@6.6.0",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_patch.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_vendor.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_serialization.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_serialization.py`

 * *Files 0% similar despite different names*

```diff
@@ -625,15 +625,15 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{}{}".format(xml_ns, xml_name)
+                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
                             serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
                             serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
                             serialized.extend(new_attr)  # type: ignore
@@ -1267,15 +1267,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1291,15 +1291,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_storage_mover_mgmt_client.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_storage_mover_mgmt_client.py`

 * *Files 0% similar despite different names*

```diff
@@ -49,15 +49,15 @@
     :vartype job_runs: azure.mgmt.storagemover.operations.JobRunsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-07-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2023-07-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -66,15 +66,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = StorageMoverMgmtClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.storage_movers = StorageMoversOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/_configuration.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/_configuration.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class StorageMoverMgmtClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for StorageMoverMgmtClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-07-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2023-07-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(StorageMoverMgmtClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop("api_version", "2022-07-01-preview")
+        api_version: str = kwargs.pop("api_version", "2023-07-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/__init__.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/_patch.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/_storage_mover_mgmt_client_enums.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/_storage_mover_mgmt_client_enums.py`

 * *Files 10% similar despite different names*

```diff
@@ -39,19 +39,27 @@
 
     USER = "User"
     APPLICATION = "Application"
     MANAGED_IDENTITY = "ManagedIdentity"
     KEY = "Key"
 
 
+class CredentialType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
+    """The Credentials type."""
+
+    AZURE_KEY_VAULT_SMB = "AzureKeyVaultSmb"
+
+
 class EndpointType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The Endpoint resource type."""
 
     AZURE_STORAGE_BLOB_CONTAINER = "AzureStorageBlobContainer"
     NFS_MOUNT = "NfsMount"
+    AZURE_STORAGE_SMB_FILE_SHARE = "AzureStorageSmbFileShare"
+    SMB_MOUNT = "SmbMount"
 
 
 class JobRunScanStatus(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The status of Agent's scanning of source."""
 
     NOT_STARTED = "NotStarted"
     SCANNING = "Scanning"
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/_models_py3.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/_models_py3.py`

 * *Files 11% similar despite different names*

```diff
@@ -26,34 +26,40 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
+        "system_data": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
     }
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.id = None
         self.name = None
         self.type = None
+        self.system_data = None
 
 
 class ProxyResource(Resource):
     """The resource model definition for a Azure Resource Manager proxy resource. It will not have
     tags and a location.
 
     Variables are only populated by the server, and will be ignored when sending a request.
@@ -62,26 +68,31 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
+        "system_data": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
     }
 
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
 
 
@@ -96,15 +107,16 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
-    :ivar system_data: Resource system metadata.
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
     :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     :ivar description: A description for the Agent.
     :vartype description: str
     :ivar agent_version: The Agent version.
     :vartype agent_version: str
     :ivar arc_resource_id: The fully qualified resource ID of the Hybrid Compute resource for the
      Agent. Required.
@@ -176,15 +188,14 @@
         :keyword arc_resource_id: The fully qualified resource ID of the Hybrid Compute resource for
          the Agent. Required.
         :paramtype arc_resource_id: str
         :keyword arc_vm_uuid: The VM UUID of the Hybrid Compute resource for the Agent. Required.
         :paramtype arc_vm_uuid: str
         """
         super().__init__(**kwargs)
-        self.system_data = None
         self.description = description
         self.agent_version = None
         self.arc_resource_id = arc_resource_id
         self.arc_vm_uuid = arc_vm_uuid
         self.agent_status = None
         self.last_status_update = None
         self.local_ip_address = None
@@ -266,26 +277,97 @@
         :keyword description: A description for the Agent.
         :paramtype description: str
         """
         super().__init__(**kwargs)
         self.description = description
 
 
+class Credentials(_serialization.Model):
+    """The Credentials.
+
+    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
+    AzureKeyVaultSmbCredentials
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar type: The Credentials type. Required. "AzureKeyVaultSmb"
+    :vartype type: str or ~azure.mgmt.storagemover.models.CredentialType
+    """
+
+    _validation = {
+        "type": {"required": True},
+    }
+
+    _attribute_map = {
+        "type": {"key": "type", "type": "str"},
+    }
+
+    _subtype_map = {"type": {"AzureKeyVaultSmb": "AzureKeyVaultSmbCredentials"}}
+
+    def __init__(self, **kwargs: Any) -> None:
+        """ """
+        super().__init__(**kwargs)
+        self.type: Optional[str] = None
+
+
+class AzureKeyVaultSmbCredentials(Credentials):
+    """The Azure Key Vault secret URIs which store the credentials.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar type: The Credentials type. Required. "AzureKeyVaultSmb"
+    :vartype type: str or ~azure.mgmt.storagemover.models.CredentialType
+    :ivar username_uri: The Azure Key Vault secret URI which stores the username. Use empty string
+     to clean-up existing value.
+    :vartype username_uri: str
+    :ivar password_uri: The Azure Key Vault secret URI which stores the password. Use empty string
+     to clean-up existing value.
+    :vartype password_uri: str
+    """
+
+    _validation = {
+        "type": {"required": True},
+    }
+
+    _attribute_map = {
+        "type": {"key": "type", "type": "str"},
+        "username_uri": {"key": "usernameUri", "type": "str"},
+        "password_uri": {"key": "passwordUri", "type": "str"},
+    }
+
+    def __init__(
+        self, *, username_uri: Optional[str] = None, password_uri: Optional[str] = None, **kwargs: Any
+    ) -> None:
+        """
+        :keyword username_uri: The Azure Key Vault secret URI which stores the username. Use empty
+         string to clean-up existing value.
+        :paramtype username_uri: str
+        :keyword password_uri: The Azure Key Vault secret URI which stores the password. Use empty
+         string to clean-up existing value.
+        :paramtype password_uri: str
+        """
+        super().__init__(**kwargs)
+        self.type: str = "AzureKeyVaultSmb"
+        self.username_uri = username_uri
+        self.password_uri = password_uri
+
+
 class EndpointBaseProperties(_serialization.Model):
     """The resource specific properties for the Storage Mover resource.
 
     You probably want to use the sub-classes and not this class directly. Known sub-classes are:
-    AzureStorageBlobContainerEndpointProperties, NfsMountEndpointProperties
+    AzureStorageBlobContainerEndpointProperties, AzureStorageSmbFileShareEndpointProperties,
+    NfsMountEndpointProperties, SmbMountEndpointProperties
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar endpoint_type: The Endpoint resource type. Required. Known values are:
-     "AzureStorageBlobContainer" and "NfsMount".
+     "AzureStorageBlobContainer", "NfsMount", "AzureStorageSmbFileShare", and "SmbMount".
     :vartype endpoint_type: str or ~azure.mgmt.storagemover.models.EndpointType
     :ivar description: A description for the Endpoint.
     :vartype description: str
     :ivar provisioning_state: The provisioning state of this resource. "Succeeded"
     :vartype provisioning_state: str or ~azure.mgmt.storagemover.models.ProvisioningState
     """
 
@@ -299,15 +381,17 @@
         "description": {"key": "description", "type": "str"},
         "provisioning_state": {"key": "provisioningState", "type": "str"},
     }
 
     _subtype_map = {
         "endpoint_type": {
             "AzureStorageBlobContainer": "AzureStorageBlobContainerEndpointProperties",
+            "AzureStorageSmbFileShare": "AzureStorageSmbFileShareEndpointProperties",
             "NfsMount": "NfsMountEndpointProperties",
+            "SmbMount": "SmbMountEndpointProperties",
         }
     }
 
     def __init__(self, *, description: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword description: A description for the Endpoint.
         :paramtype description: str
@@ -315,22 +399,22 @@
         super().__init__(**kwargs)
         self.endpoint_type: Optional[str] = None
         self.description = description
         self.provisioning_state = None
 
 
 class AzureStorageBlobContainerEndpointProperties(EndpointBaseProperties):
-    """AzureStorageBlobContainerEndpointProperties.
+    """The properties of Azure Storage blob container endpoint.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar endpoint_type: The Endpoint resource type. Required. Known values are:
-     "AzureStorageBlobContainer" and "NfsMount".
+     "AzureStorageBlobContainer", "NfsMount", "AzureStorageSmbFileShare", and "SmbMount".
     :vartype endpoint_type: str or ~azure.mgmt.storagemover.models.EndpointType
     :ivar description: A description for the Endpoint.
     :vartype description: str
     :ivar provisioning_state: The provisioning state of this resource. "Succeeded"
     :vartype provisioning_state: str or ~azure.mgmt.storagemover.models.ProvisioningState
     :ivar storage_account_resource_id: The Azure Resource ID of the storage account that is the
      target destination. Required.
@@ -378,48 +462,171 @@
         self.storage_account_resource_id = storage_account_resource_id
         self.blob_container_name = blob_container_name
 
 
 class EndpointBaseUpdateProperties(_serialization.Model):
     """The Endpoint resource, which contains information about file sources and targets.
 
+    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
+    AzureStorageBlobContainerEndpointUpdateProperties,
+    AzureStorageSmbFileShareEndpointUpdateProperties, NfsMountEndpointUpdateProperties,
+    SmbMountEndpointUpdateProperties
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar endpoint_type: The Endpoint resource type. Required. Known values are:
+     "AzureStorageBlobContainer", "NfsMount", "AzureStorageSmbFileShare", and "SmbMount".
+    :vartype endpoint_type: str or ~azure.mgmt.storagemover.models.EndpointType
     :ivar description: A description for the Endpoint.
     :vartype description: str
     """
 
+    _validation = {
+        "endpoint_type": {"required": True},
+    }
+
     _attribute_map = {
+        "endpoint_type": {"key": "endpointType", "type": "str"},
         "description": {"key": "description", "type": "str"},
     }
 
+    _subtype_map = {
+        "endpoint_type": {
+            "AzureStorageBlobContainer": "AzureStorageBlobContainerEndpointUpdateProperties",
+            "AzureStorageSmbFileShare": "AzureStorageSmbFileShareEndpointUpdateProperties",
+            "NfsMount": "NfsMountEndpointUpdateProperties",
+            "SmbMount": "SmbMountEndpointUpdateProperties",
+        }
+    }
+
     def __init__(self, *, description: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword description: A description for the Endpoint.
         :paramtype description: str
         """
         super().__init__(**kwargs)
+        self.endpoint_type: Optional[str] = None
         self.description = description
 
 
 class AzureStorageBlobContainerEndpointUpdateProperties(EndpointBaseUpdateProperties):
     """AzureStorageBlobContainerEndpointUpdateProperties.
 
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar endpoint_type: The Endpoint resource type. Required. Known values are:
+     "AzureStorageBlobContainer", "NfsMount", "AzureStorageSmbFileShare", and "SmbMount".
+    :vartype endpoint_type: str or ~azure.mgmt.storagemover.models.EndpointType
     :ivar description: A description for the Endpoint.
     :vartype description: str
     """
 
+    _validation = {
+        "endpoint_type": {"required": True},
+    }
+
     _attribute_map = {
+        "endpoint_type": {"key": "endpointType", "type": "str"},
         "description": {"key": "description", "type": "str"},
     }
 
     def __init__(self, *, description: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword description: A description for the Endpoint.
         :paramtype description: str
         """
         super().__init__(description=description, **kwargs)
+        self.endpoint_type: str = "AzureStorageBlobContainer"
+
+
+class AzureStorageSmbFileShareEndpointProperties(EndpointBaseProperties):
+    """The properties of Azure Storage SMB file share endpoint.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar endpoint_type: The Endpoint resource type. Required. Known values are:
+     "AzureStorageBlobContainer", "NfsMount", "AzureStorageSmbFileShare", and "SmbMount".
+    :vartype endpoint_type: str or ~azure.mgmt.storagemover.models.EndpointType
+    :ivar description: A description for the Endpoint.
+    :vartype description: str
+    :ivar provisioning_state: The provisioning state of this resource. "Succeeded"
+    :vartype provisioning_state: str or ~azure.mgmt.storagemover.models.ProvisioningState
+    :ivar storage_account_resource_id: The Azure Resource ID of the storage account. Required.
+    :vartype storage_account_resource_id: str
+    :ivar file_share_name: The name of the Azure Storage file share. Required.
+    :vartype file_share_name: str
+    """
+
+    _validation = {
+        "endpoint_type": {"required": True},
+        "provisioning_state": {"readonly": True},
+        "storage_account_resource_id": {"required": True},
+        "file_share_name": {"required": True},
+    }
+
+    _attribute_map = {
+        "endpoint_type": {"key": "endpointType", "type": "str"},
+        "description": {"key": "description", "type": "str"},
+        "provisioning_state": {"key": "provisioningState", "type": "str"},
+        "storage_account_resource_id": {"key": "storageAccountResourceId", "type": "str"},
+        "file_share_name": {"key": "fileShareName", "type": "str"},
+    }
+
+    def __init__(
+        self,
+        *,
+        storage_account_resource_id: str,
+        file_share_name: str,
+        description: Optional[str] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword description: A description for the Endpoint.
+        :paramtype description: str
+        :keyword storage_account_resource_id: The Azure Resource ID of the storage account. Required.
+        :paramtype storage_account_resource_id: str
+        :keyword file_share_name: The name of the Azure Storage file share. Required.
+        :paramtype file_share_name: str
+        """
+        super().__init__(description=description, **kwargs)
+        self.endpoint_type: str = "AzureStorageSmbFileShare"
+        self.storage_account_resource_id = storage_account_resource_id
+        self.file_share_name = file_share_name
+
+
+class AzureStorageSmbFileShareEndpointUpdateProperties(EndpointBaseUpdateProperties):
+    """The properties of Azure Storage SMB file share endpoint to update.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar endpoint_type: The Endpoint resource type. Required. Known values are:
+     "AzureStorageBlobContainer", "NfsMount", "AzureStorageSmbFileShare", and "SmbMount".
+    :vartype endpoint_type: str or ~azure.mgmt.storagemover.models.EndpointType
+    :ivar description: A description for the Endpoint.
+    :vartype description: str
+    """
+
+    _validation = {
+        "endpoint_type": {"required": True},
+    }
+
+    _attribute_map = {
+        "endpoint_type": {"key": "endpointType", "type": "str"},
+        "description": {"key": "description", "type": "str"},
+    }
+
+    def __init__(self, *, description: Optional[str] = None, **kwargs: Any) -> None:
+        """
+        :keyword description: A description for the Endpoint.
+        :paramtype description: str
+        """
+        super().__init__(description=description, **kwargs)
+        self.endpoint_type: str = "AzureStorageSmbFileShare"
 
 
 class Endpoint(ProxyResource):
     """The Endpoint resource, which contains information about file sources and targets.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -429,44 +636,44 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     :ivar properties: The resource specific properties for the Storage Mover resource. Required.
     :vartype properties: ~azure.mgmt.storagemover.models.EndpointBaseProperties
-    :ivar system_data: Resource system metadata.
-    :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
-        "properties": {"required": True},
         "system_data": {"readonly": True},
+        "properties": {"required": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
-        "properties": {"key": "properties", "type": "EndpointBaseProperties"},
         "system_data": {"key": "systemData", "type": "SystemData"},
+        "properties": {"key": "properties", "type": "EndpointBaseProperties"},
     }
 
     def __init__(self, *, properties: "_models.EndpointBaseProperties", **kwargs: Any) -> None:
         """
         :keyword properties: The resource specific properties for the Storage Mover resource. Required.
         :paramtype properties: ~azure.mgmt.storagemover.models.EndpointBaseProperties
         """
         super().__init__(**kwargs)
         self.properties = properties
-        self.system_data = None
 
 
 class EndpointBaseUpdateParameters(_serialization.Model):
     """The Endpoint resource.
 
     :ivar properties: The Endpoint resource, which contains information about file sources and
      targets.
@@ -619,15 +826,16 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
-    :ivar system_data: Resource system metadata.
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
     :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     :ivar description: A description for the Job Definition.
     :vartype description: str
     :ivar copy_mode: Strategy to use for copy. Required. Known values are: "Additive" and "Mirror".
     :vartype copy_mode: str or ~azure.mgmt.storagemover.models.CopyMode
     :ivar source_name: The name of the source Endpoint. Required.
     :vartype source_name: str
@@ -723,15 +931,14 @@
         :paramtype target_name: str
         :keyword target_subpath: The subpath to use when writing to the target Endpoint.
         :paramtype target_subpath: str
         :keyword agent_name: Name of the Agent to assign for new Job Runs of this Job Definition.
         :paramtype agent_name: str
         """
         super().__init__(**kwargs)
-        self.system_data = None
         self.description = description
         self.copy_mode = copy_mode
         self.source_name = source_name
         self.source_resource_id = None
         self.source_subpath = source_subpath
         self.target_name = target_name
         self.target_resource_id = None
@@ -821,15 +1028,16 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
-    :ivar system_data: Resource system metadata.
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
     :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     :ivar status: The state of the job execution. Known values are: "Queued", "Started", "Running",
      "CancelRequested", "Canceling", "Canceled", "Failed", and "Succeeded".
     :vartype status: str or ~azure.mgmt.storagemover.models.JobRunStatus
     :ivar scan_status: The status of Agent's scanning of source. Known values are: "NotStarted",
      "Scanning", and "Completed".
     :vartype scan_status: str or ~azure.mgmt.storagemover.models.JobRunScanStatus
@@ -968,15 +1176,14 @@
         "error": {"key": "properties.error", "type": "JobRunError"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
     def __init__(self, **kwargs: Any) -> None:  # pylint: disable=too-many-locals
         """ """
         super().__init__(**kwargs)
-        self.system_data = None
         self.status = None
         self.scan_status = None
         self.agent_name = None
         self.agent_resource_id = None
         self.execution_start_time = None
         self.execution_end_time = None
         self.last_status_update = None
@@ -1086,22 +1293,22 @@
     def __init__(self, **kwargs: Any) -> None:
         """ """
         super().__init__(**kwargs)
         self.job_run_resource_id = None
 
 
 class NfsMountEndpointProperties(EndpointBaseProperties):
-    """NfsMountEndpointProperties.
+    """The properties of NFS share endpoint.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar endpoint_type: The Endpoint resource type. Required. Known values are:
-     "AzureStorageBlobContainer" and "NfsMount".
+     "AzureStorageBlobContainer", "NfsMount", "AzureStorageSmbFileShare", and "SmbMount".
     :vartype endpoint_type: str or ~azure.mgmt.storagemover.models.EndpointType
     :ivar description: A description for the Endpoint.
     :vartype description: str
     :ivar provisioning_state: The provisioning state of this resource. "Succeeded"
     :vartype provisioning_state: str or ~azure.mgmt.storagemover.models.ProvisioningState
     :ivar host: The host name or IP address of the server exporting the file system. Required.
     :vartype host: str
@@ -1153,28 +1360,39 @@
         self.nfs_version = nfs_version
         self.export = export
 
 
 class NfsMountEndpointUpdateProperties(EndpointBaseUpdateProperties):
     """NfsMountEndpointUpdateProperties.
 
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar endpoint_type: The Endpoint resource type. Required. Known values are:
+     "AzureStorageBlobContainer", "NfsMount", "AzureStorageSmbFileShare", and "SmbMount".
+    :vartype endpoint_type: str or ~azure.mgmt.storagemover.models.EndpointType
     :ivar description: A description for the Endpoint.
     :vartype description: str
     """
 
+    _validation = {
+        "endpoint_type": {"required": True},
+    }
+
     _attribute_map = {
+        "endpoint_type": {"key": "endpointType", "type": "str"},
         "description": {"key": "description", "type": "str"},
     }
 
     def __init__(self, *, description: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword description: A description for the Endpoint.
         :paramtype description: str
         """
         super().__init__(description=description, **kwargs)
+        self.endpoint_type: str = "NfsMount"
 
 
 class Operation(_serialization.Model):
     """Details of a REST API operation, returned from the Resource Provider Operations API.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
@@ -1303,15 +1521,16 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
-    :ivar system_data: Resource system metadata.
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
     :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     :ivar description: A description for the Project.
     :vartype description: str
     :ivar provisioning_state: The provisioning state of this resource. "Succeeded"
     :vartype provisioning_state: str or ~azure.mgmt.storagemover.models.ProvisioningState
     """
 
@@ -1334,15 +1553,14 @@
 
     def __init__(self, *, description: Optional[str] = None, **kwargs: Any) -> None:
         """
         :keyword description: A description for the Project.
         :paramtype description: str
         """
         super().__init__(**kwargs)
-        self.system_data = None
         self.description = description
         self.provisioning_state = None
 
 
 class ProjectList(_serialization.Model):
     """List of Project resources.
 
@@ -1388,14 +1606,124 @@
         :keyword description: A description for the Project.
         :paramtype description: str
         """
         super().__init__(**kwargs)
         self.description = description
 
 
+class SmbMountEndpointProperties(EndpointBaseProperties):
+    """The properties of SMB share endpoint.
+
+    Variables are only populated by the server, and will be ignored when sending a request.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar endpoint_type: The Endpoint resource type. Required. Known values are:
+     "AzureStorageBlobContainer", "NfsMount", "AzureStorageSmbFileShare", and "SmbMount".
+    :vartype endpoint_type: str or ~azure.mgmt.storagemover.models.EndpointType
+    :ivar description: A description for the Endpoint.
+    :vartype description: str
+    :ivar provisioning_state: The provisioning state of this resource. "Succeeded"
+    :vartype provisioning_state: str or ~azure.mgmt.storagemover.models.ProvisioningState
+    :ivar host: The host name or IP address of the server exporting the file system. Required.
+    :vartype host: str
+    :ivar share_name: The name of the SMB share being exported from the server. Required.
+    :vartype share_name: str
+    :ivar credentials: The Azure Key Vault secret URIs which store the required credentials to
+     access the SMB share.
+    :vartype credentials: ~azure.mgmt.storagemover.models.AzureKeyVaultSmbCredentials
+    """
+
+    _validation = {
+        "endpoint_type": {"required": True},
+        "provisioning_state": {"readonly": True},
+        "host": {"required": True},
+        "share_name": {"required": True},
+    }
+
+    _attribute_map = {
+        "endpoint_type": {"key": "endpointType", "type": "str"},
+        "description": {"key": "description", "type": "str"},
+        "provisioning_state": {"key": "provisioningState", "type": "str"},
+        "host": {"key": "host", "type": "str"},
+        "share_name": {"key": "shareName", "type": "str"},
+        "credentials": {"key": "credentials", "type": "AzureKeyVaultSmbCredentials"},
+    }
+
+    def __init__(
+        self,
+        *,
+        host: str,
+        share_name: str,
+        description: Optional[str] = None,
+        credentials: Optional["_models.AzureKeyVaultSmbCredentials"] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword description: A description for the Endpoint.
+        :paramtype description: str
+        :keyword host: The host name or IP address of the server exporting the file system. Required.
+        :paramtype host: str
+        :keyword share_name: The name of the SMB share being exported from the server. Required.
+        :paramtype share_name: str
+        :keyword credentials: The Azure Key Vault secret URIs which store the required credentials to
+         access the SMB share.
+        :paramtype credentials: ~azure.mgmt.storagemover.models.AzureKeyVaultSmbCredentials
+        """
+        super().__init__(description=description, **kwargs)
+        self.endpoint_type: str = "SmbMount"
+        self.host = host
+        self.share_name = share_name
+        self.credentials = credentials
+
+
+class SmbMountEndpointUpdateProperties(EndpointBaseUpdateProperties):
+    """The properties of SMB share endpoint to update.
+
+    All required parameters must be populated in order to send to Azure.
+
+    :ivar endpoint_type: The Endpoint resource type. Required. Known values are:
+     "AzureStorageBlobContainer", "NfsMount", "AzureStorageSmbFileShare", and "SmbMount".
+    :vartype endpoint_type: str or ~azure.mgmt.storagemover.models.EndpointType
+    :ivar description: A description for the Endpoint.
+    :vartype description: str
+    :ivar credentials: The Azure Key Vault secret URIs which store the required credentials to
+     access the SMB share.
+    :vartype credentials: ~azure.mgmt.storagemover.models.AzureKeyVaultSmbCredentials
+    """
+
+    _validation = {
+        "endpoint_type": {"required": True},
+    }
+
+    _attribute_map = {
+        "endpoint_type": {"key": "endpointType", "type": "str"},
+        "description": {"key": "description", "type": "str"},
+        "credentials": {"key": "credentials", "type": "AzureKeyVaultSmbCredentials"},
+    }
+
+    def __init__(
+        self,
+        *,
+        description: Optional[str] = None,
+        credentials: Optional["_models.AzureKeyVaultSmbCredentials"] = None,
+        **kwargs: Any
+    ) -> None:
+        """
+        :keyword description: A description for the Endpoint.
+        :paramtype description: str
+        :keyword credentials: The Azure Key Vault secret URIs which store the required credentials to
+         access the SMB share.
+        :paramtype credentials: ~azure.mgmt.storagemover.models.AzureKeyVaultSmbCredentials
+        """
+        super().__init__(description=description, **kwargs)
+        self.endpoint_type: str = "SmbMount"
+        self.credentials = credentials
+
+
 class TrackedResource(Resource):
     """The resource model definition for an Azure Resource Manager tracked top level resource which
     has 'tags' and a 'location'.
 
     Variables are only populated by the server, and will be ignored when sending a request.
 
     All required parameters must be populated in order to send to Azure.
@@ -1404,31 +1732,36 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
+        "system_data": {"readonly": True},
         "location": {"required": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
     }
 
     def __init__(self, *, location: str, tags: Optional[Dict[str, str]] = None, **kwargs: Any) -> None:
         """
         :keyword tags: Resource tags.
@@ -1453,42 +1786,43 @@
      /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}.
     :vartype id: str
     :ivar name: The name of the resource.
     :vartype name: str
     :ivar type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or
      "Microsoft.Storage/storageAccounts".
     :vartype type: str
+    :ivar system_data: Azure Resource Manager metadata containing createdBy and modifiedBy
+     information.
+    :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     :ivar tags: Resource tags.
     :vartype tags: dict[str, str]
     :ivar location: The geo-location where the resource lives. Required.
     :vartype location: str
-    :ivar system_data: Resource system metadata.
-    :vartype system_data: ~azure.mgmt.storagemover.models.SystemData
     :ivar description: A description for the Storage Mover.
     :vartype description: str
     :ivar provisioning_state: The provisioning state of this resource. "Succeeded"
     :vartype provisioning_state: str or ~azure.mgmt.storagemover.models.ProvisioningState
     """
 
     _validation = {
         "id": {"readonly": True},
         "name": {"readonly": True},
         "type": {"readonly": True},
-        "location": {"required": True},
         "system_data": {"readonly": True},
+        "location": {"required": True},
         "provisioning_state": {"readonly": True},
     }
 
     _attribute_map = {
         "id": {"key": "id", "type": "str"},
         "name": {"key": "name", "type": "str"},
         "type": {"key": "type", "type": "str"},
+        "system_data": {"key": "systemData", "type": "SystemData"},
         "tags": {"key": "tags", "type": "{str}"},
         "location": {"key": "location", "type": "str"},
-        "system_data": {"key": "systemData", "type": "SystemData"},
         "description": {"key": "properties.description", "type": "str"},
         "provisioning_state": {"key": "properties.provisioningState", "type": "str"},
     }
 
     def __init__(
         self, *, location: str, tags: Optional[Dict[str, str]] = None, description: Optional[str] = None, **kwargs: Any
     ) -> None:
@@ -1497,15 +1831,14 @@
         :paramtype tags: dict[str, str]
         :keyword location: The geo-location where the resource lives. Required.
         :paramtype location: str
         :keyword description: A description for the Storage Mover.
         :paramtype description: str
         """
         super().__init__(tags=tags, location=location, **kwargs)
-        self.system_data = None
         self.description = description
         self.provisioning_state = None
 
 
 class StorageMoverList(_serialization.Model):
     """List of Storage Movers.
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/models/__init__.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/models/__init__.py`

 * *Files 10% similar despite different names*

```diff
@@ -6,16 +6,20 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from ._models_py3 import Agent
 from ._models_py3 import AgentList
 from ._models_py3 import AgentPropertiesErrorDetails
 from ._models_py3 import AgentUpdateParameters
+from ._models_py3 import AzureKeyVaultSmbCredentials
 from ._models_py3 import AzureStorageBlobContainerEndpointProperties
 from ._models_py3 import AzureStorageBlobContainerEndpointUpdateProperties
+from ._models_py3 import AzureStorageSmbFileShareEndpointProperties
+from ._models_py3 import AzureStorageSmbFileShareEndpointUpdateProperties
+from ._models_py3 import Credentials
 from ._models_py3 import Endpoint
 from ._models_py3 import EndpointBaseProperties
 from ._models_py3 import EndpointBaseUpdateParameters
 from ._models_py3 import EndpointBaseUpdateProperties
 from ._models_py3 import EndpointList
 from ._models_py3 import ErrorAdditionalInfo
 from ._models_py3 import ErrorDetail
@@ -33,24 +37,27 @@
 from ._models_py3 import OperationDisplay
 from ._models_py3 import OperationListResult
 from ._models_py3 import Project
 from ._models_py3 import ProjectList
 from ._models_py3 import ProjectUpdateParameters
 from ._models_py3 import ProxyResource
 from ._models_py3 import Resource
+from ._models_py3 import SmbMountEndpointProperties
+from ._models_py3 import SmbMountEndpointUpdateProperties
 from ._models_py3 import StorageMover
 from ._models_py3 import StorageMoverList
 from ._models_py3 import StorageMoverUpdateParameters
 from ._models_py3 import SystemData
 from ._models_py3 import TrackedResource
 
 from ._storage_mover_mgmt_client_enums import ActionType
 from ._storage_mover_mgmt_client_enums import AgentStatus
 from ._storage_mover_mgmt_client_enums import CopyMode
 from ._storage_mover_mgmt_client_enums import CreatedByType
+from ._storage_mover_mgmt_client_enums import CredentialType
 from ._storage_mover_mgmt_client_enums import EndpointType
 from ._storage_mover_mgmt_client_enums import JobRunScanStatus
 from ._storage_mover_mgmt_client_enums import JobRunStatus
 from ._storage_mover_mgmt_client_enums import NfsVersion
 from ._storage_mover_mgmt_client_enums import Origin
 from ._storage_mover_mgmt_client_enums import ProvisioningState
 from ._patch import __all__ as _patch_all
@@ -58,16 +65,20 @@
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Agent",
     "AgentList",
     "AgentPropertiesErrorDetails",
     "AgentUpdateParameters",
+    "AzureKeyVaultSmbCredentials",
     "AzureStorageBlobContainerEndpointProperties",
     "AzureStorageBlobContainerEndpointUpdateProperties",
+    "AzureStorageSmbFileShareEndpointProperties",
+    "AzureStorageSmbFileShareEndpointUpdateProperties",
+    "Credentials",
     "Endpoint",
     "EndpointBaseProperties",
     "EndpointBaseUpdateParameters",
     "EndpointBaseUpdateProperties",
     "EndpointList",
     "ErrorAdditionalInfo",
     "ErrorDetail",
@@ -85,23 +96,26 @@
     "OperationDisplay",
     "OperationListResult",
     "Project",
     "ProjectList",
     "ProjectUpdateParameters",
     "ProxyResource",
     "Resource",
+    "SmbMountEndpointProperties",
+    "SmbMountEndpointUpdateProperties",
     "StorageMover",
     "StorageMoverList",
     "StorageMoverUpdateParameters",
     "SystemData",
     "TrackedResource",
     "ActionType",
     "AgentStatus",
     "CopyMode",
     "CreatedByType",
+    "CredentialType",
     "EndpointType",
     "JobRunScanStatus",
     "JobRunStatus",
     "NfsVersion",
     "Origin",
     "ProvisioningState",
 ]
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_patch.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_endpoints_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_endpoints_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,34 +28,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     resource_group_name: str, storage_mover_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/endpoints",
     )  # pylint: disable=line-too-long
@@ -80,17 +74,15 @@
 
 def build_get_request(
     resource_group_name: str, storage_mover_name: str, endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/endpoints/{endpointName}",
     )  # pylint: disable=line-too-long
@@ -116,17 +108,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, storage_mover_name: str, endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/endpoints/{endpointName}",
@@ -155,17 +145,15 @@
 
 def build_update_request(
     resource_group_name: str, storage_mover_name: str, endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/endpoints/{endpointName}",
@@ -194,17 +182,15 @@
 
 def build_delete_request(
     resource_group_name: str, storage_mover_name: str, endpoint_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/endpoints/{endpointName}",
     )  # pylint: disable=line-too-long
@@ -260,17 +246,15 @@
         :return: An iterator like instance of either Endpoint or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.storagemover.models.Endpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.EndpointList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -316,16 +300,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -363,17 +348,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             endpoint_name=endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -381,16 +364,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -507,24 +491,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(endpoint, (IO, bytes)):
+        if isinstance(endpoint, (IOBase, bytes)):
             _content = endpoint
         else:
             _json = self._serialize.body(endpoint, "Endpoint")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -537,16 +519,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -663,24 +646,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(endpoint, (IO, bytes)):
+        if isinstance(endpoint, (IOBase, bytes)):
             _content = endpoint
         else:
             _json = self._serialize.body(endpoint, "EndpointBaseUpdateParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -693,16 +674,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -729,17 +711,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             endpoint_name=endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -747,16 +727,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -793,17 +774,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.StorageMover/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -91,17 +84,15 @@
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.storagemover.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -144,16 +135,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_agents_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_agents_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,34 +28,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     resource_group_name: str, storage_mover_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/agents",
     )  # pylint: disable=line-too-long
@@ -80,17 +74,15 @@
 
 def build_get_request(
     resource_group_name: str, storage_mover_name: str, agent_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/agents/{agentName}",
     )  # pylint: disable=line-too-long
@@ -116,17 +108,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, storage_mover_name: str, agent_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/agents/{agentName}",
@@ -155,17 +145,15 @@
 
 def build_update_request(
     resource_group_name: str, storage_mover_name: str, agent_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/agents/{agentName}",
@@ -194,17 +182,15 @@
 
 def build_delete_request(
     resource_group_name: str, storage_mover_name: str, agent_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/agents/{agentName}",
     )  # pylint: disable=line-too-long
@@ -260,17 +246,15 @@
         :return: An iterator like instance of either Agent or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.storagemover.models.Agent]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AgentList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -316,16 +300,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -361,17 +346,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Agent] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             agent_name=agent_name,
             subscription_id=self._config.subscription_id,
@@ -379,16 +362,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -505,24 +489,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Agent] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(agent, (IO, bytes)):
+        if isinstance(agent, (IOBase, bytes)):
             _content = agent
         else:
             _json = self._serialize.body(agent, "Agent")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -535,16 +517,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -658,24 +641,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Agent] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(agent, (IO, bytes)):
+        if isinstance(agent, (IOBase, bytes)):
             _content = agent
         else:
             _json = self._serialize.body(agent, "AgentUpdateParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -688,16 +669,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -724,17 +706,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             agent_name=agent_name,
             subscription_id=self._config.subscription_id,
@@ -742,16 +722,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -788,17 +769,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_job_runs_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_job_runs_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -48,17 +43,15 @@
     job_definition_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}/jobDefinitions/{jobDefinitionName}/jobRuns",
     )  # pylint: disable=line-too-long
@@ -91,17 +84,15 @@
     job_run_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}/jobDefinitions/{jobDefinitionName}/jobRuns/{jobRunName}",
     )  # pylint: disable=line-too-long
@@ -170,17 +161,15 @@
         :return: An iterator like instance of either JobRun or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.storagemover.models.JobRun]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobRunList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -228,16 +217,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -285,17 +275,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobRun] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             job_definition_name=job_definition_name,
@@ -305,16 +293,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_projects_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_projects_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,34 +28,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     resource_group_name: str, storage_mover_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects",
     )  # pylint: disable=line-too-long
@@ -80,17 +74,15 @@
 
 def build_get_request(
     resource_group_name: str, storage_mover_name: str, project_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}",
     )  # pylint: disable=line-too-long
@@ -116,17 +108,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, storage_mover_name: str, project_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}",
@@ -155,17 +145,15 @@
 
 def build_update_request(
     resource_group_name: str, storage_mover_name: str, project_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}",
@@ -194,17 +182,15 @@
 
 def build_delete_request(
     resource_group_name: str, storage_mover_name: str, project_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}",
     )  # pylint: disable=line-too-long
@@ -260,17 +246,15 @@
         :return: An iterator like instance of either Project or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.storagemover.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProjectList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -316,16 +300,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -363,17 +348,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Project] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             subscription_id=self._config.subscription_id,
@@ -381,16 +364,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -504,24 +488,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Project] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(project, (IO, bytes)):
+        if isinstance(project, (IOBase, bytes)):
             _content = project
         else:
             _json = self._serialize.body(project, "Project")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -534,16 +516,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -660,24 +643,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Project] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(project, (IO, bytes)):
+        if isinstance(project, (IOBase, bytes)):
             _content = project
         else:
             _json = self._serialize.body(project, "ProjectUpdateParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -690,16 +671,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -726,17 +708,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             subscription_id=self._config.subscription_id,
@@ -744,16 +724,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -790,17 +771,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_storage_movers_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_storage_movers_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,32 +28,26 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_by_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.StorageMover/storageMovers")
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
@@ -69,17 +63,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers",
     )  # pylint: disable=line-too-long
@@ -103,17 +95,15 @@
 
 def build_get_request(
     resource_group_name: str, storage_mover_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}",
     )  # pylint: disable=line-too-long
@@ -138,17 +128,15 @@
 
 def build_create_or_update_request(
     resource_group_name: str, storage_mover_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}",
@@ -176,17 +164,15 @@
 
 def build_update_request(
     resource_group_name: str, storage_mover_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}",
@@ -214,17 +200,15 @@
 
 def build_delete_request(
     resource_group_name: str, storage_mover_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}",
     )  # pylint: disable=line-too-long
@@ -274,17 +258,15 @@
         :return: An iterator like instance of either StorageMover or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.storagemover.models.StorageMover]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.StorageMoverList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -328,16 +310,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -361,17 +344,15 @@
         :return: An iterator like instance of either StorageMover or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.storagemover.models.StorageMover]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.StorageMoverList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -416,16 +397,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -459,33 +441,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.StorageMover] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -590,24 +571,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.StorageMover] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(storage_mover, (IO, bytes)):
+        if isinstance(storage_mover, (IOBase, bytes)):
             _content = storage_mover
         else:
             _json = self._serialize.body(storage_mover, "StorageMover")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -619,16 +598,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -736,24 +716,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.StorageMover] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(storage_mover, (IO, bytes)):
+        if isinstance(storage_mover, (IOBase, bytes)):
             _content = storage_mover
         else:
             _json = self._serialize.body(storage_mover, "StorageMoverUpdateParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -765,16 +743,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -801,33 +780,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -860,17 +838,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/_job_definitions_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_job_definitions_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -28,34 +28,28 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from .._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     resource_group_name: str, storage_mover_name: str, project_name: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}/jobDefinitions",
     )  # pylint: disable=line-too-long
@@ -86,17 +80,15 @@
     job_definition_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}/jobDefinitions/{jobDefinitionName}",
     )  # pylint: disable=line-too-long
@@ -128,17 +120,15 @@
     job_definition_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}/jobDefinitions/{jobDefinitionName}",
@@ -173,17 +163,15 @@
     job_definition_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}/jobDefinitions/{jobDefinitionName}",
@@ -218,17 +206,15 @@
     job_definition_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}/jobDefinitions/{jobDefinitionName}",
     )  # pylint: disable=line-too-long
@@ -260,17 +246,15 @@
     job_definition_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}/jobDefinitions/{jobDefinitionName}/startJob",
     )  # pylint: disable=line-too-long
@@ -302,17 +286,15 @@
     job_definition_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2023-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageMover/storageMovers/{storageMoverName}/projects/{projectName}/jobDefinitions/{jobDefinitionName}/stopJob",
     )  # pylint: disable=line-too-long
@@ -373,17 +355,15 @@
         :return: An iterator like instance of either JobDefinition or the result of cls(response)
         :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.storagemover.models.JobDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobDefinitionList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -430,16 +410,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -484,17 +465,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             job_definition_name=job_definition_name,
@@ -503,16 +482,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -638,24 +618,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(job_definition, (IO, bytes)):
+        if isinstance(job_definition, (IOBase, bytes)):
             _content = job_definition
         else:
             _json = self._serialize.body(job_definition, "JobDefinition")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -669,16 +647,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -804,24 +783,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(job_definition, (IO, bytes)):
+        if isinstance(job_definition, (IOBase, bytes)):
             _content = job_definition
         else:
             _json = self._serialize.body(job_definition, "JobDefinitionUpdateParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -835,16 +812,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -876,17 +854,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             job_definition_name=job_definition_name,
@@ -895,16 +871,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -948,17 +925,15 @@
         :return: An instance of LROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.LROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -1031,17 +1006,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobRunResourceId] = kwargs.pop("cls", None)
 
         request = build_start_job_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             job_definition_name=job_definition_name,
@@ -1050,16 +1023,17 @@
             template_url=self.start_job.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1108,17 +1082,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobRunResourceId] = kwargs.pop("cls", None)
 
         request = build_stop_job_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             job_definition_name=job_definition_name,
@@ -1127,16 +1099,17 @@
             template_url=self.stop_job.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/operations/__init__.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/_patch.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/_storage_mover_mgmt_client.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/_storage_mover_mgmt_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -49,15 +49,15 @@
     :vartype job_runs: azure.mgmt.storagemover.aio.operations.JobRunsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2022-07-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2023-07-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
      Retry-After header is present.
     """
 
     def __init__(
@@ -66,15 +66,15 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = StorageMoverMgmtClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
         self.storage_movers = StorageMoversOperations(self._client, self._config, self._serialize, self._deserialize)
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/_configuration.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/_configuration.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class StorageMoverMgmtClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for StorageMoverMgmtClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-07-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2023-07-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(StorageMoverMgmtClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop("api_version", "2022-07-01-preview")
+        api_version: str = kwargs.pop("api_version", "2023-07-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/__init__.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_patch.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_endpoints_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_endpoints_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -35,18 +35,14 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class EndpointsOperations:
     """
     .. warning::
@@ -81,17 +77,15 @@
         :return: An iterator like instance of either Endpoint or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.storagemover.models.Endpoint]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.EndpointList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -137,16 +131,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -184,17 +179,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             endpoint_name=endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -202,16 +195,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -328,24 +322,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(endpoint, (IO, bytes)):
+        if isinstance(endpoint, (IOBase, bytes)):
             _content = endpoint
         else:
             _json = self._serialize.body(endpoint, "Endpoint")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -358,16 +350,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -484,24 +477,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Endpoint] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(endpoint, (IO, bytes)):
+        if isinstance(endpoint, (IOBase, bytes)):
             _content = endpoint
         else:
             _json = self._serialize.body(endpoint, "EndpointBaseUpdateParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -514,16 +505,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -550,17 +542,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             endpoint_name=endpoint_name,
             subscription_id=self._config.subscription_id,
@@ -568,16 +558,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -614,17 +605,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
@@ -67,17 +62,15 @@
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.storagemover.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -120,16 +113,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_agents_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_agents_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -35,18 +35,14 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AgentsOperations:
     """
     .. warning::
@@ -79,17 +75,15 @@
         :return: An iterator like instance of either Agent or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.storagemover.models.Agent]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.AgentList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -135,16 +129,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -182,17 +177,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Agent] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             agent_name=agent_name,
             subscription_id=self._config.subscription_id,
@@ -200,16 +193,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -326,24 +320,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Agent] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(agent, (IO, bytes)):
+        if isinstance(agent, (IOBase, bytes)):
             _content = agent
         else:
             _json = self._serialize.body(agent, "Agent")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -356,16 +348,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -479,24 +472,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Agent] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(agent, (IO, bytes)):
+        if isinstance(agent, (IOBase, bytes)):
             _content = agent
         else:
             _json = self._serialize.body(agent, "AgentUpdateParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -509,16 +500,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -545,17 +537,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             agent_name=agent_name,
             subscription_id=self._config.subscription_id,
@@ -563,16 +553,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -609,17 +600,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_job_runs_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_job_runs_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -27,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._job_runs_operations import build_get_request, build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobRunsOperations:
     """
     .. warning::
@@ -82,17 +77,15 @@
         :return: An iterator like instance of either JobRun or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.storagemover.models.JobRun]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobRunList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -140,16 +133,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -197,17 +191,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobRun] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             job_definition_name=job_definition_name,
@@ -217,16 +209,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_projects_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_projects_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -35,18 +35,14 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_request,
     build_list_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ProjectsOperations:
     """
     .. warning::
@@ -81,17 +77,15 @@
         :return: An iterator like instance of either Project or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.storagemover.models.Project]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.ProjectList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -137,16 +131,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -184,17 +179,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.Project] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             subscription_id=self._config.subscription_id,
@@ -202,16 +195,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -325,24 +319,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Project] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(project, (IO, bytes)):
+        if isinstance(project, (IOBase, bytes)):
             _content = project
         else:
             _json = self._serialize.body(project, "Project")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -355,16 +347,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -481,24 +474,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.Project] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(project, (IO, bytes)):
+        if isinstance(project, (IOBase, bytes)):
             _content = project
         else:
             _json = self._serialize.body(project, "ProjectUpdateParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -511,16 +502,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -547,17 +539,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             subscription_id=self._config.subscription_id,
@@ -565,16 +555,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -611,17 +602,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_storage_movers_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_storage_movers_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -36,18 +36,14 @@
     build_delete_request,
     build_get_request,
     build_list_by_subscription_request,
     build_list_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class StorageMoversOperations:
     """
     .. warning::
@@ -75,17 +71,15 @@
         :return: An iterator like instance of either StorageMover or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.storagemover.models.StorageMover]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.StorageMoverList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -129,16 +123,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -162,17 +157,15 @@
         :return: An iterator like instance of either StorageMover or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.storagemover.models.StorageMover]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.StorageMoverList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -217,16 +210,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -260,33 +254,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.StorageMover] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -391,24 +384,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.StorageMover] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(storage_mover, (IO, bytes)):
+        if isinstance(storage_mover, (IOBase, bytes)):
             _content = storage_mover
         else:
             _json = self._serialize.body(storage_mover, "StorageMover")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -420,16 +411,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -537,24 +529,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.StorageMover] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(storage_mover, (IO, bytes)):
+        if isinstance(storage_mover, (IOBase, bytes)):
             _content = storage_mover
         else:
             _json = self._serialize.body(storage_mover, "StorageMoverUpdateParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -566,16 +556,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -602,33 +593,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -663,17 +653,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/_job_definitions_operations.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/aio/operations/_job_definitions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -37,18 +37,14 @@
     build_get_request,
     build_list_request,
     build_start_job_request,
     build_stop_job_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class JobDefinitionsOperations:
     """
     .. warning::
@@ -85,17 +81,15 @@
         :return: An iterator like instance of either JobDefinition or the result of cls(response)
         :rtype: ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.storagemover.models.JobDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobDefinitionList] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -142,16 +136,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -196,17 +191,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             job_definition_name=job_definition_name,
@@ -215,16 +208,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -350,24 +344,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(job_definition, (IO, bytes)):
+        if isinstance(job_definition, (IOBase, bytes)):
             _content = job_definition
         else:
             _json = self._serialize.body(job_definition, "JobDefinition")
 
         request = build_create_or_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -381,16 +373,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -516,24 +509,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.JobDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(job_definition, (IO, bytes)):
+        if isinstance(job_definition, (IOBase, bytes)):
             _content = job_definition
         else:
             _json = self._serialize.body(job_definition, "JobDefinitionUpdateParameters")
 
         request = build_update_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
@@ -547,16 +538,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -588,17 +580,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             job_definition_name=job_definition_name,
@@ -607,16 +597,17 @@
             template_url=self._delete_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 202, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -660,17 +651,15 @@
         :return: An instance of AsyncLROPoller that returns either None or the result of cls(response)
         :rtype: ~azure.core.polling.AsyncLROPoller[None]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[None] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._delete_initial(  # type: ignore
                 resource_group_name=resource_group_name,
@@ -743,17 +732,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobRunResourceId] = kwargs.pop("cls", None)
 
         request = build_start_job_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             job_definition_name=job_definition_name,
@@ -762,16 +749,17 @@
             template_url=self.start_job.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -820,17 +808,15 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", self._config.api_version)
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._config.api_version))
         cls: ClsType[_models.JobRunResourceId] = kwargs.pop("cls", None)
 
         request = build_stop_job_request(
             resource_group_name=resource_group_name,
             storage_mover_name=storage_mover_name,
             project_name=project_name,
             job_definition_name=job_definition_name,
@@ -839,16 +825,17 @@
             template_url=self.stop_job.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure/mgmt/storagemover/aio/operations/__init__.py` & `azure-mgmt-storagemover-2.0.0b1/azure/mgmt/storagemover/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/PKG-INFO` & `azure-mgmt-storagemover-2.0.0b1/PKG-INFO`

 * *Files 18% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-storagemover
-Version: 1.0.0b1
+Version: 2.0.0b1
 Summary: Microsoft Azure Storagemover Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
 Classifier: Development Status :: 4 - Beta
@@ -55,25 +55,26 @@
 
 In addition, Azure subscription ID can be configured via environment variable `AZURE_SUBSCRIPTION_ID`.
 
 With above configuration, client can be authenticated by following code:
 
 ```python
 from azure.identity import DefaultAzureCredential
-from azure.mgmt.storagemover import 
+from azure.mgmt.storagemover import StorageMoverMgmtClient
 import os
 
 sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
-client = (credential=DefaultAzureCredential(), subscription_id=sub_id)
+client = StorageMoverMgmtClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
 ```
 
 ## Examples
 
-
-Code samples for this package can be found at [Storagemover Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com and [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+Code samples for this package can be found at:
+- [Search Storagemover Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
 
 ## Troubleshooting
 
 ## Next steps
 
 ## Provide Feedback
@@ -84,10 +85,30 @@
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-storagemover%2FREADME.png)
 
 
 # Release History
 
+## 2.0.0b1 (2023-07-21)
+
+### Features Added
+
+  - Model ProxyResource has a new parameter system_data
+  - Model Resource has a new parameter system_data
+  - Model TrackedResource has a new parameter system_data
+
+### Breaking Changes
+
+  - Model AzureStorageBlobContainerEndpointUpdateProperties has a new required parameter endpoint_type
+  - Model EndpointBaseUpdateProperties has a new required parameter endpoint_type
+  - Model NfsMountEndpointUpdateProperties has a new required parameter endpoint_type
+
+## 1.0.0 (2023-03-07)
+
+### Other changes
+
+  - First GA version
+
 ## 1.0.0b1 (2023-02-20)
 
 * Initial Release
```

## Comparing `azure-mgmt-storagemover-1.0.0b1/azure_mgmt_storagemover.egg-info/SOURCES.txt` & `azure-mgmt-storagemover-2.0.0b1/azure_mgmt_storagemover.egg-info/SOURCES.txt`

 * *Files identical despite different names*

