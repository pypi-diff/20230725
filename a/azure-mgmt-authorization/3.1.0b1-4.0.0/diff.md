# Comparing `tmp/azure-mgmt-authorization-3.1.0b1.zip` & `tmp/azure-mgmt-authorization-4.0.0.zip`

## zipinfo {}

```diff
@@ -1,591 +1,668 @@
-Zip file size: 1053246 bytes, number of entries: 589
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/tests/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/
--rw-rw-r--  2.0 unx      634 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/_meta.json
--rw-rw-r--  2.0 unx    13676 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/CHANGELOG.md
--rw-rw-r--  2.0 unx       38 b- defN 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/setup.cfg
--rw-rw-r--  2.0 unx    16734 b- defN 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/PKG-INFO
--rw-rw-r--  2.0 unx      219 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/MANIFEST.in
--rw-rw-r--  2.0 unx     2157 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/README.md
--rw-rw-r--  2.0 unx     1074 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/LICENSE
--rw-rw-r--  2.0 unx     2832 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/setup.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/tests/recordings/
--rw-rw-r--  2.0 unx    15913 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/tests/test_cli_mgmt_authorization.py
--rw-rw-r--  2.0 unx     2566 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/tests/disable_test_mgmt_authorization.py
--rw-rw-r--  2.0 unx     2801 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/tests/conftest.py
--rw-rw-r--  2.0 unx       39 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/tests/recordings/test_cli_mgmt_authorization.pyTestMgmtAuthorizationtest_deny_assignment.json
--rw-rw-r--  2.0 unx    10882 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/tests/recordings/test_cli_mgmt_authorization.pyTestMgmtAuthorizationtest_list_by_resource.json
--rw-rw-r--  2.0 unx      116 b- defN 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/requires.txt
--rw-rw-r--  2.0 unx    39421 b- defN 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/SOURCES.txt
--rw-rw-r--  2.0 unx    16734 b- defN 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/PKG-INFO
--rw-rw-r--  2.0 unx        6 b- defN 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/top_level.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/dependency_links.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/not-zip-safe
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/
--rw-rw-r--  2.0 unx       65 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/
--rw-rw-r--  2.0 unx       65 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/
--rw-rw-r--  2.0 unx       26 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/py.typed
--rw-rw-r--  2.0 unx      554 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/models.py
--rw-rw-r--  2.0 unx    74037 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3199 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_configuration.py
--rw-rw-r--  2.0 unx    78842 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_serialization.py
--rw-rw-r--  2.0 unx      743 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/__init__.py
--rw-rw-r--  2.0 unx      347 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_version.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_vendor.py
--rw-rw-r--  2.0 unx     7703 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3475 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_version.py
--rw-rw-r--  2.0 unx    23095 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policy_assignments_operations.py
--rw-rw-r--  2.0 unx    33135 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_requests_operations.py
--rw-rw-r--  2.0 unx    11829 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedules_operations.py
--rw-rw-r--  2.0 unx    12083 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_instances_operations.py
--rw-rw-r--  2.0 unx    12098 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_instances_operations.py
--rw-rw-r--  2.0 unx    33098 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_requests_operations.py
--rw-rw-r--  2.0 unx     1963 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/__init__.py
--rw-rw-r--  2.0 unx    11802 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedules_operations.py
--rw-rw-r--  2.0 unx    21942 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policies_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_patch.py
--rw-rw-r--  2.0 unx     7745 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_eligible_child_resources_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/
--rw-rw-r--  2.0 unx     7866 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3523 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/_patch.py
--rw-rw-r--  2.0 unx    18211 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policy_assignments_operations.py
--rw-rw-r--  2.0 unx    26626 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_requests_operations.py
--rw-rw-r--  2.0 unx     9608 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedules_operations.py
--rw-rw-r--  2.0 unx     9804 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_instances_operations.py
--rw-rw-r--  2.0 unx     9826 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_instances_operations.py
--rw-rw-r--  2.0 unx    26613 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_requests_operations.py
--rw-rw-r--  2.0 unx     1963 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     9587 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedules_operations.py
--rw-rw-r--  2.0 unx    17334 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policies_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     6681 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_eligible_child_resources_operations.py
--rw-rw-r--  2.0 unx   140817 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/_models_py3.py
--rw-rw-r--  2.0 unx     6980 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/_patch.py
--rw-rw-r--  2.0 unx     4469 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/_authorization_management_client_enums.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_vendor.py
--rw-rw-r--  2.0 unx     5731 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3762 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_version.py
--rw-rw-r--  2.0 unx    25541 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_role_definitions_operations.py
--rw-rw-r--  2.0 unx    62483 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx    36526 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_deny_assignments_operations.py
--rw-rw-r--  2.0 unx     1233 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/__init__.py
--rw-rw-r--  2.0 unx    11213 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_provider_operations_metadata_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_patch.py
--rw-rw-r--  2.0 unx    14815 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_permissions_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/
--rw-rw-r--  2.0 unx     5878 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3810 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/_patch.py
--rw-rw-r--  2.0 unx    20194 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_definitions_operations.py
--rw-rw-r--  2.0 unx    49033 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx    28946 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_deny_assignments_operations.py
--rw-rw-r--  2.0 unx     1233 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     9204 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_provider_operations_metadata_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    11648 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_permissions_operations.py
--rw-rw-r--  2.0 unx    74589 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/_models_py3.py
--rw-rw-r--  2.0 unx     4019 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/_patch.py
--rw-rw-r--  2.0 unx     2411 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/_authorization_management_client_enums.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     5295 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3786 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_version.py
--rw-rw-r--  2.0 unx    25970 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_definitions_operations.py
--rw-rw-r--  2.0 unx    56399 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     1132 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx    11373 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_provider_operations_metadata_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_patch.py
--rw-rw-r--  2.0 unx    14993 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_permissions_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     5438 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3834 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx    20473 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_definitions_operations.py
--rw-rw-r--  2.0 unx    44162 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     1132 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     9304 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_provider_operations_metadata_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    11748 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_permissions_operations.py
--rw-rw-r--  2.0 unx    24063 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx     1868 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/_patch.py
--rw-rw-r--  2.0 unx    75087 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3263 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/_configuration.py
--rw-rw-r--  2.0 unx      588 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/__init__.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_vendor.py
--rw-rw-r--  2.0 unx     4404 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3762 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_version.py
--rw-rw-r--  2.0 unx     7355 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/_classic_administrators_operations.py
--rw-rw-r--  2.0 unx      826 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/
--rw-rw-r--  2.0 unx     4535 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3810 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/_patch.py
--rw-rw-r--  2.0 unx     6302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/_classic_administrators_operations.py
--rw-rw-r--  2.0 unx      826 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     6379 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/_models_py3.py
--rw-rw-r--  2.0 unx     1062 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_vendor.py
--rw-rw-r--  2.0 unx    17847 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3223 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_version.py
--rw-rw-r--  2.0 unx    12569 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_default_settings_operations.py
--rw-rw-r--  2.0 unx    11202 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definitions_operations.py
--rw-rw-r--  2.0 unx     8029 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_decisions_operations.py
--rw-rw-r--  2.0 unx    17458 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_configurations_operations.py
--rw-rw-r--  2.0 unx    26545 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_schedule_definitions_operations.py
--rw-rw-r--  2.0 unx     8018 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_decisions_operations.py
--rw-rw-r--  2.0 unx     6948 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instance_operations.py
--rw-rw-r--  2.0 unx     7534 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_contacted_reviewers_operations.py
--rw-rw-r--  2.0 unx    11511 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx     9332 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_operation_operations.py
--rw-rw-r--  2.0 unx     7333 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
--rw-rw-r--  2.0 unx    15157 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_incidents_operations.py
--rw-rw-r--  2.0 unx    12510 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_default_settings_operations.py
--rw-rw-r--  2.0 unx    19618 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_operations.py
--rw-rw-r--  2.0 unx    30049 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alerts_operations.py
--rw-rw-r--  2.0 unx    13893 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_operations.py
--rw-rw-r--  2.0 unx     7314 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instances_operations.py
--rw-rw-r--  2.0 unx    26028 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_operations.py
--rw-rw-r--  2.0 unx    11291 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definitions_operations.py
--rw-rw-r--  2.0 unx    20036 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_my_decisions_operations.py
--rw-rw-r--  2.0 unx     6937 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instance_operations.py
--rw-rw-r--  2.0 unx    22100 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_operations.py
--rw-rw-r--  2.0 unx     7029 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    26436 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_operations.py
--rw-rw-r--  2.0 unx    13670 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_operations.py
--rw-rw-r--  2.0 unx     7545 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py
--rw-rw-r--  2.0 unx     5188 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx     6199 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_operations.py
--rw-rw-r--  2.0 unx    10803 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_definitions_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_patch.py
--rw-rw-r--  2.0 unx    19793 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instances_operations.py
--rw-rw-r--  2.0 unx     7317 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instances_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/
--rw-rw-r--  2.0 unx    18094 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3271 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx    10379 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_default_settings_operations.py
--rw-rw-r--  2.0 unx     9017 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definitions_operations.py
--rw-rw-r--  2.0 unx     6556 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_decisions_operations.py
--rw-rw-r--  2.0 unx    14050 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_configurations_operations.py
--rw-rw-r--  2.0 unx    20570 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_schedule_definitions_operations.py
--rw-rw-r--  2.0 unx     6613 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_decisions_operations.py
--rw-rw-r--  2.0 unx     5544 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instance_operations.py
--rw-rw-r--  2.0 unx     6285 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_contacted_reviewers_operations.py
--rw-rw-r--  2.0 unx     9172 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx     7136 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_operation_operations.py
--rw-rw-r--  2.0 unx     6168 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
--rw-rw-r--  2.0 unx    11466 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_incidents_operations.py
--rw-rw-r--  2.0 unx    10078 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_default_settings_operations.py
--rw-rw-r--  2.0 unx    15443 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_operations.py
--rw-rw-r--  2.0 unx    24863 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alerts_operations.py
--rw-rw-r--  2.0 unx    11309 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_operations.py
--rw-rw-r--  2.0 unx     6084 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instances_operations.py
--rw-rw-r--  2.0 unx    19440 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_operations.py
--rw-rw-r--  2.0 unx     8907 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definitions_operations.py
--rw-rw-r--  2.0 unx    15986 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
--rw-rw-r--  2.0 unx     5610 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instance_operations.py
--rw-rw-r--  2.0 unx    15523 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_operations.py
--rw-rw-r--  2.0 unx     6179 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    20097 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
--rw-rw-r--  2.0 unx    10943 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_operations.py
--rw-rw-r--  2.0 unx     6228 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py
--rw-rw-r--  2.0 unx     5188 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     5445 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_operations.py
--rw-rw-r--  2.0 unx     8686 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_definitions_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    15810 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instances_operations.py
--rw-rw-r--  2.0 unx     6155 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instances_operations.py
--rw-rw-r--  2.0 unx   196915 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx     8238 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/_patch.py
--rw-rw-r--  2.0 unx     6367 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/_authorization_management_client_enums.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     4316 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3786 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_version.py
--rw-rw-r--  2.0 unx    36990 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/_deny_assignments_operations.py
--rw-rw-r--  2.0 unx      808 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     4447 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3834 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx    29230 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_deny_assignments_operations.py
--rw-rw-r--  2.0 unx      808 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    14913 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx     1246 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     9126 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3786 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_version.py
--rw-rw-r--  2.0 unx     8670 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_decisions_operations.py
--rw-rw-r--  2.0 unx    12152 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx     7974 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
--rw-rw-r--  2.0 unx    12510 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_default_settings_operations.py
--rw-rw-r--  2.0 unx    20259 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_operations.py
--rw-rw-r--  2.0 unx    20677 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_my_decisions_operations.py
--rw-rw-r--  2.0 unx    22100 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_operations.py
--rw-rw-r--  2.0 unx     7670 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    27077 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_operations.py
--rw-rw-r--  2.0 unx     8186 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py
--rw-rw-r--  2.0 unx     2398 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx     6840 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     9297 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3834 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx     7197 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_decisions_operations.py
--rw-rw-r--  2.0 unx     9813 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx     6809 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
--rw-rw-r--  2.0 unx    10078 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_default_settings_operations.py
--rw-rw-r--  2.0 unx    16084 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_operations.py
--rw-rw-r--  2.0 unx    16627 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
--rw-rw-r--  2.0 unx    15523 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_operations.py
--rw-rw-r--  2.0 unx     6820 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    20738 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
--rw-rw-r--  2.0 unx     6869 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py
--rw-rw-r--  2.0 unx     2398 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     6086 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx   110386 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx     4601 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/_patch.py
--rw-rw-r--  2.0 unx     5362 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/_authorization_management_client_enums.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_vendor.py
--rw-rw-r--  2.0 unx     6213 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3762 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_version.py
--rw-rw-r--  2.0 unx    25659 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_role_definitions_operations.py
--rw-rw-r--  2.0 unx     7355 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_classic_administrators_operations.py
--rw-rw-r--  2.0 unx     5142 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_global_administrator_operations.py
--rw-rw-r--  2.0 unx    57543 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     1364 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/__init__.py
--rw-rw-r--  2.0 unx    11174 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_provider_operations_metadata_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_patch.py
--rw-rw-r--  2.0 unx    14776 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_permissions_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/
--rw-rw-r--  2.0 unx     6364 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3810 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/_patch.py
--rw-rw-r--  2.0 unx    20259 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_definitions_operations.py
--rw-rw-r--  2.0 unx     6302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_classic_administrators_operations.py
--rw-rw-r--  2.0 unx     4394 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_global_administrator_operations.py
--rw-rw-r--  2.0 unx    45486 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     1364 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     9204 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_provider_operations_metadata_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    11648 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_permissions_operations.py
--rw-rw-r--  2.0 unx    25706 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/_models_py3.py
--rw-rw-r--  2.0 unx     2218 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     4270 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3786 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_version.py
--rw-rw-r--  2.0 unx    56399 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx      808 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     4401 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3834 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx    44162 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx      808 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    11259 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx     1294 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/_patch.py
--rw-rw-r--  2.0 unx      782 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/_authorization_management_client_enums.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     7945 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3786 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_version.py
--rw-rw-r--  2.0 unx     8670 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_decisions_operations.py
--rw-rw-r--  2.0 unx    12152 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    12510 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_default_settings_operations.py
--rw-rw-r--  2.0 unx    12520 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_operations.py
--rw-rw-r--  2.0 unx    20677 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_my_decisions_operations.py
--rw-rw-r--  2.0 unx    22100 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_operations.py
--rw-rw-r--  2.0 unx     7670 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    27077 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_operations.py
--rw-rw-r--  2.0 unx     2008 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx     6840 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     8108 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3834 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx     7197 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_decisions_operations.py
--rw-rw-r--  2.0 unx     9813 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    10078 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_default_settings_operations.py
--rw-rw-r--  2.0 unx     9859 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_operations.py
--rw-rw-r--  2.0 unx    16627 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
--rw-rw-r--  2.0 unx    15523 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_operations.py
--rw-rw-r--  2.0 unx     6820 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    20738 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
--rw-rw-r--  2.0 unx     2008 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     6086 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    94137 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx     4176 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/_patch.py
--rw-rw-r--  2.0 unx     4852 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/_authorization_management_client_enums.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     7945 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3786 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_version.py
--rw-rw-r--  2.0 unx     8080 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_decisions_operations.py
--rw-rw-r--  2.0 unx    11568 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    12510 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_default_settings_operations.py
--rw-rw-r--  2.0 unx    11930 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_operations.py
--rw-rw-r--  2.0 unx    20087 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_my_decisions_operations.py
--rw-rw-r--  2.0 unx    22100 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_operations.py
--rw-rw-r--  2.0 unx     7100 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    26507 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_operations.py
--rw-rw-r--  2.0 unx     2008 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx     6840 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     8108 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3834 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx     6776 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_decisions_operations.py
--rw-rw-r--  2.0 unx     9378 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    10078 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_default_settings_operations.py
--rw-rw-r--  2.0 unx     9424 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_operations.py
--rw-rw-r--  2.0 unx    16206 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
--rw-rw-r--  2.0 unx    15523 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_operations.py
--rw-rw-r--  2.0 unx     6385 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
--rw-rw-r--  2.0 unx    20303 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
--rw-rw-r--  2.0 unx     2008 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     6086 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    85033 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx     3800 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/_patch.py
--rw-rw-r--  2.0 unx     4485 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/_authorization_management_client_enums.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     4315 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3786 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_version.py
--rw-rw-r--  2.0 unx      827 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/_patch.py
--rw-rw-r--  2.0 unx     6014 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/_role_assignment_metrics_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     4446 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3834 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx      827 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     4885 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_role_assignment_metrics_operations.py
--rw-rw-r--  2.0 unx     5173 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx      982 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     6552 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3499 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_version.py
--rw-rw-r--  2.0 unx    22322 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_step_operations.py
--rw-rw-r--  2.0 unx    21045 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_step_operations.py
--rw-rw-r--  2.0 unx    11396 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_operations.py
--rw-rw-r--  2.0 unx     6205 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_steps_operations.py
--rw-rw-r--  2.0 unx     5924 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_steps_operations.py
--rw-rw-r--  2.0 unx    11995 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_operations.py
--rw-rw-r--  2.0 unx     1605 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx     6840 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     6707 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3547 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx    18172 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_step_operations.py
--rw-rw-r--  2.0 unx    17198 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_step_operations.py
--rw-rw-r--  2.0 unx     9561 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_operations.py
--rw-rw-r--  2.0 unx     5040 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_steps_operations.py
--rw-rw-r--  2.0 unx     4894 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_steps_operations.py
--rw-rw-r--  2.0 unx     9858 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_operations.py
--rw-rw-r--  2.0 unx     1605 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     6086 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    19215 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx     1920 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/_patch.py
--rw-rw-r--  2.0 unx     1452 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/_authorization_management_client_enums.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     8354 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3786 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_version.py
--rw-rw-r--  2.0 unx    23440 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policy_assignments_operations.py
--rw-rw-r--  2.0 unx    25858 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_requests_operations.py
--rw-rw-r--  2.0 unx    79506 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx    11989 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedules_operations.py
--rw-rw-r--  2.0 unx    12243 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_instances_operations.py
--rw-rw-r--  2.0 unx    12258 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_instances_operations.py
--rw-rw-r--  2.0 unx    25869 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_requests_operations.py
--rw-rw-r--  2.0 unx     2064 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx    11962 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedules_operations.py
--rw-rw-r--  2.0 unx    22287 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policies_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_patch.py
--rw-rw-r--  2.0 unx     7829 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_eligible_child_resources_operations.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     8521 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3834 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx    18436 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policy_assignments_operations.py
--rw-rw-r--  2.0 unx    20717 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_requests_operations.py
--rw-rw-r--  2.0 unx    63338 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx     9708 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedules_operations.py
--rw-rw-r--  2.0 unx     9904 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_instances_operations.py
--rw-rw-r--  2.0 unx     9926 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_instances_operations.py
--rw-rw-r--  2.0 unx    20746 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_requests_operations.py
--rw-rw-r--  2.0 unx     2064 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx     9687 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedules_operations.py
--rw-rw-r--  2.0 unx    17559 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policies_operations.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx     6735 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_eligible_child_resources_operations.py
--rw-rw-r--  2.0 unx   159358 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx     7638 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/_patch.py
--rw-rw-r--  2.0 unx     4466 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/_authorization_management_client_enums.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/
--rw-rw-r--  2.0 unx     1302 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_vendor.py
--rw-rw-r--  2.0 unx     4270 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3786 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_configuration.py
--rw-rw-r--  2.0 unx      927 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_patch.py
--rw-rw-r--  2.0 unx      488 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_version.py
--rw-rw-r--  2.0 unx    59126 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx      808 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/_patch.py
-drwxrwxr-x  2.0 unx        0 b- stor 23-Feb-15 09:04 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/
--rw-rw-r--  2.0 unx     4401 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/_authorization_management_client.py
--rw-rw-r--  2.0 unx     3834 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/_configuration.py
--rw-rw-r--  2.0 unx      874 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/_patch.py
--rw-rw-r--  2.0 unx    45693 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_role_assignments_operations.py
--rw-rw-r--  2.0 unx      808 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_patch.py
--rw-rw-r--  2.0 unx    17087 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/_models_py3.py
--rw-rw-r--  2.0 unx     1294 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/__init__.py
--rw-rw-r--  2.0 unx      674 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/_patch.py
--rw-rw-r--  2.0 unx      782 b- defN 23-Feb-15 09:03 azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/_authorization_management_client_enums.py
-589 files, 5240996 bytes uncompressed, 883920 bytes compressed:  83.2%
+Zip file size: 1134795 bytes, number of entries: 666
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/tests/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/
+-rw-rw-r--  2.0 unx     1074 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/LICENSE
+-rw-rw-r--  2.0 unx      634 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/_meta.json
+-rw-rw-r--  2.0 unx    18561 b- defN 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/PKG-INFO
+-rw-rw-r--  2.0 unx      219 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/MANIFEST.in
+-rw-rw-r--  2.0 unx     2186 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/README.md
+-rw-rw-r--  2.0 unx    15463 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/CHANGELOG.md
+-rw-rw-r--  2.0 unx     2865 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/setup.py
+-rw-rw-r--  2.0 unx       38 b- defN 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/setup.cfg
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/
+-rw-rw-r--  2.0 unx       65 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/
+-rw-rw-r--  2.0 unx       26 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/py.typed
+-rw-rw-r--  2.0 unx      554 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/models.py
+-rw-rw-r--  2.0 unx    78854 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_serialization.py
+-rw-rw-r--  2.0 unx      743 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/__init__.py
+-rw-rw-r--  2.0 unx    76574 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      345 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_version.py
+-rw-rw-r--  2.0 unx     3199 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     4356 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     4492 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx     4767 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_role_assignment_metrics_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      827 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     5856 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/_role_assignment_metrics_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx      827 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx     5173 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx      982 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/__init__.py
+-rw-rw-r--  2.0 unx     4437 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_vendor.py
+-rw-rw-r--  2.0 unx     3513 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/__init__.py
+-rw-rw-r--  2.0 unx     4573 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3561 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     6196 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/_classic_administrators_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      826 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     7231 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/_classic_administrators_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/_patch.py
+-rw-rw-r--  2.0 unx      826 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/__init__.py
+-rw-rw-r--  2.0 unx     6379 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/_patch.py
+-rw-rw-r--  2.0 unx     1062 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     9409 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     9585 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx     6755 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py
+-rw-rw-r--  2.0 unx    15489 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_operations.py
+-rw-rw-r--  2.0 unx    16038 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_operations.py
+-rw-rw-r--  2.0 unx    10007 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_default_settings_operations.py
+-rw-rw-r--  2.0 unx    16581 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx     7083 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_decisions_operations.py
+-rw-rw-r--  2.0 unx     6706 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx     9720 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx     6695 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
+-rw-rw-r--  2.0 unx     2398 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    20734 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
+-rw-rw-r--  2.0 unx     5972 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx     8032 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py
+-rw-rw-r--  2.0 unx    21866 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_operations.py
+-rw-rw-r--  2.0 unx    20093 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_operations.py
+-rw-rw-r--  2.0 unx    12359 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_default_settings_operations.py
+-rw-rw-r--  2.0 unx    20511 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_my_decisions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx     8516 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_decisions_operations.py
+-rw-rw-r--  2.0 unx     7516 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx    11979 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx     7820 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
+-rw-rw-r--  2.0 unx     2398 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    26873 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_operations.py
+-rw-rw-r--  2.0 unx     6686 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_operations.py
+-rw-rw-r--  2.0 unx   110386 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     4601 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx     5362 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     8184 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     8352 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx    15489 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_operations.py
+-rw-rw-r--  2.0 unx     9331 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_operations.py
+-rw-rw-r--  2.0 unx    10007 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_default_settings_operations.py
+-rw-rw-r--  2.0 unx    16160 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx     6662 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_decisions_operations.py
+-rw-rw-r--  2.0 unx     6271 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx     9285 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx     2008 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    20299 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
+-rw-rw-r--  2.0 unx     5972 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx    21866 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_operations.py
+-rw-rw-r--  2.0 unx    11757 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_operations.py
+-rw-rw-r--  2.0 unx    12359 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_default_settings_operations.py
+-rw-rw-r--  2.0 unx    19921 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_my_decisions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx     7926 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_decisions_operations.py
+-rw-rw-r--  2.0 unx     6946 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx    11395 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx     2008 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    26303 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_operations.py
+-rw-rw-r--  2.0 unx     6686 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_operations.py
+-rw-rw-r--  2.0 unx    85033 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     3800 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx     4485 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     5712 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3242 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     5864 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3290 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx     9234 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_definitions_operations.py
+-rw-rw-r--  2.0 unx    12035 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_incidents_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx     4660 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_operation_operations.py
+-rw-rw-r--  2.0 unx    14645 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_configurations_operations.py
+-rw-rw-r--  2.0 unx     1193 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    25490 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alerts_operations.py
+-rw-rw-r--  2.0 unx    11271 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_definitions_operations.py
+-rw-rw-r--  2.0 unx    15606 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_incidents_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx     5827 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_operation_operations.py
+-rw-rw-r--  2.0 unx    17933 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_configurations_operations.py
+-rw-rw-r--  2.0 unx     1193 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    30476 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alerts_operations.py
+-rw-rw-r--  2.0 unx    40134 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     2812 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx      702 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/__init__.py
+-rw-rw-r--  2.0 unx    16820 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx    17052 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx     6682 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instances_operations.py
+-rw-rw-r--  2.0 unx    10308 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_default_settings_operations.py
+-rw-rw-r--  2.0 unx     6755 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py
+-rw-rw-r--  2.0 unx    16405 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instances_operations.py
+-rw-rw-r--  2.0 unx    15489 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_operations.py
+-rw-rw-r--  2.0 unx     9565 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definitions_operations.py
+-rw-rw-r--  2.0 unx    16038 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_operations.py
+-rw-rw-r--  2.0 unx     5426 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instance_operations.py
+-rw-rw-r--  2.0 unx     6812 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_contacted_reviewers_operations.py
+-rw-rw-r--  2.0 unx    11238 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_operations.py
+-rw-rw-r--  2.0 unx    10007 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_default_settings_operations.py
+-rw-rw-r--  2.0 unx     6611 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instances_operations.py
+-rw-rw-r--  2.0 unx    16581 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    21207 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_schedule_definitions_operations.py
+-rw-rw-r--  2.0 unx     7083 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_decisions_operations.py
+-rw-rw-r--  2.0 unx     6706 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx     9720 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx    10872 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_operations.py
+-rw-rw-r--  2.0 unx     6695 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
+-rw-rw-r--  2.0 unx     4702 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     9455 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definitions_operations.py
+-rw-rw-r--  2.0 unx    19432 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_operations.py
+-rw-rw-r--  2.0 unx    20734 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
+-rw-rw-r--  2.0 unx     7140 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_decisions_operations.py
+-rw-rw-r--  2.0 unx     5972 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx     5492 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instance_operations.py
+-rw-rw-r--  2.0 unx     7804 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instances_operations.py
+-rw-rw-r--  2.0 unx    12418 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_default_settings_operations.py
+-rw-rw-r--  2.0 unx     8032 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py
+-rw-rw-r--  2.0 unx    20268 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instances_operations.py
+-rw-rw-r--  2.0 unx    21866 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_operations.py
+-rw-rw-r--  2.0 unx    11670 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definitions_operations.py
+-rw-rw-r--  2.0 unx    20093 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_operations.py
+-rw-rw-r--  2.0 unx     6790 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instance_operations.py
+-rw-rw-r--  2.0 unx     8021 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_contacted_reviewers_operations.py
+-rw-rw-r--  2.0 unx    13742 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_operations.py
+-rw-rw-r--  2.0 unx    12359 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_default_settings_operations.py
+-rw-rw-r--  2.0 unx     7801 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instances_operations.py
+-rw-rw-r--  2.0 unx    20511 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_my_decisions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx    26982 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_schedule_definitions_operations.py
+-rw-rw-r--  2.0 unx     8516 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_decisions_operations.py
+-rw-rw-r--  2.0 unx     7516 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx    11979 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx    13519 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_operations.py
+-rw-rw-r--  2.0 unx     7820 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
+-rw-rw-r--  2.0 unx     4702 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    11759 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definitions_operations.py
+-rw-rw-r--  2.0 unx    25820 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_operations.py
+-rw-rw-r--  2.0 unx    26873 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_operations.py
+-rw-rw-r--  2.0 unx     8505 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_decisions_operations.py
+-rw-rw-r--  2.0 unx     6686 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_operations.py
+-rw-rw-r--  2.0 unx     6779 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instance_operations.py
+-rw-rw-r--  2.0 unx   157505 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     6051 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx     6202 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/_authorization_management_client_enums.py
+-rw-rw-r--  2.0 unx      588 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/__init__.py
+-rw-rw-r--  2.0 unx    77663 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3263 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     4357 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     4493 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      808 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    29233 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_deny_assignments_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx      808 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    36753 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/_deny_assignments_operations.py
+-rw-rw-r--  2.0 unx    14913 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     1246 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     4311 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     4447 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      808 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    44279 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx      808 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    56116 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx    11259 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     1294 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx      782 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     4311 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     4447 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx      808 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    45810 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx      808 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    58843 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx    17087 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     1294 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx      782 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     4703 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3242 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     4843 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3290 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx    27249 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_role_assignment_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx     1006 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    27262 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_role_eligibility_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx    33684 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/_role_assignment_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx     1006 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    33721 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/_role_eligibility_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx    41631 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     2893 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx     2490 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     8184 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     8352 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx    15489 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_operations.py
+-rw-rw-r--  2.0 unx     9766 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_operations.py
+-rw-rw-r--  2.0 unx    10007 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_default_settings_operations.py
+-rw-rw-r--  2.0 unx    16581 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx     7083 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_decisions_operations.py
+-rw-rw-r--  2.0 unx     6706 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx     9720 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx     2008 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    20734 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
+-rw-rw-r--  2.0 unx     5972 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx    21866 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_operations.py
+-rw-rw-r--  2.0 unx    12347 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_operations.py
+-rw-rw-r--  2.0 unx    12359 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_default_settings_operations.py
+-rw-rw-r--  2.0 unx    20511 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_my_decisions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx     8516 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_decisions_operations.py
+-rw-rw-r--  2.0 unx     7516 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx    11979 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
+-rw-rw-r--  2.0 unx     2008 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    26873 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_operations.py
+-rw-rw-r--  2.0 unx     6686 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_operations.py
+-rw-rw-r--  2.0 unx    94137 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     4176 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx     4852 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/__init__.py
+-rw-rw-r--  2.0 unx     7848 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_vendor.py
+-rw-rw-r--  2.0 unx     3226 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/__init__.py
+-rw-rw-r--  2.0 unx     8016 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3274 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx     9531 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedules_operations.py
+-rw-rw-r--  2.0 unx     6575 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_eligible_child_resources_operations.py
+-rw-rw-r--  2.0 unx    26653 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx     9749 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_instances_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    17341 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policies_operations.py
+-rw-rw-r--  2.0 unx     1963 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    18218 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policy_assignments_operations.py
+-rw-rw-r--  2.0 unx     9727 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_instances_operations.py
+-rw-rw-r--  2.0 unx     9510 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedules_operations.py
+-rw-rw-r--  2.0 unx    26666 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx    11716 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedules_operations.py
+-rw-rw-r--  2.0 unx     7621 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_eligible_child_resources_operations.py
+-rw-rw-r--  2.0 unx    33048 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx    11985 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_instances_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    21877 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policies_operations.py
+-rw-rw-r--  2.0 unx     1963 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/__init__.py
+-rw-rw-r--  2.0 unx    23030 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policy_assignments_operations.py
+-rw-rw-r--  2.0 unx    11970 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_instances_operations.py
+-rw-rw-r--  2.0 unx    11689 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedules_operations.py
+-rw-rw-r--  2.0 unx    33085 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx   140817 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/_patch.py
+-rw-rw-r--  2.0 unx     6980 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/__init__.py
+-rw-rw-r--  2.0 unx     4469 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     8593 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     8765 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx     9615 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedules_operations.py
+-rw-rw-r--  2.0 unx     6621 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_eligible_child_resources_operations.py
+-rw-rw-r--  2.0 unx    20721 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx     9833 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_instances_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    17534 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policies_operations.py
+-rw-rw-r--  2.0 unx     2064 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    18411 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policy_assignments_operations.py
+-rw-rw-r--  2.0 unx     9811 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_instances_operations.py
+-rw-rw-r--  2.0 unx    63505 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx     9594 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedules_operations.py
+-rw-rw-r--  2.0 unx    20692 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx    11816 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedules_operations.py
+-rw-rw-r--  2.0 unx     7675 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_eligible_child_resources_operations.py
+-rw-rw-r--  2.0 unx    25684 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx    12085 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_instances_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx    22102 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policies_operations.py
+-rw-rw-r--  2.0 unx     2064 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    23255 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policy_assignments_operations.py
+-rw-rw-r--  2.0 unx    12070 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_instances_operations.py
+-rw-rw-r--  2.0 unx    79193 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx    11789 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedules_operations.py
+-rw-rw-r--  2.0 unx    25673 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_requests_operations.py
+-rw-rw-r--  2.0 unx   159423 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     7638 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx     4469 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/__init__.py
+-rw-rw-r--  2.0 unx     6338 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_vendor.py
+-rw-rw-r--  2.0 unx     3513 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/__init__.py
+-rw-rw-r--  2.0 unx     6494 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3561 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx    11575 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_permissions_operations.py
+-rw-rw-r--  2.0 unx     6196 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_classic_administrators_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    20295 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx     9127 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_provider_operations_metadata_operations.py
+-rw-rw-r--  2.0 unx     1364 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    45683 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx     4284 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_global_administrator_operations.py
+-rw-rw-r--  2.0 unx    14667 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_permissions_operations.py
+-rw-rw-r--  2.0 unx     7231 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_classic_administrators_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    25605 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx    11061 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_provider_operations_metadata_operations.py
+-rw-rw-r--  2.0 unx     1364 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/__init__.py
+-rw-rw-r--  2.0 unx    57560 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx     5014 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_global_administrator_operations.py
+-rw-rw-r--  2.0 unx    25706 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/_patch.py
+-rw-rw-r--  2.0 unx     2218 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     5424 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     5572 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx    11659 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_permissions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    20469 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx     9211 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_provider_operations_metadata_operations.py
+-rw-rw-r--  2.0 unx     1132 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    44279 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx    14824 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_permissions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx    25766 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx    11200 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_provider_operations_metadata_operations.py
+-rw-rw-r--  2.0 unx     1132 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    56116 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx    24063 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     1868 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/__init__.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     6747 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3242 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     6907 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3290 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx     9468 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_operations.py
+-rw-rw-r--  2.0 unx     4922 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_steps_operations.py
+-rw-rw-r--  2.0 unx    18126 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_step_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    17152 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_step_operations.py
+-rw-rw-r--  2.0 unx     4776 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_steps_operations.py
+-rw-rw-r--  2.0 unx     9765 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_operations.py
+-rw-rw-r--  2.0 unx     1605 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx     5972 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_operations.py
+-rw-rw-r--  2.0 unx    11223 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_operations.py
+-rw-rw-r--  2.0 unx     6047 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_steps_operations.py
+-rw-rw-r--  2.0 unx    22156 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_step_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx    20879 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_step_operations.py
+-rw-rw-r--  2.0 unx     5766 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_steps_operations.py
+-rw-rw-r--  2.0 unx    11822 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_operations.py
+-rw-rw-r--  2.0 unx     1605 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx     6686 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_operations.py
+-rw-rw-r--  2.0 unx    19215 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     1920 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx     1452 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/__init__.py
+-rw-rw-r--  2.0 unx     4673 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_vendor.py
+-rw-rw-r--  2.0 unx     3529 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/__init__.py
+-rw-rw-r--  2.0 unx     4813 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3577 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/_configuration.py
+-rw-rw-r--  2.0 unx    11659 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_permissions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    22831 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx      896 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    14839 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/_permissions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/_patch.py
+-rw-rw-r--  2.0 unx    28128 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx      896 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/__init__.py
+-rw-rw-r--  2.0 unx    41677 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/models/_patch.py
+-rw-rw-r--  2.0 unx     2844 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/models/__init__.py
+-rw-rw-r--  2.0 unx     2144 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_patch.py
+-rw-rw-r--  2.0 unx      927 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/__init__.py
+-rw-rw-r--  2.0 unx     5842 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_authorization_management_client.py
+-rw-rw-r--  2.0 unx      486 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_version.py
+-rw-rw-r--  2.0 unx     1302 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_vendor.py
+-rw-rw-r--  2.0 unx     3513 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_configuration.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/_patch.py
+-rw-rw-r--  2.0 unx      874 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/__init__.py
+-rw-rw-r--  2.0 unx     5994 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/_authorization_management_client.py
+-rw-rw-r--  2.0 unx     3561 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/_configuration.py
+-rw-rw-r--  2.0 unx    11575 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_permissions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_patch.py
+-rw-rw-r--  2.0 unx    20230 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx     9127 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_provider_operations_metadata_operations.py
+-rw-rw-r--  2.0 unx     1233 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/__init__.py
+-rw-rw-r--  2.0 unx    49230 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx    28997 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_deny_assignments_operations.py
+-rw-rw-r--  2.0 unx    14721 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_permissions_operations.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_patch.py
+-rw-rw-r--  2.0 unx    25487 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_role_definitions_operations.py
+-rw-rw-r--  2.0 unx    11100 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_provider_operations_metadata_operations.py
+-rw-rw-r--  2.0 unx     1233 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/__init__.py
+-rw-rw-r--  2.0 unx    62500 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_role_assignments_operations.py
+-rw-rw-r--  2.0 unx    36469 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_deny_assignments_operations.py
+-rw-rw-r--  2.0 unx    74589 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/_models_py3.py
+-rw-rw-r--  2.0 unx      674 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/_patch.py
+-rw-rw-r--  2.0 unx     4019 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/__init__.py
+-rw-rw-r--  2.0 unx     2411 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/_authorization_management_client_enums.py
+drwxrwxr-x  2.0 unx        0 b- stor 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/tests/recordings/
+-rw-rw-r--  2.0 unx    15913 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/tests/test_cli_mgmt_authorization.py
+-rw-rw-r--  2.0 unx     2801 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/tests/conftest.py
+-rw-rw-r--  2.0 unx     2566 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/tests/disable_test_mgmt_authorization.py
+-rw-rw-r--  2.0 unx       39 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/tests/recordings/test_cli_mgmt_authorization.pyTestMgmtAuthorizationtest_deny_assignment.json
+-rw-rw-r--  2.0 unx    10971 b- defN 23-Jul-25 03:27 azure-mgmt-authorization-4.0.0/tests/recordings/test_cli_mgmt_authorization.pyTestMgmtAuthorizationtest_list_by_resource.json
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/dependency_links.txt
+-rw-rw-r--  2.0 unx    43813 b- defN 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/SOURCES.txt
+-rw-rw-r--  2.0 unx    18561 b- defN 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/PKG-INFO
+-rw-rw-r--  2.0 unx      124 b- defN 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/requires.txt
+-rw-rw-r--  2.0 unx        1 b- defN 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/not-zip-safe
+-rw-rw-r--  2.0 unx        6 b- defN 23-Jul-25 03:28 azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/top_level.txt
+666 files, 5621809 bytes uncompressed, 946967 bytes compressed:  83.2%
```

## zipnote {}

```diff
@@ -1,1768 +1,1999 @@
-Filename: azure-mgmt-authorization-3.1.0b1/
+Filename: azure-mgmt-authorization-4.0.0/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/tests/
+Filename: azure-mgmt-authorization-4.0.0/azure/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/
+Filename: azure-mgmt-authorization-4.0.0/tests/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/
+Filename: azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/_meta.json
+Filename: azure-mgmt-authorization-4.0.0/LICENSE
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/CHANGELOG.md
+Filename: azure-mgmt-authorization-4.0.0/_meta.json
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/setup.cfg
+Filename: azure-mgmt-authorization-4.0.0/PKG-INFO
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/PKG-INFO
+Filename: azure-mgmt-authorization-4.0.0/MANIFEST.in
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/MANIFEST.in
+Filename: azure-mgmt-authorization-4.0.0/README.md
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/README.md
+Filename: azure-mgmt-authorization-4.0.0/CHANGELOG.md
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/LICENSE
+Filename: azure-mgmt-authorization-4.0.0/setup.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/setup.py
+Filename: azure-mgmt-authorization-4.0.0/setup.cfg
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/tests/recordings/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/tests/test_cli_mgmt_authorization.py
+Filename: azure-mgmt-authorization-4.0.0/azure/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/tests/disable_test_mgmt_authorization.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/tests/conftest.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/tests/recordings/test_cli_mgmt_authorization.pyTestMgmtAuthorizationtest_deny_assignment.json
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/tests/recordings/test_cli_mgmt_authorization.pyTestMgmtAuthorizationtest_list_by_resource.json
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/requires.txt
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/SOURCES.txt
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/PKG-INFO
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/top_level.txt
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/dependency_links.txt
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/not-zip-safe
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/py.typed
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/models.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_serialization.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/py.typed
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/models.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_serialization.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_role_assignment_metrics_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/_role_assignment_metrics_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policy_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_requests_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedules_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_requests_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedules_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policies_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_eligible_child_resources_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policy_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_requests_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedules_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/_classic_administrators_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_requests_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/_classic_administrators_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedules_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policies_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_eligible_child_resources_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/_authorization_management_client_enums.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_role_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_deny_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_provider_operations_metadata_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_default_settings_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_permissions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_deny_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_provider_operations_metadata_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_permissions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_default_settings_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_my_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/_authorization_management_client_enums.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/_authorization_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_provider_operations_metadata_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_permissions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_provider_operations_metadata_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_permissions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_default_settings_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_default_settings_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_my_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/_classic_administrators_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/_authorization_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/_classic_administrators_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_default_settings_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_incidents_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_operation_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_configurations_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_configurations_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_schedule_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alerts_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_contacted_reviewers_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_incidents_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_operation_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_operation_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_configurations_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_incidents_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_default_settings_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alerts_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alerts_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/_authorization_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_my_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_default_settings_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_default_settings_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_contacted_reviewers_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_configurations_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_schedule_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_default_settings_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_contacted_reviewers_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_schedule_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_operation_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_incidents_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_default_settings_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alerts_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_default_settings_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_contacted_reviewers_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_default_settings_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_my_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/_authorization_management_client_enums.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_schedule_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/_deny_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/_authorization_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_deny_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_default_settings_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_deny_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_my_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/_deny_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_default_settings_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/_authorization_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/_authorization_management_client_enums.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_role_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_classic_administrators_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_global_administrator_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_provider_operations_metadata_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_permissions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/_authorization_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_classic_administrators_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_global_administrator_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_provider_operations_metadata_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_permissions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_role_assignment_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_role_eligibility_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/_role_assignment_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/_role_eligibility_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/_authorization_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/_authorization_management_client_enums.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_default_settings_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_default_settings_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_my_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_default_settings_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_my_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_decisions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_default_settings_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/_authorization_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/_authorization_management_client_enums.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedules_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_eligible_child_resources_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_default_settings_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policies_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_my_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policy_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedules_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedules_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_eligible_child_resources_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policies_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policy_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedules_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_default_settings_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/_authorization_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/_authorization_management_client_enums.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedules_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_eligible_child_resources_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/_role_assignment_metrics_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policies_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policy_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedules_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedules_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_role_assignment_metrics_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_eligible_child_resources_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policies_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policy_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_instances_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedules_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_requests_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_step_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_step_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/_authorization_management_client_enums.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_steps_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_steps_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_step_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_step_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_permissions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_steps_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_classic_administrators_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_steps_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_provider_operations_metadata_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_global_administrator_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_permissions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_classic_administrators_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/_authorization_management_client_enums.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_role_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_provider_operations_metadata_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_global_administrator_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policy_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_requests_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedules_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_requests_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedules_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policies_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_eligible_child_resources_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_permissions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_provider_operations_metadata_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policy_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_requests_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_permissions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedules_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_definitions_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_instances_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_provider_operations_metadata_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_requests_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_assignments_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedules_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/_models_py3.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policies_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_eligible_child_resources_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/_authorization_management_client_enums.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_version.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_vendor.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_vendor.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/_authorization_management_client.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_version.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/_configuration.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_steps_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_step_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/_authorization_management_client.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_step_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/_configuration.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_steps_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/__init__.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_role_assignments_operations.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_steps_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/_models_py3.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_step_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/__init__.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_patch.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/_patch.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_step_operations.py
 Comment: 
 
-Filename: azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/_authorization_management_client_enums.py
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_steps_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/_models_py3.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/_authorization_management_client_enums.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/models/
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_authorization_management_client.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_version.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_vendor.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_configuration.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/_authorization_management_client.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/_configuration.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_permissions_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_role_definitions_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/_permissions_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/_role_definitions_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/models/_models_py3.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/models/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/models/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/models/_authorization_management_client_enums.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_authorization_management_client.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_version.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_vendor.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_configuration.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/_authorization_management_client.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/_configuration.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_permissions_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_definitions_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_provider_operations_metadata_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_assignments_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_deny_assignments_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_permissions_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_role_definitions_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_provider_operations_metadata_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_role_assignments_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_deny_assignments_operations.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/_models_py3.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/_patch.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/__init__.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/_authorization_management_client_enums.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/tests/recordings/
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/tests/test_cli_mgmt_authorization.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/tests/conftest.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/tests/disable_test_mgmt_authorization.py
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/tests/recordings/test_cli_mgmt_authorization.pyTestMgmtAuthorizationtest_deny_assignment.json
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/tests/recordings/test_cli_mgmt_authorization.pyTestMgmtAuthorizationtest_list_by_resource.json
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/dependency_links.txt
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/SOURCES.txt
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/PKG-INFO
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/requires.txt
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/not-zip-safe
+Comment: 
+
+Filename: azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/top_level.txt
 Comment: 
 
 Zip file comment:
```

## Comparing `azure-mgmt-authorization-3.1.0b1/_meta.json` & `azure-mgmt-authorization-4.0.0/_meta.json`

 * *Files 9% similar despite different names*

### Pretty-printed

 * *Similarity: 0.7777777777777777%*

 * *Differences: {"'autorest_command'": "'autorest specification/authorization/resource-manager/readme.md "*

 * *                       '--generate-sample=True --include-x-ms-examples-original-file=True --python '*

 * *                       '--python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk '*

 * *                       '--use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 '*

 * *                       "--version=3.9.2 --version-tolerant=False'",*

 * * "'commit'": "'1af2861030243b06ee35172c95899f4809eedfc7'",*

 * * "'use'": "{i []*

```diff
@@ -1,11 +1,11 @@
 {
     "autorest": "3.9.2",
-    "autorest_command": "autorest specification/authorization/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.4.0 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
-    "commit": "d37b3db5ec88a9fc2afcae36bf8d2004b1c5b537",
+    "autorest_command": "autorest specification/authorization/resource-manager/readme.md --generate-sample=True --include-x-ms-examples-original-file=True --python --python-sdks-folder=/home/vsts/work/1/azure-sdk-for-python/sdk --use=@autorest/python@6.6.0 --use=@autorest/modelerfour@4.24.3 --version=3.9.2 --version-tolerant=False",
+    "commit": "1af2861030243b06ee35172c95899f4809eedfc7",
     "readme": "specification/authorization/resource-manager/readme.md",
     "repository_url": "https://github.com/Azure/azure-rest-api-specs",
     "use": [
-        "@autorest/python@6.4.0",
+        "@autorest/python@6.6.0",
         "@autorest/modelerfour@4.24.3"
     ]
 }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/CHANGELOG.md` & `azure-mgmt-authorization-4.0.0/CHANGELOG.md`

 * *Files 4% similar despite different names*

```diff
@@ -1,9 +1,42 @@
 # Release History
 
+## 4.0.0 (2023-07-21)
+
+### Features Added
+
+  - Added operation RoleAssignmentScheduleRequestsOperations.validate
+  - Added operation RoleEligibilityScheduleRequestsOperations.validate
+  - Model AlertConfiguration has a new parameter alert_definition
+  - Model AlertConfigurationProperties has a new parameter alert_definition
+  - Model AlertOperationResult has a new parameter created_date_time
+  - Model AlertOperationResult has a new parameter last_action_date_time
+  - Model AlertOperationResult has a new parameter resource_location
+  - Model AlertOperationResult has a new parameter status_detail
+  - Model AzureRolesAssignedOutsidePimAlertConfigurationProperties has a new parameter alert_definition
+  - Model DenyAssignment has a new parameter condition
+  - Model DenyAssignment has a new parameter condition_version
+  - Model DenyAssignment has a new parameter created_by
+  - Model DenyAssignment has a new parameter created_on
+  - Model DenyAssignment has a new parameter updated_by
+  - Model DenyAssignment has a new parameter updated_on
+  - Model DuplicateRoleCreatedAlertConfigurationProperties has a new parameter alert_definition
+  - Model Permission has a new parameter condition
+  - Model Permission has a new parameter condition_version
+  - Model RoleDefinition has a new parameter created_by
+  - Model RoleDefinition has a new parameter created_on
+  - Model RoleDefinition has a new parameter updated_by
+  - Model RoleDefinition has a new parameter updated_on
+  - Model TooManyOwnersAssignedToResourceAlertConfigurationProperties has a new parameter alert_definition
+  - Model TooManyPermanentOwnersAssignedToResourceAlertConfigurationProperties has a new parameter alert_definition
+
+### Breaking Changes
+
+  - Removed operation AlertOperationOperations.list_for_scope
+
 ## 3.1.0b1 (2023-02-15)
 
 ### Features Added
 
   - Model AlertConfiguration has a new parameter alert_definition
   - Model AlertConfigurationProperties has a new parameter alert_definition
   - Model AzureRolesAssignedOutsidePimAlertConfigurationProperties has a new parameter alert_definition
```

## Comparing `azure-mgmt-authorization-3.1.0b1/PKG-INFO` & `azure-mgmt-authorization-4.0.0/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-authorization
-Version: 3.1.0b1
+Version: 4.0.0
 Summary: Microsoft Azure Authorization Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
-Classifier: Development Status :: 4 - Beta
+Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
@@ -64,16 +64,17 @@
 
 sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
 client = AuthorizationManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
 ```
 
 ## Examples
 
-
-Code samples for this package can be found at [Authorization Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com and [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+Code samples for this package can be found at:
+- [Search Authorization Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
 
 ## Troubleshooting
 
 ## Next steps
 
 ## Provide Feedback
@@ -84,14 +85,47 @@
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-authorization%2FREADME.png)
 
 
 # Release History
 
+## 4.0.0 (2023-07-21)
+
+### Features Added
+
+  - Added operation RoleAssignmentScheduleRequestsOperations.validate
+  - Added operation RoleEligibilityScheduleRequestsOperations.validate
+  - Model AlertConfiguration has a new parameter alert_definition
+  - Model AlertConfigurationProperties has a new parameter alert_definition
+  - Model AlertOperationResult has a new parameter created_date_time
+  - Model AlertOperationResult has a new parameter last_action_date_time
+  - Model AlertOperationResult has a new parameter resource_location
+  - Model AlertOperationResult has a new parameter status_detail
+  - Model AzureRolesAssignedOutsidePimAlertConfigurationProperties has a new parameter alert_definition
+  - Model DenyAssignment has a new parameter condition
+  - Model DenyAssignment has a new parameter condition_version
+  - Model DenyAssignment has a new parameter created_by
+  - Model DenyAssignment has a new parameter created_on
+  - Model DenyAssignment has a new parameter updated_by
+  - Model DenyAssignment has a new parameter updated_on
+  - Model DuplicateRoleCreatedAlertConfigurationProperties has a new parameter alert_definition
+  - Model Permission has a new parameter condition
+  - Model Permission has a new parameter condition_version
+  - Model RoleDefinition has a new parameter created_by
+  - Model RoleDefinition has a new parameter created_on
+  - Model RoleDefinition has a new parameter updated_by
+  - Model RoleDefinition has a new parameter updated_on
+  - Model TooManyOwnersAssignedToResourceAlertConfigurationProperties has a new parameter alert_definition
+  - Model TooManyPermanentOwnersAssignedToResourceAlertConfigurationProperties has a new parameter alert_definition
+
+### Breaking Changes
+
+  - Removed operation AlertOperationOperations.list_for_scope
+
 ## 3.1.0b1 (2023-02-15)
 
 ### Features Added
 
   - Model AlertConfiguration has a new parameter alert_definition
   - Model AlertConfigurationProperties has a new parameter alert_definition
   - Model AzureRolesAssignedOutsidePimAlertConfigurationProperties has a new parameter alert_definition
```

## Comparing `azure-mgmt-authorization-3.1.0b1/README.md` & `azure-mgmt-authorization-4.0.0/README.md`

 * *Files 7% similar despite different names*

```diff
@@ -41,16 +41,17 @@
 
 sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
 client = AuthorizationManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
 ```
 
 ## Examples
 
-
-Code samples for this package can be found at [Authorization Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com and [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+Code samples for this package can be found at:
+- [Search Authorization Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
 
 ## Troubleshooting
 
 ## Next steps
 
 ## Provide Feedback
```

## Comparing `azure-mgmt-authorization-3.1.0b1/LICENSE` & `azure-mgmt-authorization-4.0.0/LICENSE`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/setup.py` & `azure-mgmt-authorization-4.0.0/setup.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,79 +1,83 @@
 #!/usr/bin/env python
 
-#-------------------------------------------------------------------------
+# -------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for
 # license information.
-#--------------------------------------------------------------------------
+# --------------------------------------------------------------------------
 
 import re
 import os.path
 from io import open
 from setuptools import find_packages, setup
 
 # Change the PACKAGE_NAME only to change folder and different name
 PACKAGE_NAME = "azure-mgmt-authorization"
 PACKAGE_PPRINT_NAME = "Authorization Management"
 
 # a-b-c => a/b/c
-package_folder_path = PACKAGE_NAME.replace('-', '/')
+package_folder_path = PACKAGE_NAME.replace("-", "/")
 # a-b-c => a.b.c
-namespace_name = PACKAGE_NAME.replace('-', '.')
+namespace_name = PACKAGE_NAME.replace("-", ".")
 
 # Version extraction inspired from 'requests'
-with open(os.path.join(package_folder_path, 'version.py')
-          if os.path.exists(os.path.join(package_folder_path, 'version.py'))
-          else os.path.join(package_folder_path, '_version.py'), 'r') as fd:
-    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]',
-                        fd.read(), re.MULTILINE).group(1)
+with open(
+    os.path.join(package_folder_path, "version.py")
+    if os.path.exists(os.path.join(package_folder_path, "version.py"))
+    else os.path.join(package_folder_path, "_version.py"),
+    "r",
+) as fd:
+    version = re.search(r'^VERSION\s*=\s*[\'"]([^\'"]*)[\'"]', fd.read(), re.MULTILINE).group(1)
 
 if not version:
-    raise RuntimeError('Cannot find version information')
+    raise RuntimeError("Cannot find version information")
 
-with open('README.md', encoding='utf-8') as f:
+with open("README.md", encoding="utf-8") as f:
     readme = f.read()
-with open('CHANGELOG.md', encoding='utf-8') as f:
+with open("CHANGELOG.md", encoding="utf-8") as f:
     changelog = f.read()
 
 setup(
     name=PACKAGE_NAME,
     version=version,
-    description='Microsoft Azure {} Client Library for Python'.format(PACKAGE_PPRINT_NAME),
-    long_description=readme + '\n\n' + changelog,
-    long_description_content_type='text/markdown',
-    license='MIT License',
-    author='Microsoft Corporation',
-    author_email='azpysdkhelp@microsoft.com',
-    url='https://github.com/Azure/azure-sdk-for-python',
+    description="Microsoft Azure {} Client Library for Python".format(PACKAGE_PPRINT_NAME),
+    long_description=readme + "\n\n" + changelog,
+    long_description_content_type="text/markdown",
+    license="MIT License",
+    author="Microsoft Corporation",
+    author_email="azpysdkhelp@microsoft.com",
+    url="https://github.com/Azure/azure-sdk-for-python",
     keywords="azure, azure sdk",  # update with search keywords relevant to the azure service / product
     classifiers=[
-        'Development Status :: 4 - Beta',
-        'Programming Language :: Python',
-        'Programming Language :: Python :: 3 :: Only',
-        'Programming Language :: Python :: 3',
-        'Programming Language :: Python :: 3.7',
-        'Programming Language :: Python :: 3.8',
-        'Programming Language :: Python :: 3.9',
-        'Programming Language :: Python :: 3.10',
-        'Programming Language :: Python :: 3.11',
-        'License :: OSI Approved :: MIT License',
+        "Development Status :: 5 - Production/Stable",
+        "Programming Language :: Python",
+        "Programming Language :: Python :: 3 :: Only",
+        "Programming Language :: Python :: 3",
+        "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
+        "Programming Language :: Python :: 3.9",
+        "Programming Language :: Python :: 3.10",
+        "Programming Language :: Python :: 3.11",
+        "License :: OSI Approved :: MIT License",
     ],
     zip_safe=False,
-    packages=find_packages(exclude=[
-        'tests',
-        # Exclude packages that will be covered by PEP420 or nspkg
-        'azure',
-        'azure.mgmt',
-    ]),
+    packages=find_packages(
+        exclude=[
+            "tests",
+            # Exclude packages that will be covered by PEP420 or nspkg
+            "azure",
+            "azure.mgmt",
+        ]
+    ),
     include_package_data=True,
     package_data={
-        'pytyped': ['py.typed'],
+        "pytyped": ["py.typed"],
     },
     install_requires=[
-        "msrest>=0.7.1",
+        "isodate<1.0.0,>=0.6.1",
         "azure-common~=1.1",
         "azure-mgmt-core>=1.3.2,<2.0.0",
         "typing-extensions>=4.3.0; python_version<'3.8.0'",
     ],
-    python_requires=">=3.7"
+    python_requires=">=3.7",
 )
```

## Comparing `azure-mgmt-authorization-3.1.0b1/tests/test_cli_mgmt_authorization.py` & `azure-mgmt-authorization-4.0.0/tests/test_cli_mgmt_authorization.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/tests/disable_test_mgmt_authorization.py` & `azure-mgmt-authorization-4.0.0/tests/disable_test_mgmt_authorization.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/tests/conftest.py` & `azure-mgmt-authorization-4.0.0/tests/conftest.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/tests/recordings/test_cli_mgmt_authorization.pyTestMgmtAuthorizationtest_list_by_resource.json` & `azure-mgmt-authorization-4.0.0/tests/recordings/test_cli_mgmt_authorization.pyTestMgmtAuthorizationtest_list_by_resource.json`

 * *Files 8% similar despite different names*

### Pretty-printed

 * *Similarity: 0.9956129807692308%*

 * *Differences: {"'Entries'": "{0: {'RequestHeaders': {'User-Agent': 'azsdk-python-identity/1.13.0 Python/3.8.17 "*

 * *              '(Linux-5.15.0-1041-azure-x86_64-with-glibc2.2.5) '*

 * *              "VSTS_0fb41ef4-5012-48a9-bf39-4ee3de03ee35_build_2500_0'}, 'ResponseHeaders': "*

 * *              "{'Date': 'Tue, 18 Jul 2023 03:44:36 GMT', 'x-ms-ests-server': '2.1.15811.5 - NCUS "*

 * *              "ProdSlices', 'x-ms-httpver': '1.1'}}, 1: {'RequestHeaders': {'User-Agent': "*

 * *              "'azsdk-python-identity/1.13.0 Python/3.8.17 "*

 * *  []*

```diff
@@ -2,15 +2,15 @@
     "Entries": [
         {
             "RequestBody": null,
             "RequestHeaders": {
                 "Accept": "*/*",
                 "Accept-Encoding": "gzip, deflate",
                 "Connection": "keep-alive",
-                "User-Agent": "azsdk-python-identity/1.12.0 Python/3.8.16 (Linux-5.15.0-1031-azure-x86_64-with-glibc2.2.5) VSTS_0fb41ef4-5012-48a9-bf39-4ee3de03ee35_build_2500_0"
+                "User-Agent": "azsdk-python-identity/1.13.0 Python/3.8.17 (Linux-5.15.0-1041-azure-x86_64-with-glibc2.2.5) VSTS_0fb41ef4-5012-48a9-bf39-4ee3de03ee35_build_2500_0"
             },
             "RequestMethod": "GET",
             "RequestUri": "https://login.microsoftonline.com/00000000-0000-0000-0000-000000000000/v2.0/.well-known/openid-configuration",
             "ResponseBody": {
                 "authorization_endpoint": "https://login.microsoftonline.com/00000000-0000-0000-0000-000000000000/oauth2/v2.0/authorize",
                 "claims_supported": [
                     "sub",
@@ -79,32 +79,33 @@
             },
             "ResponseHeaders": {
                 "Access-Control-Allow-Methods": "GET, OPTIONS",
                 "Access-Control-Allow-Origin": "*",
                 "Cache-Control": "max-age=86400, private",
                 "Content-Length": "1753",
                 "Content-Type": "application/json; charset=utf-8",
-                "Date": "Wed, 15 Feb 2023 03:43:04 GMT",
+                "Date": "Tue, 18 Jul 2023 03:44:36 GMT",
                 "P3P": "CP=\"DSP CUR OTPi IND OTRi ONL FIN\"",
                 "Set-Cookie": "[set-cookie;]",
                 "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
                 "X-Content-Type-Options": "nosniff",
                 "X-XSS-Protection": "0",
-                "x-ms-ests-server": "2.1.14649.17 - NCUS ProdSlices"
+                "x-ms-ests-server": "2.1.15811.5 - NCUS ProdSlices",
+                "x-ms-httpver": "1.1"
             },
             "StatusCode": 200
         },
         {
             "RequestBody": null,
             "RequestHeaders": {
                 "Accept": "application/json",
                 "Accept-Encoding": "gzip, deflate",
                 "Connection": "keep-alive",
                 "Cookie": "cookie;",
-                "User-Agent": "azsdk-python-identity/1.12.0 Python/3.8.16 (Linux-5.15.0-1031-azure-x86_64-with-glibc2.2.5) VSTS_0fb41ef4-5012-48a9-bf39-4ee3de03ee35_build_2500_0"
+                "User-Agent": "azsdk-python-identity/1.13.0 Python/3.8.17 (Linux-5.15.0-1041-azure-x86_64-with-glibc2.2.5) VSTS_0fb41ef4-5012-48a9-bf39-4ee3de03ee35_build_2500_0"
             },
             "RequestMethod": "GET",
             "RequestUri": "https://login.microsoftonline.com/common/discovery/instance?api-version=1.1&authorization_endpoint=https://login.microsoftonline.com/common/oauth2/authorize",
             "ResponseBody": {
                 "api-version": "1.1",
                 "metadata": [
                     {
@@ -152,41 +153,42 @@
             },
             "ResponseHeaders": {
                 "Access-Control-Allow-Methods": "GET, OPTIONS",
                 "Access-Control-Allow-Origin": "*",
                 "Cache-Control": "max-age=86400, private",
                 "Content-Length": "945",
                 "Content-Type": "application/json; charset=utf-8",
-                "Date": "Wed, 15 Feb 2023 03:43:05 GMT",
+                "Date": "Tue, 18 Jul 2023 03:44:36 GMT",
                 "P3P": "CP=\"DSP CUR OTPi IND OTRi ONL FIN\"",
                 "Set-Cookie": "[set-cookie;]",
                 "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
                 "X-Content-Type-Options": "nosniff",
                 "X-XSS-Protection": "0",
-                "x-ms-ests-server": "2.1.14601.8 - WUS2 ProdSlices"
+                "x-ms-ests-server": "2.1.15811.5 - WUS2 ProdSlices",
+                "x-ms-httpver": "1.1"
             },
             "StatusCode": 200
         },
         {
             "RequestBody": "client_id=00000000-0000-0000-0000-000000000000&grant_type=client_credentials&client_info=1&client_secret=00000000-0000-0000-0000-000000000000&claims=%7B%22access_token%22%3A+%7B%22xms_cc%22%3A+%7B%22values%22%3A+%5B%22CP1%22%5D%7D%7D%7D&scope=https%3A%2F%2Fmanagement.azure.com%2F.default",
             "RequestHeaders": {
                 "Accept": "application/json",
                 "Accept-Encoding": "gzip, deflate",
                 "Connection": "keep-alive",
                 "Content-Length": "288",
                 "Content-Type": "application/x-www-form-urlencoded",
                 "Cookie": "cookie;",
-                "User-Agent": "azsdk-python-identity/1.12.0 Python/3.8.16 (Linux-5.15.0-1031-azure-x86_64-with-glibc2.2.5) VSTS_0fb41ef4-5012-48a9-bf39-4ee3de03ee35_build_2500_0",
-                "client-request-id": "424f6838-bfde-4901-a814-82eff72266b8",
+                "User-Agent": "azsdk-python-identity/1.13.0 Python/3.8.17 (Linux-5.15.0-1041-azure-x86_64-with-glibc2.2.5) VSTS_0fb41ef4-5012-48a9-bf39-4ee3de03ee35_build_2500_0",
+                "client-request-id": "034fe16e-bd26-411b-bf4d-1ac375589c97",
                 "x-client-cpu": "x64",
                 "x-client-current-telemetry": "4|730,0|",
                 "x-client-last-telemetry": "4|0|||",
                 "x-client-os": "linux",
                 "x-client-sku": "MSAL.Python",
-                "x-client-ver": "1.21.0",
+                "x-client-ver": "1.22.0",
                 "x-ms-lib-capability": "retry-after, h429"
             },
             "RequestMethod": "POST",
             "RequestUri": "https://login.microsoftonline.com/00000000-0000-0000-0000-000000000000/oauth2/v2.0/token",
             "ResponseBody": {
                 "access_token": "access_token",
                 "expires_in": 86399,
@@ -194,39 +196,40 @@
                 "refresh_in": 43199,
                 "token_type": "Bearer"
             },
             "ResponseHeaders": {
                 "Cache-Control": "no-store, no-cache",
                 "Content-Length": "114",
                 "Content-Type": "application/json; charset=utf-8",
-                "Date": "Wed, 15 Feb 2023 03:43:05 GMT",
+                "Date": "Tue, 18 Jul 2023 03:44:36 GMT",
                 "Expires": "-1",
                 "P3P": "CP=\"DSP CUR OTPi IND OTRi ONL FIN\"",
                 "Pragma": "no-cache",
                 "Set-Cookie": "[set-cookie;]",
                 "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
                 "X-Content-Type-Options": "nosniff",
                 "X-XSS-Protection": "0",
-                "client-request-id": "424f6838-bfde-4901-a814-82eff72266b8",
+                "client-request-id": "034fe16e-bd26-411b-bf4d-1ac375589c97",
                 "x-ms-clitelem": "1,0,0,,",
-                "x-ms-ests-server": "2.1.14649.17 - EUS ProdSlices"
+                "x-ms-ests-server": "2.1.15811.5 - SCUS ProdSlices",
+                "x-ms-httpver": "1.1"
             },
             "StatusCode": 200
         },
         {
             "RequestBody": {
                 "location": "eastus"
             },
             "RequestHeaders": {
                 "Accept": "application/json",
                 "Accept-Encoding": "gzip, deflate",
                 "Connection": "keep-alive",
                 "Content-Length": "22",
                 "Content-Type": "application/json",
-                "User-Agent": "azsdk-python-azure-mgmt-resource/22.0.0 Python/3.8.16 (Linux-5.15.0-1031-azure-x86_64-with-glibc2.2.5) VSTS_0fb41ef4-5012-48a9-bf39-4ee3de03ee35_build_2500_0"
+                "User-Agent": "azsdk-python-azure-mgmt-resource/23.1.0b2 Python/3.8.17 (Linux-5.15.0-1041-azure-x86_64-with-glibc2.2.5) VSTS_0fb41ef4-5012-48a9-bf39-4ee3de03ee35_build_2500_0"
             },
             "RequestMethod": "PUT",
             "RequestUri": "https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rgname/providers/Microsoft.Compute/availabilitySets/resourcexxx?api-version=2019-07-01",
             "ResponseBody": {
                 "id": "/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/rgname/providers/Microsoft.Compute/availabilitySets/resourcexxx",
                 "location": "eastus",
                 "name": "resourcexxx",
@@ -239,28 +242,28 @@
                 },
                 "type": "Microsoft.Compute/availabilitySets"
             },
             "ResponseHeaders": {
                 "Cache-Control": "no-cache",
                 "Content-Encoding": "gzip",
                 "Content-Type": "application/json; charset=utf-8",
-                "Date": "Wed, 15 Feb 2023 03:43:07 GMT",
+                "Date": "Tue, 18 Jul 2023 03:44:37 GMT",
                 "Expires": "-1",
                 "Pragma": "no-cache",
                 "Server": [
                     "Microsoft-HTTPAPI/2.0",
                     "Microsoft-HTTPAPI/2.0"
                 ],
                 "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
                 "Transfer-Encoding": "chunked",
                 "Vary": "Accept-Encoding",
                 "X-Content-Type-Options": "nosniff",
-                "x-ms-correlation-request-id": "bf9c1e16-4e9d-41de-9df3-c967617fe137",
+                "x-ms-correlation-request-id": "d73cba54-b058-419a-8614-1864e1d1b6bd",
                 "x-ms-ratelimit-remaining-resource": "Microsoft.Compute/PutVM3Min;239,Microsoft.Compute/PutVM30Min;1199",
                 "x-ms-ratelimit-remaining-subscription-writes": "1199",
-                "x-ms-routing-request-id": "SOUTHCENTRALUS:20230215T034308Z:bf9c1e16-4e9d-41de-9df3-c967617fe137"
+                "x-ms-routing-request-id": "CENTRALUS:20230718T034437Z:d73cba54-b058-419a-8614-1864e1d1b6bd"
             },
             "StatusCode": 200
         }
     ],
     "Variables": {}
 }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/SOURCES.txt` & `azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/SOURCES.txt`

 * *Files 2% similar despite different names*

```diff
@@ -405,19 +405,14 @@
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_decisions_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_operations.py
-azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_configurations_operations.py
-azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_definitions_operations.py
-azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_incidents_operations.py
-azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_operation_operations.py
-azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alerts_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_patch.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_default_settings_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instance_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instances_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definitions_operations.py
@@ -441,19 +436,14 @@
 azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_decisions_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_my_decisions_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_operations.py
-azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_configurations_operations.py
-azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_definitions_operations.py
-azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_incidents_operations.py
-azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_operation_operations.py
-azure/mgmt/authorization/v2021_12_01_preview/operations/_alerts_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_patch.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_default_settings_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instance_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instances_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_operations.py
 azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definitions_operations.py
@@ -487,14 +477,86 @@
 azure/mgmt/authorization/v2022_04_01/operations/__init__.py
 azure/mgmt/authorization/v2022_04_01/operations/_deny_assignments_operations.py
 azure/mgmt/authorization/v2022_04_01/operations/_patch.py
 azure/mgmt/authorization/v2022_04_01/operations/_permissions_operations.py
 azure/mgmt/authorization/v2022_04_01/operations/_provider_operations_metadata_operations.py
 azure/mgmt/authorization/v2022_04_01/operations/_role_assignments_operations.py
 azure/mgmt/authorization/v2022_04_01/operations/_role_definitions_operations.py
+azure/mgmt/authorization/v2022_04_01_preview/__init__.py
+azure/mgmt/authorization/v2022_04_01_preview/_authorization_management_client.py
+azure/mgmt/authorization/v2022_04_01_preview/_configuration.py
+azure/mgmt/authorization/v2022_04_01_preview/_patch.py
+azure/mgmt/authorization/v2022_04_01_preview/_vendor.py
+azure/mgmt/authorization/v2022_04_01_preview/_version.py
+azure/mgmt/authorization/v2022_04_01_preview/aio/__init__.py
+azure/mgmt/authorization/v2022_04_01_preview/aio/_authorization_management_client.py
+azure/mgmt/authorization/v2022_04_01_preview/aio/_configuration.py
+azure/mgmt/authorization/v2022_04_01_preview/aio/_patch.py
+azure/mgmt/authorization/v2022_04_01_preview/aio/operations/__init__.py
+azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_patch.py
+azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_role_assignment_schedule_requests_operations.py
+azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_role_eligibility_schedule_requests_operations.py
+azure/mgmt/authorization/v2022_04_01_preview/models/__init__.py
+azure/mgmt/authorization/v2022_04_01_preview/models/_authorization_management_client_enums.py
+azure/mgmt/authorization/v2022_04_01_preview/models/_models_py3.py
+azure/mgmt/authorization/v2022_04_01_preview/models/_patch.py
+azure/mgmt/authorization/v2022_04_01_preview/operations/__init__.py
+azure/mgmt/authorization/v2022_04_01_preview/operations/_patch.py
+azure/mgmt/authorization/v2022_04_01_preview/operations/_role_assignment_schedule_requests_operations.py
+azure/mgmt/authorization/v2022_04_01_preview/operations/_role_eligibility_schedule_requests_operations.py
+azure/mgmt/authorization/v2022_05_01_preview/__init__.py
+azure/mgmt/authorization/v2022_05_01_preview/_authorization_management_client.py
+azure/mgmt/authorization/v2022_05_01_preview/_configuration.py
+azure/mgmt/authorization/v2022_05_01_preview/_patch.py
+azure/mgmt/authorization/v2022_05_01_preview/_vendor.py
+azure/mgmt/authorization/v2022_05_01_preview/_version.py
+azure/mgmt/authorization/v2022_05_01_preview/aio/__init__.py
+azure/mgmt/authorization/v2022_05_01_preview/aio/_authorization_management_client.py
+azure/mgmt/authorization/v2022_05_01_preview/aio/_configuration.py
+azure/mgmt/authorization/v2022_05_01_preview/aio/_patch.py
+azure/mgmt/authorization/v2022_05_01_preview/aio/operations/__init__.py
+azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_patch.py
+azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_permissions_operations.py
+azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_role_definitions_operations.py
+azure/mgmt/authorization/v2022_05_01_preview/models/__init__.py
+azure/mgmt/authorization/v2022_05_01_preview/models/_authorization_management_client_enums.py
+azure/mgmt/authorization/v2022_05_01_preview/models/_models_py3.py
+azure/mgmt/authorization/v2022_05_01_preview/models/_patch.py
+azure/mgmt/authorization/v2022_05_01_preview/operations/__init__.py
+azure/mgmt/authorization/v2022_05_01_preview/operations/_patch.py
+azure/mgmt/authorization/v2022_05_01_preview/operations/_permissions_operations.py
+azure/mgmt/authorization/v2022_05_01_preview/operations/_role_definitions_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/__init__.py
+azure/mgmt/authorization/v2022_08_01_preview/_authorization_management_client.py
+azure/mgmt/authorization/v2022_08_01_preview/_configuration.py
+azure/mgmt/authorization/v2022_08_01_preview/_patch.py
+azure/mgmt/authorization/v2022_08_01_preview/_vendor.py
+azure/mgmt/authorization/v2022_08_01_preview/_version.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/__init__.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/_authorization_management_client.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/_configuration.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/_patch.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/operations/__init__.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_configurations_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_definitions_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_incidents_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_operation_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alerts_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_patch.py
+azure/mgmt/authorization/v2022_08_01_preview/models/__init__.py
+azure/mgmt/authorization/v2022_08_01_preview/models/_authorization_management_client_enums.py
+azure/mgmt/authorization/v2022_08_01_preview/models/_models_py3.py
+azure/mgmt/authorization/v2022_08_01_preview/models/_patch.py
+azure/mgmt/authorization/v2022_08_01_preview/operations/__init__.py
+azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_configurations_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_definitions_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_incidents_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_operation_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/operations/_alerts_operations.py
+azure/mgmt/authorization/v2022_08_01_preview/operations/_patch.py
 azure_mgmt_authorization.egg-info/PKG-INFO
 azure_mgmt_authorization.egg-info/SOURCES.txt
 azure_mgmt_authorization.egg-info/dependency_links.txt
 azure_mgmt_authorization.egg-info/not-zip-safe
 azure_mgmt_authorization.egg-info/requires.txt
 azure_mgmt_authorization.egg-info/top_level.txt
 tests/conftest.py
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure_mgmt_authorization.egg-info/PKG-INFO` & `azure-mgmt-authorization-4.0.0/azure_mgmt_authorization.egg-info/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 Metadata-Version: 2.1
 Name: azure-mgmt-authorization
-Version: 3.1.0b1
+Version: 4.0.0
 Summary: Microsoft Azure Authorization Management Client Library for Python
 Home-page: https://github.com/Azure/azure-sdk-for-python
 Author: Microsoft Corporation
 Author-email: azpysdkhelp@microsoft.com
 License: MIT License
 Keywords: azure,azure sdk
-Classifier: Development Status :: 4 - Beta
+Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python
 Classifier: Programming Language :: Python :: 3 :: Only
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
@@ -64,16 +64,17 @@
 
 sub_id = os.getenv("AZURE_SUBSCRIPTION_ID")
 client = AuthorizationManagementClient(credential=DefaultAzureCredential(), subscription_id=sub_id)
 ```
 
 ## Examples
 
-
-Code samples for this package can be found at [Authorization Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com and [Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
+Code samples for this package can be found at:
+- [Search Authorization Management](https://docs.microsoft.com/samples/browse/?languages=python&term=Getting%20started%20-%20Managing&terms=Getting%20started%20-%20Managing) on docs.microsoft.com
+- [Azure Python Mgmt SDK Samples Repo](https://aka.ms/azsdk/python/mgmt/samples)
 
 
 ## Troubleshooting
 
 ## Next steps
 
 ## Provide Feedback
@@ -84,14 +85,47 @@
 
 
 ![Impressions](https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-python%2Fazure-mgmt-authorization%2FREADME.png)
 
 
 # Release History
 
+## 4.0.0 (2023-07-21)
+
+### Features Added
+
+  - Added operation RoleAssignmentScheduleRequestsOperations.validate
+  - Added operation RoleEligibilityScheduleRequestsOperations.validate
+  - Model AlertConfiguration has a new parameter alert_definition
+  - Model AlertConfigurationProperties has a new parameter alert_definition
+  - Model AlertOperationResult has a new parameter created_date_time
+  - Model AlertOperationResult has a new parameter last_action_date_time
+  - Model AlertOperationResult has a new parameter resource_location
+  - Model AlertOperationResult has a new parameter status_detail
+  - Model AzureRolesAssignedOutsidePimAlertConfigurationProperties has a new parameter alert_definition
+  - Model DenyAssignment has a new parameter condition
+  - Model DenyAssignment has a new parameter condition_version
+  - Model DenyAssignment has a new parameter created_by
+  - Model DenyAssignment has a new parameter created_on
+  - Model DenyAssignment has a new parameter updated_by
+  - Model DenyAssignment has a new parameter updated_on
+  - Model DuplicateRoleCreatedAlertConfigurationProperties has a new parameter alert_definition
+  - Model Permission has a new parameter condition
+  - Model Permission has a new parameter condition_version
+  - Model RoleDefinition has a new parameter created_by
+  - Model RoleDefinition has a new parameter created_on
+  - Model RoleDefinition has a new parameter updated_by
+  - Model RoleDefinition has a new parameter updated_on
+  - Model TooManyOwnersAssignedToResourceAlertConfigurationProperties has a new parameter alert_definition
+  - Model TooManyPermanentOwnersAssignedToResourceAlertConfigurationProperties has a new parameter alert_definition
+
+### Breaking Changes
+
+  - Removed operation AlertOperationOperations.list_for_scope
+
 ## 3.1.0b1 (2023-02-15)
 
 ### Features Added
 
   - Model AlertConfiguration has a new parameter alert_definition
   - Model AlertConfigurationProperties has a new parameter alert_definition
   - Model AzureRolesAssignedOutsidePimAlertConfigurationProperties has a new parameter alert_definition
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/models.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/models.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_authorization_management_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -67,19 +67,14 @@
             'access_review_instance_contacted_reviewers': '2021-12-01-preview',
             'access_review_instance_decisions': '2021-12-01-preview',
             'access_review_instance_my_decisions': '2021-12-01-preview',
             'access_review_instances': '2021-12-01-preview',
             'access_review_instances_assigned_for_my_approval': '2021-12-01-preview',
             'access_review_schedule_definitions': '2021-12-01-preview',
             'access_review_schedule_definitions_assigned_for_my_approval': '2021-12-01-preview',
-            'alert_configurations': '2021-12-01-preview',
-            'alert_definitions': '2021-12-01-preview',
-            'alert_incidents': '2021-12-01-preview',
-            'alert_operation': '2021-12-01-preview',
-            'alerts': '2021-12-01-preview',
             'classic_administrators': '2015-07-01',
             'eligible_child_resources': '2020-10-01',
             'global_administrator': '2015-07-01',
             'operations': '2021-12-01-preview',
             'role_assignment_approval': '2021-01-01-preview',
             'role_assignment_approval_step': '2021-01-01-preview',
             'role_assignment_approval_steps': '2021-01-01-preview',
@@ -115,14 +110,16 @@
         credential: "TokenCredential",
         subscription_id: str,
         api_version: Optional[str]=None,
         base_url: str = "https://management.azure.com",
         profile: KnownProfiles=KnownProfiles.default,
         **kwargs: Any
     ):
+        if api_version:
+            kwargs.setdefault('api_version', api_version)
         self._config = AuthorizationManagementClientConfiguration(credential, subscription_id, **kwargs)
         self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
         super(AuthorizationManagementClient, self).__init__(
             api_version=api_version,
             profile=profile
         )
 
@@ -145,14 +142,17 @@
            * 2020-10-01: :mod:`v2020_10_01.models<azure.mgmt.authorization.v2020_10_01.models>`
            * 2020-10-01-preview: :mod:`v2020_10_01_preview.models<azure.mgmt.authorization.v2020_10_01_preview.models>`
            * 2021-01-01-preview: :mod:`v2021_01_01_preview.models<azure.mgmt.authorization.v2021_01_01_preview.models>`
            * 2021-03-01-preview: :mod:`v2021_03_01_preview.models<azure.mgmt.authorization.v2021_03_01_preview.models>`
            * 2021-07-01-preview: :mod:`v2021_07_01_preview.models<azure.mgmt.authorization.v2021_07_01_preview.models>`
            * 2021-12-01-preview: :mod:`v2021_12_01_preview.models<azure.mgmt.authorization.v2021_12_01_preview.models>`
            * 2022-04-01: :mod:`v2022_04_01.models<azure.mgmt.authorization.v2022_04_01.models>`
+           * 2022-04-01-preview: :mod:`v2022_04_01_preview.models<azure.mgmt.authorization.v2022_04_01_preview.models>`
+           * 2022-05-01-preview: :mod:`v2022_05_01_preview.models<azure.mgmt.authorization.v2022_05_01_preview.models>`
+           * 2022-08-01-preview: :mod:`v2022_08_01_preview.models<azure.mgmt.authorization.v2022_08_01_preview.models>`
         """
         if api_version == '2015-06-01':
             from .v2015_06_01 import models
             return models
         elif api_version == '2015-07-01':
             from .v2015_07_01 import models
             return models
@@ -191,14 +191,23 @@
             return models
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview import models
             return models
         elif api_version == '2022-04-01':
             from .v2022_04_01 import models
             return models
+        elif api_version == '2022-04-01-preview':
+            from .v2022_04_01_preview import models
+            return models
+        elif api_version == '2022-05-01-preview':
+            from .v2022_05_01_preview import models
+            return models
+        elif api_version == '2022-08-01-preview':
+            from .v2022_08_01_preview import models
+            return models
         raise ValueError("API version {} is not available".format(api_version))
 
     @property
     def access_review_default_settings(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewDefaultSettingsOperations<azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewDefaultSettingsOperations>`
@@ -214,71 +223,71 @@
         elif api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import AccessReviewDefaultSettingsOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewDefaultSettingsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_default_settings'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_history_definition(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`AccessReviewHistoryDefinitionOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.AccessReviewHistoryDefinitionOperations>`
         """
         api_version = self._get_api_version('access_review_history_definition')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewHistoryDefinitionOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_history_definition'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_history_definition_instance(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`AccessReviewHistoryDefinitionInstanceOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.AccessReviewHistoryDefinitionInstanceOperations>`
         """
         api_version = self._get_api_version('access_review_history_definition_instance')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewHistoryDefinitionInstanceOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_history_definition_instance'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_history_definition_instances(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`AccessReviewHistoryDefinitionInstancesOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.AccessReviewHistoryDefinitionInstancesOperations>`
         """
         api_version = self._get_api_version('access_review_history_definition_instances')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewHistoryDefinitionInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_history_definition_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_history_definitions(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`AccessReviewHistoryDefinitionsOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.AccessReviewHistoryDefinitionsOperations>`
         """
         api_version = self._get_api_version('access_review_history_definitions')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewHistoryDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_history_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instance(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewInstanceOperations<azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstanceOperations>`
            * 2021-03-01-preview: :class:`AccessReviewInstanceOperations<azure.mgmt.authorization.v2021_03_01_preview.operations.AccessReviewInstanceOperations>`
@@ -293,15 +302,15 @@
         elif api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import AccessReviewInstanceOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewInstanceOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instance'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instance_contacted_reviewers(self):
         """Instance depends on the API version:
 
            * 2021-07-01-preview: :class:`AccessReviewInstanceContactedReviewersOperations<azure.mgmt.authorization.v2021_07_01_preview.operations.AccessReviewInstanceContactedReviewersOperations>`
            * 2021-12-01-preview: :class:`AccessReviewInstanceContactedReviewersOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.AccessReviewInstanceContactedReviewersOperations>`
@@ -310,15 +319,15 @@
         if api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import AccessReviewInstanceContactedReviewersOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewInstanceContactedReviewersOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instance_contacted_reviewers'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instance_decisions(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewInstanceDecisionsOperations<azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstanceDecisionsOperations>`
            * 2021-03-01-preview: :class:`AccessReviewInstanceDecisionsOperations<azure.mgmt.authorization.v2021_03_01_preview.operations.AccessReviewInstanceDecisionsOperations>`
@@ -333,15 +342,15 @@
         elif api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import AccessReviewInstanceDecisionsOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewInstanceDecisionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instance_decisions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instance_my_decisions(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewInstanceMyDecisionsOperations<azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstanceMyDecisionsOperations>`
            * 2021-03-01-preview: :class:`AccessReviewInstanceMyDecisionsOperations<azure.mgmt.authorization.v2021_03_01_preview.operations.AccessReviewInstanceMyDecisionsOperations>`
@@ -356,15 +365,15 @@
         elif api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import AccessReviewInstanceMyDecisionsOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewInstanceMyDecisionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instance_my_decisions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instances(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewInstancesOperations<azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstancesOperations>`
            * 2021-03-01-preview: :class:`AccessReviewInstancesOperations<azure.mgmt.authorization.v2021_03_01_preview.operations.AccessReviewInstancesOperations>`
@@ -379,15 +388,15 @@
         elif api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import AccessReviewInstancesOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instances_assigned_for_my_approval(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewInstancesAssignedForMyApprovalOperations<azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstancesAssignedForMyApprovalOperations>`
            * 2021-03-01-preview: :class:`AccessReviewInstancesAssignedForMyApprovalOperations<azure.mgmt.authorization.v2021_03_01_preview.operations.AccessReviewInstancesAssignedForMyApprovalOperations>`
@@ -402,15 +411,15 @@
         elif api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import AccessReviewInstancesAssignedForMyApprovalOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewInstancesAssignedForMyApprovalOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instances_assigned_for_my_approval'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_schedule_definitions(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewScheduleDefinitionsOperations<azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewScheduleDefinitionsOperations>`
            * 2021-03-01-preview: :class:`AccessReviewScheduleDefinitionsOperations<azure.mgmt.authorization.v2021_03_01_preview.operations.AccessReviewScheduleDefinitionsOperations>`
@@ -425,15 +434,15 @@
         elif api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import AccessReviewScheduleDefinitionsOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewScheduleDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_schedule_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_schedule_definitions_assigned_for_my_approval(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations<azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations>`
            * 2021-03-01-preview: :class:`AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations<azure.mgmt.authorization.v2021_03_01_preview.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations>`
@@ -448,85 +457,85 @@
         elif api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_schedule_definitions_assigned_for_my_approval'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def alert_configurations(self):
         """Instance depends on the API version:
 
-           * 2021-12-01-preview: :class:`AlertConfigurationsOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.AlertConfigurationsOperations>`
+           * 2022-08-01-preview: :class:`AlertConfigurationsOperations<azure.mgmt.authorization.v2022_08_01_preview.operations.AlertConfigurationsOperations>`
         """
         api_version = self._get_api_version('alert_configurations')
-        if api_version == '2021-12-01-preview':
-            from .v2021_12_01_preview.operations import AlertConfigurationsOperations as OperationClass
+        if api_version == '2022-08-01-preview':
+            from .v2022_08_01_preview.operations import AlertConfigurationsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'alert_configurations'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def alert_definitions(self):
         """Instance depends on the API version:
 
-           * 2021-12-01-preview: :class:`AlertDefinitionsOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.AlertDefinitionsOperations>`
+           * 2022-08-01-preview: :class:`AlertDefinitionsOperations<azure.mgmt.authorization.v2022_08_01_preview.operations.AlertDefinitionsOperations>`
         """
         api_version = self._get_api_version('alert_definitions')
-        if api_version == '2021-12-01-preview':
-            from .v2021_12_01_preview.operations import AlertDefinitionsOperations as OperationClass
+        if api_version == '2022-08-01-preview':
+            from .v2022_08_01_preview.operations import AlertDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'alert_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def alert_incidents(self):
         """Instance depends on the API version:
 
-           * 2021-12-01-preview: :class:`AlertIncidentsOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.AlertIncidentsOperations>`
+           * 2022-08-01-preview: :class:`AlertIncidentsOperations<azure.mgmt.authorization.v2022_08_01_preview.operations.AlertIncidentsOperations>`
         """
         api_version = self._get_api_version('alert_incidents')
-        if api_version == '2021-12-01-preview':
-            from .v2021_12_01_preview.operations import AlertIncidentsOperations as OperationClass
+        if api_version == '2022-08-01-preview':
+            from .v2022_08_01_preview.operations import AlertIncidentsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'alert_incidents'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def alert_operation(self):
         """Instance depends on the API version:
 
-           * 2021-12-01-preview: :class:`AlertOperationOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.AlertOperationOperations>`
+           * 2022-08-01-preview: :class:`AlertOperationOperations<azure.mgmt.authorization.v2022_08_01_preview.operations.AlertOperationOperations>`
         """
         api_version = self._get_api_version('alert_operation')
-        if api_version == '2021-12-01-preview':
-            from .v2021_12_01_preview.operations import AlertOperationOperations as OperationClass
+        if api_version == '2022-08-01-preview':
+            from .v2022_08_01_preview.operations import AlertOperationOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'alert_operation'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def alerts(self):
         """Instance depends on the API version:
 
-           * 2021-12-01-preview: :class:`AlertsOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.AlertsOperations>`
+           * 2022-08-01-preview: :class:`AlertsOperations<azure.mgmt.authorization.v2022_08_01_preview.operations.AlertsOperations>`
         """
         api_version = self._get_api_version('alerts')
-        if api_version == '2021-12-01-preview':
-            from .v2021_12_01_preview.operations import AlertsOperations as OperationClass
+        if api_version == '2022-08-01-preview':
+            from .v2022_08_01_preview.operations import AlertsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'alerts'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def classic_administrators(self):
         """Instance depends on the API version:
 
            * 2015-06-01: :class:`ClassicAdministratorsOperations<azure.mgmt.authorization.v2015_06_01.operations.ClassicAdministratorsOperations>`
            * 2015-07-01: :class:`ClassicAdministratorsOperations<azure.mgmt.authorization.v2015_07_01.operations.ClassicAdministratorsOperations>`
@@ -535,15 +544,15 @@
         if api_version == '2015-06-01':
             from .v2015_06_01.operations import ClassicAdministratorsOperations as OperationClass
         elif api_version == '2015-07-01':
             from .v2015_07_01.operations import ClassicAdministratorsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'classic_administrators'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def deny_assignments(self):
         """Instance depends on the API version:
 
            * 2018-07-01-preview: :class:`DenyAssignmentsOperations<azure.mgmt.authorization.v2018_07_01_preview.operations.DenyAssignmentsOperations>`
            * 2022-04-01: :class:`DenyAssignmentsOperations<azure.mgmt.authorization.v2022_04_01.operations.DenyAssignmentsOperations>`
@@ -552,15 +561,15 @@
         if api_version == '2018-07-01-preview':
             from .v2018_07_01_preview.operations import DenyAssignmentsOperations as OperationClass
         elif api_version == '2022-04-01':
             from .v2022_04_01.operations import DenyAssignmentsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'deny_assignments'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def eligible_child_resources(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`EligibleChildResourcesOperations<azure.mgmt.authorization.v2020_10_01.operations.EligibleChildResourcesOperations>`
            * 2020-10-01-preview: :class:`EligibleChildResourcesOperations<azure.mgmt.authorization.v2020_10_01_preview.operations.EligibleChildResourcesOperations>`
@@ -569,29 +578,29 @@
         if api_version == '2020-10-01':
             from .v2020_10_01.operations import EligibleChildResourcesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from .v2020_10_01_preview.operations import EligibleChildResourcesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'eligible_child_resources'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def global_administrator(self):
         """Instance depends on the API version:
 
            * 2015-07-01: :class:`GlobalAdministratorOperations<azure.mgmt.authorization.v2015_07_01.operations.GlobalAdministratorOperations>`
         """
         api_version = self._get_api_version('global_administrator')
         if api_version == '2015-07-01':
             from .v2015_07_01.operations import GlobalAdministratorOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'global_administrator'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def operations(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`Operations<azure.mgmt.authorization.v2018_05_01_preview.operations.Operations>`
            * 2021-01-01-preview: :class:`Operations<azure.mgmt.authorization.v2021_01_01_preview.operations.Operations>`
@@ -609,35 +618,38 @@
         elif api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import Operations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import Operations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'operations'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def permissions(self):
         """Instance depends on the API version:
 
            * 2015-07-01: :class:`PermissionsOperations<azure.mgmt.authorization.v2015_07_01.operations.PermissionsOperations>`
            * 2018-01-01-preview: :class:`PermissionsOperations<azure.mgmt.authorization.v2018_01_01_preview.operations.PermissionsOperations>`
            * 2022-04-01: :class:`PermissionsOperations<azure.mgmt.authorization.v2022_04_01.operations.PermissionsOperations>`
+           * 2022-05-01-preview: :class:`PermissionsOperations<azure.mgmt.authorization.v2022_05_01_preview.operations.PermissionsOperations>`
         """
         api_version = self._get_api_version('permissions')
         if api_version == '2015-07-01':
             from .v2015_07_01.operations import PermissionsOperations as OperationClass
         elif api_version == '2018-01-01-preview':
             from .v2018_01_01_preview.operations import PermissionsOperations as OperationClass
         elif api_version == '2022-04-01':
             from .v2022_04_01.operations import PermissionsOperations as OperationClass
+        elif api_version == '2022-05-01-preview':
+            from .v2022_05_01_preview.operations import PermissionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'permissions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def provider_operations_metadata(self):
         """Instance depends on the API version:
 
            * 2015-07-01: :class:`ProviderOperationsMetadataOperations<azure.mgmt.authorization.v2015_07_01.operations.ProviderOperationsMetadataOperations>`
            * 2018-01-01-preview: :class:`ProviderOperationsMetadataOperations<azure.mgmt.authorization.v2018_01_01_preview.operations.ProviderOperationsMetadataOperations>`
@@ -649,71 +661,71 @@
         elif api_version == '2018-01-01-preview':
             from .v2018_01_01_preview.operations import ProviderOperationsMetadataOperations as OperationClass
         elif api_version == '2022-04-01':
             from .v2022_04_01.operations import ProviderOperationsMetadataOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'provider_operations_metadata'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_approval(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`RoleAssignmentApprovalOperations<azure.mgmt.authorization.v2021_01_01_preview.operations.RoleAssignmentApprovalOperations>`
         """
         api_version = self._get_api_version('role_assignment_approval')
         if api_version == '2021-01-01-preview':
             from .v2021_01_01_preview.operations import RoleAssignmentApprovalOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_approval'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_approval_step(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`RoleAssignmentApprovalStepOperations<azure.mgmt.authorization.v2021_01_01_preview.operations.RoleAssignmentApprovalStepOperations>`
         """
         api_version = self._get_api_version('role_assignment_approval_step')
         if api_version == '2021-01-01-preview':
             from .v2021_01_01_preview.operations import RoleAssignmentApprovalStepOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_approval_step'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_approval_steps(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`RoleAssignmentApprovalStepsOperations<azure.mgmt.authorization.v2021_01_01_preview.operations.RoleAssignmentApprovalStepsOperations>`
         """
         api_version = self._get_api_version('role_assignment_approval_steps')
         if api_version == '2021-01-01-preview':
             from .v2021_01_01_preview.operations import RoleAssignmentApprovalStepsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_approval_steps'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_metrics(self):
         """Instance depends on the API version:
 
            * 2019-08-01-preview: :class:`RoleAssignmentMetricsOperations<azure.mgmt.authorization.v2019_08_01_preview.operations.RoleAssignmentMetricsOperations>`
         """
         api_version = self._get_api_version('role_assignment_metrics')
         if api_version == '2019-08-01-preview':
             from .v2019_08_01_preview.operations import RoleAssignmentMetricsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_metrics'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_schedule_instances(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleAssignmentScheduleInstancesOperations<azure.mgmt.authorization.v2020_10_01.operations.RoleAssignmentScheduleInstancesOperations>`
            * 2020-10-01-preview: :class:`RoleAssignmentScheduleInstancesOperations<azure.mgmt.authorization.v2020_10_01_preview.operations.RoleAssignmentScheduleInstancesOperations>`
@@ -722,32 +734,35 @@
         if api_version == '2020-10-01':
             from .v2020_10_01.operations import RoleAssignmentScheduleInstancesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from .v2020_10_01_preview.operations import RoleAssignmentScheduleInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_schedule_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_schedule_requests(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleAssignmentScheduleRequestsOperations<azure.mgmt.authorization.v2020_10_01.operations.RoleAssignmentScheduleRequestsOperations>`
            * 2020-10-01-preview: :class:`RoleAssignmentScheduleRequestsOperations<azure.mgmt.authorization.v2020_10_01_preview.operations.RoleAssignmentScheduleRequestsOperations>`
+           * 2022-04-01-preview: :class:`RoleAssignmentScheduleRequestsOperations<azure.mgmt.authorization.v2022_04_01_preview.operations.RoleAssignmentScheduleRequestsOperations>`
         """
         api_version = self._get_api_version('role_assignment_schedule_requests')
         if api_version == '2020-10-01':
             from .v2020_10_01.operations import RoleAssignmentScheduleRequestsOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from .v2020_10_01_preview.operations import RoleAssignmentScheduleRequestsOperations as OperationClass
+        elif api_version == '2022-04-01-preview':
+            from .v2022_04_01_preview.operations import RoleAssignmentScheduleRequestsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_schedule_requests'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_schedules(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleAssignmentSchedulesOperations<azure.mgmt.authorization.v2020_10_01.operations.RoleAssignmentSchedulesOperations>`
            * 2020-10-01-preview: :class:`RoleAssignmentSchedulesOperations<azure.mgmt.authorization.v2020_10_01_preview.operations.RoleAssignmentSchedulesOperations>`
@@ -756,15 +771,15 @@
         if api_version == '2020-10-01':
             from .v2020_10_01.operations import RoleAssignmentSchedulesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from .v2020_10_01_preview.operations import RoleAssignmentSchedulesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_schedules'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignments(self):
         """Instance depends on the API version:
 
            * 2015-07-01: :class:`RoleAssignmentsOperations<azure.mgmt.authorization.v2015_07_01.operations.RoleAssignmentsOperations>`
            * 2018-01-01-preview: :class:`RoleAssignmentsOperations<azure.mgmt.authorization.v2018_01_01_preview.operations.RoleAssignmentsOperations>`
@@ -785,35 +800,38 @@
         elif api_version == '2020-10-01-preview':
             from .v2020_10_01_preview.operations import RoleAssignmentsOperations as OperationClass
         elif api_version == '2022-04-01':
             from .v2022_04_01.operations import RoleAssignmentsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignments'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_definitions(self):
         """Instance depends on the API version:
 
            * 2015-07-01: :class:`RoleDefinitionsOperations<azure.mgmt.authorization.v2015_07_01.operations.RoleDefinitionsOperations>`
            * 2018-01-01-preview: :class:`RoleDefinitionsOperations<azure.mgmt.authorization.v2018_01_01_preview.operations.RoleDefinitionsOperations>`
            * 2022-04-01: :class:`RoleDefinitionsOperations<azure.mgmt.authorization.v2022_04_01.operations.RoleDefinitionsOperations>`
+           * 2022-05-01-preview: :class:`RoleDefinitionsOperations<azure.mgmt.authorization.v2022_05_01_preview.operations.RoleDefinitionsOperations>`
         """
         api_version = self._get_api_version('role_definitions')
         if api_version == '2015-07-01':
             from .v2015_07_01.operations import RoleDefinitionsOperations as OperationClass
         elif api_version == '2018-01-01-preview':
             from .v2018_01_01_preview.operations import RoleDefinitionsOperations as OperationClass
         elif api_version == '2022-04-01':
             from .v2022_04_01.operations import RoleDefinitionsOperations as OperationClass
+        elif api_version == '2022-05-01-preview':
+            from .v2022_05_01_preview.operations import RoleDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_eligibility_schedule_instances(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleEligibilityScheduleInstancesOperations<azure.mgmt.authorization.v2020_10_01.operations.RoleEligibilityScheduleInstancesOperations>`
            * 2020-10-01-preview: :class:`RoleEligibilityScheduleInstancesOperations<azure.mgmt.authorization.v2020_10_01_preview.operations.RoleEligibilityScheduleInstancesOperations>`
@@ -822,32 +840,35 @@
         if api_version == '2020-10-01':
             from .v2020_10_01.operations import RoleEligibilityScheduleInstancesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from .v2020_10_01_preview.operations import RoleEligibilityScheduleInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_eligibility_schedule_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_eligibility_schedule_requests(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleEligibilityScheduleRequestsOperations<azure.mgmt.authorization.v2020_10_01.operations.RoleEligibilityScheduleRequestsOperations>`
            * 2020-10-01-preview: :class:`RoleEligibilityScheduleRequestsOperations<azure.mgmt.authorization.v2020_10_01_preview.operations.RoleEligibilityScheduleRequestsOperations>`
+           * 2022-04-01-preview: :class:`RoleEligibilityScheduleRequestsOperations<azure.mgmt.authorization.v2022_04_01_preview.operations.RoleEligibilityScheduleRequestsOperations>`
         """
         api_version = self._get_api_version('role_eligibility_schedule_requests')
         if api_version == '2020-10-01':
             from .v2020_10_01.operations import RoleEligibilityScheduleRequestsOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from .v2020_10_01_preview.operations import RoleEligibilityScheduleRequestsOperations as OperationClass
+        elif api_version == '2022-04-01-preview':
+            from .v2022_04_01_preview.operations import RoleEligibilityScheduleRequestsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_eligibility_schedule_requests'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_eligibility_schedules(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleEligibilitySchedulesOperations<azure.mgmt.authorization.v2020_10_01.operations.RoleEligibilitySchedulesOperations>`
            * 2020-10-01-preview: :class:`RoleEligibilitySchedulesOperations<azure.mgmt.authorization.v2020_10_01_preview.operations.RoleEligibilitySchedulesOperations>`
@@ -856,15 +877,15 @@
         if api_version == '2020-10-01':
             from .v2020_10_01.operations import RoleEligibilitySchedulesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from .v2020_10_01_preview.operations import RoleEligibilitySchedulesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_eligibility_schedules'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_management_policies(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleManagementPoliciesOperations<azure.mgmt.authorization.v2020_10_01.operations.RoleManagementPoliciesOperations>`
            * 2020-10-01-preview: :class:`RoleManagementPoliciesOperations<azure.mgmt.authorization.v2020_10_01_preview.operations.RoleManagementPoliciesOperations>`
@@ -873,15 +894,15 @@
         if api_version == '2020-10-01':
             from .v2020_10_01.operations import RoleManagementPoliciesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from .v2020_10_01_preview.operations import RoleManagementPoliciesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_management_policies'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_management_policy_assignments(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleManagementPolicyAssignmentsOperations<azure.mgmt.authorization.v2020_10_01.operations.RoleManagementPolicyAssignmentsOperations>`
            * 2020-10-01-preview: :class:`RoleManagementPolicyAssignmentsOperations<azure.mgmt.authorization.v2020_10_01_preview.operations.RoleManagementPolicyAssignmentsOperations>`
@@ -890,197 +911,197 @@
         if api_version == '2020-10-01':
             from .v2020_10_01.operations import RoleManagementPolicyAssignmentsOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from .v2020_10_01_preview.operations import RoleManagementPolicyAssignmentsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_management_policy_assignments'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_default_settings(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewDefaultSettingsOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.ScopeAccessReviewDefaultSettingsOperations>`
         """
         api_version = self._get_api_version('scope_access_review_default_settings')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import ScopeAccessReviewDefaultSettingsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_default_settings'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_history_definition(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewHistoryDefinitionOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.ScopeAccessReviewHistoryDefinitionOperations>`
         """
         api_version = self._get_api_version('scope_access_review_history_definition')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import ScopeAccessReviewHistoryDefinitionOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_history_definition'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_history_definition_instance(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewHistoryDefinitionInstanceOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.ScopeAccessReviewHistoryDefinitionInstanceOperations>`
         """
         api_version = self._get_api_version('scope_access_review_history_definition_instance')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import ScopeAccessReviewHistoryDefinitionInstanceOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_history_definition_instance'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_history_definition_instances(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewHistoryDefinitionInstancesOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.ScopeAccessReviewHistoryDefinitionInstancesOperations>`
         """
         api_version = self._get_api_version('scope_access_review_history_definition_instances')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import ScopeAccessReviewHistoryDefinitionInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_history_definition_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_history_definitions(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewHistoryDefinitionsOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.ScopeAccessReviewHistoryDefinitionsOperations>`
         """
         api_version = self._get_api_version('scope_access_review_history_definitions')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import ScopeAccessReviewHistoryDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_history_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_instance(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewInstanceOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.ScopeAccessReviewInstanceOperations>`
         """
         api_version = self._get_api_version('scope_access_review_instance')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import ScopeAccessReviewInstanceOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_instance'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_instance_contacted_reviewers(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewInstanceContactedReviewersOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.ScopeAccessReviewInstanceContactedReviewersOperations>`
         """
         api_version = self._get_api_version('scope_access_review_instance_contacted_reviewers')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import ScopeAccessReviewInstanceContactedReviewersOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_instance_contacted_reviewers'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_instance_decisions(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewInstanceDecisionsOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.ScopeAccessReviewInstanceDecisionsOperations>`
         """
         api_version = self._get_api_version('scope_access_review_instance_decisions')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import ScopeAccessReviewInstanceDecisionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_instance_decisions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_instances(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewInstancesOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.ScopeAccessReviewInstancesOperations>`
         """
         api_version = self._get_api_version('scope_access_review_instances')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import ScopeAccessReviewInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_schedule_definitions(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewScheduleDefinitionsOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.ScopeAccessReviewScheduleDefinitionsOperations>`
         """
         api_version = self._get_api_version('scope_access_review_schedule_definitions')
         if api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import ScopeAccessReviewScheduleDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_schedule_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_role_assignment_approval(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`ScopeRoleAssignmentApprovalOperations<azure.mgmt.authorization.v2021_01_01_preview.operations.ScopeRoleAssignmentApprovalOperations>`
         """
         api_version = self._get_api_version('scope_role_assignment_approval')
         if api_version == '2021-01-01-preview':
             from .v2021_01_01_preview.operations import ScopeRoleAssignmentApprovalOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_role_assignment_approval'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_role_assignment_approval_step(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`ScopeRoleAssignmentApprovalStepOperations<azure.mgmt.authorization.v2021_01_01_preview.operations.ScopeRoleAssignmentApprovalStepOperations>`
         """
         api_version = self._get_api_version('scope_role_assignment_approval_step')
         if api_version == '2021-01-01-preview':
             from .v2021_01_01_preview.operations import ScopeRoleAssignmentApprovalStepOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_role_assignment_approval_step'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_role_assignment_approval_steps(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`ScopeRoleAssignmentApprovalStepsOperations<azure.mgmt.authorization.v2021_01_01_preview.operations.ScopeRoleAssignmentApprovalStepsOperations>`
         """
         api_version = self._get_api_version('scope_role_assignment_approval_steps')
         if api_version == '2021-01-01-preview':
             from .v2021_01_01_preview.operations import ScopeRoleAssignmentApprovalStepsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_role_assignment_approval_steps'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def tenant_level_access_review_instance_contacted_reviewers(self):
         """Instance depends on the API version:
 
            * 2021-07-01-preview: :class:`TenantLevelAccessReviewInstanceContactedReviewersOperations<azure.mgmt.authorization.v2021_07_01_preview.operations.TenantLevelAccessReviewInstanceContactedReviewersOperations>`
            * 2021-12-01-preview: :class:`TenantLevelAccessReviewInstanceContactedReviewersOperations<azure.mgmt.authorization.v2021_12_01_preview.operations.TenantLevelAccessReviewInstanceContactedReviewersOperations>`
@@ -1089,15 +1110,15 @@
         if api_version == '2021-07-01-preview':
             from .v2021_07_01_preview.operations import TenantLevelAccessReviewInstanceContactedReviewersOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from .v2021_12_01_preview.operations import TenantLevelAccessReviewInstanceContactedReviewersOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'tenant_level_access_review_instance_contacted_reviewers'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     def close(self):
         self._client.close()
     def __enter__(self):
         self._client.__enter__()
         return self
     def __exit__(self, *exc_details):
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_configuration.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/_serialization.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/_serialization.py`

 * *Files 0% similar despite different names*

```diff
@@ -627,15 +627,15 @@
                         xml_desc = attr_desc.get("xml", {})
                         xml_name = xml_desc.get("name", attr_desc["key"])
                         xml_prefix = xml_desc.get("prefix", None)
                         xml_ns = xml_desc.get("ns", None)
                         if xml_desc.get("attr", False):
                             if xml_ns:
                                 ET.register_namespace(xml_prefix, xml_ns)
-                                xml_name = "{}{}".format(xml_ns, xml_name)
+                                xml_name = "{{{}}}{}".format(xml_ns, xml_name)
                             serialized.set(xml_name, new_attr)  # type: ignore
                             continue
                         if xml_desc.get("text", False):
                             serialized.text = new_attr  # type: ignore
                             continue
                         if isinstance(new_attr, list):
                             serialized.extend(new_attr)  # type: ignore
@@ -1269,15 +1269,15 @@
     :rtype: tuple
     :returns: A tuple XML name + namespace dict
     """
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
     xml_name = internal_type_xml_map.get("name", internal_type.__name__)
     xml_ns = internal_type_xml_map.get("ns", None)
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
     return xml_name
 
 
 def xml_key_extractor(attr, attr_desc, data):
     if isinstance(data, dict):
         return None
 
@@ -1293,15 +1293,15 @@
     is_wrapped = xml_desc.get("wrapped", False)
     internal_type = attr_desc.get("internalType", None)
     internal_type_xml_map = getattr(internal_type, "_xml_map", {})
 
     # Integrate namespace if necessary
     xml_ns = xml_desc.get("ns", internal_type_xml_map.get("ns", None))
     if xml_ns:
-        xml_name = "{}{}".format(xml_ns, xml_name)
+        xml_name = "{{{}}}{}".format(xml_ns, xml_name)
 
     # If it's an attribute, that's simple
     if xml_desc.get("attr", False):
         return data.get(xml_name)
 
     # If it's x-ms-text, that's simple too
     if xml_desc.get("text", False):
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_authorization_management_client.py`

 * *Files 5% similar despite different names*

```diff
@@ -74,46 +74,46 @@
     :paramtype api_version: str
     """
 
     def __init__(
         self, credential: "TokenCredential", base_url: str = "https://management.azure.com", **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(credential=credential, **kwargs)
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.eligible_child_resources = EligibleChildResourcesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_assignment_schedules = RoleAssignmentSchedulesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_assignment_schedule_instances = RoleAssignmentScheduleInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_assignment_schedule_requests = RoleAssignmentScheduleRequestsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_eligibility_schedules = RoleEligibilitySchedulesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_eligibility_schedule_instances = RoleEligibilityScheduleInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_eligibility_schedule_requests = RoleEligibilityScheduleRequestsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_management_policies = RoleManagementPoliciesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_management_policy_assignments = RoleManagementPolicyAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_configuration.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,49 +2,43 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
-    :keyword api_version: Api Version. Default value is "2020-10-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2022-04-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", "2020-10-01")
+        api_version: str = kwargs.pop("api_version", "2022-04-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
 
         self.credential = credential
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policy_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policy_assignments_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, role_management_policy_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments/{roleManagementPolicyAssignmentName}",
     )  # pylint: disable=line-too-long
@@ -71,15 +67,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_management_policy_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments/{roleManagementPolicyAssignmentName}",
@@ -104,15 +100,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(scope: str, role_management_policy_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments/{roleManagementPolicyAssignmentName}",
     )  # pylint: disable=line-too-long
@@ -134,15 +130,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -172,14 +168,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(
         self, scope: str, role_management_policy_assignment_name: str, **kwargs: Any
     ) -> _models.RoleManagementPolicyAssignment:
         """Get the specified role management policy assignment for a resource scope.
 
@@ -200,30 +197,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleManagementPolicyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -329,22 +327,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleManagementPolicyAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleManagementPolicyAssignment")
 
         request = build_create_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
@@ -355,16 +353,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -403,30 +402,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -450,15 +450,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleManagementPolicyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -502,16 +502,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_requests_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/_role_eligibility_schedule_requests_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(scope: str, role_eligibility_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}",
@@ -74,15 +70,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_eligibility_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}",
     )  # pylint: disable=line-too-long
@@ -104,15 +100,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -130,15 +126,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(scope: str, role_eligibility_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}/cancel",
     )  # pylint: disable=line-too-long
@@ -160,15 +156,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_request(scope: str, role_eligibility_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}/validate",
@@ -195,57 +191,60 @@
 
 class RoleEligibilityScheduleRequestsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_04_01_preview.AuthorizationManagementClient`'s
         :attr:`role_eligibility_schedule_requests` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     def create(
         self,
         scope: str,
         role_eligibility_schedule_request_name: str,
         parameters: _models.RoleEligibilityScheduleRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.RoleEligibilityScheduleRequest:
         """Creates a role eligibility schedule request.
 
         :param scope: The scope of the role eligibility schedule request to create. The scope can be
-         any REST resource instance. For example, use '/subscriptions/{subscription-id}/' for a
-         subscription, '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}' for a
-         resource group, and
-         '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
+         any REST resource instance. For example, use
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a subscription,
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}'
+         for a resource group, and
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name of the role eligibility to create. It
          can be any valid GUID. Required.
         :type role_eligibility_schedule_request_name: str
         :param parameters: Parameters for the role eligibility schedule request. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :type parameters:
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create(
         self,
         scope: str,
@@ -254,85 +253,89 @@
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.RoleEligibilityScheduleRequest:
         """Creates a role eligibility schedule request.
 
         :param scope: The scope of the role eligibility schedule request to create. The scope can be
-         any REST resource instance. For example, use '/subscriptions/{subscription-id}/' for a
-         subscription, '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}' for a
-         resource group, and
-         '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
+         any REST resource instance. For example, use
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a subscription,
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}'
+         for a resource group, and
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name of the role eligibility to create. It
          can be any valid GUID. Required.
         :type role_eligibility_schedule_request_name: str
         :param parameters: Parameters for the role eligibility schedule request. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create(
         self,
         scope: str,
         role_eligibility_schedule_request_name: str,
         parameters: Union[_models.RoleEligibilityScheduleRequest, IO],
         **kwargs: Any
     ) -> _models.RoleEligibilityScheduleRequest:
         """Creates a role eligibility schedule request.
 
         :param scope: The scope of the role eligibility schedule request to create. The scope can be
-         any REST resource instance. For example, use '/subscriptions/{subscription-id}/' for a
-         subscription, '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}' for a
-         resource group, and
-         '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
+         any REST resource instance. For example, use
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a subscription,
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}'
+         for a resource group, and
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name of the role eligibility to create. It
          can be any valid GUID. Required.
         :type role_eligibility_schedule_request_name: str
         :param parameters: Parameters for the role eligibility schedule request. Is either a
          RoleEligibilityScheduleRequest type or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
-         or IO
+        :type parameters:
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleEligibilityScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleEligibilityScheduleRequest")
 
         request = build_create_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
@@ -343,16 +346,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -377,44 +381,47 @@
         :param scope: The scope of the role eligibility schedule request. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name (guid) of the role eligibility schedule
          request to get. Required.
         :type role_eligibility_schedule_request_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilityScheduleRequest] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -446,21 +453,23 @@
          created for the current user. Use $filter=asApprover() to return all role eligibility schedule
          requests where the current user is an approver. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleEligibilityScheduleRequest or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilityScheduleRequestListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -505,16 +514,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -547,30 +557,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_cancel_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
             api_version=api_version,
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -596,21 +609,22 @@
 
         :param scope: The scope of the role eligibility request to validate. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name of the role eligibility request to
          validate. Required.
         :type role_eligibility_schedule_request_name: str
         :param parameters: Parameters for the role eligibility schedule request. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :type parameters:
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def validate(
         self,
         scope: str,
@@ -630,15 +644,15 @@
         :param parameters: Parameters for the role eligibility schedule request. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def validate(
         self,
         scope: str,
@@ -651,43 +665,45 @@
         :param scope: The scope of the role eligibility request to validate. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name of the role eligibility request to
          validate. Required.
         :type role_eligibility_schedule_request_name: str
         :param parameters: Parameters for the role eligibility schedule request. Is either a
          RoleEligibilityScheduleRequest type or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
-         or IO
+        :type parameters:
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleEligibilityScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleEligibilityScheduleRequest")
 
         request = build_validate_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
@@ -698,16 +714,17 @@
             template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedules_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedules_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, role_eligibility_schedule_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules/{roleEligibilityScheduleName}",
     )  # pylint: disable=line-too-long
@@ -71,15 +66,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -99,68 +94,72 @@
 
 class RoleEligibilitySchedulesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.AuthorizationManagementClient`'s
         :attr:`role_eligibility_schedules` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, scope: str, role_eligibility_schedule_name: str, **kwargs: Any) -> _models.RoleEligibilitySchedule:
         """Get the specified role eligibility schedule for a resource scope.
 
         :param scope: The scope of the role eligibility schedule. Required.
         :type scope: str
         :param role_eligibility_schedule_name: The name (guid) of the role eligibility schedule to get.
          Required.
         :type role_eligibility_schedule_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilitySchedule or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilitySchedule
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilitySchedule
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilitySchedule] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_eligibility_schedule_name=role_eligibility_schedule_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -191,21 +190,23 @@
          $filter=asTarget() to return all role eligibility schedules created for the current user.
          Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleEligibilitySchedule or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilitySchedule]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilitySchedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilityScheduleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -250,16 +251,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_instances_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleInstances")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -67,15 +62,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_assignment_schedule_instance_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleInstances/{roleAssignmentScheduleInstanceName}",
     )  # pylint: disable=line-too-long
@@ -99,26 +94,27 @@
 
 class RoleAssignmentScheduleInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.AuthorizationManagementClient`'s
         :attr:`role_assignment_schedule_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleAssignmentScheduleInstance"]:
         """Gets role assignment schedule instances of a role assignment schedule.
 
@@ -131,21 +127,23 @@
          Use $filter=asTarget() to return all role assignment schedule instances created for the current
          user. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignmentScheduleInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentScheduleInstance]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleAssignmentScheduleInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -190,16 +188,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -218,44 +217,47 @@
         :param scope: The scope of the role assignments schedules. Required.
         :type scope: str
         :param role_assignment_schedule_instance_name: The name (hash of schedule name + time) of the
          role assignment schedule to get. Required.
         :type role_assignment_schedule_instance_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentScheduleInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentScheduleInstance
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleAssignmentScheduleInstance] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_schedule_instance_name=role_assignment_schedule_instance_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_instances_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -67,15 +62,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_eligibility_schedule_instance_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances/{roleEligibilityScheduleInstanceName}",
     )  # pylint: disable=line-too-long
@@ -99,26 +94,27 @@
 
 class RoleEligibilityScheduleInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.AuthorizationManagementClient`'s
         :attr:`role_eligibility_schedule_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleEligibilityScheduleInstance"]:
         """Gets role eligibility schedule instances of a role eligibility schedule.
 
@@ -131,21 +127,23 @@
          $filter=asTarget() to return all role eligibility schedules created for the current user.
          Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleEligibilityScheduleInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleInstance]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilityScheduleInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilityScheduleInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -190,16 +188,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -218,44 +217,47 @@
         :param scope: The scope of the role eligibility schedules. Required.
         :type scope: str
         :param role_eligibility_schedule_instance_name: The name (hash of schedule name + time) of the
          role eligibility schedule to get. Required.
         :type role_eligibility_schedule_instance_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleInstance
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilityScheduleInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilityScheduleInstance] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_eligibility_schedule_instance_name=role_eligibility_schedule_instance_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_requests_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_requests_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(scope: str, role_assignment_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}",
@@ -74,15 +70,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_assignment_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}",
     )  # pylint: disable=line-too-long
@@ -104,15 +100,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -130,15 +126,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(scope: str, role_assignment_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}/cancel",
     )  # pylint: disable=line-too-long
@@ -160,15 +156,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_request(scope: str, role_assignment_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}/validate",
@@ -207,14 +203,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     def create(
         self,
         scope: str,
         role_assignment_schedule_request_name: str,
         parameters: _models.RoleAssignmentScheduleRequest,
@@ -317,22 +314,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentScheduleRequest")
 
         request = build_create_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
@@ -343,16 +340,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -391,30 +389,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -452,15 +451,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentScheduleRequest]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleAssignmentScheduleRequestListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -505,16 +504,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -547,30 +547,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_cancel_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
             api_version=api_version,
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -672,22 +673,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentScheduleRequest")
 
         request = build_validate_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
@@ -698,16 +699,17 @@
             template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedules_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedules_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, role_assignment_schedule_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules/{roleAssignmentScheduleName}",
     )  # pylint: disable=line-too-long
@@ -71,15 +66,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -99,68 +94,72 @@
 
 class RoleAssignmentSchedulesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.AuthorizationManagementClient`'s
         :attr:`role_assignment_schedules` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, scope: str, role_assignment_schedule_name: str, **kwargs: Any) -> _models.RoleAssignmentSchedule:
         """Get the specified role assignment schedule for a resource scope.
 
         :param scope: The scope of the role assignment schedule. Required.
         :type scope: str
         :param role_assignment_schedule_name: The name (guid) of the role assignment schedule to get.
          Required.
         :type role_assignment_schedule_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentSchedule or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentSchedule
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentSchedule
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleAssignmentSchedule] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_schedule_name=role_assignment_schedule_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -191,21 +190,23 @@
          Use $filter=asTarget() to return all role assignment schedules created for the current user.
          Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignmentSchedule or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentSchedule]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentSchedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleAssignmentScheduleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -250,16 +251,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policies_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_management_policies_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, role_management_policy_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies/{roleManagementPolicyName}"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -68,15 +64,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(scope: str, role_management_policy_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies/{roleManagementPolicyName}"
     )  # pylint: disable=line-too-long
@@ -98,15 +94,15 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(scope: str, role_management_policy_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies/{roleManagementPolicyName}"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -125,15 +121,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -163,14 +159,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, scope: str, role_management_policy_name: str, **kwargs: Any) -> _models.RoleManagementPolicy:
         """Get the specified role management policy for a resource scope.
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
@@ -189,30 +186,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleManagementPolicy] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -317,22 +315,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleManagementPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleManagementPolicy")
 
         request = build_update_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
@@ -343,16 +341,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -391,30 +390,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -438,15 +438,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleManagementPolicyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -490,16 +490,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/operations/_eligible_child_resources_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_eligible_child_resources_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/eligibleChildResources")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -81,14 +76,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, scope: str, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.EligibleChildResource"]:
         """Get the child resources of a resource on which user has eligible access.
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
@@ -103,15 +99,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.EligibleChildResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.EligibleChildResourcesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -156,16 +152,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/_authorization_management_client.py`

 * *Files 5% similar despite different names*

```diff
@@ -74,46 +74,46 @@
     :paramtype api_version: str
     """
 
     def __init__(
         self, credential: "AsyncTokenCredential", base_url: str = "https://management.azure.com", **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(credential=credential, **kwargs)
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.eligible_child_resources = EligibleChildResourcesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_assignment_schedules = RoleAssignmentSchedulesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_assignment_schedule_instances = RoleAssignmentScheduleInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_assignment_schedule_requests = RoleAssignmentScheduleRequestsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_eligibility_schedules = RoleEligibilitySchedulesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_eligibility_schedule_instances = RoleEligibilityScheduleInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_eligibility_schedule_requests = RoleEligibilityScheduleRequestsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_management_policies = RoleManagementPoliciesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
         self.role_management_policy_assignments = RoleManagementPolicyAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -36,15 +30,15 @@
     :keyword api_version: Api Version. Default value is "2020-10-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", "2020-10-01")
+        api_version: str = kwargs.pop("api_version", "2020-10-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
 
         self.credential = credential
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policy_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policy_assignments_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -32,84 +32,84 @@
 from ...operations._role_management_policy_assignments_operations import (
     build_create_request,
     build_delete_request,
     build_get_request,
     build_list_for_scope_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleManagementPolicyAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`role_management_policy_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(
         self, scope: str, role_management_policy_assignment_name: str, **kwargs: Any
     ) -> _models.RoleManagementPolicyAssignment:
         """Get the specified role management policy assignment for a resource scope.
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
         :param role_management_policy_assignment_name: The name of format {guid_guid} the role
          management policy assignment to get. Required.
         :type role_management_policy_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicyAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleManagementPolicyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -139,21 +139,22 @@
 
         :param scope: The scope of the role management policy assignment to upsert. Required.
         :type scope: str
         :param role_management_policy_assignment_name: The name of format {guid_guid} the role
          management policy assignment to upsert. Required.
         :type role_management_policy_assignment_name: str
         :param parameters: Parameters for the role management policy assignment. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
+        :type parameters:
+         ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicyAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create(
         self,
         scope: str,
@@ -173,15 +174,15 @@
         :param parameters: Parameters for the role management policy assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicyAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create(
         self,
         scope: str,
@@ -194,43 +195,45 @@
         :param scope: The scope of the role management policy assignment to upsert. Required.
         :type scope: str
         :param role_management_policy_assignment_name: The name of format {guid_guid} the role
          management policy assignment to upsert. Required.
         :type role_management_policy_assignment_name: str
         :param parameters: Parameters for the role management policy assignment. Is either a
          RoleManagementPolicyAssignment type or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
-         or IO
+        :type parameters:
+         ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicyAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleManagementPolicyAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleManagementPolicyAssignment")
 
         request = build_create_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
@@ -241,16 +244,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -289,30 +293,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -330,21 +337,23 @@
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleManagementPolicyAssignment or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleManagementPolicyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -388,16 +397,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_requests_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_role_eligibility_schedule_requests_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,71 +33,70 @@
     build_cancel_request,
     build_create_request,
     build_get_request,
     build_list_for_scope_request,
     build_validate_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleEligibilityScheduleRequestsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_04_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`role_eligibility_schedule_requests` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     async def create(
         self,
         scope: str,
         role_eligibility_schedule_request_name: str,
         parameters: _models.RoleEligibilityScheduleRequest,
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.RoleEligibilityScheduleRequest:
         """Creates a role eligibility schedule request.
 
         :param scope: The scope of the role eligibility schedule request to create. The scope can be
-         any REST resource instance. For example, use '/subscriptions/{subscription-id}/' for a
-         subscription, '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}' for a
-         resource group, and
-         '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
+         any REST resource instance. For example, use
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a subscription,
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}'
+         for a resource group, and
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name of the role eligibility to create. It
          can be any valid GUID. Required.
         :type role_eligibility_schedule_request_name: str
         :param parameters: Parameters for the role eligibility schedule request. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :type parameters:
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create(
         self,
         scope: str,
@@ -106,85 +105,89 @@
         *,
         content_type: str = "application/json",
         **kwargs: Any
     ) -> _models.RoleEligibilityScheduleRequest:
         """Creates a role eligibility schedule request.
 
         :param scope: The scope of the role eligibility schedule request to create. The scope can be
-         any REST resource instance. For example, use '/subscriptions/{subscription-id}/' for a
-         subscription, '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}' for a
-         resource group, and
-         '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
+         any REST resource instance. For example, use
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a subscription,
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}'
+         for a resource group, and
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name of the role eligibility to create. It
          can be any valid GUID. Required.
         :type role_eligibility_schedule_request_name: str
         :param parameters: Parameters for the role eligibility schedule request. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create(
         self,
         scope: str,
         role_eligibility_schedule_request_name: str,
         parameters: Union[_models.RoleEligibilityScheduleRequest, IO],
         **kwargs: Any
     ) -> _models.RoleEligibilityScheduleRequest:
         """Creates a role eligibility schedule request.
 
         :param scope: The scope of the role eligibility schedule request to create. The scope can be
-         any REST resource instance. For example, use '/subscriptions/{subscription-id}/' for a
-         subscription, '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}' for a
-         resource group, and
-         '/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
+         any REST resource instance. For example, use
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a subscription,
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}'
+         for a resource group, and
+         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name of the role eligibility to create. It
          can be any valid GUID. Required.
         :type role_eligibility_schedule_request_name: str
         :param parameters: Parameters for the role eligibility schedule request. Is either a
          RoleEligibilityScheduleRequest type or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
-         or IO
+        :type parameters:
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleEligibilityScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleEligibilityScheduleRequest")
 
         request = build_create_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
@@ -195,16 +198,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -229,44 +233,47 @@
         :param scope: The scope of the role eligibility schedule request. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name (guid) of the role eligibility schedule
          request to get. Required.
         :type role_eligibility_schedule_request_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilityScheduleRequest] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -298,21 +305,23 @@
          created for the current user. Use $filter=asApprover() to return all role eligibility schedule
          requests where the current user is an approver. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleEligibilityScheduleRequest or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilityScheduleRequestListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -357,16 +366,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -399,30 +409,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_cancel_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
             api_version=api_version,
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -448,21 +461,22 @@
 
         :param scope: The scope of the role eligibility request to validate. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name of the role eligibility request to
          validate. Required.
         :type role_eligibility_schedule_request_name: str
         :param parameters: Parameters for the role eligibility schedule request. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :type parameters:
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def validate(
         self,
         scope: str,
@@ -482,15 +496,15 @@
         :param parameters: Parameters for the role eligibility schedule request. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def validate(
         self,
         scope: str,
@@ -503,43 +517,45 @@
         :param scope: The scope of the role eligibility request to validate. Required.
         :type scope: str
         :param role_eligibility_schedule_request_name: The name of the role eligibility request to
          validate. Required.
         :type role_eligibility_schedule_request_name: str
         :param parameters: Parameters for the role eligibility schedule request. Is either a
          RoleEligibilityScheduleRequest type or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
-         or IO
+        :type parameters:
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleEligibilityScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleEligibilityScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleEligibilityScheduleRequest")
 
         request = build_validate_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
@@ -550,16 +566,17 @@
             template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedules_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedules_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -27,84 +26,84 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._role_eligibility_schedules_operations import build_get_request, build_list_for_scope_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleEligibilitySchedulesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`role_eligibility_schedules` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(
         self, scope: str, role_eligibility_schedule_name: str, **kwargs: Any
     ) -> _models.RoleEligibilitySchedule:
         """Get the specified role eligibility schedule for a resource scope.
 
         :param scope: The scope of the role eligibility schedule. Required.
         :type scope: str
         :param role_eligibility_schedule_name: The name (guid) of the role eligibility schedule to get.
          Required.
         :type role_eligibility_schedule_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilitySchedule or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilitySchedule
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilitySchedule
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilitySchedule] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_eligibility_schedule_name=role_eligibility_schedule_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -135,21 +134,23 @@
          $filter=asTarget() to return all role eligibility schedules created for the current user.
          Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleEligibilitySchedule or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilitySchedule]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilitySchedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilityScheduleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -194,16 +195,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_instances_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -27,40 +26,37 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._role_assignment_schedule_instances_operations import build_get_request, build_list_for_scope_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentScheduleInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`role_assignment_schedule_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleAssignmentScheduleInstance"]:
         """Gets role assignment schedule instances of a role assignment schedule.
 
@@ -73,21 +69,23 @@
          Use $filter=asTarget() to return all role assignment schedule instances created for the current
          user. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignmentScheduleInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentScheduleInstance]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleAssignmentScheduleInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -132,16 +130,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -160,44 +159,47 @@
         :param scope: The scope of the role assignments schedules. Required.
         :type scope: str
         :param role_assignment_schedule_instance_name: The name (hash of schedule name + time) of the
          role assignment schedule to get. Required.
         :type role_assignment_schedule_instance_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentScheduleInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentScheduleInstance
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleAssignmentScheduleInstance] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_schedule_instance_name=role_assignment_schedule_instance_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_instances_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -30,40 +29,37 @@
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._role_eligibility_schedule_instances_operations import (
     build_get_request,
     build_list_for_scope_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleEligibilityScheduleInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`role_eligibility_schedule_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleEligibilityScheduleInstance"]:
         """Gets role eligibility schedule instances of a role eligibility schedule.
 
@@ -76,21 +72,23 @@
          $filter=asTarget() to return all role eligibility schedules created for the current user.
          Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleEligibilityScheduleInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleInstance]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilityScheduleInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilityScheduleInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -135,16 +133,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -163,44 +162,47 @@
         :param scope: The scope of the role eligibility schedules. Required.
         :type scope: str
         :param role_eligibility_schedule_instance_name: The name (hash of schedule name + time) of the
          role eligibility schedule to get. Required.
         :type role_eligibility_schedule_instance_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleEligibilityScheduleInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleInstance
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilityScheduleInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleEligibilityScheduleInstance] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_eligibility_schedule_instance_name=role_eligibility_schedule_instance_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_requests_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_requests_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,18 +33,14 @@
     build_cancel_request,
     build_create_request,
     build_get_request,
     build_list_for_scope_request,
     build_validate_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentScheduleRequestsOperations:
     """
     .. warning::
@@ -59,14 +55,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     async def create(
         self,
         scope: str,
         role_assignment_schedule_request_name: str,
         parameters: _models.RoleAssignmentScheduleRequest,
@@ -169,22 +166,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentScheduleRequest")
 
         request = build_create_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
@@ -195,16 +192,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -243,30 +241,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -304,15 +303,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentScheduleRequest]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleAssignmentScheduleRequestListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -357,16 +356,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -399,30 +399,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_cancel_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
             api_version=api_version,
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -524,22 +525,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentScheduleRequest")
 
         request = build_validate_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
@@ -550,16 +551,17 @@
             template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedules_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedules_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -27,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._role_assignment_schedules_operations import build_get_request, build_list_for_scope_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentSchedulesOperations:
     """
     .. warning::
@@ -53,14 +48,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(
         self, scope: str, role_assignment_schedule_name: str, **kwargs: Any
     ) -> _models.RoleAssignmentSchedule:
         """Get the specified role assignment schedule for a resource scope.
 
@@ -81,30 +77,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleAssignmentSchedule] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_schedule_name=role_assignment_schedule_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -141,15 +138,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentSchedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleAssignmentScheduleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -194,16 +191,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policies_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policies_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -32,82 +32,82 @@
 from ...operations._role_management_policies_operations import (
     build_delete_request,
     build_get_request,
     build_list_for_scope_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleManagementPoliciesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`role_management_policies` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(self, scope: str, role_management_policy_name: str, **kwargs: Any) -> _models.RoleManagementPolicy:
         """Get the specified role management policy for a resource scope.
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
         :param role_management_policy_name: The name (guid) of the role management policy to get.
          Required.
         :type role_management_policy_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicy or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleManagementPolicy] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -137,21 +137,21 @@
 
         :param scope: The scope of the role management policy to upsert. Required.
         :type scope: str
         :param role_management_policy_name: The name (guid) of the role management policy to upsert.
          Required.
         :type role_management_policy_name: str
         :param parameters: Parameters for the role management policy. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy
+        :type parameters: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicy or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def update(
         self,
         scope: str,
@@ -171,15 +171,15 @@
         :param parameters: Parameters for the role management policy. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicy or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def update(
         self,
         scope: str,
@@ -192,42 +192,45 @@
         :param scope: The scope of the role management policy to upsert. Required.
         :type scope: str
         :param role_management_policy_name: The name (guid) of the role management policy to upsert.
          Required.
         :type role_management_policy_name: str
         :param parameters: Parameters for the role management policy. Is either a RoleManagementPolicy
          type or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy or IO
+        :type parameters: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy or
+         IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicy or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleManagementPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleManagementPolicy")
 
         request = build_update_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
@@ -238,16 +241,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -286,30 +290,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -327,21 +334,23 @@
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleManagementPolicy or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
         cls: ClsType[_models.RoleManagementPolicyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -385,16 +394,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/aio/operations/_eligible_child_resources_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_eligible_child_resources_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._eligible_child_resources_operations import build_get_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class EligibleChildResourcesOperations:
     """
     .. warning::
@@ -52,14 +47,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.EligibleChildResource"]:
         """Get the child resources of a resource on which user has eligible access.
 
@@ -76,15 +72,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.EligibleChildResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01"] = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.EligibleChildResourcesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -129,16 +125,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01/models/_authorization_management_client_enums.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/_authorization_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/_authorization_management_client.py`

 * *Files 5% similar despite different names*

```diff
@@ -65,32 +65,34 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.deny_assignments = DenyAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2022-04-01"
         )
         self.provider_operations_metadata = ProviderOperationsMetadataOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2022-04-01"
         )
         self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2022-04-01"
+        )
+        self.permissions = PermissionsOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2022-04-01"
         )
-        self.permissions = PermissionsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.role_definitions = RoleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2022-04-01"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2022-04-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2021-12-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", "2022-04-01")
+        api_version: str = kwargs.pop("api_version", "2021-12-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_role_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_role_definitions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_delete_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionId": _SERIALIZER.url("role_definition_id", role_definition_id, "str"),
@@ -66,15 +62,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionId": _SERIALIZER.url("role_definition_id", role_definition_id, "str"),
@@ -91,15 +87,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -119,15 +115,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -145,15 +141,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(role_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
     }
@@ -183,14 +179,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def delete(self, scope: str, role_definition_id: str, **kwargs: Any) -> Optional[_models.RoleDefinition]:
         """Deletes a role definition.
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
@@ -208,30 +205,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[Optional[_models.RoleDefinition]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -268,30 +266,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -388,22 +387,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(role_definition, (IO, bytes)):
+        if isinstance(role_definition, (IOBase, bytes)):
             _content = role_definition
         else:
             _json = self._serialize.body(role_definition, "RoleDefinition")
 
         request = build_create_or_update_request(
             scope=scope,
             role_definition_id=role_definition_id,
@@ -414,16 +413,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -452,15 +452,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -505,16 +505,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -547,29 +548,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_role_assignments_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +26,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_for_subscription_request(
     subscription_id: str, *, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/roleAssignments"
     )
     path_format_arguments = {
@@ -80,15 +76,15 @@
     filter: Optional[str] = None,
     tenant_id: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -124,15 +120,15 @@
     filter: Optional[str] = None,
     tenant_id: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -165,15 +161,15 @@
 
 def build_get_request(
     scope: str, role_assignment_name: str, *, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str", skip_quote=True),
@@ -192,15 +188,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -222,15 +218,15 @@
 
 def build_delete_request(
     scope: str, role_assignment_name: str, *, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str", skip_quote=True),
@@ -256,15 +252,15 @@
     tenant_id: Optional[str] = None,
     skip_token: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -286,15 +282,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(role_assignment_id: str, *, tenant_id: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleAssignmentId}")
     path_format_arguments = {
         "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
     }
@@ -312,15 +308,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_by_id_request(role_assignment_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleAssignmentId}")
     path_format_arguments = {
         "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
@@ -341,15 +337,15 @@
 
 def build_delete_by_id_request(
     role_assignment_id: str, *, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleAssignmentId}")
     path_format_arguments = {
         "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
     }
@@ -381,14 +377,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_subscription(
         self, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleAssignment"]:
         """List all role assignments that apply to a subscription.
 
@@ -403,15 +400,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -457,16 +454,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -499,15 +497,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -554,16 +552,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -610,15 +609,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -668,16 +667,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -719,31 +719,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -860,22 +861,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -886,16 +887,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -943,31 +945,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1016,15 +1019,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1071,16 +1074,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1117,30 +1121,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_assignment_id=role_assignment_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1237,22 +1242,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
@@ -1262,16 +1267,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1316,30 +1322,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_assignment_id=role_assignment_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_deny_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_deny_assignments_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -51,15 +46,15 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/denyAssignments",
     )  # pylint: disable=line-too-long
@@ -91,15 +86,15 @@
 
 def build_list_for_resource_group_request(
     resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/denyAssignments",
     )  # pylint: disable=line-too-long
@@ -123,15 +118,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/denyAssignments"
     )
     path_format_arguments = {
@@ -151,15 +146,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, deny_assignment_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/denyAssignments/{denyAssignmentId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "denyAssignmentId": _SERIALIZER.url("deny_assignment_id", deny_assignment_id, "str"),
@@ -176,15 +171,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(deny_assignment_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{denyAssignmentId}")
     path_format_arguments = {
         "denyAssignmentId": _SERIALIZER.url("deny_assignment_id", deny_assignment_id, "str", skip_quote=True),
     }
@@ -200,15 +195,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/denyAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -240,14 +235,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -285,15 +281,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -343,16 +339,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -390,15 +387,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -444,16 +441,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -486,15 +484,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -539,16 +537,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -579,30 +578,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             deny_assignment_id=deny_assignment_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -639,29 +639,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             deny_assignment_id=deny_assignment_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -700,15 +701,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -753,16 +754,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_provider_operations_metadata_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_provider_operations_metadata_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(resource_provider_namespace: str, *, expand: str = "resourceTypes", **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/providers/Microsoft.Authorization/providerOperations/{resourceProviderNamespace}"
     )
     path_format_arguments = {
@@ -71,15 +66,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(*, expand: str = "resourceTypes", **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/providerOperations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -94,69 +89,73 @@
 
 class ProviderOperationsMetadataOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2022_04_01.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2018_01_01_preview.AuthorizationManagementClient`'s
         :attr:`provider_operations_metadata` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(
         self, resource_provider_namespace: str, expand: str = "resourceTypes", **kwargs: Any
     ) -> _models.ProviderOperationsMetadata:
         """Gets provider operations metadata for the specified resource provider.
 
         :param resource_provider_namespace: The namespace of the resource provider. Required.
         :type resource_provider_namespace: str
         :param expand: Specifies whether to expand the values. Default value is "resourceTypes".
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProviderOperationsMetadata or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.ProviderOperationsMetadata
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.ProviderOperationsMetadata
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
+        )
         cls: ClsType[_models.ProviderOperationsMetadata] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_provider_namespace=resource_provider_namespace,
             expand=expand,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -177,21 +176,23 @@
 
         :param expand: Specifies whether to expand the values. Default value is "resourceTypes".
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ProviderOperationsMetadata or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.ProviderOperationsMetadata]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.ProviderOperationsMetadata]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
+        )
         cls: ClsType[_models.ProviderOperationsMetadataListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -235,16 +236,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/operations/_permissions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_permissions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_for_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Authorization/permissions",
     )  # pylint: disable=line-too-long
@@ -79,29 +74,27 @@
     resource_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/permissions",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "resourceProviderNamespace": _SERIALIZER.url(
-            "resource_provider_namespace", resource_provider_namespace, "str", skip_quote=True
-        ),
+        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
         "parentResourcePath": _SERIALIZER.url("parent_resource_path", parent_resource_path, "str", skip_quote=True),
         "resourceType": _SERIALIZER.url("resource_type", resource_type, "str", skip_quote=True),
         "resourceName": _SERIALIZER.url("resource_name", resource_name, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
@@ -117,43 +110,44 @@
 
 class PermissionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2022_04_01.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2015_07_01.AuthorizationManagementClient`'s
         :attr:`permissions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.Permission"]:
         """Gets all permissions the caller has for a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Permission or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.Permission]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -198,16 +192,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -241,21 +236,21 @@
         :type parent_resource_path: str
         :param resource_type: The resource type of the resource. Required.
         :type resource_type: str
         :param resource_name: The name of the resource to get the permissions for. Required.
         :type resource_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Permission or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.Permission]
+        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -304,16 +299,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/_authorization_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -65,32 +65,34 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.deny_assignments = DenyAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2022-04-01"
         )
         self.provider_operations_metadata = ProviderOperationsMetadataOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2022-04-01"
         )
         self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2022-04-01"
+        )
+        self.permissions = PermissionsOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2022-04-01"
         )
-        self.permissions = PermissionsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.role_definitions = RoleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2022-04-01"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -38,15 +32,15 @@
     :keyword api_version: Api Version. Default value is "2022-04-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", "2022-04-01")
+        api_version: str = kwargs.pop("api_version", "2022-04-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_definitions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,81 +33,79 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_by_id_request,
     build_get_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleDefinitionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2022_04_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2015_07_01.aio.AuthorizationManagementClient`'s
         :attr:`role_definitions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def delete(self, scope: str, role_definition_id: str, **kwargs: Any) -> Optional[_models.RoleDefinition]:
         """Deletes a role definition.
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
         :param role_definition_id: The ID of the role definition to delete. Required.
         :type role_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or None or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition or None
+        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[Optional[_models.RoleDefinition]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -130,44 +128,45 @@
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
         :param role_definition_id: The ID of the role definition. Required.
         :type role_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
+        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -195,21 +194,21 @@
         """Creates or updates a role definition.
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
         :param role_definition_id: The ID of the role definition. Required.
         :type role_definition_id: str
         :param role_definition: The values for the role definition. Required.
-        :type role_definition: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
+        :type role_definition: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
+        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_or_update(
         self,
         scope: str,
@@ -228,15 +227,15 @@
         :param role_definition: The values for the role definition. Required.
         :type role_definition: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
+        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_or_update(
         self, scope: str, role_definition_id: str, role_definition: Union[_models.RoleDefinition, IO], **kwargs: Any
     ) -> _models.RoleDefinition:
@@ -244,42 +243,42 @@
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
         :param role_definition_id: The ID of the role definition. Required.
         :type role_definition_id: str
         :param role_definition: The values for the role definition. Is either a RoleDefinition type or
          a IO type. Required.
-        :type role_definition: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition or IO
+        :type role_definition: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
+        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(role_definition, (IO, bytes)):
+        if isinstance(role_definition, (IOBase, bytes)):
             _content = role_definition
         else:
             _json = self._serialize.body(role_definition, "RoleDefinition")
 
         request = build_create_or_update_request(
             scope=scope,
             role_definition_id=role_definition_id,
@@ -290,16 +289,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -322,21 +322,21 @@
         :type scope: str
         :param filter: The filter to apply on the operation. Use atScopeAndBelow filter to search below
          the given scope as well. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleDefinition or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -381,16 +381,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -398,54 +399,55 @@
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}
 
     @distributed_trace_async
-    async def get_by_id(self, role_id: str, **kwargs: Any) -> _models.RoleDefinition:
+    async def get_by_id(self, role_definition_id: str, **kwargs: Any) -> _models.RoleDefinition:
         """Gets a role definition by ID.
 
-        :param role_id: The fully qualified role definition ID. Use the format,
+        :param role_definition_id: The fully qualified role definition ID. Use the format,
          /subscriptions/{guid}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId} for
          subscription level role definitions, or
          /providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId} for tenant level role
          definitions. Required.
-        :type role_id: str
+        :type role_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
+        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
-            role_id=role_id,
+            role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -454,8 +456,8 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_by_id.metadata = {"url": "/{roleId}"}
+    get_by_id.metadata = {"url": "/{roleDefinitionId}"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_assignments_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -38,18 +38,14 @@
     build_get_request,
     build_list_for_resource_group_request,
     build_list_for_resource_request,
     build_list_for_scope_request,
     build_list_for_subscription_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentsOperations:
     """
     .. warning::
@@ -64,14 +60,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_subscription(
         self, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleAssignment"]:
         """List all role assignments that apply to a subscription.
 
@@ -86,15 +83,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -140,16 +137,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -182,15 +180,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -237,16 +235,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -293,15 +292,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -351,16 +350,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -402,31 +402,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -543,22 +544,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -569,16 +570,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -626,31 +628,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -699,15 +702,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -754,16 +757,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -800,30 +804,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_assignment_id=role_assignment_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -920,22 +925,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
@@ -945,16 +950,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -999,30 +1005,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_assignment_id=role_assignment_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_deny_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_deny_assignments_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,18 +33,14 @@
     build_get_request,
     build_list_for_resource_group_request,
     build_list_for_resource_request,
     build_list_for_scope_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DenyAssignmentsOperations:
     """
     .. warning::
@@ -60,14 +55,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -105,15 +101,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -163,16 +159,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -210,15 +207,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -264,16 +261,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -306,15 +304,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -359,16 +357,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -399,30 +398,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             deny_assignment_id=deny_assignment_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -459,29 +459,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             deny_assignment_id=deny_assignment_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -520,15 +521,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -573,16 +574,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_provider_operations_metadata_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_provider_operations_metadata_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -27,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._provider_operations_metadata_operations import build_get_request, build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ProviderOperationsMetadataOperations:
     """
     .. warning::
@@ -53,14 +48,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(
         self, resource_provider_namespace: str, expand: str = "resourceTypes", **kwargs: Any
     ) -> _models.ProviderOperationsMetadata:
         """Gets provider operations metadata for the specified resource provider.
 
@@ -80,30 +76,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.ProviderOperationsMetadata] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_provider_namespace=resource_provider_namespace,
             expand=expand,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -130,15 +127,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.ProviderOperationsMetadata]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.ProviderOperationsMetadataListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -182,16 +179,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/aio/operations/_permissions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_permissions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,58 +25,55 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._permissions_operations import build_list_for_resource_group_request, build_list_for_resource_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class PermissionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2022_04_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2015_07_01.aio.AuthorizationManagementClient`'s
         :attr:`permissions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.Permission"]:
         """Gets all permissions the caller has for a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Permission or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.Permission]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -122,16 +118,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -166,21 +163,21 @@
         :param resource_type: The resource type of the resource. Required.
         :type resource_type: str
         :param resource_name: The name of the resource to get the permissions for. Required.
         :type resource_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Permission or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.Permission]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-04-01"] = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -229,16 +226,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2022_04_01/models/_authorization_management_client_enums.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/models/_authorization_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_authorization_management_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -60,29 +60,31 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.provider_operations_metadata = ProviderOperationsMetadataOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-01-01-preview"
         )
         self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-01-01-preview"
+        )
+        self.permissions = PermissionsOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2018-01-01-preview"
         )
-        self.permissions = PermissionsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.role_definitions = RoleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-01-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2018-01-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2018-05-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop("api_version", "2018-01-01-preview")
+        api_version: str = kwargs.pop("api_version", "2018-05-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_definitions_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_delete_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionId": _SERIALIZER.url("role_definition_id", role_definition_id, "str"),
@@ -68,17 +62,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionId": _SERIALIZER.url("role_definition_id", role_definition_id, "str"),
@@ -95,17 +87,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -125,17 +115,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -153,17 +141,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(role_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
     }
@@ -193,14 +179,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def delete(self, scope: str, role_definition_id: str, **kwargs: Any) -> Optional[_models.RoleDefinition]:
         """Deletes a role definition.
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
@@ -218,32 +205,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[Optional[_models.RoleDefinition]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -280,32 +268,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -403,24 +392,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(role_definition, (IO, bytes)):
+        if isinstance(role_definition, (IOBase, bytes)):
             _content = role_definition
         else:
             _json = self._serialize.body(role_definition, "RoleDefinition")
 
         request = build_create_or_update_request(
             scope=scope,
             role_definition_id=role_definition_id,
@@ -431,16 +420,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -469,16 +459,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -524,16 +514,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -566,31 +557,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_role_assignments_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -51,17 +47,15 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -93,17 +87,15 @@
 
 def build_list_for_resource_group_request(
     resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -127,17 +119,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
@@ -154,17 +144,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -184,17 +172,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
@@ -211,17 +197,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(role_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
     }
@@ -237,17 +221,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_by_id_request(role_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
@@ -266,17 +248,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(role_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
     }
@@ -292,17 +272,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/roleAssignments"
     )
     path_format_arguments = {
@@ -322,17 +300,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -364,14 +340,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -402,16 +379,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -462,16 +439,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -502,16 +480,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -558,16 +536,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -600,32 +579,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -748,24 +728,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -776,16 +756,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -820,32 +801,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -878,31 +860,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -990,24 +973,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_id=role_id,
             api_version=api_version,
@@ -1017,16 +1000,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1059,31 +1043,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1111,16 +1096,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -1166,16 +1151,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1203,16 +1189,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -1258,16 +1244,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_provider_operations_metadata_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/operations/_provider_operations_metadata_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(resource_provider_namespace: str, *, expand: str = "resourceTypes", **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/providers/Microsoft.Authorization/providerOperations/{resourceProviderNamespace}"
     )
     path_format_arguments = {
@@ -73,17 +66,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(*, expand: str = "resourceTypes", **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/providerOperations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -98,71 +89,71 @@
 
 class ProviderOperationsMetadataOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_01_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_04_01.AuthorizationManagementClient`'s
         :attr:`provider_operations_metadata` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(
         self, resource_provider_namespace: str, expand: str = "resourceTypes", **kwargs: Any
     ) -> _models.ProviderOperationsMetadata:
         """Gets provider operations metadata for the specified resource provider.
 
         :param resource_provider_namespace: The namespace of the resource provider. Required.
         :type resource_provider_namespace: str
         :param expand: Specifies whether to expand the values. Default value is "resourceTypes".
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: ProviderOperationsMetadata or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.ProviderOperationsMetadata
+        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.ProviderOperationsMetadata
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.ProviderOperationsMetadata] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_provider_namespace=resource_provider_namespace,
             expand=expand,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -183,23 +174,21 @@
 
         :param expand: Specifies whether to expand the values. Default value is "resourceTypes".
         :type expand: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ProviderOperationsMetadata or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.ProviderOperationsMetadata]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01.models.ProviderOperationsMetadata]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.ProviderOperationsMetadataListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -243,16 +232,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/operations/_permissions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_permissions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_for_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Authorization/permissions",
     )  # pylint: disable=line-too-long
@@ -81,17 +74,15 @@
     resource_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/permissions",
     )  # pylint: disable=line-too-long
@@ -133,14 +124,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.Permission"]:
         """Gets all permissions the caller has for a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
@@ -150,16 +142,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -205,16 +197,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -255,16 +248,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -314,16 +307,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_authorization_management_client.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,112 +3,98 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
-from typing import Any, Awaitable, TYPE_CHECKING
+from typing import Any, TYPE_CHECKING
 
-from azure.core.rest import AsyncHttpResponse, HttpRequest
-from azure.mgmt.core import AsyncARMPipelineClient
+from azure.core.rest import HttpRequest, HttpResponse
+from azure.mgmt.core import ARMPipelineClient
 
-from .. import models as _models
-from ..._serialization import Deserializer, Serializer
+from . import models as _models
+from .._serialization import Deserializer, Serializer
 from ._configuration import AuthorizationManagementClientConfiguration
-from .operations import (
-    PermissionsOperations,
-    ProviderOperationsMetadataOperations,
-    RoleAssignmentsOperations,
-    RoleDefinitionsOperations,
-)
+from .operations import PermissionsOperations, RoleDefinitionsOperations
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClient:  # pylint: disable=client-accepts-api-version-keyword
     """Role based access control provides you a way to apply granular level policy administration down
-    to individual resources or resource groups. These calls handle provider operations.
+    to individual resources or resource groups. These operations allow you to manage role
+    definitions. A role definition describes the set of actions that can be performed on resources.
 
-    :ivar provider_operations_metadata: ProviderOperationsMetadataOperations operations
-    :vartype provider_operations_metadata:
-     azure.mgmt.authorization.v2018_01_01_preview.aio.operations.ProviderOperationsMetadataOperations
-    :ivar role_assignments: RoleAssignmentsOperations operations
-    :vartype role_assignments:
-     azure.mgmt.authorization.v2018_01_01_preview.aio.operations.RoleAssignmentsOperations
     :ivar permissions: PermissionsOperations operations
     :vartype permissions:
-     azure.mgmt.authorization.v2018_01_01_preview.aio.operations.PermissionsOperations
+     azure.mgmt.authorization.v2022_05_01_preview.operations.PermissionsOperations
     :ivar role_definitions: RoleDefinitionsOperations operations
     :vartype role_definitions:
-     azure.mgmt.authorization.v2018_01_01_preview.aio.operations.RoleDefinitionsOperations
+     azure.mgmt.authorization.v2022_05_01_preview.operations.RoleDefinitionsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2018-01-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2022-05-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(
         self,
-        credential: "AsyncTokenCredential",
+        credential: "TokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.provider_operations_metadata = ProviderOperationsMetadataOperations(
-            self._client, self._config, self._serialize, self._deserialize
+        self.permissions = PermissionsOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2022-05-01-preview"
         )
-        self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.permissions = PermissionsOperations(self._client, self._config, self._serialize, self._deserialize)
         self.role_definitions = RoleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2022-05-01-preview"
         )
 
-    def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
+    def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
-        >>> response = await client._send_request(request)
-        <AsyncHttpResponse: 200 OK>
+        >>> response = client._send_request(request)
+        <HttpResponse: 200 OK>
 
         For more information on this code flow, see https://aka.ms/azsdk/dpcodegen/python/send_request
 
         :param request: The network request you want to make. Required.
         :type request: ~azure.core.rest.HttpRequest
         :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
         :return: The response of your network call. Does not do error handling on your response.
-        :rtype: ~azure.core.rest.AsyncHttpResponse
+        :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    async def close(self) -> None:
-        await self._client.close()
+    def close(self) -> None:
+        self._client.close()
 
-    async def __aenter__(self) -> "AuthorizationManagementClient":
-        await self._client.__aenter__()
+    def __enter__(self) -> "AuthorizationManagementClient":
+        self._client.__enter__()
         return self
 
-    async def __aexit__(self, *exc_details: Any) -> None:
-        await self._client.__aexit__(*exc_details)
+    def __exit__(self, *exc_details: Any) -> None:
+        self._client.__exit__(*exc_details)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2018-01-01-preview". Note that overriding
-     this default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2015-07-01". Note that overriding this
+     default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop("api_version", "2018-01-01-preview")
+        api_version: str = kwargs.pop("api_version", "2015-07-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_definitions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,18 +33,14 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_by_id_request,
     build_get_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleDefinitionsOperations:
     """
     .. warning::
@@ -59,14 +55,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def delete(self, scope: str, role_definition_id: str, **kwargs: Any) -> Optional[_models.RoleDefinition]:
         """Deletes a role definition.
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
@@ -84,32 +81,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[Optional[_models.RoleDefinition]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -146,32 +144,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -269,24 +268,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(role_definition, (IO, bytes)):
+        if isinstance(role_definition, (IOBase, bytes)):
             _content = role_definition
         else:
             _json = self._serialize.body(role_definition, "RoleDefinition")
 
         request = build_create_or_update_request(
             scope=scope,
             role_definition_id=role_definition_id,
@@ -297,16 +296,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -335,16 +335,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -390,16 +390,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -432,31 +433,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_role_assignments_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -38,40 +38,37 @@
     build_get_request,
     build_list_for_resource_group_request,
     build_list_for_resource_request,
     build_list_for_scope_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_01_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2018_09_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`role_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -96,22 +93,22 @@
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -162,16 +159,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -196,22 +194,22 @@
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -258,16 +256,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -286,46 +285,47 @@
 
         :param scope: The scope of the role assignment to delete. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to delete. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or None or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment or None
+        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -362,21 +362,21 @@
          for a resource. Required.
         :type scope: str
         :param role_assignment_name: A GUID for the role assignment to create. The name must be unique
          and different for each role assignment. Required.
         :type role_assignment_name: str
         :param parameters: Parameters for the role assignment. Required.
         :type parameters:
-         ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignmentCreateParameters
+         ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignmentCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create(
         self,
         scope: str,
@@ -401,15 +401,15 @@
         :param parameters: Parameters for the role assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create(
         self,
         scope: str,
@@ -428,44 +428,44 @@
         :type scope: str
         :param role_assignment_name: A GUID for the role assignment to create. The name must be unique
          and different for each role assignment. Required.
         :type role_assignment_name: str
         :param parameters: Parameters for the role assignment. Is either a
          RoleAssignmentCreateParameters type or a IO type. Required.
         :type parameters:
-         ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignmentCreateParameters or IO
+         ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignmentCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -476,16 +476,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -506,46 +507,47 @@
 
         :param scope: The scope of the role assignment. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to get. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -564,45 +566,46 @@
     async def delete_by_id(self, role_id: str, **kwargs: Any) -> Optional[_models.RoleAssignment]:
         """Deletes a role assignment.
 
         :param role_id: The ID of the role assignment to delete. Required.
         :type role_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or None or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment or None
+        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -630,21 +633,21 @@
     ) -> _models.RoleAssignment:
         """Creates a role assignment by ID.
 
         :param role_id: The ID of the role assignment to create. Required.
         :type role_id: str
         :param parameters: Parameters for the role assignment. Required.
         :type parameters:
-         ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignmentCreateParameters
+         ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignmentCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_by_id(
         self, role_id: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.RoleAssignment:
@@ -655,59 +658,59 @@
         :param parameters: Parameters for the role assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_by_id(
         self, role_id: str, parameters: Union[_models.RoleAssignmentCreateParameters, IO], **kwargs: Any
     ) -> _models.RoleAssignment:
         """Creates a role assignment by ID.
 
         :param role_id: The ID of the role assignment to create. Required.
         :type role_id: str
         :param parameters: Parameters for the role assignment. Is either a
          RoleAssignmentCreateParameters type or a IO type. Required.
         :type parameters:
-         ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignmentCreateParameters or IO
+         ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignmentCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_id=role_id,
             api_version=api_version,
@@ -717,16 +720,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -745,45 +749,46 @@
     async def get_by_id(self, role_id: str, **kwargs: Any) -> _models.RoleAssignment:
         """Gets a role assignment by ID.
 
         :param role_id: The ID of the role assignment to get. Required.
         :type role_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -805,22 +810,22 @@
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -866,16 +871,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -897,22 +903,22 @@
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -958,16 +964,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_provider_operations_metadata_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_provider_operations_metadata_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -27,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._provider_operations_metadata_operations import build_get_request, build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ProviderOperationsMetadataOperations:
     """
     .. warning::
@@ -53,14 +48,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(
         self, resource_provider_namespace: str, expand: str = "resourceTypes", **kwargs: Any
     ) -> _models.ProviderOperationsMetadata:
         """Gets provider operations metadata for the specified resource provider.
 
@@ -80,32 +76,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.ProviderOperationsMetadata] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_provider_namespace=resource_provider_namespace,
             expand=expand,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -132,16 +129,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.ProviderOperationsMetadata]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.ProviderOperationsMetadataListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -186,16 +183,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_permissions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_permissions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._permissions_operations import build_list_for_resource_group_request, build_list_for_resource_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class PermissionsOperations:
     """
     .. warning::
@@ -52,14 +47,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.Permission"]:
         """Gets all permissions the caller has for a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
@@ -69,16 +65,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -124,16 +120,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -174,16 +171,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -233,16 +230,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_01_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/_authorization_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -67,19 +67,14 @@
             'access_review_instance_contacted_reviewers': '2021-12-01-preview',
             'access_review_instance_decisions': '2021-12-01-preview',
             'access_review_instance_my_decisions': '2021-12-01-preview',
             'access_review_instances': '2021-12-01-preview',
             'access_review_instances_assigned_for_my_approval': '2021-12-01-preview',
             'access_review_schedule_definitions': '2021-12-01-preview',
             'access_review_schedule_definitions_assigned_for_my_approval': '2021-12-01-preview',
-            'alert_configurations': '2021-12-01-preview',
-            'alert_definitions': '2021-12-01-preview',
-            'alert_incidents': '2021-12-01-preview',
-            'alert_operation': '2021-12-01-preview',
-            'alerts': '2021-12-01-preview',
             'classic_administrators': '2015-07-01',
             'eligible_child_resources': '2020-10-01',
             'global_administrator': '2015-07-01',
             'operations': '2021-12-01-preview',
             'role_assignment_approval': '2021-01-01-preview',
             'role_assignment_approval_step': '2021-01-01-preview',
             'role_assignment_approval_steps': '2021-01-01-preview',
@@ -115,14 +110,16 @@
         credential: "AsyncTokenCredential",
         subscription_id: str,
         api_version: Optional[str] = None,
         base_url: str = "https://management.azure.com",
         profile: KnownProfiles = KnownProfiles.default,
         **kwargs: Any
     ) -> None:
+        if api_version:
+            kwargs.setdefault('api_version', api_version)
         self._config = AuthorizationManagementClientConfiguration(credential, subscription_id, **kwargs)
         self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
         super(AuthorizationManagementClient, self).__init__(
             api_version=api_version,
             profile=profile
         )
 
@@ -145,14 +142,17 @@
            * 2020-10-01: :mod:`v2020_10_01.models<azure.mgmt.authorization.v2020_10_01.models>`
            * 2020-10-01-preview: :mod:`v2020_10_01_preview.models<azure.mgmt.authorization.v2020_10_01_preview.models>`
            * 2021-01-01-preview: :mod:`v2021_01_01_preview.models<azure.mgmt.authorization.v2021_01_01_preview.models>`
            * 2021-03-01-preview: :mod:`v2021_03_01_preview.models<azure.mgmt.authorization.v2021_03_01_preview.models>`
            * 2021-07-01-preview: :mod:`v2021_07_01_preview.models<azure.mgmt.authorization.v2021_07_01_preview.models>`
            * 2021-12-01-preview: :mod:`v2021_12_01_preview.models<azure.mgmt.authorization.v2021_12_01_preview.models>`
            * 2022-04-01: :mod:`v2022_04_01.models<azure.mgmt.authorization.v2022_04_01.models>`
+           * 2022-04-01-preview: :mod:`v2022_04_01_preview.models<azure.mgmt.authorization.v2022_04_01_preview.models>`
+           * 2022-05-01-preview: :mod:`v2022_05_01_preview.models<azure.mgmt.authorization.v2022_05_01_preview.models>`
+           * 2022-08-01-preview: :mod:`v2022_08_01_preview.models<azure.mgmt.authorization.v2022_08_01_preview.models>`
         """
         if api_version == '2015-06-01':
             from ..v2015_06_01 import models
             return models
         elif api_version == '2015-07-01':
             from ..v2015_07_01 import models
             return models
@@ -191,14 +191,23 @@
             return models
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview import models
             return models
         elif api_version == '2022-04-01':
             from ..v2022_04_01 import models
             return models
+        elif api_version == '2022-04-01-preview':
+            from ..v2022_04_01_preview import models
+            return models
+        elif api_version == '2022-05-01-preview':
+            from ..v2022_05_01_preview import models
+            return models
+        elif api_version == '2022-08-01-preview':
+            from ..v2022_08_01_preview import models
+            return models
         raise ValueError("API version {} is not available".format(api_version))
 
     @property
     def access_review_default_settings(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewDefaultSettingsOperations<azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewDefaultSettingsOperations>`
@@ -214,71 +223,71 @@
         elif api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import AccessReviewDefaultSettingsOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewDefaultSettingsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_default_settings'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_history_definition(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`AccessReviewHistoryDefinitionOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AccessReviewHistoryDefinitionOperations>`
         """
         api_version = self._get_api_version('access_review_history_definition')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewHistoryDefinitionOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_history_definition'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_history_definition_instance(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`AccessReviewHistoryDefinitionInstanceOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AccessReviewHistoryDefinitionInstanceOperations>`
         """
         api_version = self._get_api_version('access_review_history_definition_instance')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewHistoryDefinitionInstanceOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_history_definition_instance'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_history_definition_instances(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`AccessReviewHistoryDefinitionInstancesOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AccessReviewHistoryDefinitionInstancesOperations>`
         """
         api_version = self._get_api_version('access_review_history_definition_instances')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewHistoryDefinitionInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_history_definition_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_history_definitions(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`AccessReviewHistoryDefinitionsOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AccessReviewHistoryDefinitionsOperations>`
         """
         api_version = self._get_api_version('access_review_history_definitions')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewHistoryDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_history_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instance(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewInstanceOperations<azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstanceOperations>`
            * 2021-03-01-preview: :class:`AccessReviewInstanceOperations<azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstanceOperations>`
@@ -293,15 +302,15 @@
         elif api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import AccessReviewInstanceOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewInstanceOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instance'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instance_contacted_reviewers(self):
         """Instance depends on the API version:
 
            * 2021-07-01-preview: :class:`AccessReviewInstanceContactedReviewersOperations<azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstanceContactedReviewersOperations>`
            * 2021-12-01-preview: :class:`AccessReviewInstanceContactedReviewersOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AccessReviewInstanceContactedReviewersOperations>`
@@ -310,15 +319,15 @@
         if api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import AccessReviewInstanceContactedReviewersOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewInstanceContactedReviewersOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instance_contacted_reviewers'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instance_decisions(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewInstanceDecisionsOperations<azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstanceDecisionsOperations>`
            * 2021-03-01-preview: :class:`AccessReviewInstanceDecisionsOperations<azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstanceDecisionsOperations>`
@@ -333,15 +342,15 @@
         elif api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import AccessReviewInstanceDecisionsOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewInstanceDecisionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instance_decisions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instance_my_decisions(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewInstanceMyDecisionsOperations<azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstanceMyDecisionsOperations>`
            * 2021-03-01-preview: :class:`AccessReviewInstanceMyDecisionsOperations<azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstanceMyDecisionsOperations>`
@@ -356,15 +365,15 @@
         elif api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import AccessReviewInstanceMyDecisionsOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewInstanceMyDecisionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instance_my_decisions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instances(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewInstancesOperations<azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstancesOperations>`
            * 2021-03-01-preview: :class:`AccessReviewInstancesOperations<azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstancesOperations>`
@@ -379,15 +388,15 @@
         elif api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import AccessReviewInstancesOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_instances_assigned_for_my_approval(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewInstancesAssignedForMyApprovalOperations<azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstancesAssignedForMyApprovalOperations>`
            * 2021-03-01-preview: :class:`AccessReviewInstancesAssignedForMyApprovalOperations<azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstancesAssignedForMyApprovalOperations>`
@@ -402,15 +411,15 @@
         elif api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import AccessReviewInstancesAssignedForMyApprovalOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewInstancesAssignedForMyApprovalOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_instances_assigned_for_my_approval'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_schedule_definitions(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewScheduleDefinitionsOperations<azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewScheduleDefinitionsOperations>`
            * 2021-03-01-preview: :class:`AccessReviewScheduleDefinitionsOperations<azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewScheduleDefinitionsOperations>`
@@ -425,15 +434,15 @@
         elif api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import AccessReviewScheduleDefinitionsOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewScheduleDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_schedule_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def access_review_schedule_definitions_assigned_for_my_approval(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations<azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations>`
            * 2021-03-01-preview: :class:`AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations<azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations>`
@@ -448,85 +457,85 @@
         elif api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'access_review_schedule_definitions_assigned_for_my_approval'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def alert_configurations(self):
         """Instance depends on the API version:
 
-           * 2021-12-01-preview: :class:`AlertConfigurationsOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AlertConfigurationsOperations>`
+           * 2022-08-01-preview: :class:`AlertConfigurationsOperations<azure.mgmt.authorization.v2022_08_01_preview.aio.operations.AlertConfigurationsOperations>`
         """
         api_version = self._get_api_version('alert_configurations')
-        if api_version == '2021-12-01-preview':
-            from ..v2021_12_01_preview.aio.operations import AlertConfigurationsOperations as OperationClass
+        if api_version == '2022-08-01-preview':
+            from ..v2022_08_01_preview.aio.operations import AlertConfigurationsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'alert_configurations'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def alert_definitions(self):
         """Instance depends on the API version:
 
-           * 2021-12-01-preview: :class:`AlertDefinitionsOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AlertDefinitionsOperations>`
+           * 2022-08-01-preview: :class:`AlertDefinitionsOperations<azure.mgmt.authorization.v2022_08_01_preview.aio.operations.AlertDefinitionsOperations>`
         """
         api_version = self._get_api_version('alert_definitions')
-        if api_version == '2021-12-01-preview':
-            from ..v2021_12_01_preview.aio.operations import AlertDefinitionsOperations as OperationClass
+        if api_version == '2022-08-01-preview':
+            from ..v2022_08_01_preview.aio.operations import AlertDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'alert_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def alert_incidents(self):
         """Instance depends on the API version:
 
-           * 2021-12-01-preview: :class:`AlertIncidentsOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AlertIncidentsOperations>`
+           * 2022-08-01-preview: :class:`AlertIncidentsOperations<azure.mgmt.authorization.v2022_08_01_preview.aio.operations.AlertIncidentsOperations>`
         """
         api_version = self._get_api_version('alert_incidents')
-        if api_version == '2021-12-01-preview':
-            from ..v2021_12_01_preview.aio.operations import AlertIncidentsOperations as OperationClass
+        if api_version == '2022-08-01-preview':
+            from ..v2022_08_01_preview.aio.operations import AlertIncidentsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'alert_incidents'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def alert_operation(self):
         """Instance depends on the API version:
 
-           * 2021-12-01-preview: :class:`AlertOperationOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AlertOperationOperations>`
+           * 2022-08-01-preview: :class:`AlertOperationOperations<azure.mgmt.authorization.v2022_08_01_preview.aio.operations.AlertOperationOperations>`
         """
         api_version = self._get_api_version('alert_operation')
-        if api_version == '2021-12-01-preview':
-            from ..v2021_12_01_preview.aio.operations import AlertOperationOperations as OperationClass
+        if api_version == '2022-08-01-preview':
+            from ..v2022_08_01_preview.aio.operations import AlertOperationOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'alert_operation'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def alerts(self):
         """Instance depends on the API version:
 
-           * 2021-12-01-preview: :class:`AlertsOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AlertsOperations>`
+           * 2022-08-01-preview: :class:`AlertsOperations<azure.mgmt.authorization.v2022_08_01_preview.aio.operations.AlertsOperations>`
         """
         api_version = self._get_api_version('alerts')
-        if api_version == '2021-12-01-preview':
-            from ..v2021_12_01_preview.aio.operations import AlertsOperations as OperationClass
+        if api_version == '2022-08-01-preview':
+            from ..v2022_08_01_preview.aio.operations import AlertsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'alerts'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def classic_administrators(self):
         """Instance depends on the API version:
 
            * 2015-06-01: :class:`ClassicAdministratorsOperations<azure.mgmt.authorization.v2015_06_01.aio.operations.ClassicAdministratorsOperations>`
            * 2015-07-01: :class:`ClassicAdministratorsOperations<azure.mgmt.authorization.v2015_07_01.aio.operations.ClassicAdministratorsOperations>`
@@ -535,15 +544,15 @@
         if api_version == '2015-06-01':
             from ..v2015_06_01.aio.operations import ClassicAdministratorsOperations as OperationClass
         elif api_version == '2015-07-01':
             from ..v2015_07_01.aio.operations import ClassicAdministratorsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'classic_administrators'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def deny_assignments(self):
         """Instance depends on the API version:
 
            * 2018-07-01-preview: :class:`DenyAssignmentsOperations<azure.mgmt.authorization.v2018_07_01_preview.aio.operations.DenyAssignmentsOperations>`
            * 2022-04-01: :class:`DenyAssignmentsOperations<azure.mgmt.authorization.v2022_04_01.aio.operations.DenyAssignmentsOperations>`
@@ -552,15 +561,15 @@
         if api_version == '2018-07-01-preview':
             from ..v2018_07_01_preview.aio.operations import DenyAssignmentsOperations as OperationClass
         elif api_version == '2022-04-01':
             from ..v2022_04_01.aio.operations import DenyAssignmentsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'deny_assignments'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def eligible_child_resources(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`EligibleChildResourcesOperations<azure.mgmt.authorization.v2020_10_01.aio.operations.EligibleChildResourcesOperations>`
            * 2020-10-01-preview: :class:`EligibleChildResourcesOperations<azure.mgmt.authorization.v2020_10_01_preview.aio.operations.EligibleChildResourcesOperations>`
@@ -569,29 +578,29 @@
         if api_version == '2020-10-01':
             from ..v2020_10_01.aio.operations import EligibleChildResourcesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from ..v2020_10_01_preview.aio.operations import EligibleChildResourcesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'eligible_child_resources'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def global_administrator(self):
         """Instance depends on the API version:
 
            * 2015-07-01: :class:`GlobalAdministratorOperations<azure.mgmt.authorization.v2015_07_01.aio.operations.GlobalAdministratorOperations>`
         """
         api_version = self._get_api_version('global_administrator')
         if api_version == '2015-07-01':
             from ..v2015_07_01.aio.operations import GlobalAdministratorOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'global_administrator'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def operations(self):
         """Instance depends on the API version:
 
            * 2018-05-01-preview: :class:`Operations<azure.mgmt.authorization.v2018_05_01_preview.aio.operations.Operations>`
            * 2021-01-01-preview: :class:`Operations<azure.mgmt.authorization.v2021_01_01_preview.aio.operations.Operations>`
@@ -609,35 +618,38 @@
         elif api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import Operations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import Operations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'operations'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def permissions(self):
         """Instance depends on the API version:
 
            * 2015-07-01: :class:`PermissionsOperations<azure.mgmt.authorization.v2015_07_01.aio.operations.PermissionsOperations>`
            * 2018-01-01-preview: :class:`PermissionsOperations<azure.mgmt.authorization.v2018_01_01_preview.aio.operations.PermissionsOperations>`
            * 2022-04-01: :class:`PermissionsOperations<azure.mgmt.authorization.v2022_04_01.aio.operations.PermissionsOperations>`
+           * 2022-05-01-preview: :class:`PermissionsOperations<azure.mgmt.authorization.v2022_05_01_preview.aio.operations.PermissionsOperations>`
         """
         api_version = self._get_api_version('permissions')
         if api_version == '2015-07-01':
             from ..v2015_07_01.aio.operations import PermissionsOperations as OperationClass
         elif api_version == '2018-01-01-preview':
             from ..v2018_01_01_preview.aio.operations import PermissionsOperations as OperationClass
         elif api_version == '2022-04-01':
             from ..v2022_04_01.aio.operations import PermissionsOperations as OperationClass
+        elif api_version == '2022-05-01-preview':
+            from ..v2022_05_01_preview.aio.operations import PermissionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'permissions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def provider_operations_metadata(self):
         """Instance depends on the API version:
 
            * 2015-07-01: :class:`ProviderOperationsMetadataOperations<azure.mgmt.authorization.v2015_07_01.aio.operations.ProviderOperationsMetadataOperations>`
            * 2018-01-01-preview: :class:`ProviderOperationsMetadataOperations<azure.mgmt.authorization.v2018_01_01_preview.aio.operations.ProviderOperationsMetadataOperations>`
@@ -649,71 +661,71 @@
         elif api_version == '2018-01-01-preview':
             from ..v2018_01_01_preview.aio.operations import ProviderOperationsMetadataOperations as OperationClass
         elif api_version == '2022-04-01':
             from ..v2022_04_01.aio.operations import ProviderOperationsMetadataOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'provider_operations_metadata'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_approval(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`RoleAssignmentApprovalOperations<azure.mgmt.authorization.v2021_01_01_preview.aio.operations.RoleAssignmentApprovalOperations>`
         """
         api_version = self._get_api_version('role_assignment_approval')
         if api_version == '2021-01-01-preview':
             from ..v2021_01_01_preview.aio.operations import RoleAssignmentApprovalOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_approval'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_approval_step(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`RoleAssignmentApprovalStepOperations<azure.mgmt.authorization.v2021_01_01_preview.aio.operations.RoleAssignmentApprovalStepOperations>`
         """
         api_version = self._get_api_version('role_assignment_approval_step')
         if api_version == '2021-01-01-preview':
             from ..v2021_01_01_preview.aio.operations import RoleAssignmentApprovalStepOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_approval_step'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_approval_steps(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`RoleAssignmentApprovalStepsOperations<azure.mgmt.authorization.v2021_01_01_preview.aio.operations.RoleAssignmentApprovalStepsOperations>`
         """
         api_version = self._get_api_version('role_assignment_approval_steps')
         if api_version == '2021-01-01-preview':
             from ..v2021_01_01_preview.aio.operations import RoleAssignmentApprovalStepsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_approval_steps'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_metrics(self):
         """Instance depends on the API version:
 
            * 2019-08-01-preview: :class:`RoleAssignmentMetricsOperations<azure.mgmt.authorization.v2019_08_01_preview.aio.operations.RoleAssignmentMetricsOperations>`
         """
         api_version = self._get_api_version('role_assignment_metrics')
         if api_version == '2019-08-01-preview':
             from ..v2019_08_01_preview.aio.operations import RoleAssignmentMetricsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_metrics'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_schedule_instances(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleAssignmentScheduleInstancesOperations<azure.mgmt.authorization.v2020_10_01.aio.operations.RoleAssignmentScheduleInstancesOperations>`
            * 2020-10-01-preview: :class:`RoleAssignmentScheduleInstancesOperations<azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleAssignmentScheduleInstancesOperations>`
@@ -722,32 +734,35 @@
         if api_version == '2020-10-01':
             from ..v2020_10_01.aio.operations import RoleAssignmentScheduleInstancesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from ..v2020_10_01_preview.aio.operations import RoleAssignmentScheduleInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_schedule_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_schedule_requests(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleAssignmentScheduleRequestsOperations<azure.mgmt.authorization.v2020_10_01.aio.operations.RoleAssignmentScheduleRequestsOperations>`
            * 2020-10-01-preview: :class:`RoleAssignmentScheduleRequestsOperations<azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleAssignmentScheduleRequestsOperations>`
+           * 2022-04-01-preview: :class:`RoleAssignmentScheduleRequestsOperations<azure.mgmt.authorization.v2022_04_01_preview.aio.operations.RoleAssignmentScheduleRequestsOperations>`
         """
         api_version = self._get_api_version('role_assignment_schedule_requests')
         if api_version == '2020-10-01':
             from ..v2020_10_01.aio.operations import RoleAssignmentScheduleRequestsOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from ..v2020_10_01_preview.aio.operations import RoleAssignmentScheduleRequestsOperations as OperationClass
+        elif api_version == '2022-04-01-preview':
+            from ..v2022_04_01_preview.aio.operations import RoleAssignmentScheduleRequestsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_schedule_requests'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignment_schedules(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleAssignmentSchedulesOperations<azure.mgmt.authorization.v2020_10_01.aio.operations.RoleAssignmentSchedulesOperations>`
            * 2020-10-01-preview: :class:`RoleAssignmentSchedulesOperations<azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleAssignmentSchedulesOperations>`
@@ -756,15 +771,15 @@
         if api_version == '2020-10-01':
             from ..v2020_10_01.aio.operations import RoleAssignmentSchedulesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from ..v2020_10_01_preview.aio.operations import RoleAssignmentSchedulesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignment_schedules'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_assignments(self):
         """Instance depends on the API version:
 
            * 2015-07-01: :class:`RoleAssignmentsOperations<azure.mgmt.authorization.v2015_07_01.aio.operations.RoleAssignmentsOperations>`
            * 2018-01-01-preview: :class:`RoleAssignmentsOperations<azure.mgmt.authorization.v2018_01_01_preview.aio.operations.RoleAssignmentsOperations>`
@@ -785,35 +800,38 @@
         elif api_version == '2020-10-01-preview':
             from ..v2020_10_01_preview.aio.operations import RoleAssignmentsOperations as OperationClass
         elif api_version == '2022-04-01':
             from ..v2022_04_01.aio.operations import RoleAssignmentsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_assignments'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_definitions(self):
         """Instance depends on the API version:
 
            * 2015-07-01: :class:`RoleDefinitionsOperations<azure.mgmt.authorization.v2015_07_01.aio.operations.RoleDefinitionsOperations>`
            * 2018-01-01-preview: :class:`RoleDefinitionsOperations<azure.mgmt.authorization.v2018_01_01_preview.aio.operations.RoleDefinitionsOperations>`
            * 2022-04-01: :class:`RoleDefinitionsOperations<azure.mgmt.authorization.v2022_04_01.aio.operations.RoleDefinitionsOperations>`
+           * 2022-05-01-preview: :class:`RoleDefinitionsOperations<azure.mgmt.authorization.v2022_05_01_preview.aio.operations.RoleDefinitionsOperations>`
         """
         api_version = self._get_api_version('role_definitions')
         if api_version == '2015-07-01':
             from ..v2015_07_01.aio.operations import RoleDefinitionsOperations as OperationClass
         elif api_version == '2018-01-01-preview':
             from ..v2018_01_01_preview.aio.operations import RoleDefinitionsOperations as OperationClass
         elif api_version == '2022-04-01':
             from ..v2022_04_01.aio.operations import RoleDefinitionsOperations as OperationClass
+        elif api_version == '2022-05-01-preview':
+            from ..v2022_05_01_preview.aio.operations import RoleDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_eligibility_schedule_instances(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleEligibilityScheduleInstancesOperations<azure.mgmt.authorization.v2020_10_01.aio.operations.RoleEligibilityScheduleInstancesOperations>`
            * 2020-10-01-preview: :class:`RoleEligibilityScheduleInstancesOperations<azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleEligibilityScheduleInstancesOperations>`
@@ -822,32 +840,35 @@
         if api_version == '2020-10-01':
             from ..v2020_10_01.aio.operations import RoleEligibilityScheduleInstancesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from ..v2020_10_01_preview.aio.operations import RoleEligibilityScheduleInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_eligibility_schedule_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_eligibility_schedule_requests(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleEligibilityScheduleRequestsOperations<azure.mgmt.authorization.v2020_10_01.aio.operations.RoleEligibilityScheduleRequestsOperations>`
            * 2020-10-01-preview: :class:`RoleEligibilityScheduleRequestsOperations<azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleEligibilityScheduleRequestsOperations>`
+           * 2022-04-01-preview: :class:`RoleEligibilityScheduleRequestsOperations<azure.mgmt.authorization.v2022_04_01_preview.aio.operations.RoleEligibilityScheduleRequestsOperations>`
         """
         api_version = self._get_api_version('role_eligibility_schedule_requests')
         if api_version == '2020-10-01':
             from ..v2020_10_01.aio.operations import RoleEligibilityScheduleRequestsOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from ..v2020_10_01_preview.aio.operations import RoleEligibilityScheduleRequestsOperations as OperationClass
+        elif api_version == '2022-04-01-preview':
+            from ..v2022_04_01_preview.aio.operations import RoleEligibilityScheduleRequestsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_eligibility_schedule_requests'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_eligibility_schedules(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleEligibilitySchedulesOperations<azure.mgmt.authorization.v2020_10_01.aio.operations.RoleEligibilitySchedulesOperations>`
            * 2020-10-01-preview: :class:`RoleEligibilitySchedulesOperations<azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleEligibilitySchedulesOperations>`
@@ -856,15 +877,15 @@
         if api_version == '2020-10-01':
             from ..v2020_10_01.aio.operations import RoleEligibilitySchedulesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from ..v2020_10_01_preview.aio.operations import RoleEligibilitySchedulesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_eligibility_schedules'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_management_policies(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleManagementPoliciesOperations<azure.mgmt.authorization.v2020_10_01.aio.operations.RoleManagementPoliciesOperations>`
            * 2020-10-01-preview: :class:`RoleManagementPoliciesOperations<azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleManagementPoliciesOperations>`
@@ -873,15 +894,15 @@
         if api_version == '2020-10-01':
             from ..v2020_10_01.aio.operations import RoleManagementPoliciesOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from ..v2020_10_01_preview.aio.operations import RoleManagementPoliciesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_management_policies'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def role_management_policy_assignments(self):
         """Instance depends on the API version:
 
            * 2020-10-01: :class:`RoleManagementPolicyAssignmentsOperations<azure.mgmt.authorization.v2020_10_01.aio.operations.RoleManagementPolicyAssignmentsOperations>`
            * 2020-10-01-preview: :class:`RoleManagementPolicyAssignmentsOperations<azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleManagementPolicyAssignmentsOperations>`
@@ -890,197 +911,197 @@
         if api_version == '2020-10-01':
             from ..v2020_10_01.aio.operations import RoleManagementPolicyAssignmentsOperations as OperationClass
         elif api_version == '2020-10-01-preview':
             from ..v2020_10_01_preview.aio.operations import RoleManagementPolicyAssignmentsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'role_management_policy_assignments'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_default_settings(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewDefaultSettingsOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.ScopeAccessReviewDefaultSettingsOperations>`
         """
         api_version = self._get_api_version('scope_access_review_default_settings')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import ScopeAccessReviewDefaultSettingsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_default_settings'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_history_definition(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewHistoryDefinitionOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.ScopeAccessReviewHistoryDefinitionOperations>`
         """
         api_version = self._get_api_version('scope_access_review_history_definition')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import ScopeAccessReviewHistoryDefinitionOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_history_definition'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_history_definition_instance(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewHistoryDefinitionInstanceOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.ScopeAccessReviewHistoryDefinitionInstanceOperations>`
         """
         api_version = self._get_api_version('scope_access_review_history_definition_instance')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import ScopeAccessReviewHistoryDefinitionInstanceOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_history_definition_instance'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_history_definition_instances(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewHistoryDefinitionInstancesOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.ScopeAccessReviewHistoryDefinitionInstancesOperations>`
         """
         api_version = self._get_api_version('scope_access_review_history_definition_instances')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import ScopeAccessReviewHistoryDefinitionInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_history_definition_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_history_definitions(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewHistoryDefinitionsOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.ScopeAccessReviewHistoryDefinitionsOperations>`
         """
         api_version = self._get_api_version('scope_access_review_history_definitions')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import ScopeAccessReviewHistoryDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_history_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_instance(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewInstanceOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.ScopeAccessReviewInstanceOperations>`
         """
         api_version = self._get_api_version('scope_access_review_instance')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import ScopeAccessReviewInstanceOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_instance'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_instance_contacted_reviewers(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewInstanceContactedReviewersOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.ScopeAccessReviewInstanceContactedReviewersOperations>`
         """
         api_version = self._get_api_version('scope_access_review_instance_contacted_reviewers')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import ScopeAccessReviewInstanceContactedReviewersOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_instance_contacted_reviewers'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_instance_decisions(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewInstanceDecisionsOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.ScopeAccessReviewInstanceDecisionsOperations>`
         """
         api_version = self._get_api_version('scope_access_review_instance_decisions')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import ScopeAccessReviewInstanceDecisionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_instance_decisions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_instances(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewInstancesOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.ScopeAccessReviewInstancesOperations>`
         """
         api_version = self._get_api_version('scope_access_review_instances')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import ScopeAccessReviewInstancesOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_instances'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_access_review_schedule_definitions(self):
         """Instance depends on the API version:
 
            * 2021-12-01-preview: :class:`ScopeAccessReviewScheduleDefinitionsOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.ScopeAccessReviewScheduleDefinitionsOperations>`
         """
         api_version = self._get_api_version('scope_access_review_schedule_definitions')
         if api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import ScopeAccessReviewScheduleDefinitionsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_access_review_schedule_definitions'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_role_assignment_approval(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`ScopeRoleAssignmentApprovalOperations<azure.mgmt.authorization.v2021_01_01_preview.aio.operations.ScopeRoleAssignmentApprovalOperations>`
         """
         api_version = self._get_api_version('scope_role_assignment_approval')
         if api_version == '2021-01-01-preview':
             from ..v2021_01_01_preview.aio.operations import ScopeRoleAssignmentApprovalOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_role_assignment_approval'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_role_assignment_approval_step(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`ScopeRoleAssignmentApprovalStepOperations<azure.mgmt.authorization.v2021_01_01_preview.aio.operations.ScopeRoleAssignmentApprovalStepOperations>`
         """
         api_version = self._get_api_version('scope_role_assignment_approval_step')
         if api_version == '2021-01-01-preview':
             from ..v2021_01_01_preview.aio.operations import ScopeRoleAssignmentApprovalStepOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_role_assignment_approval_step'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def scope_role_assignment_approval_steps(self):
         """Instance depends on the API version:
 
            * 2021-01-01-preview: :class:`ScopeRoleAssignmentApprovalStepsOperations<azure.mgmt.authorization.v2021_01_01_preview.aio.operations.ScopeRoleAssignmentApprovalStepsOperations>`
         """
         api_version = self._get_api_version('scope_role_assignment_approval_steps')
         if api_version == '2021-01-01-preview':
             from ..v2021_01_01_preview.aio.operations import ScopeRoleAssignmentApprovalStepsOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'scope_role_assignment_approval_steps'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     @property
     def tenant_level_access_review_instance_contacted_reviewers(self):
         """Instance depends on the API version:
 
            * 2021-07-01-preview: :class:`TenantLevelAccessReviewInstanceContactedReviewersOperations<azure.mgmt.authorization.v2021_07_01_preview.aio.operations.TenantLevelAccessReviewInstanceContactedReviewersOperations>`
            * 2021-12-01-preview: :class:`TenantLevelAccessReviewInstanceContactedReviewersOperations<azure.mgmt.authorization.v2021_12_01_preview.aio.operations.TenantLevelAccessReviewInstanceContactedReviewersOperations>`
@@ -1089,15 +1110,15 @@
         if api_version == '2021-07-01-preview':
             from ..v2021_07_01_preview.aio.operations import TenantLevelAccessReviewInstanceContactedReviewersOperations as OperationClass
         elif api_version == '2021-12-01-preview':
             from ..v2021_12_01_preview.aio.operations import TenantLevelAccessReviewInstanceContactedReviewersOperations as OperationClass
         else:
             raise ValueError("API version {} does not have operation group 'tenant_level_access_review_instance_contacted_reviewers'".format(api_version))
         self._config.api_version = api_version
-        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)))
+        return OperationClass(self._client, self._config, Serializer(self._models_dict(api_version)), Deserializer(self._models_dict(api_version)), api_version)
 
     async def close(self):
         await self._client.close()
     async def __aenter__(self):
         await self._client.__aenter__()
         return self
     async def __aexit__(self, *exc_details):
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/_configuration.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_authorization_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -48,22 +48,22 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.classic_administrators = ClassicAdministratorsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-06-01"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/_configuration.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2015-06-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2018-09-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2015-06-01"] = kwargs.pop("api_version", "2015-06-01")
+        api_version: str = kwargs.pop("api_version", "2018-09-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/_classic_administrators_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_classic_administrators_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-06-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/classicAdministrators"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -69,42 +64,43 @@
 
 class ClassicAdministratorsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2015_06_01.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2015_07_01.AuthorizationManagementClient`'s
         :attr:`classic_administrators` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.ClassicAdministrator"]:
         """Gets service administrator, account administrator, and co-administrators for the subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ClassicAdministrator or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_06_01.models.ClassicAdministrator]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.ClassicAdministrator]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-06-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.ClassicAdministratorListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -148,16 +144,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/_authorization_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -48,22 +48,22 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.classic_administrators = ClassicAdministratorsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-06-01"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -38,15 +32,15 @@
     :keyword api_version: Api Version. Default value is "2015-06-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2015-06-01"] = kwargs.pop("api_version", "2015-06-01")
+        api_version: str = kwargs.pop("api_version", "2015-06-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/_classic_administrators_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_classic_administrators_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,56 +25,53 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._classic_administrators_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ClassicAdministratorsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2015_06_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2015_07_01.aio.AuthorizationManagementClient`'s
         :attr:`classic_administrators` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.ClassicAdministrator"]:
         """Gets service administrator, account administrator, and co-administrators for the subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ClassicAdministrator or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_06_01.models.ClassicAdministrator]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.ClassicAdministrator]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-06-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-06-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.ClassicAdministratorListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -119,16 +115,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_06_01/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_authorization_management_client.py`

 * *Files 14% similar despite different names*

```diff
@@ -25,19 +25,14 @@
     AccessReviewInstanceDecisionsOperations,
     AccessReviewInstanceMyDecisionsOperations,
     AccessReviewInstanceOperations,
     AccessReviewInstancesAssignedForMyApprovalOperations,
     AccessReviewInstancesOperations,
     AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations,
     AccessReviewScheduleDefinitionsOperations,
-    AlertConfigurationsOperations,
-    AlertDefinitionsOperations,
-    AlertIncidentsOperations,
-    AlertOperationOperations,
-    AlertsOperations,
     Operations,
     ScopeAccessReviewDefaultSettingsOperations,
     ScopeAccessReviewHistoryDefinitionInstanceOperations,
     ScopeAccessReviewHistoryDefinitionInstancesOperations,
     ScopeAccessReviewHistoryDefinitionOperations,
     ScopeAccessReviewHistoryDefinitionsOperations,
     ScopeAccessReviewInstanceContactedReviewersOperations,
@@ -141,140 +136,120 @@
     :ivar access_review_instance_my_decisions: AccessReviewInstanceMyDecisionsOperations operations
     :vartype access_review_instance_my_decisions:
      azure.mgmt.authorization.v2021_12_01_preview.operations.AccessReviewInstanceMyDecisionsOperations
     :ivar tenant_level_access_review_instance_contacted_reviewers:
      TenantLevelAccessReviewInstanceContactedReviewersOperations operations
     :vartype tenant_level_access_review_instance_contacted_reviewers:
      azure.mgmt.authorization.v2021_12_01_preview.operations.TenantLevelAccessReviewInstanceContactedReviewersOperations
-    :ivar alerts: AlertsOperations operations
-    :vartype alerts: azure.mgmt.authorization.v2021_12_01_preview.operations.AlertsOperations
-    :ivar alert_configurations: AlertConfigurationsOperations operations
-    :vartype alert_configurations:
-     azure.mgmt.authorization.v2021_12_01_preview.operations.AlertConfigurationsOperations
-    :ivar alert_definitions: AlertDefinitionsOperations operations
-    :vartype alert_definitions:
-     azure.mgmt.authorization.v2021_12_01_preview.operations.AlertDefinitionsOperations
-    :ivar alert_incidents: AlertIncidentsOperations operations
-    :vartype alert_incidents:
-     azure.mgmt.authorization.v2021_12_01_preview.operations.AlertIncidentsOperations
-    :ivar alert_operation: AlertOperationOperations operations
-    :vartype alert_operation:
-     azure.mgmt.authorization.v2021_12_01_preview.operations.AlertOperationOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-     Retry-After header is present.
+    :keyword api_version: Api Version. Default value is "2021-12-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
+    :paramtype api_version: str
     """
 
     def __init__(
         self,
         credential: "TokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
+        )
         self.access_review_history_definitions = AccessReviewHistoryDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_history_definition = AccessReviewHistoryDefinitionOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_history_definition_instance = AccessReviewHistoryDefinitionInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_history_definition_instances = AccessReviewHistoryDefinitionInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_schedule_definitions = AccessReviewScheduleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_instances = AccessReviewInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_instance = AccessReviewInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_instance_decisions = AccessReviewInstanceDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_instance_contacted_reviewers = AccessReviewInstanceContactedReviewersOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_default_settings = AccessReviewDefaultSettingsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_history_definitions = ScopeAccessReviewHistoryDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_history_definition = ScopeAccessReviewHistoryDefinitionOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_history_definition_instance = ScopeAccessReviewHistoryDefinitionInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_history_definition_instances = ScopeAccessReviewHistoryDefinitionInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_schedule_definitions = ScopeAccessReviewScheduleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_instances = ScopeAccessReviewInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_instance = ScopeAccessReviewInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_instance_decisions = ScopeAccessReviewInstanceDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_instance_contacted_reviewers = ScopeAccessReviewInstanceContactedReviewersOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_default_settings = ScopeAccessReviewDefaultSettingsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_schedule_definitions_assigned_for_my_approval = (
             AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations(
-                self._client, self._config, self._serialize, self._deserialize
+                self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
             )
         )
         self.access_review_instances_assigned_for_my_approval = AccessReviewInstancesAssignedForMyApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_instance_my_decisions = AccessReviewInstanceMyDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.tenant_level_access_review_instance_contacted_reviewers = (
             TenantLevelAccessReviewInstanceContactedReviewersOperations(
-                self._client, self._config, self._serialize, self._deserialize
+                self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
             )
         )
-        self.alerts = AlertsOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.alert_configurations = AlertConfigurationsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.alert_definitions = AlertDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.alert_incidents = AlertIncidentsOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.alert_operation = AlertOperationOperations(self._client, self._config, self._serialize, self._deserialize)
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,55 +6,61 @@
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
+    :keyword api_version: Api Version. Default value is "2021-07-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
+    :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
+        api_version: str = kwargs.pop("api_version", "2021-07-01-preview")
+
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
         self.subscription_id = subscription_id
+        self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "mgmt-authorization/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_default_settings_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_default_settings_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +24,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
     }
@@ -65,17 +59,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_put_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
@@ -108,14 +100,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, scope: str, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
         :param scope: The scope of the resource. Required.
         :type scope: str
@@ -131,31 +124,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -241,24 +235,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
 
         request = build_put_request(
             scope=scope,
             api_version=api_version,
@@ -268,16 +262,17 @@
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definitions_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
     }
@@ -68,17 +62,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(scope: str, history_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}",
     )  # pylint: disable=line-too-long
@@ -112,14 +104,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewHistoryDefinition"]:
         """Lists the accessReviewHistoryDefinitions available from this provider, definition instances are
         only available for 30 days after creation.
@@ -135,16 +128,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -163,15 +156,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewHistoryDefinitionListResult", pipeline_response)
@@ -179,16 +183,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -219,32 +224,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             scope=scope,
             history_definition_id=history_definition_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_decisions_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,106 +25,90 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(
-    schedule_definition_id: str, id: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
-) -> HttpRequest:
+def build_list_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
         "id": _SERIALIZER.url("id", id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-    if filter is not None:
-        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class AccessReviewInstanceDecisionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_instance_decisions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(
-        self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> Iterable["_models.AccessReviewDecision"]:
+    def list(self, schedule_definition_id: str, id: str, **kwargs: Any) -> Iterable["_models.AccessReviewDecision"]:
         """Get access review instance decisions.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
-        :param filter: The filter to apply on the operation. Other than standard filters, one custom
-         filter option is supported : 'assignedToMeToReview()'. When one specified
-         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
-         returned. Default value is None.
-        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewDecision or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -135,25 +119,35 @@
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     schedule_definition_id=schedule_definition_id,
                     id=id,
                     subscription_id=self._config.subscription_id,
-                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewDecisionListResult", pipeline_response)
@@ -161,16 +155,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_configurations_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_configurations_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlertConfigurations/{alertId}"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -69,17 +64,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlertConfigurations/{alertId}"
     )  # pylint: disable=line-too-long
@@ -101,17 +94,15 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlertConfigurations")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -129,26 +120,27 @@
 
 class AlertConfigurationsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_08_01_preview.AuthorizationManagementClient`'s
         :attr:`alert_configurations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, scope: str, alert_id: str, **kwargs: Any) -> _models.AlertConfiguration:
         """Get the specified alert configuration.
 
         :param scope: The scope of the alert configuration. The scope can be any REST resource
          instance. For example, use '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/'
@@ -158,46 +150,47 @@
          '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param alert_id: The name of the alert configuration to get. Required.
         :type alert_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AlertConfiguration or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration
+        :rtype: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertConfiguration
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertConfiguration] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             alert_id=alert_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -224,15 +217,15 @@
         """Update an alert configuration.
 
         :param scope: The scope of the alert configuration. Required.
         :type scope: str
         :param alert_id: The name of the alert configuration to update. Required.
         :type alert_id: str
         :param parameters: Parameters for the alert configuration. Required.
-        :type parameters: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration
+        :type parameters: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertConfiguration
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -267,15 +260,15 @@
 
         :param scope: The scope of the alert configuration. Required.
         :type scope: str
         :param alert_id: The name of the alert configuration to update. Required.
         :type alert_id: str
         :param parameters: Parameters for the alert configuration. Is either a AlertConfiguration type
          or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration or IO
+        :type parameters: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertConfiguration or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -287,24 +280,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AlertConfiguration")
 
         request = build_update_request(
             scope=scope,
             alert_id=alert_id,
@@ -315,16 +308,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -339,22 +333,22 @@
         """Gets alert configurations for a resource scope.
 
         :param scope: The scope of the alert configuration. Required.
         :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AlertConfiguration or the result of cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_08_01_preview.models.AlertConfiguration]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertConfigurationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -372,15 +366,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AlertConfigurationListResult", pipeline_response)
@@ -388,16 +393,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_schedule_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_schedule_definitions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str"),
     }
@@ -68,17 +63,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(scope: str, schedule_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
@@ -98,17 +91,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(scope: str, schedule_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
@@ -128,17 +119,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_by_id_request(scope: str, schedule_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
@@ -161,17 +150,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_stop_request(scope: str, schedule_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/stop",
     )  # pylint: disable=line-too-long
@@ -205,14 +192,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review schedule definitions.
 
@@ -229,16 +217,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -257,15 +245,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
@@ -273,16 +272,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -315,32 +315,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -379,32 +380,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -506,24 +508,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleDefinitionProperties")
 
         request = build_create_or_update_by_id_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
@@ -534,16 +536,17 @@
             template_url=self.create_or_update_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -582,32 +585,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             api_version=api_version,
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,162 +25,155 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(
-    scope: str, schedule_definition_id: str, id: str, *, filter: Optional[str] = None, **kwargs: Any
-) -> HttpRequest:
+def build_list_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions",
+        "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "scope": _SERIALIZER.url("scope", scope, "str"),
         "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
         "id": _SERIALIZER.url("id", id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-    if filter is not None:
-        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ScopeAccessReviewInstanceDecisionsOperations:
+class TenantLevelAccessReviewInstanceContactedReviewersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
-        :attr:`scope_access_review_instance_decisions` attribute.
+        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
+        :attr:`tenant_level_access_review_instance_contacted_reviewers` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
-        self, scope: str, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> Iterable["_models.AccessReviewDecision"]:
-        """Get access review instance decisions.
+        self, schedule_definition_id: str, id: str, **kwargs: Any
+    ) -> Iterable["_models.AccessReviewContactedReviewer"]:
+        """Get access review instance contacted reviewers.
 
-        :param scope: The scope of the resource. Required.
-        :type scope: str
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
-        :param filter: The filter to apply on the operation. Other than standard filters, one custom
-         filter option is supported : 'assignedToMeToReview()'. When one specified
-         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
-         returned. Default value is None.
-        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewDecision or the result of
+        :return: An iterator like instance of either AccessReviewContactedReviewer or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewContactedReviewer]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
-        cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
-                    scope=scope,
                     schedule_definition_id=schedule_definition_id,
                     id=id,
-                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewDecisionListResult", pipeline_response)
+            deserialized = self._deserialize("AccessReviewContactedReviewerListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {
-        "url": "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions"
+        "url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instance_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,43 +23,37 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_generate_download_uri_request(
-    history_definition_id: str, instance_id: str, subscription_id: str, **kwargs: Any
+    scope: str, history_definition_id: str, instance_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances/{instanceId}/generateDownloadUri",
+        "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances/{instanceId}/generateDownloadUri",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "scope": _SERIALIZER.url("scope", scope, "str"),
         "historyDefinitionId": _SERIALIZER.url("history_definition_id", history_definition_id, "str"),
         "instanceId": _SERIALIZER.url("instance_id", instance_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
@@ -68,40 +61,43 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class AccessReviewHistoryDefinitionInstanceOperations:
+class ScopeAccessReviewHistoryDefinitionInstanceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
-        :attr:`access_review_history_definition_instance` attribute.
+        :attr:`scope_access_review_history_definition_instance` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def generate_download_uri(
-        self, history_definition_id: str, instance_id: str, **kwargs: Any
+        self, scope: str, history_definition_id: str, instance_id: str, **kwargs: Any
     ) -> _models.AccessReviewHistoryInstance:
         """Generates a uri which can be used to retrieve review history data. This URI has a TTL of 1 day
         and can be retrieved by fetching the accessReviewHistoryDefinition object.
 
+        :param scope: The scope of the resource. Required.
+        :type scope: str
         :param history_definition_id: The id of the access review history definition. Required.
         :type history_definition_id: str
         :param instance_id: The id of the access review history definition instance to generate a URI
          for. Required.
         :type instance_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewHistoryInstance or the result of cls(response)
@@ -115,33 +111,34 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryInstance] = kwargs.pop("cls", None)
 
         request = build_generate_download_uri_request(
+            scope=scope,
             history_definition_id=history_definition_id,
             instance_id=instance_id,
-            subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.generate_download_uri.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -151,9 +148,9 @@
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     generate_download_uri.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances/{instanceId}/generateDownloadUri"
+        "url": "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances/{instanceId}/generateDownloadUri"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_contacted_reviewers_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_contacted_reviewers_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(scope: str, schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers",
     )  # pylint: disable=line-too-long
@@ -85,14 +79,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, scope: str, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> Iterable["_models.AccessReviewContactedReviewer"]:
         """Get access review instance contacted reviewers.
 
@@ -108,16 +103,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewContactedReviewer]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -137,15 +132,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewContactedReviewerListResult", pipeline_response)
@@ -153,16 +159,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(schedule_definition_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances",
     )  # pylint: disable=line-too-long
@@ -71,17 +65,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
     )  # pylint: disable=line-too-long
@@ -115,14 +107,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewInstance"]:
         """Get access review instances assigned for my approval.
 
@@ -139,16 +132,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -167,15 +160,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
@@ -183,16 +187,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -225,32 +230,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_operation_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,228 +2,214 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, Optional, TypeVar
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from ..._serialization import Serializer
-from .._vendor import _convert_request, _format_url_section
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_get_request(scope: str, operation_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlertOperations/{operationId}"
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
-        "operationId": _SERIALIZER.url("operation_id", operation_id, "str", skip_quote=True),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_list_for_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._scope_role_assignment_approval_operations import build_get_by_id_request, build_list_request
 
-    # Construct URL
-    _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlertOperations")
-    path_format_arguments = {
-        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+T = TypeVar("T")
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AlertOperationOperations:
+class ScopeRoleAssignmentApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
-        :attr:`alert_operation` attribute.
+        :class:`~azure.mgmt.authorization.v2021_01_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`scope_role_assignment_approval` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def get(self, scope: str, operation_id: str, **kwargs: Any) -> _models.AlertOperationResult:
-        """Get the specified alert operation.
+    def list(
+        self, scope: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.RoleAssignmentApproval"]:
+        """Get role assignment approvals.
 
-        :param scope: The scope of the alert operation. Required.
+        :param scope: The scope of the resource. Required.
         :type scope: str
-        :param operation_id: The id of the alert operation. Required.
-        :type operation_id: str
+        :param filter: The filter to apply on the operation. Valid values for $filter are:
+         'asApprover()', 'asCreatedBy()' and 'asTarget()'. If $filter is not provided, no filtering is
+         performed. If $filter=asApprover() is provided, the returned list only includes all role
+         assignment approvals that the calling user is assigned as an approver for. If
+         $filter=asCreatedBy() is provided, the returned list only includes all role assignment
+         approvals that the calling user created requests for. If $filter=asTarget() is provided, the
+         returned list only includes all role assignment approvals that the calling user has requests
+         targeted for. Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AlertOperationResult or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertOperationResult
+        :return: An iterator like instance of either RoleAssignmentApproval or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApproval]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
+        )
+        cls: ClsType[_models.RoleAssignmentApprovalListResult] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
-        )
-        cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
-
-        request = build_get_request(
-            scope=scope,
-            operation_id=operation_id,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("AlertOperationResult", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleManagementAlertOperations/{operationId}"}
-
-    @distributed_trace
-    def list_for_scope(self, scope: str, **kwargs: Any) -> _models.AlertOperationListResult:
-        """Gets alert operations for a resource scope.
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        :param scope: The scope of the alert operation. Required.
+                request = build_list_request(
+                    scope=scope,
+                    filter=filter,
+                    api_version=api_version,
+                    template_url=self.list.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("RoleAssignmentApprovalListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+            return pipeline_response
+
+        return AsyncItemPaged(get_next, extract_data)
+
+    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals"}
+
+    @distributed_trace_async
+    async def get_by_id(self, approval_id: str, scope: str, **kwargs: Any) -> _models.RoleAssignmentApproval:
+        """Get role assignment approval.
+
+        :param approval_id: The id of the role assignment approval. Required.
+        :type approval_id: str
+        :param scope: The scope of the resource. Required.
         :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AlertOperationListResult or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertOperationListResult
+        :return: RoleAssignmentApproval or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApproval
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
-        cls: ClsType[_models.AlertOperationListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoleAssignmentApproval] = kwargs.pop("cls", None)
 
-        request = build_list_for_scope_request(
+        request = build_get_by_id_request(
+            approval_id=approval_id,
             scope=scope,
             api_version=api_version,
-            template_url=self.list_for_scope.metadata["url"],
+            template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("AlertOperationListResult", pipeline_response)
+        deserialized = self._deserialize("RoleAssignmentApproval", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleManagementAlertOperations"}
+    get_by_id.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,73 +25,69 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
+def build_list_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers",
+        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
         "id": _SERIALIZER.url("id", id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class TenantLevelAccessReviewInstanceContactedReviewersOperations:
+class AccessReviewInstanceContactedReviewersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
-        :attr:`tenant_level_access_review_instance_contacted_reviewers` attribute.
+        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
+        :attr:`access_review_instance_contacted_reviewers` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> Iterable["_models.AccessReviewContactedReviewer"]:
         """Get access review instance contacted reviewers.
 
@@ -99,22 +95,22 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewContactedReviewer or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewContactedReviewer]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewContactedReviewer]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -124,24 +120,36 @@
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     schedule_definition_id=schedule_definition_id,
                     id=id,
+                    subscription_id=self._config.subscription_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewContactedReviewerListResult", pipeline_response)
@@ -149,24 +157,25 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {
-        "url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_incidents_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_incidents_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, alert_id: str, alert_incident_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleManagementAlerts/{alertId}/alertIncidents/{alertIncidentId}",
     )  # pylint: disable=line-too-long
@@ -71,17 +65,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlerts/{alertId}/alertIncidents"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -100,17 +92,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_remediate_request(scope: str, alert_id: str, alert_incident_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleManagementAlerts/{alertId}/alertIncidents/{alertIncidentId}/remediate",
     )  # pylint: disable=line-too-long
@@ -133,26 +123,27 @@
 
 class AlertIncidentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_08_01_preview.AuthorizationManagementClient`'s
         :attr:`alert_incidents` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, scope: str, alert_id: str, alert_incident_id: str, **kwargs: Any) -> _models.AlertIncident:
         """Get the specified alert incident.
 
         :param scope: The scope of the alert incident. The scope can be any REST resource instance. For
          example, use '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a
@@ -164,30 +155,30 @@
         :type scope: str
         :param alert_id: The name of the alert. Required.
         :type alert_id: str
         :param alert_incident_id: The name of the alert incident to get. Required.
         :type alert_incident_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AlertIncident or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertIncident
+        :rtype: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertIncident
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertIncident] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             alert_id=alert_id,
             alert_incident_id=alert_incident_id,
@@ -195,16 +186,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -227,22 +219,22 @@
         :param scope: The scope of the alert incident. Required.
         :type scope: str
         :param alert_id: The name of the alert. Required.
         :type alert_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AlertIncident or the result of cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertIncident]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_08_01_preview.models.AlertIncident]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertIncidentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -261,15 +253,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AlertIncidentListResult", pipeline_response)
@@ -277,16 +280,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -322,16 +326,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_remediate_request(
             scope=scope,
             alert_id=alert_id,
             alert_incident_id=alert_incident_id,
@@ -339,16 +343,17 @@
             template_url=self.remediate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_default_settings_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_default_settings_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +24,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default",
     )  # pylint: disable=line-too-long
@@ -68,17 +62,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_put_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default",
@@ -114,14 +106,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
@@ -135,31 +128,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         request = build_get_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -236,24 +230,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
 
         request = build_put_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
@@ -263,16 +257,17 @@
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instances_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,34 +26,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     schedule_definition_id: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances",
     )  # pylint: disable=line-too-long
@@ -74,17 +69,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
     )  # pylint: disable=line-too-long
@@ -105,17 +98,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
@@ -153,14 +144,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewInstance"]:
         """Get access review instances.
 
@@ -177,16 +169,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -206,15 +198,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
@@ -222,16 +225,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -264,16 +268,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -281,16 +285,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -395,24 +400,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewInstanceProperties")
 
         request = build_create_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -424,16 +429,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alerts_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alerts_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, cast, overload
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -27,32 +28,26 @@
 from azure.mgmt.core.exceptions import ARMErrorFormat
 from azure.mgmt.core.polling.arm_polling import ARMPolling
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlerts/{alertId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "alertId": _SERIALIZER.url("alert_id", alert_id, "str", skip_quote=True),
@@ -69,17 +64,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlerts/{alertId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -99,17 +92,15 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlerts")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -125,17 +116,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_refresh_request(scope: str, alert_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlerts/{alertId}/refresh"
     )
     path_format_arguments = {
@@ -154,17 +143,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_refresh_all_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlerts/refresh")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -182,26 +169,27 @@
 
 class AlertsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_08_01_preview.AuthorizationManagementClient`'s
         :attr:`alerts` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, scope: str, alert_id: str, **kwargs: Any) -> _models.Alert:
         """Get the specified alert.
 
         :param scope: The scope of the alert. The scope can be any REST resource instance. For example,
          use '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a subscription,
@@ -210,46 +198,47 @@
          '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param alert_id: The name of the alert to get. Required.
         :type alert_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Alert or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.Alert
+        :rtype: ~azure.mgmt.authorization.v2022_08_01_preview.models.Alert
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.Alert] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             alert_id=alert_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -276,15 +265,15 @@
         """Update an alert.
 
         :param scope: The scope of the alert. Required.
         :type scope: str
         :param alert_id: The name of the alert to dismiss. Required.
         :type alert_id: str
         :param parameters: Parameters for the alert. Required.
-        :type parameters: ~azure.mgmt.authorization.v2021_12_01_preview.models.Alert
+        :type parameters: ~azure.mgmt.authorization.v2022_08_01_preview.models.Alert
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -318,15 +307,15 @@
         """Update an alert.
 
         :param scope: The scope of the alert. Required.
         :type scope: str
         :param alert_id: The name of the alert to dismiss. Required.
         :type alert_id: str
         :param parameters: Parameters for the alert. Is either a Alert type or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2021_12_01_preview.models.Alert or IO
+        :type parameters: ~azure.mgmt.authorization.v2022_08_01_preview.models.Alert or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -338,24 +327,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Alert")
 
         request = build_update_request(
             scope=scope,
             alert_id=alert_id,
@@ -366,16 +355,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -390,22 +380,22 @@
         """Gets alerts for a resource scope.
 
         :param scope: The scope of the alert. Required.
         :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Alert or the result of cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.Alert]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_08_01_preview.models.Alert]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -423,15 +413,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AlertListResult", pipeline_response)
@@ -439,16 +440,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -466,32 +468,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
 
         request = build_refresh_request(
             scope=scope,
             alert_id=alert_id,
             api_version=api_version,
             template_url=self._refresh_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -525,22 +528,22 @@
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either AlertOperationResult or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertOperationResult]
+         ~azure.core.polling.LROPoller[~azure.mgmt.authorization.v2022_08_01_preview.models.AlertOperationResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._refresh_initial(
@@ -593,31 +596,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
 
         request = build_refresh_all_request(
             scope=scope,
             api_version=api_version,
             template_url=self._refresh_all_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -647,22 +651,22 @@
          strategy.
         :paramtype polling: bool or ~azure.core.polling.PollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of LROPoller that returns either AlertOperationResult or the result of
          cls(response)
         :rtype:
-         ~azure.core.polling.LROPoller[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertOperationResult]
+         ~azure.core.polling.LROPoller[~azure.mgmt.authorization.v2022_08_01_preview.models.AlertOperationResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
         polling: Union[bool, PollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = self._refresh_all_initial(
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +24,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(scope: str, history_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}",
@@ -72,17 +66,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(scope: str, history_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}",
     )  # pylint: disable=line-too-long
@@ -116,14 +108,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     def create(
         self,
         scope: str,
         history_definition_id: str,
         properties: _models.AccessReviewHistoryDefinitionProperties,
@@ -210,24 +203,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewHistoryDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewHistoryDefinitionProperties")
 
         request = build_create_request(
             scope=scope,
             history_definition_id=history_definition_id,
@@ -238,16 +231,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -286,32 +280,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             scope=scope,
             history_definition_id=history_definition_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_instance_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,167 +2,153 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(history_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_generate_download_uri_request(
+    history_definition_id: str, instance_id: str, subscription_id: str, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances",
+        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances/{instanceId}/generateDownloadUri",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "historyDefinitionId": _SERIALIZER.url("history_definition_id", history_definition_id, "str"),
+        "instanceId": _SERIALIZER.url("instance_id", instance_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class AccessReviewHistoryDefinitionInstancesOperations:
+class AccessReviewHistoryDefinitionInstanceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
-        :attr:`access_review_history_definition_instances` attribute.
+        :attr:`access_review_history_definition_instance` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(self, history_definition_id: str, **kwargs: Any) -> Iterable["_models.AccessReviewHistoryInstance"]:
-        """Get access review history definition instances by definition Id.
+    def generate_download_uri(
+        self, history_definition_id: str, instance_id: str, **kwargs: Any
+    ) -> _models.AccessReviewHistoryInstance:
+        """Generates a uri which can be used to retrieve review history data. This URI has a TTL of 1 day
+        and can be retrieved by fetching the accessReviewHistoryDefinition object.
 
         :param history_definition_id: The id of the access review history definition. Required.
         :type history_definition_id: str
+        :param instance_id: The id of the access review history definition instance to generate a URI
+         for. Required.
+        :type instance_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewHistoryInstance or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryInstance]
+        :return: AccessReviewHistoryInstance or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
-        )
-        cls: ClsType[_models.AccessReviewHistoryDefinitionInstanceListResult] = kwargs.pop("cls", None)
-
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
+        )
+        cls: ClsType[_models.AccessReviewHistoryInstance] = kwargs.pop("cls", None)
+
+        request = build_generate_download_uri_request(
+            history_definition_id=history_definition_id,
+            instance_id=instance_id,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            template_url=self.generate_download_uri.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-                request = build_list_request(
-                    history_definition_id=history_definition_id,
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-
-            else:
-                request = HttpRequest("GET", next_link)
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
-
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewHistoryDefinitionInstanceListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
-
-        def get_next(next_link=None):
-            request = prepare_request(next_link)
-
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        deserialized = self._deserialize("AccessReviewHistoryInstance", pipeline_response)
 
-            return pipeline_response
+        if cls:
+            return cls(pipeline_response, deserialized, {})
 
-        return ItemPaged(get_next, extract_data)
+        return deserialized
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances"
+    generate_download_uri.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances/{instanceId}/generateDownloadUri"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +24,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_stop_request(scope: str, schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/stop",
     )  # pylint: disable=line-too-long
@@ -70,17 +64,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_record_all_decisions_request(scope: str, schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/recordAllDecisions",
@@ -104,17 +96,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_reset_decisions_request(scope: str, schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/resetDecisions",
     )  # pylint: disable=line-too-long
@@ -135,17 +125,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_apply_decisions_request(scope: str, schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/applyDecisions",
     )  # pylint: disable=line-too-long
@@ -166,17 +154,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_send_reminders_request(scope: str, schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/sendReminders",
     )  # pylint: disable=line-too-long
@@ -211,14 +197,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def stop(  # pylint: disable=inconsistent-return-statements
         self, scope: str, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> None:
         """An action to stop an access review instance.
 
@@ -240,16 +227,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -257,16 +244,17 @@
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -376,24 +364,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "RecordAllDecisionsProperties")
 
         request = build_record_all_decisions_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
@@ -405,16 +393,17 @@
             template_url=self.record_all_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -451,16 +440,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_reset_decisions_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -468,16 +457,17 @@
             template_url=self.reset_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -514,16 +504,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_apply_decisions_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -531,16 +521,17 @@
             template_url=self.apply_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -577,16 +568,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_send_reminders_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -594,16 +585,17 @@
             template_url=self.send_reminders.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definitions_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions",
     )  # pylint: disable=line-too-long
@@ -71,17 +65,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(history_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}",
     )  # pylint: disable=line-too-long
@@ -115,14 +107,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.AccessReviewHistoryDefinition"]:
         """Lists the accessReviewHistoryDefinitions available from this provider, definition instances are
         only available for 30 days after creation.
 
         :param filter: The filter to apply on the operation. Only standard filters on definition name
@@ -134,16 +127,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -162,15 +155,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewHistoryDefinitionListResult", pipeline_response)
@@ -178,16 +182,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -218,32 +223,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             history_definition_id=history_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_my_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_my_decisions_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,34 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(
-    schedule_definition_id: str, id: str, *, filter: Optional[str] = None, **kwargs: Any
-) -> HttpRequest:
+def build_list_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions",
     )  # pylint: disable=line-too-long
@@ -61,30 +54,26 @@
         "id": _SERIALIZER.url("id", id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-    if filter is not None:
-        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, decision_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions/{decisionId}",
     )  # pylint: disable=line-too-long
@@ -105,17 +94,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_patch_request(schedule_definition_id: str, id: str, decision_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions/{decisionId}",
@@ -141,54 +128,48 @@
 
 class AccessReviewInstanceMyDecisionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_instance_my_decisions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(
-        self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> Iterable["_models.AccessReviewDecision"]:
+    def list(self, schedule_definition_id: str, id: str, **kwargs: Any) -> Iterable["_models.AccessReviewDecision"]:
         """Get my access review instance decisions.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
-        :param filter: The filter to apply on the operation. Other than standard filters, one custom
-         filter option is supported : 'assignedToMeToReview()'. When one specified
-         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
-         returned. Default value is None.
-        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewDecision or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -198,25 +179,35 @@
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     schedule_definition_id=schedule_definition_id,
                     id=id,
-                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewDecisionListResult", pipeline_response)
@@ -224,16 +215,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -256,30 +248,30 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             decision_id=decision_id,
@@ -287,16 +279,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -330,21 +323,21 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :param properties: Access review decision properties to patch. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecisionProperties
+         ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecisionProperties
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def patch(
         self,
         schedule_definition_id: str,
@@ -366,15 +359,15 @@
         :param properties: Access review decision properties to patch. Required.
         :type properties: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def patch(
         self,
         schedule_definition_id: str,
@@ -390,44 +383,44 @@
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :param properties: Access review decision properties to patch. Is either a
          AccessReviewDecisionProperties type or a IO type. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecisionProperties or IO
+         ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecisionProperties or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewDecisionProperties")
 
         request = build_patch_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -439,16 +432,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,160 +2,137 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, Optional, TypeVar
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from ..._serialization import Serializer
-from .._vendor import _convert_request, _format_url_section
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_generate_download_uri_request(
-    scope: str, history_definition_id: str, instance_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances/{instanceId}/generateDownloadUri",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scope": _SERIALIZER.url("scope", scope, "str"),
-        "historyDefinitionId": _SERIALIZER.url("history_definition_id", history_definition_id, "str"),
-        "instanceId": _SERIALIZER.url("instance_id", instance_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._access_review_schedule_definitions_assigned_for_my_approval_operations import build_list_request
 
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+T = TypeVar("T")
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ScopeAccessReviewHistoryDefinitionInstanceOperations:
+class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
-        :attr:`scope_access_review_history_definition_instance` attribute.
+        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def generate_download_uri(
-        self, scope: str, history_definition_id: str, instance_id: str, **kwargs: Any
-    ) -> _models.AccessReviewHistoryInstance:
-        """Generates a uri which can be used to retrieve review history data. This URI has a TTL of 1 day
-        and can be retrieved by fetching the accessReviewHistoryDefinition object.
-
-        :param scope: The scope of the resource. Required.
-        :type scope: str
-        :param history_definition_id: The id of the access review history definition. Required.
-        :type history_definition_id: str
-        :param instance_id: The id of the access review history definition instance to generate a URI
-         for. Required.
-        :type instance_id: str
+    def list(self, **kwargs: Any) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
+        """Get access review instances assigned for my approval.
+
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewHistoryInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryInstance
+        :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
+        )
+        cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
-        )
-        cls: ClsType[_models.AccessReviewHistoryInstance] = kwargs.pop("cls", None)
-
-        request = build_generate_download_uri_request(
-            scope=scope,
-            history_definition_id=history_definition_id,
-            instance_id=instance_id,
-            api_version=api_version,
-            template_url=self.generate_download_uri.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        deserialized = self._deserialize("AccessReviewHistoryInstance", pipeline_response)
+                request = build_list_request(
+                    api_version=api_version,
+                    template_url=self.list.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        if cls:
-            return cls(pipeline_response, deserialized, {})
+            return pipeline_response
 
-        return deserialized
+        return AsyncItemPaged(get_next, extract_data)
 
-    generate_download_uri.metadata = {
-        "url": "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances/{instanceId}/generateDownloadUri"
-    }
+    list.metadata = {"url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +23,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_stop_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/stop",
     )  # pylint: disable=line-too-long
@@ -72,17 +65,15 @@
 
 def build_reset_decisions_request(
     schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/resetDecisions",
     )  # pylint: disable=line-too-long
@@ -105,17 +96,15 @@
 
 def build_apply_decisions_request(
     schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/applyDecisions",
     )  # pylint: disable=line-too-long
@@ -138,17 +127,15 @@
 
 def build_send_reminders_request(
     schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/sendReminders",
     )  # pylint: disable=line-too-long
@@ -169,17 +156,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_accept_recommendations_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/acceptRecommendations",
     )  # pylint: disable=line-too-long
@@ -213,14 +198,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def stop(  # pylint: disable=inconsistent-return-statements
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> None:
         """An action to stop an access review instance.
 
@@ -240,16 +226,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -257,16 +243,17 @@
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -301,16 +288,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_reset_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -318,16 +305,17 @@
             template_url=self.reset_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -362,16 +350,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_apply_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -379,16 +367,17 @@
             template_url=self.apply_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -423,16 +412,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_send_reminders_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -440,16 +429,17 @@
             template_url=self.send_reminders.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -484,32 +474,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_accept_recommendations_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.accept_recommendations.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,137 +25,135 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(*, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
+def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
-    _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions")
+    _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-    if filter is not None:
-        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
+class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
-        :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
+        :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(self, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.AccessReviewScheduleDefinition"]:
-        """Get access review instances assigned for my approval.
+    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
+        """Lists the operations available from this provider.
 
-        :param filter: The filter to apply on the operation. Other than standard filters, one custom
-         filter option is supported : 'assignedToMeToReview()'. When one specified
-         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
-         returned. Default value is None.
-        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
-         cls(response)
+        :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
-        cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
-                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
+            deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions"}
+    list.metadata = {"url": "/providers/Microsoft.Authorization/operations"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions",
     )  # pylint: disable=line-too-long
@@ -71,27 +66,25 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -101,27 +94,25 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -133,28 +124,26 @@
 
 def build_create_or_update_by_id_request(
     schedule_definition_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -166,27 +155,25 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_stop_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/stop",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -198,48 +185,49 @@
 
 class AccessReviewScheduleDefinitionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_schedule_definitions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review schedule definitions.
 
         :param filter: The filter to apply on the operation. Other than standard filters, one custom
          filter option is supported : 'assignedToMeToReview()'. When one specified
          $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
          returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -258,15 +246,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
@@ -274,16 +273,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -300,46 +300,47 @@
     def get_by_id(self, schedule_definition_id: str, **kwargs: Any) -> _models.AccessReviewScheduleDefinition:
         """Get single access review definition.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewScheduleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -376,32 +377,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -425,21 +427,21 @@
     ) -> _models.AccessReviewScheduleDefinition:
         """Create or Update access review schedule definition.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param properties: Access review schedule definition properties. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinitionProperties
+         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinitionProperties
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewScheduleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_or_update_by_id(
         self, schedule_definition_id: str, properties: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AccessReviewScheduleDefinition:
@@ -450,15 +452,15 @@
         :param properties: Access review schedule definition properties. Required.
         :type properties: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewScheduleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_or_update_by_id(
         self,
         schedule_definition_id: str,
@@ -468,45 +470,45 @@
         """Create or Update access review schedule definition.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param properties: Access review schedule definition properties. Is either a
          AccessReviewScheduleDefinitionProperties type or a IO type. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinitionProperties
+         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinitionProperties
          or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewScheduleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleDefinitionProperties")
 
         request = build_create_or_update_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
@@ -517,16 +519,17 @@
             template_url=self.create_or_update_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -563,32 +566,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_history_definition_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +24,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(history_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}",
@@ -72,17 +66,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(history_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}",
     )  # pylint: disable=line-too-long
@@ -116,14 +108,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     def create(
         self,
         history_definition_id: str,
         properties: _models.AccessReviewHistoryDefinitionProperties,
         *,
@@ -196,24 +189,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewHistoryDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewHistoryDefinitionProperties")
 
         request = build_create_request(
             history_definition_id=history_definition_id,
             subscription_id=self._config.subscription_id,
@@ -224,16 +217,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -270,32 +264,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             history_definition_id=history_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers",
     )  # pylint: disable=line-too-long
@@ -85,14 +79,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> Iterable["_models.AccessReviewContactedReviewer"]:
         """Get access review instance contacted reviewers.
 
@@ -106,16 +101,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewContactedReviewer]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -135,15 +130,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewContactedReviewerListResult", pipeline_response)
@@ -151,16 +157,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -39,19 +39,14 @@
 from ._access_review_instances_assigned_for_my_approval_operations import (
     AccessReviewInstancesAssignedForMyApprovalOperations,
 )
 from ._access_review_instance_my_decisions_operations import AccessReviewInstanceMyDecisionsOperations
 from ._tenant_level_access_review_instance_contacted_reviewers_operations import (
     TenantLevelAccessReviewInstanceContactedReviewersOperations,
 )
-from ._alerts_operations import AlertsOperations
-from ._alert_configurations_operations import AlertConfigurationsOperations
-from ._alert_definitions_operations import AlertDefinitionsOperations
-from ._alert_incidents_operations import AlertIncidentsOperations
-from ._alert_operation_operations import AlertOperationOperations
 
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Operations",
@@ -75,15 +70,10 @@
     "ScopeAccessReviewInstanceDecisionsOperations",
     "ScopeAccessReviewInstanceContactedReviewersOperations",
     "ScopeAccessReviewDefaultSettingsOperations",
     "AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations",
     "AccessReviewInstancesAssignedForMyApprovalOperations",
     "AccessReviewInstanceMyDecisionsOperations",
     "TenantLevelAccessReviewInstanceContactedReviewersOperations",
-    "AlertsOperations",
-    "AlertConfigurationsOperations",
-    "AlertDefinitionsOperations",
-    "AlertIncidentsOperations",
-    "AlertOperationOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -63,42 +57,43 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.AuthorizationManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """Lists the operations available from this provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.Operation]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -115,15 +110,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationListResult", pipeline_response)
@@ -131,16 +137,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_alert_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_definitions_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,170 +2,111 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from ..._serialization import Serializer
-from .._vendor import _convert_request, _format_url_section
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_get_request(scope: str, alert_definition_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlertDefinitions/{alertDefinitionId}"
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
-        "alertDefinitionId": _SERIALIZER.url("alert_definition_id", alert_definition_id, "str", skip_quote=True),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_list_for_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._alert_definitions_operations import build_get_request, build_list_for_scope_request
 
-    api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2022-08-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlertDefinitions")
-    path_format_arguments = {
-        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+T = TypeVar("T")
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AlertDefinitionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_08_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`alert_definitions` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
-    @distributed_trace
-    def get(self, scope: str, alert_definition_id: str, **kwargs: Any) -> _models.AlertDefinition:
+    @distributed_trace_async
+    async def get(self, scope: str, alert_definition_id: str, **kwargs: Any) -> _models.AlertDefinition:
         """Get the specified alert definition.
 
         :param scope: The scope of the alert definition. The scope can be any REST resource instance.
          For example, use '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a
          subscription,
          '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}'
          for a resource group, and
          '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param alert_definition_id: The name of the alert definition to get. Required.
         :type alert_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AlertDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition
+        :rtype: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             alert_definition_id=alert_definition_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -178,30 +119,30 @@
         return deserialized
 
     get.metadata = {
         "url": "/{scope}/providers/Microsoft.Authorization/roleManagementAlertDefinitions/{alertDefinitionId}"
     }
 
     @distributed_trace
-    def list_for_scope(self, scope: str, **kwargs: Any) -> Iterable["_models.AlertDefinition"]:
+    def list_for_scope(self, scope: str, **kwargs: Any) -> AsyncIterable["_models.AlertDefinition"]:
         """Gets alert definitions for a resource scope.
 
         :param scope: The scope of the alert definition. Required.
         :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AlertDefinition or the result of cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_08_01_preview.models.AlertDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -219,37 +160,49 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        def extract_data(pipeline_response):
+        async def extract_data(pipeline_response):
             deserialized = self._deserialize("AlertDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
+        async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
 
     list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleManagementAlertDefinitions"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instances_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -25,34 +26,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     scope: str, schedule_definition_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances",
     )  # pylint: disable=line-too-long
@@ -74,17 +69,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(scope: str, schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
     )  # pylint: disable=line-too-long
@@ -105,17 +98,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
@@ -153,14 +144,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, scope: str, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewInstance"]:
         """Get access review instances.
 
@@ -179,16 +171,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -208,15 +200,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
@@ -224,16 +227,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -270,16 +274,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -287,16 +291,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -410,24 +415,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewInstanceProperties")
 
         request = build_create_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
@@ -439,16 +444,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
@@ -23,150 +23,138 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
-from .._vendor import _convert_request, _format_url_section
+from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(scope: str, history_definition_id: str, **kwargs: Any) -> HttpRequest:
+def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-12-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scope": _SERIALIZER.url("scope", scope, "str"),
-        "historyDefinitionId": _SERIALIZER.url("history_definition_id", history_definition_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+    _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class ScopeAccessReviewHistoryDefinitionInstancesOperations:
+class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
-        :attr:`scope_access_review_history_definition_instances` attribute.
+        :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
+        :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(
-        self, scope: str, history_definition_id: str, **kwargs: Any
-    ) -> Iterable["_models.AccessReviewHistoryInstance"]:
-        """Get access review history definition instances by definition Id.
-
-        :param scope: The scope of the resource. Required.
-        :type scope: str
-        :param history_definition_id: The id of the access review history definition. Required.
-        :type history_definition_id: str
+    def list(self, **kwargs: Any) -> Iterable["_models.AccessReviewScheduleDefinition"]:
+        """Get access review instances assigned for my approval.
+
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewHistoryInstance or the result of
+        :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryInstance]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
-        cls: ClsType[_models.AccessReviewHistoryDefinitionInstanceListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
-                    scope=scope,
-                    history_definition_id=history_definition_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewHistoryDefinitionInstanceListResult", pipeline_response)
+            deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances"
-    }
+    list.metadata = {"url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/_authorization_management_client.py`

 * *Files 18% similar despite different names*

```diff
@@ -25,19 +25,14 @@
     AccessReviewInstanceDecisionsOperations,
     AccessReviewInstanceMyDecisionsOperations,
     AccessReviewInstanceOperations,
     AccessReviewInstancesAssignedForMyApprovalOperations,
     AccessReviewInstancesOperations,
     AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations,
     AccessReviewScheduleDefinitionsOperations,
-    AlertConfigurationsOperations,
-    AlertDefinitionsOperations,
-    AlertIncidentsOperations,
-    AlertOperationOperations,
-    AlertsOperations,
     Operations,
     ScopeAccessReviewDefaultSettingsOperations,
     ScopeAccessReviewHistoryDefinitionInstanceOperations,
     ScopeAccessReviewHistoryDefinitionInstancesOperations,
     ScopeAccessReviewHistoryDefinitionOperations,
     ScopeAccessReviewHistoryDefinitionsOperations,
     ScopeAccessReviewInstanceContactedReviewersOperations,
@@ -141,140 +136,120 @@
     :ivar access_review_instance_my_decisions: AccessReviewInstanceMyDecisionsOperations operations
     :vartype access_review_instance_my_decisions:
      azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AccessReviewInstanceMyDecisionsOperations
     :ivar tenant_level_access_review_instance_contacted_reviewers:
      TenantLevelAccessReviewInstanceContactedReviewersOperations operations
     :vartype tenant_level_access_review_instance_contacted_reviewers:
      azure.mgmt.authorization.v2021_12_01_preview.aio.operations.TenantLevelAccessReviewInstanceContactedReviewersOperations
-    :ivar alerts: AlertsOperations operations
-    :vartype alerts: azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AlertsOperations
-    :ivar alert_configurations: AlertConfigurationsOperations operations
-    :vartype alert_configurations:
-     azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AlertConfigurationsOperations
-    :ivar alert_definitions: AlertDefinitionsOperations operations
-    :vartype alert_definitions:
-     azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AlertDefinitionsOperations
-    :ivar alert_incidents: AlertIncidentsOperations operations
-    :vartype alert_incidents:
-     azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AlertIncidentsOperations
-    :ivar alert_operation: AlertOperationOperations operations
-    :vartype alert_operation:
-     azure.mgmt.authorization.v2021_12_01_preview.aio.operations.AlertOperationOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
-     Retry-After header is present.
+    :keyword api_version: Api Version. Default value is "2021-12-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
+    :paramtype api_version: str
     """
 
     def __init__(
         self,
         credential: "AsyncTokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
+        )
         self.access_review_history_definitions = AccessReviewHistoryDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_history_definition = AccessReviewHistoryDefinitionOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_history_definition_instance = AccessReviewHistoryDefinitionInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_history_definition_instances = AccessReviewHistoryDefinitionInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_schedule_definitions = AccessReviewScheduleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_instances = AccessReviewInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_instance = AccessReviewInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_instance_decisions = AccessReviewInstanceDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_instance_contacted_reviewers = AccessReviewInstanceContactedReviewersOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_default_settings = AccessReviewDefaultSettingsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_history_definitions = ScopeAccessReviewHistoryDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_history_definition = ScopeAccessReviewHistoryDefinitionOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_history_definition_instance = ScopeAccessReviewHistoryDefinitionInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_history_definition_instances = ScopeAccessReviewHistoryDefinitionInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_schedule_definitions = ScopeAccessReviewScheduleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_instances = ScopeAccessReviewInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_instance = ScopeAccessReviewInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_instance_decisions = ScopeAccessReviewInstanceDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_instance_contacted_reviewers = ScopeAccessReviewInstanceContactedReviewersOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.scope_access_review_default_settings = ScopeAccessReviewDefaultSettingsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_schedule_definitions_assigned_for_my_approval = (
             AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations(
-                self._client, self._config, self._serialize, self._deserialize
+                self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
             )
         )
         self.access_review_instances_assigned_for_my_approval = AccessReviewInstancesAssignedForMyApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.access_review_instance_my_decisions = AccessReviewInstanceMyDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
         )
         self.tenant_level_access_review_instance_contacted_reviewers = (
             TenantLevelAccessReviewInstanceContactedReviewersOperations(
-                self._client, self._config, self._serialize, self._deserialize
+                self._client, self._config, self._serialize, self._deserialize, "2021-12-01-preview"
             )
         )
-        self.alerts = AlertsOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.alert_configurations = AlertConfigurationsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.alert_definitions = AlertDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.alert_incidents = AlertIncidentsOperations(self._client, self._config, self._serialize, self._deserialize)
-        self.alert_operation = AlertOperationOperations(self._client, self._config, self._serialize, self._deserialize)
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -25,25 +25,31 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
+    :keyword api_version: Api Version. Default value is "2019-08-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
+    :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
+        api_version: str = kwargs.pop("api_version", "2019-08-01-preview")
+
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
         self.subscription_id = subscription_id
+        self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
         kwargs.setdefault("sdk_moniker", "mgmt-authorization/{}".format(VERSION))
         self._configure(**kwargs)
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_default_settings_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_default_settings_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -22,82 +22,78 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._scope_access_review_default_settings_operations import build_get_request, build_put_request
+from ...operations._access_review_default_settings_operations import build_get_request, build_put_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ScopeAccessReviewDefaultSettingsOperations:
+class AccessReviewDefaultSettingsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`scope_access_review_default_settings` attribute.
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`access_review_default_settings` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
-    async def get(self, scope: str, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
+    async def get(self, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
-        :param scope: The scope of the resource. Required.
-        :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDefaultSettings
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         request = build_get_request(
-            scope=scope,
+            subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -106,120 +102,112 @@
         deserialized = self._deserialize("AccessReviewDefaultSettings", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"}
+    get.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"
+    }
 
     @overload
     async def put(
-        self,
-        scope: str,
-        properties: _models.AccessReviewScheduleSettings,
-        *,
-        content_type: str = "application/json",
-        **kwargs: Any
+        self, properties: _models.AccessReviewScheduleSettings, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
-        :param scope: The scope of the resource. Required.
-        :type scope: str
         :param properties: Access review schedule settings. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleSettings
+         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleSettings
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDefaultSettings
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def put(
-        self, scope: str, properties: IO, *, content_type: str = "application/json", **kwargs: Any
+        self, properties: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
-        :param scope: The scope of the resource. Required.
-        :type scope: str
         :param properties: Access review schedule settings. Required.
         :type properties: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDefaultSettings
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def put(
-        self, scope: str, properties: Union[_models.AccessReviewScheduleSettings, IO], **kwargs: Any
+        self, properties: Union[_models.AccessReviewScheduleSettings, IO], **kwargs: Any
     ) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
-        :param scope: The scope of the resource. Required.
-        :type scope: str
         :param properties: Access review schedule settings. Is either a AccessReviewScheduleSettings
          type or a IO type. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleSettings or IO
+         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleSettings or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDefaultSettings
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
 
         request = build_put_request(
-            scope=scope,
+            subscription_id=self._config.subscription_id,
             api_version=api_version,
             content_type=content_type,
             json=_json,
             content=_content,
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -228,8 +216,10 @@
         deserialized = self._deserialize("AccessReviewDefaultSettings", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    put.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"}
+    put.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"
+    }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definitions_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -29,18 +29,14 @@
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._scope_access_review_history_definitions_operations import (
     build_get_by_id_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScopeAccessReviewHistoryDefinitionsOperations:
     """
     .. warning::
@@ -55,14 +51,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewHistoryDefinition"]:
         """Lists the accessReviewHistoryDefinitions available from this provider, definition instances are
         only available for 30 days after creation.
@@ -78,16 +75,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -106,15 +103,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewHistoryDefinitionListResult", pipeline_response)
@@ -122,16 +130,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -164,32 +173,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             scope=scope,
             history_definition_id=history_definition_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_decisions_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -25,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_instance_decisions_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceDecisionsOperations:
     """
     .. warning::
@@ -51,14 +47,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewDecision"]:
         """Get access review instance decisions.
 
@@ -77,16 +74,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -107,15 +104,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewDecisionListResult", pipeline_response)
@@ -123,16 +131,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_configurations_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_configurations_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,40 +31,37 @@
 from ..._vendor import _convert_request
 from ...operations._alert_configurations_operations import (
     build_get_request,
     build_list_for_scope_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AlertConfigurationsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_08_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`alert_configurations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(self, scope: str, alert_id: str, **kwargs: Any) -> _models.AlertConfiguration:
         """Get the specified alert configuration.
 
         :param scope: The scope of the alert configuration. The scope can be any REST resource
          instance. For example, use '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/'
@@ -73,46 +71,47 @@
          '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param alert_id: The name of the alert configuration to get. Required.
         :type alert_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AlertConfiguration or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration
+        :rtype: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertConfiguration
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertConfiguration] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             alert_id=alert_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -139,15 +138,15 @@
         """Update an alert configuration.
 
         :param scope: The scope of the alert configuration. Required.
         :type scope: str
         :param alert_id: The name of the alert configuration to update. Required.
         :type alert_id: str
         :param parameters: Parameters for the alert configuration. Required.
-        :type parameters: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration
+        :type parameters: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertConfiguration
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -182,15 +181,15 @@
 
         :param scope: The scope of the alert configuration. Required.
         :type scope: str
         :param alert_id: The name of the alert configuration to update. Required.
         :type alert_id: str
         :param parameters: Parameters for the alert configuration. Is either a AlertConfiguration type
          or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration or IO
+        :type parameters: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertConfiguration or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -202,24 +201,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "AlertConfiguration")
 
         request = build_update_request(
             scope=scope,
             alert_id=alert_id,
@@ -230,16 +229,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -254,22 +254,22 @@
         """Gets alert configurations for a resource scope.
 
         :param scope: The scope of the alert configuration. Required.
         :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AlertConfiguration or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_08_01_preview.models.AlertConfiguration]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertConfigurationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -287,15 +287,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AlertConfigurationListResult", pipeline_response)
@@ -303,16 +314,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_schedule_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_schedule_definitions_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -32,18 +33,14 @@
     build_create_or_update_by_id_request,
     build_delete_by_id_request,
     build_get_by_id_request,
     build_list_request,
     build_stop_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScopeAccessReviewScheduleDefinitionsOperations:
     """
     .. warning::
@@ -58,14 +55,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review schedule definitions.
 
@@ -82,16 +80,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -110,15 +108,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
@@ -126,16 +135,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -168,32 +178,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -232,32 +243,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -359,24 +371,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleDefinitionProperties")
 
         request = build_create_or_update_by_id_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
@@ -387,16 +399,17 @@
             template_url=self.create_or_update_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -435,32 +448,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             api_version=api_version,
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_decisions_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -25,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._scope_access_review_instance_decisions_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScopeAccessReviewInstanceDecisionsOperations:
     """
     .. warning::
@@ -51,14 +47,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, scope: str, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewDecision"]:
         """Get access review instance decisions.
 
@@ -79,16 +76,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -109,15 +106,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewDecisionListResult", pipeline_response)
@@ -125,16 +133,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instance_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,18 +23,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_history_definition_instance_operations import build_generate_download_uri_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewHistoryDefinitionInstanceOperations:
     """
     .. warning::
@@ -50,14 +45,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def generate_download_uri(
         self, history_definition_id: str, instance_id: str, **kwargs: Any
     ) -> _models.AccessReviewHistoryInstance:
         """Generates a uri which can be used to retrieve review history data. This URI has a TTL of 1 day
         and can be retrieved by fetching the accessReviewHistoryDefinition object.
@@ -79,16 +75,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryInstance] = kwargs.pop("cls", None)
 
         request = build_generate_download_uri_request(
             history_definition_id=history_definition_id,
             instance_id=instance_id,
             subscription_id=self._config.subscription_id,
@@ -96,16 +92,17 @@
             template_url=self.generate_download_uri.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_contacted_reviewers_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_contacted_reviewers_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -25,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._scope_access_review_instance_contacted_reviewers_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScopeAccessReviewInstanceContactedReviewersOperations:
     """
     .. warning::
@@ -51,14 +47,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, scope: str, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewContactedReviewer"]:
         """Get access review instance contacted reviewers.
 
@@ -74,16 +71,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewContactedReviewer]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -103,15 +100,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewContactedReviewerListResult", pipeline_response)
@@ -119,16 +127,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -29,40 +29,37 @@
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_instances_assigned_for_my_approval_operations import (
     build_get_by_id_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstancesAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`access_review_instances_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewInstance"]:
         """Get access review instances assigned for my approval.
 
@@ -73,22 +70,22 @@
          $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
          returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewInstance]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -107,15 +104,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
@@ -123,16 +131,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -151,46 +160,47 @@
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewInstance
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_operation_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_eligible_child_resources_operations.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,170 +2,147 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, Optional, TypeVar
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator_async import distributed_trace_async
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._alert_operation_operations import build_get_request, build_list_for_scope_request
+from ...operations._eligible_child_resources_operations import build_get_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AlertOperationOperations:
+class EligibleChildResourcesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`alert_operation` attribute.
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`eligible_child_resources` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
-    @distributed_trace_async
-    async def get(self, scope: str, operation_id: str, **kwargs: Any) -> _models.AlertOperationResult:
-        """Get the specified alert operation.
+    @distributed_trace
+    def get(
+        self, scope: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.EligibleChildResource"]:
+        """Get the child resources of a resource on which user has eligible access.
 
-        :param scope: The scope of the alert operation. Required.
+        :param scope: The scope of the role management policy. Required.
         :type scope: str
-        :param operation_id: The id of the alert operation. Required.
-        :type operation_id: str
+        :param filter: The filter to apply on the operation. Use $filter=resourceType+eq+'Subscription'
+         to filter on only resource of type = 'Subscription'. Use
+         $filter=resourceType+eq+'subscription'+or+resourceType+eq+'resourcegroup' to filter on resource
+         of type = 'Subscription' or 'ResourceGroup'. Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AlertOperationResult or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertOperationResult
+        :return: An iterator like instance of either EligibleChildResource or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.EligibleChildResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
-        cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
-
-        request = build_get_request(
-            scope=scope,
-            operation_id=operation_id,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("AlertOperationResult", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+        cls: ClsType[_models.EligibleChildResourcesListResult] = kwargs.pop("cls", None)
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleManagementAlertOperations/{operationId}"}
-
-    @distributed_trace_async
-    async def list_for_scope(self, scope: str, **kwargs: Any) -> _models.AlertOperationListResult:
-        """Gets alert operations for a resource scope.
-
-        :param scope: The scope of the alert operation. Required.
-        :type scope: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AlertOperationListResult or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertOperationListResult
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
-        )
-        cls: ClsType[_models.AlertOperationListResult] = kwargs.pop("cls", None)
-
-        request = build_list_for_scope_request(
-            scope=scope,
-            api_version=api_version,
-            template_url=self.list_for_scope.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        deserialized = self._deserialize("AlertOperationListResult", pipeline_response)
+                request = build_get_request(
+                    scope=scope,
+                    filter=filter,
+                    api_version=api_version,
+                    template_url=self.get.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("EligibleChildResourcesListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        if cls:
-            return cls(pipeline_response, deserialized, {})
+            return pipeline_response
 
-        return deserialized
+        return AsyncItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleManagementAlertOperations"}
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/eligibleChildResources"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,42 +23,39 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._tenant_level_access_review_instance_contacted_reviewers_operations import build_list_request
+from ...operations._access_review_instance_contacted_reviewers_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class TenantLevelAccessReviewInstanceContactedReviewersOperations:
+class AccessReviewInstanceContactedReviewersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`tenant_level_access_review_instance_contacted_reviewers` attribute.
+        :attr:`access_review_instance_contacted_reviewers` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewContactedReviewer"]:
         """Get access review instance contacted reviewers.
 
@@ -72,16 +69,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewContactedReviewer]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -91,24 +88,36 @@
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     schedule_definition_id=schedule_definition_id,
                     id=id,
+                    subscription_id=self._config.subscription_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewContactedReviewerListResult", pipeline_response)
@@ -116,24 +125,25 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {
-        "url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_incidents_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_incidents_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,40 +30,37 @@
 from ..._vendor import _convert_request
 from ...operations._alert_incidents_operations import (
     build_get_request,
     build_list_for_scope_request,
     build_remediate_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AlertIncidentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_08_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`alert_incidents` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(self, scope: str, alert_id: str, alert_incident_id: str, **kwargs: Any) -> _models.AlertIncident:
         """Get the specified alert incident.
 
         :param scope: The scope of the alert incident. The scope can be any REST resource instance. For
          example, use '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a
@@ -75,30 +72,30 @@
         :type scope: str
         :param alert_id: The name of the alert. Required.
         :type alert_id: str
         :param alert_incident_id: The name of the alert incident to get. Required.
         :type alert_incident_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AlertIncident or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertIncident
+        :rtype: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertIncident
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertIncident] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             alert_id=alert_id,
             alert_incident_id=alert_incident_id,
@@ -106,16 +103,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -138,22 +136,22 @@
         :param scope: The scope of the alert incident. Required.
         :type scope: str
         :param alert_id: The name of the alert. Required.
         :type alert_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AlertIncident or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertIncident]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_08_01_preview.models.AlertIncident]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertIncidentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -172,15 +170,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AlertIncidentListResult", pipeline_response)
@@ -188,16 +197,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -233,16 +243,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_remediate_request(
             scope=scope,
             alert_id=alert_id,
             alert_incident_id=alert_incident_id,
@@ -250,16 +260,17 @@
             template_url=self.remediate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_default_settings_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_default_settings_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,78 +24,76 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_default_settings_operations import build_get_request, build_put_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewDefaultSettingsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_07_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`access_review_default_settings` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(self, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
+        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDefaultSettings
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         request = build_get_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -116,21 +114,21 @@
     async def put(
         self, properties: _models.AccessReviewScheduleSettings, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
         :param properties: Access review schedule settings. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleSettings
+         ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewScheduleSettings
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
+        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDefaultSettings
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def put(
         self, properties: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AccessReviewDefaultSettings:
@@ -139,57 +137,57 @@
         :param properties: Access review schedule settings. Required.
         :type properties: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
+        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDefaultSettings
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def put(
         self, properties: Union[_models.AccessReviewScheduleSettings, IO], **kwargs: Any
     ) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
         :param properties: Access review schedule settings. Is either a AccessReviewScheduleSettings
          type or a IO type. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleSettings or IO
+         ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewScheduleSettings or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
+        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDefaultSettings
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
 
         request = build_put_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
@@ -199,16 +197,17 @@
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,18 +31,14 @@
 from ..._vendor import _convert_request
 from ...operations._access_review_instances_operations import (
     build_create_request,
     build_get_by_id_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstancesOperations:
     """
     .. warning::
@@ -56,14 +53,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewInstance"]:
         """Get access review instances.
 
@@ -80,16 +78,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -109,15 +107,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
@@ -125,16 +134,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -167,16 +177,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -184,16 +194,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -298,24 +309,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewInstanceProperties")
 
         request = build_create_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -327,16 +338,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alerts_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alerts_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -34,40 +35,37 @@
     build_get_request,
     build_list_for_scope_request,
     build_refresh_all_request,
     build_refresh_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AlertsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_08_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`alerts` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(self, scope: str, alert_id: str, **kwargs: Any) -> _models.Alert:
         """Get the specified alert.
 
         :param scope: The scope of the alert. The scope can be any REST resource instance. For example,
          use '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a subscription,
@@ -76,46 +74,47 @@
          '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
          for a resource. Required.
         :type scope: str
         :param alert_id: The name of the alert to get. Required.
         :type alert_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: Alert or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.Alert
+        :rtype: ~azure.mgmt.authorization.v2022_08_01_preview.models.Alert
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.Alert] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             alert_id=alert_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -142,15 +141,15 @@
         """Update an alert.
 
         :param scope: The scope of the alert. Required.
         :type scope: str
         :param alert_id: The name of the alert to dismiss. Required.
         :type alert_id: str
         :param parameters: Parameters for the alert. Required.
-        :type parameters: ~azure.mgmt.authorization.v2021_12_01_preview.models.Alert
+        :type parameters: ~azure.mgmt.authorization.v2022_08_01_preview.models.Alert
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -184,15 +183,15 @@
         """Update an alert.
 
         :param scope: The scope of the alert. Required.
         :type scope: str
         :param alert_id: The name of the alert to dismiss. Required.
         :type alert_id: str
         :param parameters: Parameters for the alert. Is either a Alert type or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2021_12_01_preview.models.Alert or IO
+        :type parameters: ~azure.mgmt.authorization.v2022_08_01_preview.models.Alert or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
         :rtype: None
         :raises ~azure.core.exceptions.HttpResponseError:
@@ -204,24 +203,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "Alert")
 
         request = build_update_request(
             scope=scope,
             alert_id=alert_id,
@@ -232,16 +231,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -256,22 +256,22 @@
         """Gets alerts for a resource scope.
 
         :param scope: The scope of the alert. Required.
         :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Alert or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.Alert]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_08_01_preview.models.Alert]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -289,15 +289,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AlertListResult", pipeline_response)
@@ -305,16 +316,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -332,32 +344,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
 
         request = build_refresh_request(
             scope=scope,
             alert_id=alert_id,
             api_version=api_version,
             template_url=self._refresh_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -393,22 +406,22 @@
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either AlertOperationResult or the result
          of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertOperationResult]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.authorization.v2022_08_01_preview.models.AlertOperationResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._refresh_initial(
@@ -461,31 +474,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
 
         request = build_refresh_all_request(
             scope=scope,
             api_version=api_version,
             template_url=self._refresh_all_initial.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [202]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -515,22 +529,22 @@
          polling strategy.
         :paramtype polling: bool or ~azure.core.polling.AsyncPollingMethod
         :keyword int polling_interval: Default waiting time between two polls for LRO operations if no
          Retry-After header is present.
         :return: An instance of AsyncLROPoller that returns either AlertOperationResult or the result
          of cls(response)
         :rtype:
-         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertOperationResult]
+         ~azure.core.polling.AsyncLROPoller[~azure.mgmt.authorization.v2022_08_01_preview.models.AlertOperationResult]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
         )
         cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
         polling: Union[bool, AsyncPollingMethod] = kwargs.pop("polling", True)
         lro_delay = kwargs.pop("polling_interval", self._config.polling_interval)
         cont_token: Optional[str] = kwargs.pop("continuation_token", None)
         if cont_token is None:
             raw_result = await self._refresh_all_initial(
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -27,18 +27,14 @@
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._scope_access_review_history_definition_operations import (
     build_create_request,
     build_delete_by_id_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScopeAccessReviewHistoryDefinitionOperations:
     """
     .. warning::
@@ -53,14 +49,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     async def create(
         self,
         scope: str,
         history_definition_id: str,
         properties: _models.AccessReviewHistoryDefinitionProperties,
@@ -147,24 +144,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewHistoryDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewHistoryDefinitionProperties")
 
         request = build_create_request(
             scope=scope,
             history_definition_id=history_definition_id,
@@ -175,16 +172,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -223,32 +221,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             scope=scope,
             history_definition_id=history_definition_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_instances_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -25,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_history_definition_instances_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewHistoryDefinitionInstancesOperations:
     """
     .. warning::
@@ -51,14 +47,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, history_definition_id: str, **kwargs: Any) -> AsyncIterable["_models.AccessReviewHistoryInstance"]:
         """Get access review history definition instances by definition Id.
 
         :param history_definition_id: The id of the access review history definition. Required.
         :type history_definition_id: str
@@ -68,16 +65,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryDefinitionInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -96,15 +93,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewHistoryDefinitionInstanceListResult", pipeline_response)
@@ -112,16 +120,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instance_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,18 +30,14 @@
     build_apply_decisions_request,
     build_record_all_decisions_request,
     build_reset_decisions_request,
     build_send_reminders_request,
     build_stop_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScopeAccessReviewInstanceOperations:
     """
     .. warning::
@@ -56,14 +52,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def stop(  # pylint: disable=inconsistent-return-statements
         self, scope: str, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> None:
         """An action to stop an access review instance.
 
@@ -85,16 +82,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -102,16 +99,17 @@
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -221,24 +219,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "RecordAllDecisionsProperties")
 
         request = build_record_all_decisions_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
@@ -250,16 +248,17 @@
             template_url=self.record_all_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -296,16 +295,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_reset_decisions_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -313,16 +312,17 @@
             template_url=self.reset_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -359,16 +359,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_apply_decisions_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -376,16 +376,17 @@
             template_url=self.apply_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -422,16 +423,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_send_reminders_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -439,16 +440,17 @@
             template_url=self.send_reminders.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definitions_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_history_definitions_operations import build_get_by_id_request, build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewHistoryDefinitionsOperations:
     """
     .. warning::
@@ -52,14 +48,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewHistoryDefinition"]:
         """Lists the accessReviewHistoryDefinitions available from this provider, definition instances are
         only available for 30 days after creation.
@@ -73,16 +70,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -101,15 +98,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewHistoryDefinitionListResult", pipeline_response)
@@ -117,16 +125,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -157,32 +166,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             history_definition_id=history_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,18 +31,14 @@
 from ..._vendor import _convert_request
 from ...operations._access_review_instance_my_decisions_operations import (
     build_get_by_id_request,
     build_list_request,
     build_patch_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceMyDecisionsOperations:
     """
     .. warning::
@@ -56,14 +53,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewDecision"]:
         """Get my access review instance decisions.
 
@@ -82,16 +80,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -111,15 +109,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewDecisionListResult", pipeline_response)
@@ -127,16 +136,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -173,16 +183,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             decision_id=decision_id,
@@ -190,16 +200,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -313,24 +324,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewDecisionProperties")
 
         request = build_patch_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -342,16 +353,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instance_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -26,18 +25,14 @@
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._scope_access_review_history_definition_instance_operations import (
     build_generate_download_uri_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScopeAccessReviewHistoryDefinitionInstanceOperations:
     """
     .. warning::
@@ -52,14 +47,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def generate_download_uri(
         self, scope: str, history_definition_id: str, instance_id: str, **kwargs: Any
     ) -> _models.AccessReviewHistoryInstance:
         """Generates a uri which can be used to retrieve review history data. This URI has a TTL of 1 day
         and can be retrieved by fetching the accessReviewHistoryDefinition object.
@@ -83,16 +79,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewHistoryInstance] = kwargs.pop("cls", None)
 
         request = build_generate_download_uri_request(
             scope=scope,
             history_definition_id=history_definition_id,
             instance_id=instance_id,
@@ -100,16 +96,17 @@
             template_url=self.generate_download_uri.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,40 +29,37 @@
     build_accept_recommendations_request,
     build_apply_decisions_request,
     build_reset_decisions_request,
     build_send_reminders_request,
     build_stop_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`access_review_instance` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def stop(  # pylint: disable=inconsistent-return-statements
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> None:
         """An action to stop an access review instance.
 
@@ -83,16 +79,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -100,16 +96,17 @@
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -144,16 +141,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_reset_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -161,16 +158,17 @@
             template_url=self.reset_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -205,16 +203,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_apply_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -222,16 +220,17 @@
             template_url=self.apply_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -266,16 +265,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_send_reminders_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -283,16 +282,17 @@
             template_url=self.send_reminders.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -327,32 +327,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_accept_recommendations_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.accept_recommendations.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -25,40 +25,37 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_schedule_definitions_assigned_for_my_approval_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_07_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review instances assigned for my approval.
 
@@ -67,22 +64,22 @@
          $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
          returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -100,15 +97,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
@@ -116,16 +124,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -32,18 +33,14 @@
     build_create_or_update_by_id_request,
     build_delete_by_id_request,
     build_get_by_id_request,
     build_list_request,
     build_stop_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewScheduleDefinitionsOperations:
     """
     .. warning::
@@ -58,14 +55,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review schedule definitions.
 
@@ -80,16 +78,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -108,15 +106,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
@@ -124,16 +133,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -164,32 +174,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -226,32 +237,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -339,24 +351,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleDefinitionProperties")
 
         request = build_create_or_update_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
@@ -367,16 +379,17 @@
             template_url=self.create_or_update_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -413,32 +426,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_history_definition_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,18 +24,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_history_definition_operations import build_create_request, build_delete_by_id_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewHistoryDefinitionOperations:
     """
     .. warning::
@@ -50,14 +46,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     async def create(
         self,
         history_definition_id: str,
         properties: _models.AccessReviewHistoryDefinitionProperties,
         *,
@@ -130,24 +127,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewHistoryDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewHistoryDefinitionProperties")
 
         request = build_create_request(
             history_definition_id=history_definition_id,
             subscription_id=self._config.subscription_id,
@@ -158,16 +155,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -204,32 +202,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             history_definition_id=history_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -25,40 +25,37 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_instance_contacted_reviewers_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceContactedReviewersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_07_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`access_review_instance_contacted_reviewers` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewContactedReviewer"]:
         """Get access review instance contacted reviewers.
 
@@ -66,22 +63,22 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewContactedReviewer or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewContactedReviewer]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewContactedReviewer]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -101,15 +98,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewContactedReviewerListResult", pipeline_response)
@@ -117,16 +125,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -39,19 +39,14 @@
 from ._access_review_instances_assigned_for_my_approval_operations import (
     AccessReviewInstancesAssignedForMyApprovalOperations,
 )
 from ._access_review_instance_my_decisions_operations import AccessReviewInstanceMyDecisionsOperations
 from ._tenant_level_access_review_instance_contacted_reviewers_operations import (
     TenantLevelAccessReviewInstanceContactedReviewersOperations,
 )
-from ._alerts_operations import AlertsOperations
-from ._alert_configurations_operations import AlertConfigurationsOperations
-from ._alert_definitions_operations import AlertDefinitionsOperations
-from ._alert_incidents_operations import AlertIncidentsOperations
-from ._alert_operation_operations import AlertOperationOperations
 
 from ._patch import __all__ as _patch_all
 from ._patch import *  # pylint: disable=unused-wildcard-import
 from ._patch import patch_sdk as _patch_sdk
 
 __all__ = [
     "Operations",
@@ -75,15 +70,10 @@
     "ScopeAccessReviewInstanceDecisionsOperations",
     "ScopeAccessReviewInstanceContactedReviewersOperations",
     "ScopeAccessReviewDefaultSettingsOperations",
     "AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations",
     "AccessReviewInstancesAssignedForMyApprovalOperations",
     "AccessReviewInstanceMyDecisionsOperations",
     "TenantLevelAccessReviewInstanceContactedReviewersOperations",
-    "AlertsOperations",
-    "AlertConfigurationsOperations",
-    "AlertDefinitionsOperations",
-    "AlertIncidentsOperations",
-    "AlertOperationOperations",
 ]
 __all__.extend([p for p in _patch_all if p not in __all__])
 _patch_sdk()
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -25,56 +25,53 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_07_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """Lists the operations available from this provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -91,15 +88,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("OperationListResult", pipeline_response)
@@ -107,16 +115,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_alert_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,175 +24,194 @@
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._alert_definitions_operations import build_get_request, build_list_for_scope_request
+from ...operations._access_review_instances_operations import build_get_by_id_request, build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AlertDefinitionsOperations:
+class AccessReviewInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`alert_definitions` attribute.
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`access_review_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
-
-    @distributed_trace_async
-    async def get(self, scope: str, alert_definition_id: str, **kwargs: Any) -> _models.AlertDefinition:
-        """Get the specified alert definition.
-
-        :param scope: The scope of the alert definition. The scope can be any REST resource instance.
-         For example, use '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/' for a
-         subscription,
-         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}'
-         for a resource group, and
-         '/providers/Microsoft.Subscription/subscriptions/{subscription-id}/resourceGroups/{resource-group-name}/providers/{resource-provider}/{resource-type}/{resource-name}'
-         for a resource. Required.
-        :type scope: str
-        :param alert_definition_id: The name of the alert definition to get. Required.
-        :type alert_definition_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AlertDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
-        )
-        cls: ClsType[_models.AlertDefinition] = kwargs.pop("cls", None)
-
-        request = build_get_request(
-            scope=scope,
-            alert_definition_id=alert_definition_id,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("AlertDefinition", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    get.metadata = {
-        "url": "/{scope}/providers/Microsoft.Authorization/roleManagementAlertDefinitions/{alertDefinitionId}"
-    }
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list_for_scope(self, scope: str, **kwargs: Any) -> AsyncIterable["_models.AlertDefinition"]:
-        """Gets alert definitions for a resource scope.
-
-        :param scope: The scope of the alert definition. Required.
-        :type scope: str
+    def list(
+        self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.AccessReviewInstance"]:
+        """Get access review instances.
+
+        :param schedule_definition_id: The id of the access review schedule definition. Required.
+        :type schedule_definition_id: str
+        :param filter: The filter to apply on the operation. Other than standard filters, one custom
+         filter option is supported : 'assignedToMeToReview()'. When one specified
+         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
+         returned. Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AlertDefinition or the result of cls(response)
+        :return: An iterator like instance of either AccessReviewInstance or the result of
+         cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2022-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2022-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
-        cls: ClsType[_models.AlertDefinitionListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_for_scope_request(
-                    scope=scope,
+                request = build_list_request(
+                    schedule_definition_id=schedule_definition_id,
+                    subscription_id=self._config.subscription_id,
+                    filter=filter,
                     api_version=api_version,
-                    template_url=self.list_for_scope.metadata["url"],
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AlertDefinitionListResult", pipeline_response)
+            deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleManagementAlertDefinitions"}
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances"
+    }
+
+    @distributed_trace_async
+    async def get_by_id(self, schedule_definition_id: str, id: str, **kwargs: Any) -> _models.AccessReviewInstance:
+        """Get access review instances.
+
+        :param schedule_definition_id: The id of the access review schedule definition. Required.
+        :type schedule_definition_id: str
+        :param id: The id of the access review instance. Required.
+        :type id: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: AccessReviewInstance or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
+        )
+        cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
+
+        request = build_get_by_id_request(
+            schedule_definition_id=schedule_definition_id,
+            id=id,
+            subscription_id=self._config.subscription_id,
+            api_version=api_version,
+            template_url=self.get_by_id.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("AccessReviewInstance", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
+
+    get_by_id.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}"
+    }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_instances_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,16 +2,17 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,18 +31,14 @@
 from ..._vendor import _convert_request
 from ...operations._scope_access_review_instances_operations import (
     build_create_request,
     build_get_by_id_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScopeAccessReviewInstancesOperations:
     """
     .. warning::
@@ -56,14 +53,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, scope: str, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewInstance"]:
         """Get access review instances.
 
@@ -82,16 +80,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -111,15 +109,26 @@
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
             deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
@@ -127,16 +136,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -173,16 +183,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -190,16 +200,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -313,24 +324,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewInstanceProperties")
 
         request = build_create_request(
             scope=scope,
             schedule_definition_id=schedule_definition_id,
@@ -342,16 +353,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,16 +2,16 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -23,117 +23,124 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._scope_access_review_history_definition_instances_operations import build_list_request
+from ...operations._access_review_schedule_definitions_assigned_for_my_approval_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ScopeAccessReviewHistoryDefinitionInstancesOperations:
+class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`scope_access_review_history_definition_instances` attribute.
+        :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
-        self, scope: str, history_definition_id: str, **kwargs: Any
-    ) -> AsyncIterable["_models.AccessReviewHistoryInstance"]:
-        """Get access review history definition instances by definition Id.
-
-        :param scope: The scope of the resource. Required.
-        :type scope: str
-        :param history_definition_id: The id of the access review history definition. Required.
-        :type history_definition_id: str
+        self, filter: Optional[str] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
+        """Get access review instances assigned for my approval.
+
+        :param filter: The filter to apply on the operation. Other than standard filters, one custom
+         filter option is supported : 'assignedToMeToReview()'. When one specified
+         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
+         returned. Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewHistoryInstance or the result of
+        :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryInstance]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-12-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-12-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
-        cls: ClsType[_models.AccessReviewHistoryDefinitionInstanceListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
-                    scope=scope,
-                    history_definition_id=history_definition_id,
+                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
-                request = HttpRequest("GET", next_link)
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewHistoryDefinitionInstanceListResult", pipeline_response)
+            deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances"
-    }
+    list.metadata = {"url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/_models_py3.py`

 * *Files 12% similar despite different names*

```diff
@@ -2712,786 +2712,14 @@
         self.expand_nested_memberships = expand_nested_memberships
         self.include_inherited_access = include_inherited_access
         self.include_access_below_resource = include_access_below_resource
         self.exclude_resource_id = exclude_resource_id
         self.exclude_role_definition_id = exclude_role_definition_id
 
 
-class Alert(_serialization.Model):  # pylint: disable=too-many-instance-attributes
-    """The alert.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar id: The alert ID.
-    :vartype id: str
-    :ivar name: The alert name.
-    :vartype name: str
-    :ivar type: The alert type.
-    :vartype type: str
-    :ivar scope: The alert scope.
-    :vartype scope: str
-    :ivar is_active: False by default; true if the alert is active.
-    :vartype is_active: bool
-    :ivar incident_count: The number of generated incidents of the alert.
-    :vartype incident_count: int
-    :ivar last_modified_date_time: The date time when the alert configuration was updated or new
-     incidents were generated.
-    :vartype last_modified_date_time: ~datetime.datetime
-    :ivar last_scanned_date_time: The date time when the alert was last scanned.
-    :vartype last_scanned_date_time: ~datetime.datetime
-    :ivar alert_definition: The alert definition.
-    :vartype alert_definition: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition
-    :ivar alert_incidents: The alert incidents.
-    :vartype alert_incidents:
-     list[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertIncident]
-    :ivar alert_configuration: The alert configuration.
-    :vartype alert_configuration:
-     ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "name": {"readonly": True},
-        "type": {"readonly": True},
-        "scope": {"readonly": True},
-        "incident_count": {"readonly": True},
-        "last_modified_date_time": {"readonly": True},
-        "last_scanned_date_time": {"readonly": True},
-        "alert_definition": {"readonly": True},
-        "alert_incidents": {"readonly": True},
-        "alert_configuration": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "scope": {"key": "properties.scope", "type": "str"},
-        "is_active": {"key": "properties.isActive", "type": "bool"},
-        "incident_count": {"key": "properties.incidentCount", "type": "int"},
-        "last_modified_date_time": {"key": "properties.lastModifiedDateTime", "type": "iso-8601"},
-        "last_scanned_date_time": {"key": "properties.lastScannedDateTime", "type": "iso-8601"},
-        "alert_definition": {"key": "properties.alertDefinition", "type": "AlertDefinition"},
-        "alert_incidents": {"key": "properties.alertIncidents", "type": "[AlertIncident]"},
-        "alert_configuration": {"key": "properties.alertConfiguration", "type": "AlertConfiguration"},
-    }
-
-    def __init__(self, *, is_active: Optional[bool] = None, **kwargs: Any) -> None:
-        """
-        :keyword is_active: False by default; true if the alert is active.
-        :paramtype is_active: bool
-        """
-        super().__init__(**kwargs)
-        self.id = None
-        self.name = None
-        self.type = None
-        self.scope = None
-        self.is_active = is_active
-        self.incident_count = None
-        self.last_modified_date_time = None
-        self.last_scanned_date_time = None
-        self.alert_definition = None
-        self.alert_incidents = None
-        self.alert_configuration = None
-
-
-class AlertConfiguration(_serialization.Model):
-    """Alert configuration.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar id: The alert configuration ID.
-    :vartype id: str
-    :ivar name: The alert configuration name.
-    :vartype name: str
-    :ivar type: The alert configuration type.
-    :vartype type: str
-    :ivar alert_definition_id: The alert definition ID.
-    :vartype alert_definition_id: str
-    :ivar scope: The alert scope.
-    :vartype scope: str
-    :ivar is_enabled: True if the alert is enabled, false will disable the scanning for the
-     specific alert.
-    :vartype is_enabled: bool
-    :ivar alert_configuration_type: The alert configuration type.
-    :vartype alert_configuration_type: str
-    :ivar alert_definition: The alert definition.
-    :vartype alert_definition: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "name": {"readonly": True},
-        "type": {"readonly": True},
-        "alert_definition_id": {"readonly": True},
-        "scope": {"readonly": True},
-        "alert_definition": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "alert_definition_id": {"key": "properties.alertDefinitionId", "type": "str"},
-        "scope": {"key": "properties.scope", "type": "str"},
-        "is_enabled": {"key": "properties.isEnabled", "type": "bool"},
-        "alert_configuration_type": {"key": "properties.alertConfigurationType", "type": "str"},
-        "alert_definition": {"key": "properties.alertDefinition", "type": "AlertDefinition"},
-    }
-
-    def __init__(self, *, is_enabled: Optional[bool] = None, **kwargs: Any) -> None:
-        """
-        :keyword is_enabled: True if the alert is enabled, false will disable the scanning for the
-         specific alert.
-        :paramtype is_enabled: bool
-        """
-        super().__init__(**kwargs)
-        self.id = None
-        self.name = None
-        self.type = None
-        self.alert_definition_id = None
-        self.scope = None
-        self.is_enabled = is_enabled
-        self.alert_configuration_type: Optional[str] = None
-        self.alert_definition = None
-
-
-class AlertConfigurationListResult(_serialization.Model):
-    """Alert configuration list operation result.
-
-    :ivar value: Alert configuration list.
-    :vartype value: list[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration]
-    :ivar next_link: The URL to use for getting the next set of results.
-    :vartype next_link: str
-    """
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "[AlertConfiguration]"},
-        "next_link": {"key": "nextLink", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        value: Optional[List["_models.AlertConfiguration"]] = None,
-        next_link: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword value: Alert configuration list.
-        :paramtype value: list[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertConfiguration]
-        :keyword next_link: The URL to use for getting the next set of results.
-        :paramtype next_link: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
-        self.next_link = next_link
-
-
-class AlertConfigurationProperties(_serialization.Model):
-    """Alert configuration properties.
-
-    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
-    AzureRolesAssignedOutsidePimAlertConfigurationProperties,
-    DuplicateRoleCreatedAlertConfigurationProperties,
-    TooManyOwnersAssignedToResourceAlertConfigurationProperties,
-    TooManyPermanentOwnersAssignedToResourceAlertConfigurationProperties
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar alert_definition_id: The alert definition ID.
-    :vartype alert_definition_id: str
-    :ivar scope: The alert scope.
-    :vartype scope: str
-    :ivar is_enabled: True if the alert is enabled, false will disable the scanning for the
-     specific alert.
-    :vartype is_enabled: bool
-    :ivar alert_configuration_type: The alert configuration type. Required.
-    :vartype alert_configuration_type: str
-    :ivar alert_definition: The alert definition.
-    :vartype alert_definition: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition
-    """
-
-    _validation = {
-        "alert_definition_id": {"readonly": True},
-        "scope": {"readonly": True},
-        "alert_configuration_type": {"required": True},
-        "alert_definition": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "alert_definition_id": {"key": "alertDefinitionId", "type": "str"},
-        "scope": {"key": "scope", "type": "str"},
-        "is_enabled": {"key": "isEnabled", "type": "bool"},
-        "alert_configuration_type": {"key": "alertConfigurationType", "type": "str"},
-        "alert_definition": {"key": "alertDefinition", "type": "AlertDefinition"},
-    }
-
-    _subtype_map = {
-        "alert_configuration_type": {
-            "AzureRolesAssignedOutsidePimAlertConfiguration": "AzureRolesAssignedOutsidePimAlertConfigurationProperties",
-            "DuplicateRoleCreatedAlertConfiguration": "DuplicateRoleCreatedAlertConfigurationProperties",
-            "TooManyOwnersAssignedToResourceAlertConfiguration": "TooManyOwnersAssignedToResourceAlertConfigurationProperties",
-            "TooManyPermanentOwnersAssignedToResourceAlertConfiguration": "TooManyPermanentOwnersAssignedToResourceAlertConfigurationProperties",
-        }
-    }
-
-    def __init__(self, *, is_enabled: Optional[bool] = None, **kwargs: Any) -> None:
-        """
-        :keyword is_enabled: True if the alert is enabled, false will disable the scanning for the
-         specific alert.
-        :paramtype is_enabled: bool
-        """
-        super().__init__(**kwargs)
-        self.alert_definition_id = None
-        self.scope = None
-        self.is_enabled = is_enabled
-        self.alert_configuration_type: Optional[str] = None
-        self.alert_definition = None
-
-
-class AlertDefinition(_serialization.Model):  # pylint: disable=too-many-instance-attributes
-    """Alert definition.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar id: The alert definition ID.
-    :vartype id: str
-    :ivar name: The alert definition name.
-    :vartype name: str
-    :ivar type: The alert definition type.
-    :vartype type: str
-    :ivar display_name: The alert display name.
-    :vartype display_name: str
-    :ivar scope: The alert scope.
-    :vartype scope: str
-    :ivar description: The alert description.
-    :vartype description: str
-    :ivar severity_level: Severity level of the alert. Known values are: "Low", "Medium", and
-     "High".
-    :vartype severity_level: str or
-     ~azure.mgmt.authorization.v2021_12_01_preview.models.SeverityLevel
-    :ivar security_impact: Security impact of the alert.
-    :vartype security_impact: str
-    :ivar mitigation_steps: The methods to mitigate the alert.
-    :vartype mitigation_steps: str
-    :ivar how_to_prevent: The ways to prevent the alert.
-    :vartype how_to_prevent: str
-    :ivar is_remediatable: True if the alert can be remediated; false, otherwise.
-    :vartype is_remediatable: bool
-    :ivar is_configurable: True if the alert configuration can be configured; false, otherwise.
-    :vartype is_configurable: bool
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "name": {"readonly": True},
-        "type": {"readonly": True},
-        "display_name": {"readonly": True},
-        "scope": {"readonly": True},
-        "description": {"readonly": True},
-        "severity_level": {"readonly": True},
-        "security_impact": {"readonly": True},
-        "mitigation_steps": {"readonly": True},
-        "how_to_prevent": {"readonly": True},
-        "is_remediatable": {"readonly": True},
-        "is_configurable": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "display_name": {"key": "properties.displayName", "type": "str"},
-        "scope": {"key": "properties.scope", "type": "str"},
-        "description": {"key": "properties.description", "type": "str"},
-        "severity_level": {"key": "properties.severityLevel", "type": "str"},
-        "security_impact": {"key": "properties.securityImpact", "type": "str"},
-        "mitigation_steps": {"key": "properties.mitigationSteps", "type": "str"},
-        "how_to_prevent": {"key": "properties.howToPrevent", "type": "str"},
-        "is_remediatable": {"key": "properties.isRemediatable", "type": "bool"},
-        "is_configurable": {"key": "properties.isConfigurable", "type": "bool"},
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-        self.id = None
-        self.name = None
-        self.type = None
-        self.display_name = None
-        self.scope = None
-        self.description = None
-        self.severity_level = None
-        self.security_impact = None
-        self.mitigation_steps = None
-        self.how_to_prevent = None
-        self.is_remediatable = None
-        self.is_configurable = None
-
-
-class AlertDefinitionListResult(_serialization.Model):
-    """Alert definition list operation result.
-
-    :ivar value: Alert definition list.
-    :vartype value: list[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition]
-    :ivar next_link: The URL to use for getting the next set of results.
-    :vartype next_link: str
-    """
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "[AlertDefinition]"},
-        "next_link": {"key": "nextLink", "type": "str"},
-    }
-
-    def __init__(
-        self, *, value: Optional[List["_models.AlertDefinition"]] = None, next_link: Optional[str] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword value: Alert definition list.
-        :paramtype value: list[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition]
-        :keyword next_link: The URL to use for getting the next set of results.
-        :paramtype next_link: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
-        self.next_link = next_link
-
-
-class AlertIncident(_serialization.Model):
-    """Alert incident.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar id: The alert incident ID.
-    :vartype id: str
-    :ivar name: The alert incident name.
-    :vartype name: str
-    :ivar type: The alert incident type.
-    :vartype type: str
-    :ivar alert_incident_type: The alert incident type.
-    :vartype alert_incident_type: str
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "name": {"readonly": True},
-        "type": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "name": {"key": "name", "type": "str"},
-        "type": {"key": "type", "type": "str"},
-        "alert_incident_type": {"key": "properties.alertIncidentType", "type": "str"},
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-        self.id = None
-        self.name = None
-        self.type = None
-        self.alert_incident_type: Optional[str] = None
-
-
-class AlertIncidentListResult(_serialization.Model):
-    """Alert incident list operation result.
-
-    :ivar value: Alert incident list.
-    :vartype value: list[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertIncident]
-    :ivar next_link: The URL to use for getting the next set of results.
-    :vartype next_link: str
-    """
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "[AlertIncident]"},
-        "next_link": {"key": "nextLink", "type": "str"},
-    }
-
-    def __init__(
-        self, *, value: Optional[List["_models.AlertIncident"]] = None, next_link: Optional[str] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword value: Alert incident list.
-        :paramtype value: list[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertIncident]
-        :keyword next_link: The URL to use for getting the next set of results.
-        :paramtype next_link: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
-        self.next_link = next_link
-
-
-class AlertIncidentProperties(_serialization.Model):
-    """Alert incident properties.
-
-    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
-    AzureRolesAssignedOutsidePimAlertIncidentProperties,
-    DuplicateRoleCreatedAlertIncidentProperties,
-    TooManyOwnersAssignedToResourceAlertIncidentProperties,
-    TooManyPermanentOwnersAssignedToResourceAlertIncidentProperties
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar alert_incident_type: The alert incident type. Required.
-    :vartype alert_incident_type: str
-    """
-
-    _validation = {
-        "alert_incident_type": {"required": True},
-    }
-
-    _attribute_map = {
-        "alert_incident_type": {"key": "alertIncidentType", "type": "str"},
-    }
-
-    _subtype_map = {
-        "alert_incident_type": {
-            "AzureRolesAssignedOutsidePimAlertIncident": "AzureRolesAssignedOutsidePimAlertIncidentProperties",
-            "DuplicateRoleCreatedAlertIncident": "DuplicateRoleCreatedAlertIncidentProperties",
-            "TooManyOwnersAssignedToResourceAlertIncident": "TooManyOwnersAssignedToResourceAlertIncidentProperties",
-            "TooManyPermanentOwnersAssignedToResourceAlertIncident": "TooManyPermanentOwnersAssignedToResourceAlertIncidentProperties",
-        }
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-        self.alert_incident_type: Optional[str] = None
-
-
-class AlertListResult(_serialization.Model):
-    """Alert list operation result.
-
-    :ivar value: Alert list.
-    :vartype value: list[~azure.mgmt.authorization.v2021_12_01_preview.models.Alert]
-    :ivar next_link: The URL to use for getting the next set of results.
-    :vartype next_link: str
-    """
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "[Alert]"},
-        "next_link": {"key": "nextLink", "type": "str"},
-    }
-
-    def __init__(
-        self, *, value: Optional[List["_models.Alert"]] = None, next_link: Optional[str] = None, **kwargs: Any
-    ) -> None:
-        """
-        :keyword value: Alert list.
-        :paramtype value: list[~azure.mgmt.authorization.v2021_12_01_preview.models.Alert]
-        :keyword next_link: The URL to use for getting the next set of results.
-        :paramtype next_link: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
-        self.next_link = next_link
-
-
-class AlertOperationListResult(_serialization.Model):
-    """Alert operation list operation result.
-
-    :ivar value: Alert operation list.
-    :vartype value: list[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertOperationResult]
-    :ivar next_link: The URL to use for getting the next set of results.
-    :vartype next_link: str
-    """
-
-    _attribute_map = {
-        "value": {"key": "value", "type": "[AlertOperationResult]"},
-        "next_link": {"key": "nextLink", "type": "str"},
-    }
-
-    def __init__(
-        self,
-        *,
-        value: Optional[List["_models.AlertOperationResult"]] = None,
-        next_link: Optional[str] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword value: Alert operation list.
-        :paramtype value:
-         list[~azure.mgmt.authorization.v2021_12_01_preview.models.AlertOperationResult]
-        :keyword next_link: The URL to use for getting the next set of results.
-        :paramtype next_link: str
-        """
-        super().__init__(**kwargs)
-        self.value = value
-        self.next_link = next_link
-
-
-class AlertOperationResult(_serialization.Model):
-    """Alert operation result.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    :ivar id: The id of the alert operation.
-    :vartype id: str
-    :ivar status: The status of the alert operation.
-    :vartype status: str
-    """
-
-    _validation = {
-        "id": {"readonly": True},
-        "status": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "id": {"key": "id", "type": "str"},
-        "status": {"key": "status", "type": "str"},
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-        self.id = None
-        self.status = None
-
-
-class AzureRolesAssignedOutsidePimAlertConfigurationProperties(AlertConfigurationProperties):
-    """The Azure roles assigned outside PIM alert configuration properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar alert_definition_id: The alert definition ID.
-    :vartype alert_definition_id: str
-    :ivar scope: The alert scope.
-    :vartype scope: str
-    :ivar is_enabled: True if the alert is enabled, false will disable the scanning for the
-     specific alert.
-    :vartype is_enabled: bool
-    :ivar alert_configuration_type: The alert configuration type. Required.
-    :vartype alert_configuration_type: str
-    :ivar alert_definition: The alert definition.
-    :vartype alert_definition: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition
-    """
-
-    _validation = {
-        "alert_definition_id": {"readonly": True},
-        "scope": {"readonly": True},
-        "alert_configuration_type": {"required": True},
-        "alert_definition": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "alert_definition_id": {"key": "alertDefinitionId", "type": "str"},
-        "scope": {"key": "scope", "type": "str"},
-        "is_enabled": {"key": "isEnabled", "type": "bool"},
-        "alert_configuration_type": {"key": "alertConfigurationType", "type": "str"},
-        "alert_definition": {"key": "alertDefinition", "type": "AlertDefinition"},
-    }
-
-    def __init__(self, *, is_enabled: Optional[bool] = None, **kwargs: Any) -> None:
-        """
-        :keyword is_enabled: True if the alert is enabled, false will disable the scanning for the
-         specific alert.
-        :paramtype is_enabled: bool
-        """
-        super().__init__(is_enabled=is_enabled, **kwargs)
-        self.alert_configuration_type: str = "AzureRolesAssignedOutsidePimAlertConfiguration"
-
-
-class AzureRolesAssignedOutsidePimAlertIncidentProperties(
-    AlertIncidentProperties
-):  # pylint: disable=too-many-instance-attributes
-    """Azure roles assigned outside PIM alert incident properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar alert_incident_type: The alert incident type. Required.
-    :vartype alert_incident_type: str
-    :ivar assignee_display_name: The assignee display name.
-    :vartype assignee_display_name: str
-    :ivar assignee_user_principal_name: The assignee user principal name.
-    :vartype assignee_user_principal_name: str
-    :ivar assignee_id: The assignee ID.
-    :vartype assignee_id: str
-    :ivar role_display_name: The role display name.
-    :vartype role_display_name: str
-    :ivar role_template_id: The role template ID.
-    :vartype role_template_id: str
-    :ivar role_definition_id: The role definition ID.
-    :vartype role_definition_id: str
-    :ivar assignment_activated_date: The date the assignment was activated.
-    :vartype assignment_activated_date: ~datetime.datetime
-    :ivar requestor_id: The requestor ID.
-    :vartype requestor_id: str
-    :ivar requestor_display_name: The requestor display name.
-    :vartype requestor_display_name: str
-    :ivar requestor_user_principal_name: The requestor user principal name.
-    :vartype requestor_user_principal_name: str
-    """
-
-    _validation = {
-        "alert_incident_type": {"required": True},
-        "assignee_display_name": {"readonly": True},
-        "assignee_user_principal_name": {"readonly": True},
-        "assignee_id": {"readonly": True},
-        "role_display_name": {"readonly": True},
-        "role_template_id": {"readonly": True},
-        "role_definition_id": {"readonly": True},
-        "assignment_activated_date": {"readonly": True},
-        "requestor_id": {"readonly": True},
-        "requestor_display_name": {"readonly": True},
-        "requestor_user_principal_name": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "alert_incident_type": {"key": "alertIncidentType", "type": "str"},
-        "assignee_display_name": {"key": "assigneeDisplayName", "type": "str"},
-        "assignee_user_principal_name": {"key": "assigneeUserPrincipalName", "type": "str"},
-        "assignee_id": {"key": "assigneeId", "type": "str"},
-        "role_display_name": {"key": "roleDisplayName", "type": "str"},
-        "role_template_id": {"key": "roleTemplateId", "type": "str"},
-        "role_definition_id": {"key": "roleDefinitionId", "type": "str"},
-        "assignment_activated_date": {"key": "assignmentActivatedDate", "type": "iso-8601"},
-        "requestor_id": {"key": "requestorId", "type": "str"},
-        "requestor_display_name": {"key": "requestorDisplayName", "type": "str"},
-        "requestor_user_principal_name": {"key": "requestorUserPrincipalName", "type": "str"},
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-        self.alert_incident_type: str = "AzureRolesAssignedOutsidePimAlertIncident"
-        self.assignee_display_name = None
-        self.assignee_user_principal_name = None
-        self.assignee_id = None
-        self.role_display_name = None
-        self.role_template_id = None
-        self.role_definition_id = None
-        self.assignment_activated_date = None
-        self.requestor_id = None
-        self.requestor_display_name = None
-        self.requestor_user_principal_name = None
-
-
-class CloudErrorBody(_serialization.Model):
-    """An error response from the service.
-
-    :ivar code: An identifier for the error. Codes are invariant and are intended to be consumed
-     programmatically.
-    :vartype code: str
-    :ivar message: A message describing the error, intended to be suitable for display in a user
-     interface.
-    :vartype message: str
-    """
-
-    _attribute_map = {
-        "code": {"key": "code", "type": "str"},
-        "message": {"key": "message", "type": "str"},
-    }
-
-    def __init__(self, *, code: Optional[str] = None, message: Optional[str] = None, **kwargs: Any) -> None:
-        """
-        :keyword code: An identifier for the error. Codes are invariant and are intended to be consumed
-         programmatically.
-        :paramtype code: str
-        :keyword message: A message describing the error, intended to be suitable for display in a user
-         interface.
-        :paramtype message: str
-        """
-        super().__init__(**kwargs)
-        self.code = code
-        self.message = message
-
-
-class DuplicateRoleCreatedAlertConfigurationProperties(AlertConfigurationProperties):
-    """The duplicate role created alert configuration.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar alert_definition_id: The alert definition ID.
-    :vartype alert_definition_id: str
-    :ivar scope: The alert scope.
-    :vartype scope: str
-    :ivar is_enabled: True if the alert is enabled, false will disable the scanning for the
-     specific alert.
-    :vartype is_enabled: bool
-    :ivar alert_configuration_type: The alert configuration type. Required.
-    :vartype alert_configuration_type: str
-    :ivar alert_definition: The alert definition.
-    :vartype alert_definition: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition
-    """
-
-    _validation = {
-        "alert_definition_id": {"readonly": True},
-        "scope": {"readonly": True},
-        "alert_configuration_type": {"required": True},
-        "alert_definition": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "alert_definition_id": {"key": "alertDefinitionId", "type": "str"},
-        "scope": {"key": "scope", "type": "str"},
-        "is_enabled": {"key": "isEnabled", "type": "bool"},
-        "alert_configuration_type": {"key": "alertConfigurationType", "type": "str"},
-        "alert_definition": {"key": "alertDefinition", "type": "AlertDefinition"},
-    }
-
-    def __init__(self, *, is_enabled: Optional[bool] = None, **kwargs: Any) -> None:
-        """
-        :keyword is_enabled: True if the alert is enabled, false will disable the scanning for the
-         specific alert.
-        :paramtype is_enabled: bool
-        """
-        super().__init__(is_enabled=is_enabled, **kwargs)
-        self.alert_configuration_type: str = "DuplicateRoleCreatedAlertConfiguration"
-
-
-class DuplicateRoleCreatedAlertIncidentProperties(AlertIncidentProperties):
-    """Duplicate role created alert incident properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar alert_incident_type: The alert incident type. Required.
-    :vartype alert_incident_type: str
-    :ivar role_name: The role name.
-    :vartype role_name: str
-    :ivar duplicate_roles: The duplicate roles.
-    :vartype duplicate_roles: str
-    :ivar reason: The reason for the incident.
-    :vartype reason: str
-    """
-
-    _validation = {
-        "alert_incident_type": {"required": True},
-        "role_name": {"readonly": True},
-        "duplicate_roles": {"readonly": True},
-        "reason": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "alert_incident_type": {"key": "alertIncidentType", "type": "str"},
-        "role_name": {"key": "roleName", "type": "str"},
-        "duplicate_roles": {"key": "duplicateRoles", "type": "str"},
-        "reason": {"key": "reason", "type": "str"},
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-        self.alert_incident_type: str = "DuplicateRoleCreatedAlertIncident"
-        self.role_name = None
-        self.duplicate_roles = None
-        self.reason = None
-
-
 class ErrorDefinition(_serialization.Model):
     """Error description and code explaining why an operation failed.
 
     :ivar error: Error of the list gateway status.
     :vartype error: ~azure.mgmt.authorization.v2021_12_01_preview.models.ErrorDefinitionProperties
     """
 
@@ -3696,219 +2924,7 @@
         :paramtype justification: str
         """
         super().__init__(**kwargs)
         self.principal_id = None
         self.resource_id = None
         self.decision = decision
         self.justification = justification
-
-
-class TooManyOwnersAssignedToResourceAlertConfigurationProperties(AlertConfigurationProperties):
-    """Too many owners assigned to resource alert configuration properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar alert_definition_id: The alert definition ID.
-    :vartype alert_definition_id: str
-    :ivar scope: The alert scope.
-    :vartype scope: str
-    :ivar is_enabled: True if the alert is enabled, false will disable the scanning for the
-     specific alert.
-    :vartype is_enabled: bool
-    :ivar alert_configuration_type: The alert configuration type. Required.
-    :vartype alert_configuration_type: str
-    :ivar alert_definition: The alert definition.
-    :vartype alert_definition: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition
-    :ivar threshold_number_of_owners: The threshold number of owners.
-    :vartype threshold_number_of_owners: int
-    :ivar threshold_percentage_of_owners_out_of_all_role_members: The threshold percentage of
-     owners out of all role members.
-    :vartype threshold_percentage_of_owners_out_of_all_role_members: int
-    """
-
-    _validation = {
-        "alert_definition_id": {"readonly": True},
-        "scope": {"readonly": True},
-        "alert_configuration_type": {"required": True},
-        "alert_definition": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "alert_definition_id": {"key": "alertDefinitionId", "type": "str"},
-        "scope": {"key": "scope", "type": "str"},
-        "is_enabled": {"key": "isEnabled", "type": "bool"},
-        "alert_configuration_type": {"key": "alertConfigurationType", "type": "str"},
-        "alert_definition": {"key": "alertDefinition", "type": "AlertDefinition"},
-        "threshold_number_of_owners": {"key": "thresholdNumberOfOwners", "type": "int"},
-        "threshold_percentage_of_owners_out_of_all_role_members": {
-            "key": "thresholdPercentageOfOwnersOutOfAllRoleMembers",
-            "type": "int",
-        },
-    }
-
-    def __init__(
-        self,
-        *,
-        is_enabled: Optional[bool] = None,
-        threshold_number_of_owners: Optional[int] = None,
-        threshold_percentage_of_owners_out_of_all_role_members: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword is_enabled: True if the alert is enabled, false will disable the scanning for the
-         specific alert.
-        :paramtype is_enabled: bool
-        :keyword threshold_number_of_owners: The threshold number of owners.
-        :paramtype threshold_number_of_owners: int
-        :keyword threshold_percentage_of_owners_out_of_all_role_members: The threshold percentage of
-         owners out of all role members.
-        :paramtype threshold_percentage_of_owners_out_of_all_role_members: int
-        """
-        super().__init__(is_enabled=is_enabled, **kwargs)
-        self.alert_configuration_type: str = "TooManyOwnersAssignedToResourceAlertConfiguration"
-        self.threshold_number_of_owners = threshold_number_of_owners
-        self.threshold_percentage_of_owners_out_of_all_role_members = (
-            threshold_percentage_of_owners_out_of_all_role_members
-        )
-
-
-class TooManyOwnersAssignedToResourceAlertIncidentProperties(AlertIncidentProperties):
-    """Too many owners assigned to resource alert incident properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar alert_incident_type: The alert incident type. Required.
-    :vartype alert_incident_type: str
-    :ivar assignee_name: The assignee name.
-    :vartype assignee_name: str
-    :ivar assignee_type: The assignee type.
-    :vartype assignee_type: str
-    """
-
-    _validation = {
-        "alert_incident_type": {"required": True},
-        "assignee_name": {"readonly": True},
-        "assignee_type": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "alert_incident_type": {"key": "alertIncidentType", "type": "str"},
-        "assignee_name": {"key": "assigneeName", "type": "str"},
-        "assignee_type": {"key": "assigneeType", "type": "str"},
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-        self.alert_incident_type: str = "TooManyOwnersAssignedToResourceAlertIncident"
-        self.assignee_name = None
-        self.assignee_type = None
-
-
-class TooManyPermanentOwnersAssignedToResourceAlertConfigurationProperties(AlertConfigurationProperties):
-    """Too many permanent owners assigned to resource alert configuration properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar alert_definition_id: The alert definition ID.
-    :vartype alert_definition_id: str
-    :ivar scope: The alert scope.
-    :vartype scope: str
-    :ivar is_enabled: True if the alert is enabled, false will disable the scanning for the
-     specific alert.
-    :vartype is_enabled: bool
-    :ivar alert_configuration_type: The alert configuration type. Required.
-    :vartype alert_configuration_type: str
-    :ivar alert_definition: The alert definition.
-    :vartype alert_definition: ~azure.mgmt.authorization.v2021_12_01_preview.models.AlertDefinition
-    :ivar threshold_number_of_permanent_owners: The threshold number of permanent owners.
-    :vartype threshold_number_of_permanent_owners: int
-    :ivar threshold_percentage_of_permanent_owners_out_of_all_owners: The threshold percentage of
-     permanent owners out of all owners.
-    :vartype threshold_percentage_of_permanent_owners_out_of_all_owners: int
-    """
-
-    _validation = {
-        "alert_definition_id": {"readonly": True},
-        "scope": {"readonly": True},
-        "alert_configuration_type": {"required": True},
-        "alert_definition": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "alert_definition_id": {"key": "alertDefinitionId", "type": "str"},
-        "scope": {"key": "scope", "type": "str"},
-        "is_enabled": {"key": "isEnabled", "type": "bool"},
-        "alert_configuration_type": {"key": "alertConfigurationType", "type": "str"},
-        "alert_definition": {"key": "alertDefinition", "type": "AlertDefinition"},
-        "threshold_number_of_permanent_owners": {"key": "thresholdNumberOfPermanentOwners", "type": "int"},
-        "threshold_percentage_of_permanent_owners_out_of_all_owners": {
-            "key": "thresholdPercentageOfPermanentOwnersOutOfAllOwners",
-            "type": "int",
-        },
-    }
-
-    def __init__(
-        self,
-        *,
-        is_enabled: Optional[bool] = None,
-        threshold_number_of_permanent_owners: Optional[int] = None,
-        threshold_percentage_of_permanent_owners_out_of_all_owners: Optional[int] = None,
-        **kwargs: Any
-    ) -> None:
-        """
-        :keyword is_enabled: True if the alert is enabled, false will disable the scanning for the
-         specific alert.
-        :paramtype is_enabled: bool
-        :keyword threshold_number_of_permanent_owners: The threshold number of permanent owners.
-        :paramtype threshold_number_of_permanent_owners: int
-        :keyword threshold_percentage_of_permanent_owners_out_of_all_owners: The threshold percentage
-         of permanent owners out of all owners.
-        :paramtype threshold_percentage_of_permanent_owners_out_of_all_owners: int
-        """
-        super().__init__(is_enabled=is_enabled, **kwargs)
-        self.alert_configuration_type: str = "TooManyPermanentOwnersAssignedToResourceAlertConfiguration"
-        self.threshold_number_of_permanent_owners = threshold_number_of_permanent_owners
-        self.threshold_percentage_of_permanent_owners_out_of_all_owners = (
-            threshold_percentage_of_permanent_owners_out_of_all_owners
-        )
-
-
-class TooManyPermanentOwnersAssignedToResourceAlertIncidentProperties(AlertIncidentProperties):
-    """Too many permanent owners assigned to resource alert incident properties.
-
-    Variables are only populated by the server, and will be ignored when sending a request.
-
-    All required parameters must be populated in order to send to Azure.
-
-    :ivar alert_incident_type: The alert incident type. Required.
-    :vartype alert_incident_type: str
-    :ivar assignee_name: The assignee name.
-    :vartype assignee_name: str
-    :ivar assignee_type: The assignee type.
-    :vartype assignee_type: str
-    """
-
-    _validation = {
-        "alert_incident_type": {"required": True},
-        "assignee_name": {"readonly": True},
-        "assignee_type": {"readonly": True},
-    }
-
-    _attribute_map = {
-        "alert_incident_type": {"key": "alertIncidentType", "type": "str"},
-        "assignee_name": {"key": "assigneeName", "type": "str"},
-        "assignee_type": {"key": "assigneeType", "type": "str"},
-    }
-
-    def __init__(self, **kwargs: Any) -> None:
-        """ """
-        super().__init__(**kwargs)
-        self.alert_incident_type: str = "TooManyPermanentOwnersAssignedToResourceAlertIncident"
-        self.assignee_name = None
-        self.assignee_type = None
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_12_01_preview/models/_authorization_management_client_enums.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/_authorization_management_client_enums.py`

 * *Files 1% similar despite different names*

```diff
@@ -185,15 +185,7 @@
 
 
 class RecordAllDecisionsResult(str, Enum, metaclass=CaseInsensitiveEnumMeta):
     """The decision to make. Approvers can take action of Approve/Deny."""
 
     APPROVE = "Approve"
     DENY = "Deny"
-
-
-class SeverityLevel(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """Severity level of the alert."""
-
-    LOW = "Low"
-    MEDIUM = "Medium"
-    HIGH = "High"
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_authorization_management_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -48,22 +48,22 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.deny_assignments = DenyAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-07-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :keyword api_version: Api Version. Default value is "2018-07-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop("api_version", "2018-07-01-preview")
+        api_version: str = kwargs.pop("api_version", "2018-07-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/_deny_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/_deny_assignments_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -51,17 +46,15 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/denyAssignments",
     )  # pylint: disable=line-too-long
@@ -93,17 +86,15 @@
 
 def build_list_for_resource_group_request(
     resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/denyAssignments",
     )  # pylint: disable=line-too-long
@@ -127,17 +118,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/denyAssignments"
     )
     path_format_arguments = {
@@ -157,17 +146,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, deny_assignment_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/denyAssignments/{denyAssignmentId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "denyAssignmentId": _SERIALIZER.url("deny_assignment_id", deny_assignment_id, "str"),
@@ -184,17 +171,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(deny_assignment_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{denyAssignmentId}")
     path_format_arguments = {
         "denyAssignmentId": _SERIALIZER.url("deny_assignment_id", deny_assignment_id, "str", skip_quote=True),
     }
@@ -210,17 +195,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/denyAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -252,14 +235,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -297,16 +281,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_07_01_preview.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -357,16 +341,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -404,16 +389,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_07_01_preview.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -460,16 +445,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -502,16 +488,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_07_01_preview.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -557,16 +543,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -597,32 +584,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             deny_assignment_id=deny_assignment_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -659,31 +647,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             deny_assignment_id=deny_assignment_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -722,16 +711,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_07_01_preview.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -777,16 +766,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/_authorization_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -48,22 +48,22 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.deny_assignments = DenyAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-07-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/_configuration.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2018-07-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2018-01-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop("api_version", "2018-07-01-preview")
+        api_version: str = kwargs.pop("api_version", "2018-01-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_deny_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_deny_assignments_operations.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -34,18 +33,14 @@
     build_get_request,
     build_list_for_resource_group_request,
     build_list_for_resource_request,
     build_list_for_scope_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class DenyAssignmentsOperations:
     """
     .. warning::
@@ -60,14 +55,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -105,16 +101,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_07_01_preview.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -165,16 +161,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -212,16 +209,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_07_01_preview.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -268,16 +265,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -310,16 +308,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_07_01_preview.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -365,16 +363,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -405,32 +404,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             deny_assignment_id=deny_assignment_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -467,31 +467,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             deny_assignment_id=deny_assignment_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -530,16 +531,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_07_01_preview.models.DenyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-07-01-preview")
         )
         cls: ClsType[_models.DenyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -585,16 +586,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_07_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/_authorization_management_client.py`

 * *Files 10% similar despite different names*

```diff
@@ -3,21 +3,21 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
-from typing import Any, TYPE_CHECKING
+from typing import Any, Awaitable, TYPE_CHECKING
 
-from azure.core.rest import HttpRequest, HttpResponse
-from azure.mgmt.core import ARMPipelineClient
+from azure.core.rest import AsyncHttpResponse, HttpRequest
+from azure.mgmt.core import AsyncARMPipelineClient
 
-from . import models as _models
-from .._serialization import Deserializer, Serializer
+from .. import models as _models
+from ..._serialization import Deserializer, Serializer
 from ._configuration import AuthorizationManagementClientConfiguration
 from .operations import (
     AccessReviewDefaultSettingsOperations,
     AccessReviewInstanceContactedReviewersOperations,
     AccessReviewInstanceDecisionsOperations,
     AccessReviewInstanceMyDecisionsOperations,
     AccessReviewInstanceOperations,
@@ -27,144 +27,146 @@
     AccessReviewScheduleDefinitionsOperations,
     Operations,
     TenantLevelAccessReviewInstanceContactedReviewersOperations,
 )
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
     """Access reviews service provides the workflow for running access reviews on different kind of
     resources.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.authorization.v2021_07_01_preview.operations.Operations
+    :vartype operations: azure.mgmt.authorization.v2021_07_01_preview.aio.operations.Operations
     :ivar access_review_schedule_definitions: AccessReviewScheduleDefinitionsOperations operations
     :vartype access_review_schedule_definitions:
-     azure.mgmt.authorization.v2021_07_01_preview.operations.AccessReviewScheduleDefinitionsOperations
+     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewScheduleDefinitionsOperations
     :ivar access_review_instances: AccessReviewInstancesOperations operations
     :vartype access_review_instances:
-     azure.mgmt.authorization.v2021_07_01_preview.operations.AccessReviewInstancesOperations
+     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstancesOperations
     :ivar access_review_instance: AccessReviewInstanceOperations operations
     :vartype access_review_instance:
-     azure.mgmt.authorization.v2021_07_01_preview.operations.AccessReviewInstanceOperations
+     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstanceOperations
     :ivar access_review_instance_decisions: AccessReviewInstanceDecisionsOperations operations
     :vartype access_review_instance_decisions:
-     azure.mgmt.authorization.v2021_07_01_preview.operations.AccessReviewInstanceDecisionsOperations
+     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstanceDecisionsOperations
     :ivar access_review_instance_contacted_reviewers:
      AccessReviewInstanceContactedReviewersOperations operations
     :vartype access_review_instance_contacted_reviewers:
-     azure.mgmt.authorization.v2021_07_01_preview.operations.AccessReviewInstanceContactedReviewersOperations
+     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstanceContactedReviewersOperations
     :ivar access_review_default_settings: AccessReviewDefaultSettingsOperations operations
     :vartype access_review_default_settings:
-     azure.mgmt.authorization.v2021_07_01_preview.operations.AccessReviewDefaultSettingsOperations
+     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewDefaultSettingsOperations
     :ivar access_review_schedule_definitions_assigned_for_my_approval:
      AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations operations
     :vartype access_review_schedule_definitions_assigned_for_my_approval:
-     azure.mgmt.authorization.v2021_07_01_preview.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations
+     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations
     :ivar access_review_instances_assigned_for_my_approval:
      AccessReviewInstancesAssignedForMyApprovalOperations operations
     :vartype access_review_instances_assigned_for_my_approval:
-     azure.mgmt.authorization.v2021_07_01_preview.operations.AccessReviewInstancesAssignedForMyApprovalOperations
+     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstancesAssignedForMyApprovalOperations
     :ivar access_review_instance_my_decisions: AccessReviewInstanceMyDecisionsOperations operations
     :vartype access_review_instance_my_decisions:
-     azure.mgmt.authorization.v2021_07_01_preview.operations.AccessReviewInstanceMyDecisionsOperations
+     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstanceMyDecisionsOperations
     :ivar tenant_level_access_review_instance_contacted_reviewers:
      TenantLevelAccessReviewInstanceContactedReviewersOperations operations
     :vartype tenant_level_access_review_instance_contacted_reviewers:
-     azure.mgmt.authorization.v2021_07_01_preview.operations.TenantLevelAccessReviewInstanceContactedReviewersOperations
+     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.TenantLevelAccessReviewInstanceContactedReviewersOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
     :keyword api_version: Api Version. Default value is "2021-07-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(
         self,
-        credential: "TokenCredential",
+        credential: "AsyncTokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(
+            self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
+        )
         self.access_review_schedule_definitions = AccessReviewScheduleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
         )
         self.access_review_instances = AccessReviewInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
         )
         self.access_review_instance = AccessReviewInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
         )
         self.access_review_instance_decisions = AccessReviewInstanceDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
         )
         self.access_review_instance_contacted_reviewers = AccessReviewInstanceContactedReviewersOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
         )
         self.access_review_default_settings = AccessReviewDefaultSettingsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
         )
         self.access_review_schedule_definitions_assigned_for_my_approval = (
             AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations(
-                self._client, self._config, self._serialize, self._deserialize
+                self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
             )
         )
         self.access_review_instances_assigned_for_my_approval = AccessReviewInstancesAssignedForMyApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
         )
         self.access_review_instance_my_decisions = AccessReviewInstanceMyDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
         )
         self.tenant_level_access_review_instance_contacted_reviewers = (
             TenantLevelAccessReviewInstanceContactedReviewersOperations(
-                self._client, self._config, self._serialize, self._deserialize
+                self._client, self._config, self._serialize, self._deserialize, "2021-07-01-preview"
             )
         )
 
-    def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
+    def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
-        >>> response = client._send_request(request)
-        <HttpResponse: 200 OK>
+        >>> response = await client._send_request(request)
+        <AsyncHttpResponse: 200 OK>
 
         For more information on this code flow, see https://aka.ms/azsdk/dpcodegen/python/send_request
 
         :param request: The network request you want to make. Required.
         :type request: ~azure.core.rest.HttpRequest
         :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
         :return: The response of your network call. Does not do error handling on your response.
-        :rtype: ~azure.core.rest.HttpResponse
+        :rtype: ~azure.core.rest.AsyncHttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self) -> None:
-        self._client.close()
+    async def close(self) -> None:
+        await self._client.close()
 
-    def __enter__(self) -> "AuthorizationManagementClient":
-        self._client.__enter__()
+    async def __aenter__(self) -> "AuthorizationManagementClient":
+        await self._client.__aenter__()
         return self
 
-    def __exit__(self, *exc_details: Any) -> None:
-        self._client.__exit__(*exc_details)
+    async def __aexit__(self, *exc_details: Any) -> None:
+        await self._client.__aexit__(*exc_details)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/_configuration.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
+from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
-from ._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-07-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2020-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop("api_version", "2021-07-01-preview")
+        api_version: str = kwargs.pop("api_version", "2020-10-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = ARMChallengeAuthenticationPolicy(
+            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_decisions_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,34 +25,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     schedule_definition_id: str, id: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions",
     )  # pylint: disable=line-too-long
@@ -90,14 +83,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewDecision"]:
         """Get access review instance decisions.
 
@@ -116,16 +110,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -173,16 +167,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(schedule_definition_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances",
     )  # pylint: disable=line-too-long
@@ -72,17 +65,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
     )  # pylint: disable=line-too-long
@@ -104,26 +95,27 @@
 
 class AccessReviewInstancesAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_instances_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewInstance"]:
         """Get access review instances assigned for my approval.
 
@@ -134,22 +126,22 @@
          $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
          returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewInstance]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -195,16 +187,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -223,46 +216,47 @@
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewInstance
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers",
     )  # pylint: disable=line-too-long
@@ -73,26 +66,27 @@
 
 class TenantLevelAccessReviewInstanceContactedReviewersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
         :attr:`tenant_level_access_review_instance_contacted_reviewers` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> Iterable["_models.AccessReviewContactedReviewer"]:
         """Get access review instance contacted reviewers.
 
@@ -100,22 +94,22 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewContactedReviewer or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewContactedReviewer]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewContactedReviewer]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -161,16 +155,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_default_settings_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_default_settings_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +24,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default",
     )  # pylint: disable=line-too-long
@@ -68,17 +62,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_put_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default",
@@ -114,14 +106,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
@@ -135,31 +128,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         request = build_get_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -236,24 +230,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
 
         request = build_put_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
@@ -263,16 +257,17 @@
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,34 +26,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     schedule_definition_id: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances",
     )  # pylint: disable=line-too-long
@@ -75,17 +69,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
     )  # pylint: disable=line-too-long
@@ -106,17 +98,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
@@ -154,14 +144,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewInstance"]:
         """Get access review instances.
 
@@ -178,16 +169,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -234,16 +225,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -276,16 +268,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -293,16 +285,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -407,24 +400,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewInstanceProperties")
 
         request = build_create_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -436,16 +429,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_my_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_my_decisions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,34 +26,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     schedule_definition_id: str, id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions",
     )  # pylint: disable=line-too-long
@@ -75,17 +69,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, decision_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions/{decisionId}",
     )  # pylint: disable=line-too-long
@@ -106,17 +98,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_patch_request(schedule_definition_id: str, id: str, decision_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions/{decisionId}",
@@ -142,26 +132,27 @@
 
 class AccessReviewInstanceMyDecisionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_instance_my_decisions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewDecision"]:
         """Get my access review instance decisions.
 
@@ -174,22 +165,22 @@
          $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
          returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewDecision or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -236,16 +227,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -268,30 +260,30 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             decision_id=decision_id,
@@ -299,16 +291,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -342,21 +335,21 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :param properties: Access review decision properties to patch. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecisionProperties
+         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecisionProperties
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def patch(
         self,
         schedule_definition_id: str,
@@ -378,15 +371,15 @@
         :param properties: Access review decision properties to patch. Required.
         :type properties: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def patch(
         self,
         schedule_definition_id: str,
@@ -402,44 +395,44 @@
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :param properties: Access review decision properties to patch. Is either a
          AccessReviewDecisionProperties type or a IO type. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecisionProperties or IO
+         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecisionProperties or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewDecisionProperties")
 
         request = build_patch_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -451,16 +444,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +23,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_stop_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/stop",
     )  # pylint: disable=line-too-long
@@ -72,17 +65,15 @@
 
 def build_reset_decisions_request(
     schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/resetDecisions",
     )  # pylint: disable=line-too-long
@@ -105,17 +96,15 @@
 
 def build_apply_decisions_request(
     schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/applyDecisions",
     )  # pylint: disable=line-too-long
@@ -138,17 +127,15 @@
 
 def build_send_reminders_request(
     schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/sendReminders",
     )  # pylint: disable=line-too-long
@@ -169,17 +156,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_accept_recommendations_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/acceptRecommendations",
     )  # pylint: disable=line-too-long
@@ -201,26 +186,27 @@
 
 class AccessReviewInstanceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_instance` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def stop(  # pylint: disable=inconsistent-return-statements
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> None:
         """An action to stop an access review instance.
 
@@ -240,16 +226,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -257,16 +243,17 @@
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -301,16 +288,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_reset_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -318,16 +305,17 @@
             template_url=self.reset_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -362,16 +350,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_apply_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -379,16 +367,17 @@
             template_url=self.apply_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -423,16 +412,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_send_reminders_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -440,16 +429,17 @@
             template_url=self.send_reminders.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -484,32 +474,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_accept_recommendations_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.accept_recommendations.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(*, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -66,48 +59,49 @@
 
 class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review instances assigned for my approval.
 
         :param filter: The filter to apply on the operation. Other than standard filters, one custom
          filter option is supported : 'assignedToMeToReview()'. When one specified
          $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
          returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewScheduleDefinition]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -152,16 +146,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions",
     )  # pylint: disable=line-too-long
@@ -72,17 +66,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
@@ -102,17 +94,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
@@ -134,17 +124,15 @@
 
 def build_create_or_update_by_id_request(
     schedule_definition_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
@@ -167,17 +155,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_stop_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/stop",
     )  # pylint: disable=line-too-long
@@ -211,14 +197,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review schedule definitions.
 
         :param filter: The filter to apply on the operation. Other than standard filters, one custom
          filter option is supported : 'assignedToMeToReview()'. When one specified
@@ -231,16 +218,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -286,16 +273,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -326,32 +314,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -388,32 +377,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -501,24 +491,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleDefinitionProperties")
 
         request = build_create_or_update_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
@@ -529,16 +519,17 @@
             template_url=self.create_or_update_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -575,32 +566,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_contacted_reviewers_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_history_definition_instances_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,115 +25,108 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_list_request(scope: str, history_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers",
+        "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
-        "id": _SERIALIZER.url("id", id, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "scope": _SERIALIZER.url("scope", scope, "str"),
+        "historyDefinitionId": _SERIALIZER.url("history_definition_id", history_definition_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class AccessReviewInstanceContactedReviewersOperations:
+class ScopeAccessReviewHistoryDefinitionInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
-        :attr:`access_review_instance_contacted_reviewers` attribute.
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
+        :attr:`scope_access_review_history_definition_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
-        self, schedule_definition_id: str, id: str, **kwargs: Any
-    ) -> Iterable["_models.AccessReviewContactedReviewer"]:
-        """Get access review instance contacted reviewers.
-
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param id: The id of the access review instance. Required.
-        :type id: str
+        self, scope: str, history_definition_id: str, **kwargs: Any
+    ) -> Iterable["_models.AccessReviewHistoryInstance"]:
+        """Get access review history definition instances by definition Id.
+
+        :param scope: The scope of the resource. Required.
+        :type scope: str
+        :param history_definition_id: The id of the access review history definition. Required.
+        :type history_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewContactedReviewer or the result of
+        :return: An iterator like instance of either AccessReviewHistoryInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewContactedReviewer]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
-        cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessReviewHistoryDefinitionInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
-                    schedule_definition_id=schedule_definition_id,
-                    id=id,
-                    subscription_id=self._config.subscription_id,
+                    scope=scope,
+                    history_definition_id=history_definition_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -154,33 +146,34 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewContactedReviewerListResult", pipeline_response)
+            deserialized = self._deserialize("AccessReviewHistoryDefinitionInstanceListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
     list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers"
+        "url": "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-07-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -76,30 +69,31 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """Lists the operations available from this provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -143,16 +137,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/_authorization_management_client.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,132 +13,116 @@
 from azure.mgmt.core import AsyncARMPipelineClient
 
 from .. import models as _models
 from ..._serialization import Deserializer, Serializer
 from ._configuration import AuthorizationManagementClientConfiguration
 from .operations import (
     AccessReviewDefaultSettingsOperations,
-    AccessReviewInstanceContactedReviewersOperations,
     AccessReviewInstanceDecisionsOperations,
     AccessReviewInstanceMyDecisionsOperations,
     AccessReviewInstanceOperations,
     AccessReviewInstancesAssignedForMyApprovalOperations,
     AccessReviewInstancesOperations,
     AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations,
     AccessReviewScheduleDefinitionsOperations,
     Operations,
-    TenantLevelAccessReviewInstanceContactedReviewersOperations,
 )
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
     """Access reviews service provides the workflow for running access reviews on different kind of
     resources.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.authorization.v2021_07_01_preview.aio.operations.Operations
+    :vartype operations: azure.mgmt.authorization.v2018_05_01_preview.aio.operations.Operations
     :ivar access_review_schedule_definitions: AccessReviewScheduleDefinitionsOperations operations
     :vartype access_review_schedule_definitions:
-     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewScheduleDefinitionsOperations
+     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewScheduleDefinitionsOperations
     :ivar access_review_instances: AccessReviewInstancesOperations operations
     :vartype access_review_instances:
-     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstancesOperations
+     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstancesOperations
     :ivar access_review_instance: AccessReviewInstanceOperations operations
     :vartype access_review_instance:
-     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstanceOperations
+     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstanceOperations
     :ivar access_review_instance_decisions: AccessReviewInstanceDecisionsOperations operations
     :vartype access_review_instance_decisions:
-     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstanceDecisionsOperations
-    :ivar access_review_instance_contacted_reviewers:
-     AccessReviewInstanceContactedReviewersOperations operations
-    :vartype access_review_instance_contacted_reviewers:
-     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstanceContactedReviewersOperations
+     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstanceDecisionsOperations
     :ivar access_review_default_settings: AccessReviewDefaultSettingsOperations operations
     :vartype access_review_default_settings:
-     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewDefaultSettingsOperations
+     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewDefaultSettingsOperations
     :ivar access_review_schedule_definitions_assigned_for_my_approval:
      AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations operations
     :vartype access_review_schedule_definitions_assigned_for_my_approval:
-     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations
+     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations
     :ivar access_review_instances_assigned_for_my_approval:
      AccessReviewInstancesAssignedForMyApprovalOperations operations
     :vartype access_review_instances_assigned_for_my_approval:
-     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstancesAssignedForMyApprovalOperations
+     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstancesAssignedForMyApprovalOperations
     :ivar access_review_instance_my_decisions: AccessReviewInstanceMyDecisionsOperations operations
     :vartype access_review_instance_my_decisions:
-     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.AccessReviewInstanceMyDecisionsOperations
-    :ivar tenant_level_access_review_instance_contacted_reviewers:
-     TenantLevelAccessReviewInstanceContactedReviewersOperations operations
-    :vartype tenant_level_access_review_instance_contacted_reviewers:
-     azure.mgmt.authorization.v2021_07_01_preview.aio.operations.TenantLevelAccessReviewInstanceContactedReviewersOperations
+     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstanceMyDecisionsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2021-07-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2018-05-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(
         self,
         credential: "AsyncTokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
+        )
         self.access_review_schedule_definitions = AccessReviewScheduleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_instances = AccessReviewInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_instance = AccessReviewInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_instance_decisions = AccessReviewInstanceDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.access_review_instance_contacted_reviewers = AccessReviewInstanceContactedReviewersOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_default_settings = AccessReviewDefaultSettingsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_schedule_definitions_assigned_for_my_approval = (
             AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations(
-                self._client, self._config, self._serialize, self._deserialize
+                self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
             )
         )
         self.access_review_instances_assigned_for_my_approval = AccessReviewInstancesAssignedForMyApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_instance_my_decisions = AccessReviewInstanceMyDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
-        )
-        self.tenant_level_access_review_instance_contacted_reviewers = (
-            TenantLevelAccessReviewInstanceContactedReviewersOperations(
-                self._client, self._config, self._serialize, self._deserialize
-            )
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/_configuration.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-07-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2020-04-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop("api_version", "2021-07-01-preview")
+        api_version: str = kwargs.pop("api_version", "2020-04-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_decisions_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_instance_decisions_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceDecisionsOperations:
     """
     .. warning::
@@ -52,14 +47,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewDecision"]:
         """Get access review instance decisions.
 
@@ -78,16 +74,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -135,16 +131,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -30,18 +29,14 @@
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_instances_assigned_for_my_approval_operations import (
     build_get_by_id_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstancesAssignedForMyApprovalOperations:
     """
     .. warning::
@@ -56,14 +51,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewInstance"]:
         """Get access review instances assigned for my approval.
 
@@ -80,16 +76,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -135,16 +131,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -177,32 +174,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._tenant_level_access_review_instance_contacted_reviewers_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class TenantLevelAccessReviewInstanceContactedReviewersOperations:
     """
     .. warning::
@@ -52,14 +47,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewContactedReviewer"]:
         """Get access review instance contacted reviewers.
 
@@ -73,16 +69,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewContactedReviewer]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -128,16 +124,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_default_settings_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,225 +2,217 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._access_review_default_settings_operations import build_get_request, build_put_request
+from ...operations._access_review_instances_assigned_for_my_approval_operations import (
+    build_get_by_id_request,
+    build_list_request,
+)
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AccessReviewDefaultSettingsOperations:
+class AccessReviewInstancesAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_07_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`access_review_default_settings` attribute.
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`access_review_instances_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
-    @distributed_trace_async
-    async def get(self, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
-
+    @distributed_trace
+    def list(
+        self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.AccessReviewInstance"]:
+        """Get access review instances assigned for my approval.
+
+        :param schedule_definition_id: The id of the access review schedule definition. Required.
+        :type schedule_definition_id: str
+        :param filter: The filter to apply on the operation. Other than standard filters, one custom
+         filter option is supported : 'assignedToMeToReview()'. When one specified
+         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
+         returned. Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDefaultSettings
+        :return: An iterator like instance of either AccessReviewInstance or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
+        )
+        cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
-        )
-        cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        request = build_get_request(
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+                request = build_list_request(
+                    schedule_definition_id=schedule_definition_id,
+                    filter=filter,
+                    api_version=api_version,
+                    template_url=self.list.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
+            return pipeline_response
 
-        response = pipeline_response.http_response
+        return AsyncItemPaged(get_next, extract_data)
 
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("AccessReviewDefaultSettings", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"
+    list.metadata = {
+        "url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances"
     }
 
-    @overload
-    async def put(
-        self, properties: _models.AccessReviewScheduleSettings, *, content_type: str = "application/json", **kwargs: Any
-    ) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
-
-        :param properties: Access review schedule settings. Required.
-        :type properties:
-         ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewScheduleSettings
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDefaultSettings
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def put(
-        self, properties: IO, *, content_type: str = "application/json", **kwargs: Any
-    ) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
-
-        :param properties: Access review schedule settings. Required.
-        :type properties: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDefaultSettings
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
     @distributed_trace_async
-    async def put(
-        self, properties: Union[_models.AccessReviewScheduleSettings, IO], **kwargs: Any
-    ) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
-
-        :param properties: Access review schedule settings. Is either a AccessReviewScheduleSettings
-         type or a IO type. Required.
-        :type properties:
-         ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewScheduleSettings or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
+    async def get_by_id(self, schedule_definition_id: str, id: str, **kwargs: Any) -> _models.AccessReviewInstance:
+        """Get single access review instance assigned for my approval.
+
+        :param schedule_definition_id: The id of the access review schedule definition. Required.
+        :type schedule_definition_id: str
+        :param id: The id of the access review instance. Required.
+        :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDefaultSettings
+        :return: AccessReviewInstance or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(properties, (IO, bytes)):
-            _content = properties
-        else:
-            _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
+        cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
-        request = build_put_request(
-            subscription_id=self._config.subscription_id,
+        request = build_get_by_id_request(
+            schedule_definition_id=schedule_definition_id,
+            id=id,
             api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self.put.metadata["url"],
+            template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("AccessReviewDefaultSettings", pipeline_response)
+        deserialized = self._deserialize("AccessReviewInstance", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    put.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"
+    get_by_id.metadata = {
+        "url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instances_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -31,18 +31,14 @@
 from ..._vendor import _convert_request
 from ...operations._access_review_instances_operations import (
     build_create_request,
     build_get_by_id_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstancesOperations:
     """
     .. warning::
@@ -57,14 +53,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewInstance"]:
         """Get access review instances.
 
@@ -81,16 +78,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -137,16 +134,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -179,16 +177,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -196,16 +194,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -310,24 +309,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewInstanceProperties")
 
         request = build_create_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -339,16 +338,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -31,18 +31,14 @@
 from ..._vendor import _convert_request
 from ...operations._access_review_instance_my_decisions_operations import (
     build_get_by_id_request,
     build_list_request,
     build_patch_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceMyDecisionsOperations:
     """
     .. warning::
@@ -57,14 +53,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewDecision"]:
         """Get my access review instance decisions.
 
@@ -83,16 +80,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -139,16 +136,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -185,16 +183,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             decision_id=decision_id,
@@ -202,16 +200,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -325,24 +324,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewDecisionProperties")
 
         request = build_patch_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -354,16 +353,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,18 +29,14 @@
     build_accept_recommendations_request,
     build_apply_decisions_request,
     build_reset_decisions_request,
     build_send_reminders_request,
     build_stop_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceOperations:
     """
     .. warning::
@@ -56,14 +51,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def stop(  # pylint: disable=inconsistent-return-statements
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> None:
         """An action to stop an access review instance.
 
@@ -83,16 +79,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -100,16 +96,17 @@
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -144,16 +141,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_reset_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -161,16 +158,17 @@
             template_url=self.reset_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -205,16 +203,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_apply_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -222,16 +220,17 @@
             template_url=self.apply_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -266,16 +265,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_send_reminders_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -283,16 +282,17 @@
             template_url=self.send_reminders.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -327,32 +327,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_accept_recommendations_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.accept_recommendations.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,40 +25,37 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_schedule_definitions_assigned_for_my_approval_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_07_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review instances assigned for my approval.
 
@@ -68,22 +64,22 @@
          $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
          returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewScheduleDefinition]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -128,16 +124,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_schedule_definitions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,18 +33,14 @@
     build_create_or_update_by_id_request,
     build_delete_by_id_request,
     build_get_by_id_request,
     build_list_request,
     build_stop_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewScheduleDefinitionsOperations:
     """
     .. warning::
@@ -59,14 +55,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review schedule definitions.
 
@@ -81,16 +78,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -136,16 +133,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -176,32 +174,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -238,32 +237,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -351,24 +351,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleDefinitionProperties")
 
         request = build_create_or_update_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
@@ -379,16 +379,17 @@
             template_url=self.create_or_update_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -425,32 +426,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_access_review_instance_contacted_reviewers_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_decisions_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -24,67 +23,69 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._access_review_instance_contacted_reviewers_operations import build_list_request
+from ...operations._access_review_instance_decisions_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AccessReviewInstanceContactedReviewersOperations:
+class AccessReviewInstanceDecisionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_07_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`access_review_instance_contacted_reviewers` attribute.
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`access_review_instance_decisions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
-        self, schedule_definition_id: str, id: str, **kwargs: Any
-    ) -> AsyncIterable["_models.AccessReviewContactedReviewer"]:
-        """Get access review instance contacted reviewers.
+        self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.AccessReviewDecision"]:
+        """Get access review instance decisions.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
+        :param filter: The filter to apply on the operation. Other than standard filters, one custom
+         filter option is supported : 'assignedToMeToReview()'. When one specified
+         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
+         returned. Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewContactedReviewer or the result of
+        :return: An iterator like instance of either AccessReviewDecision or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewContactedReviewer]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
-        cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -93,14 +94,15 @@
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     schedule_definition_id=schedule_definition_id,
                     id=id,
                     subscription_id=self._config.subscription_id,
+                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -120,33 +122,34 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewContactedReviewerListResult", pipeline_response)
+            deserialized = self._deserialize("AccessReviewDecisionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers"
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,56 +25,53 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_07_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """Lists the operations available from this provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-07-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-07-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -119,16 +115,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_07_01_preview/models/_authorization_management_client_enums.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/models/_authorization_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_authorization_management_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -69,35 +69,37 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.permissions = PermissionsOperations(self._client, self._config, self._serialize, self._deserialize)
+        self.permissions = PermissionsOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
+        )
         self.role_definitions = RoleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
         )
         self.provider_operations_metadata = ProviderOperationsMetadataOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
         )
         self.global_administrator = GlobalAdministratorOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
         )
         self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
         )
         self.classic_administrators = ClassicAdministratorsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/_configuration.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2015-07-01". Note that overriding this
+    :keyword api_version: Api Version. Default value is "2015-06-01". Note that overriding this
      default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", "2015-07-01")
+        api_version: str = kwargs.pop("api_version", "2015-06-01")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_role_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_role_definitions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_delete_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionId": _SERIALIZER.url("role_definition_id", role_definition_id, "str"),
@@ -66,15 +62,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleDefinitionId": _SERIALIZER.url("role_definition_id", role_definition_id, "str"),
@@ -91,15 +87,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_or_update_request(scope: str, role_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -119,15 +115,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleDefinitions")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -145,15 +141,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(role_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleDefinitionId}")
     path_format_arguments = {
         "roleDefinitionId": _SERIALIZER.url("role_definition_id", role_definition_id, "str", skip_quote=True),
     }
@@ -183,14 +179,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def delete(self, scope: str, role_definition_id: str, **kwargs: Any) -> Optional[_models.RoleDefinition]:
         """Deletes a role definition.
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
@@ -208,30 +205,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[Optional[_models.RoleDefinition]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -268,30 +266,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -388,22 +387,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(role_definition, (IO, bytes)):
+        if isinstance(role_definition, (IOBase, bytes)):
             _content = role_definition
         else:
             _json = self._serialize.body(role_definition, "RoleDefinition")
 
         request = build_create_or_update_request(
             scope=scope,
             role_definition_id=role_definition_id,
@@ -414,16 +413,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -452,15 +452,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -505,16 +505,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -547,29 +548,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_classic_administrators_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/operations/_classic_administrators_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-06-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/classicAdministrators"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -69,42 +64,43 @@
 
 class ClassicAdministratorsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2015_07_01.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2015_06_01.AuthorizationManagementClient`'s
         :attr:`classic_administrators` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.ClassicAdministrator"]:
         """Gets service administrator, account administrator, and co-administrators for the subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ClassicAdministrator or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.ClassicAdministrator]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_06_01.models.ClassicAdministrator]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-06-01"))
         cls: ClsType[_models.ClassicAdministratorListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -148,16 +144,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_global_administrator_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_global_administrator_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,30 +23,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_elevate_access_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/elevateAccess")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -72,14 +67,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def elevate_access(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
         """Elevates access for a Global Administrator.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
@@ -93,28 +89,29 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_elevate_access_request(
             api_version=api_version,
             template_url=self.elevate_access.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_role_assignments_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -51,15 +47,15 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -89,15 +85,15 @@
 
 def build_list_for_resource_group_request(
     resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -121,15 +117,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
@@ -146,15 +142,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -174,15 +170,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
@@ -199,15 +195,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(role_assignment_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleAssignmentId}")
     path_format_arguments = {
         "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
     }
@@ -223,15 +219,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_by_id_request(role_assignment_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleAssignmentId}")
     path_format_arguments = {
         "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
@@ -250,15 +246,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(role_assignment_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleAssignmentId}")
     path_format_arguments = {
         "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
     }
@@ -274,15 +270,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/roleAssignments"
     )
     path_format_arguments = {
@@ -302,15 +298,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -342,14 +338,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -380,15 +377,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -438,16 +435,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -478,15 +476,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -532,16 +530,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -574,30 +573,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -719,22 +719,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -745,16 +745,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -789,30 +790,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -849,29 +851,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -970,22 +973,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
@@ -995,16 +998,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1041,29 +1045,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1091,15 +1096,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1144,16 +1149,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1181,15 +1187,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -1234,16 +1240,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_provider_operations_metadata_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_provider_operations_metadata_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(resource_provider_namespace: str, *, expand: str = "resourceTypes", **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/providers/Microsoft.Authorization/providerOperations/{resourceProviderNamespace}"
     )
     path_format_arguments = {
@@ -69,15 +64,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(*, expand: str = "resourceTypes", **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/providerOperations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -104,14 +99,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(
         self, resource_provider_namespace: str, expand: str = "resourceTypes", **kwargs: Any
     ) -> _models.ProviderOperationsMetadata:
         """Gets provider operations metadata for the specified resource provider.
 
@@ -131,30 +127,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.ProviderOperationsMetadata] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_provider_namespace=resource_provider_namespace,
             expand=expand,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -181,15 +178,15 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.ProviderOperationsMetadata]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.ProviderOperationsMetadataListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -233,16 +230,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/operations/_permissions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/operations/_permissions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,30 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_for_resource_group_request(resource_group_name: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Authorization/permissions",
     )  # pylint: disable=line-too-long
@@ -79,30 +74,32 @@
     resource_name: str,
     subscription_id: str,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/permissions",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
         "resourceGroupName": _SERIALIZER.url(
             "resource_group_name", resource_group_name, "str", max_length=90, min_length=1
         ),
-        "resourceProviderNamespace": _SERIALIZER.url("resource_provider_namespace", resource_provider_namespace, "str"),
+        "resourceProviderNamespace": _SERIALIZER.url(
+            "resource_provider_namespace", resource_provider_namespace, "str", skip_quote=True
+        ),
         "parentResourcePath": _SERIALIZER.url("parent_resource_path", parent_resource_path, "str", skip_quote=True),
         "resourceType": _SERIALIZER.url("resource_type", resource_type, "str", skip_quote=True),
-        "resourceName": _SERIALIZER.url("resource_name", resource_name, "str"),
+        "resourceName": _SERIALIZER.url("resource_name", resource_name, "str", pattern=r".+"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str", min_length=1),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -115,43 +112,47 @@
 
 class PermissionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2015_07_01.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_05_01_preview.AuthorizationManagementClient`'s
         :attr:`permissions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource_group(self, resource_group_name: str, **kwargs: Any) -> Iterable["_models.Permission"]:
         """Gets all permissions the caller has for a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Permission or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.Permission]
+        :rtype:
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_05_01_preview.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-05-01-preview")
+        )
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -196,16 +197,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -239,21 +241,24 @@
         :type parent_resource_path: str
         :param resource_type: The resource type of the resource. Required.
         :type resource_type: str
         :param resource_name: The name of the resource to get the permissions for. Required.
         :type resource_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Permission or the result of cls(response)
-        :rtype: ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2015_07_01.models.Permission]
+        :rtype:
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_05_01_preview.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-05-01-preview")
+        )
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -302,16 +307,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/_authorization_management_client.py`

 * *Files 6% similar despite different names*

```diff
@@ -69,35 +69,37 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.permissions = PermissionsOperations(self._client, self._config, self._serialize, self._deserialize)
+        self.permissions = PermissionsOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
+        )
         self.role_definitions = RoleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
         )
         self.provider_operations_metadata = ProviderOperationsMetadataOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
         )
         self.global_administrator = GlobalAdministratorOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
         )
         self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
         )
         self.classic_administrators = ClassicAdministratorsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2015-07-01"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2015-07-01". Note that overriding this
-     default value may result in unsupported behavior.
+    :keyword api_version: Api Version. Default value is "2021-12-01-preview". Note that overriding
+     this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", "2015-07-01")
+        api_version: str = kwargs.pop("api_version", "2021-12-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_role_definitions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,81 +33,79 @@
     build_create_or_update_request,
     build_delete_request,
     build_get_by_id_request,
     build_get_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleDefinitionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2015_07_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_04_01.aio.AuthorizationManagementClient`'s
         :attr:`role_definitions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def delete(self, scope: str, role_definition_id: str, **kwargs: Any) -> Optional[_models.RoleDefinition]:
         """Deletes a role definition.
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
         :param role_definition_id: The ID of the role definition to delete. Required.
         :type role_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or None or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition or None
+        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[Optional[_models.RoleDefinition]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -130,44 +128,45 @@
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
         :param role_definition_id: The ID of the role definition. Required.
         :type role_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
+        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_definition_id=role_definition_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -195,21 +194,21 @@
         """Creates or updates a role definition.
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
         :param role_definition_id: The ID of the role definition. Required.
         :type role_definition_id: str
         :param role_definition: The values for the role definition. Required.
-        :type role_definition: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
+        :type role_definition: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
+        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_or_update(
         self,
         scope: str,
@@ -228,15 +227,15 @@
         :param role_definition: The values for the role definition. Required.
         :type role_definition: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
+        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_or_update(
         self, scope: str, role_definition_id: str, role_definition: Union[_models.RoleDefinition, IO], **kwargs: Any
     ) -> _models.RoleDefinition:
@@ -244,42 +243,42 @@
 
         :param scope: The scope of the role definition. Required.
         :type scope: str
         :param role_definition_id: The ID of the role definition. Required.
         :type role_definition_id: str
         :param role_definition: The values for the role definition. Is either a RoleDefinition type or
          a IO type. Required.
-        :type role_definition: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition or IO
+        :type role_definition: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
+        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(role_definition, (IO, bytes)):
+        if isinstance(role_definition, (IOBase, bytes)):
             _content = role_definition
         else:
             _json = self._serialize.body(role_definition, "RoleDefinition")
 
         request = build_create_or_update_request(
             scope=scope,
             role_definition_id=role_definition_id,
@@ -290,16 +289,17 @@
             template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -322,21 +322,21 @@
         :type scope: str
         :param filter: The filter to apply on the operation. Use atScopeAndBelow filter to search below
          the given scope as well. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleDefinition or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -381,16 +381,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -398,54 +399,55 @@
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}
 
     @distributed_trace_async
-    async def get_by_id(self, role_definition_id: str, **kwargs: Any) -> _models.RoleDefinition:
+    async def get_by_id(self, role_id: str, **kwargs: Any) -> _models.RoleDefinition:
         """Gets a role definition by ID.
 
-        :param role_definition_id: The fully qualified role definition ID. Use the format,
+        :param role_id: The fully qualified role definition ID. Use the format,
          /subscriptions/{guid}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId} for
          subscription level role definitions, or
          /providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId} for tenant level role
          definitions. Required.
-        :type role_definition_id: str
+        :type role_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2015_07_01.models.RoleDefinition
+        :rtype: ~azure.mgmt.authorization.v2022_04_01.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
-            role_definition_id=role_definition_id,
+            role_id=role_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -454,8 +456,8 @@
         deserialized = self._deserialize("RoleDefinition", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_by_id.metadata = {"url": "/{roleDefinitionId}"}
+    get_by_id.metadata = {"url": "/{roleId}"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_classic_administrators_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_06_01/aio/operations/_classic_administrators_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,56 +25,53 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._classic_administrators_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ClassicAdministratorsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2015_07_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2015_06_01.aio.AuthorizationManagementClient`'s
         :attr:`classic_administrators` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.ClassicAdministrator"]:
         """Gets service administrator, account administrator, and co-administrators for the subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either ClassicAdministrator or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.ClassicAdministrator]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_06_01.models.ClassicAdministrator]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-06-01"))
         cls: ClsType[_models.ClassicAdministratorListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -119,16 +115,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_global_administrator_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_global_administrator_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,18 +23,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._global_administrator_operations import build_elevate_access_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class GlobalAdministratorOperations:
     """
     .. warning::
@@ -50,14 +45,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def elevate_access(self, **kwargs: Any) -> None:  # pylint: disable=inconsistent-return-statements
         """Elevates access for a Global Administrator.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: None or the result of cls(response)
@@ -71,28 +67,29 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_elevate_access_request(
             api_version=api_version,
             template_url=self.elevate_access.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_role_assignments_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -38,18 +38,14 @@
     build_get_request,
     build_list_for_resource_group_request,
     build_list_for_resource_request,
     build_list_for_scope_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentsOperations:
     """
     .. warning::
@@ -64,14 +60,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -102,15 +99,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -160,16 +157,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -200,15 +198,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -254,16 +252,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -296,30 +295,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -441,22 +441,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -467,16 +467,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -511,30 +512,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -571,29 +573,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -692,22 +695,22 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
@@ -717,16 +720,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -763,29 +767,30 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -813,15 +818,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -866,16 +871,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -903,15 +909,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -956,16 +962,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_provider_operations_metadata_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_provider_operations_metadata_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -27,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._provider_operations_metadata_operations import build_get_request, build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ProviderOperationsMetadataOperations:
     """
     .. warning::
@@ -53,14 +48,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(
         self, resource_provider_namespace: str, expand: str = "resourceTypes", **kwargs: Any
     ) -> _models.ProviderOperationsMetadata:
         """Gets provider operations metadata for the specified resource provider.
 
@@ -80,30 +76,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.ProviderOperationsMetadata] = kwargs.pop("cls", None)
 
         request = build_get_request(
             resource_provider_namespace=resource_provider_namespace,
             expand=expand,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -130,15 +127,15 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.ProviderOperationsMetadata]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2015-07-01"))
         cls: ClsType[_models.ProviderOperationsMetadataListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -182,16 +179,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/aio/operations/_permissions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01/aio/operations/_permissions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,58 +25,55 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._permissions_operations import build_list_for_resource_group_request, build_list_for_resource_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class PermissionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2015_07_01.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_04_01.aio.AuthorizationManagementClient`'s
         :attr:`permissions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.Permission"]:
         """Gets all permissions the caller has for a resource group.
 
         :param resource_group_name: The name of the resource group. The name is case insensitive.
          Required.
         :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Permission or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.Permission]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -122,16 +118,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -166,21 +163,21 @@
         :param resource_type: The resource type of the resource. Required.
         :type resource_type: str
         :param resource_name: The name of the resource to get the permissions for. Required.
         :type resource_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Permission or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2015_07_01.models.Permission]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_04_01.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2015-07-01"] = kwargs.pop("api_version", _params.pop("api-version", "2015-07-01"))
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2022-04-01"))
         cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -229,16 +226,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2015_07_01/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_authorization_management_client.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,44 +25,44 @@
 class AuthorizationManagementClient:  # pylint: disable=client-accepts-api-version-keyword
     """Role based access control provides you a way to apply granular level policy administration down
     to individual resources or resource groups. These operations enable you to manage role
     assignments. A role assignment grants access to Azure Active Directory users.
 
     :ivar role_assignments: RoleAssignmentsOperations operations
     :vartype role_assignments:
-     azure.mgmt.authorization.v2018_09_01_preview.operations.RoleAssignmentsOperations
+     azure.mgmt.authorization.v2020_04_01_preview.operations.RoleAssignmentsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2018-09-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2020-04-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(
         self,
         credential: "TokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-04-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_configuration.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2018-09-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2019-08-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop("api_version", "2018-09-01-preview")
+        api_version: str = kwargs.pop("api_version", "2019-08-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/_role_assignments_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -51,17 +47,15 @@
     *,
     filter: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-09-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-09-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -93,17 +87,15 @@
 
 def build_list_for_resource_group_request(
     resource_group_name: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-09-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-09-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -127,17 +119,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-09-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-09-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
@@ -154,17 +144,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-09-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-09-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -184,17 +172,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-09-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-09-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
@@ -211,17 +197,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(role_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-09-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-09-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
     }
@@ -237,17 +221,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_by_id_request(role_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-09-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-09-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
@@ -266,17 +248,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(role_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-09-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-09-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
     }
@@ -292,17 +272,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_request(subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-09-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-09-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/roleAssignments"
     )
     path_format_arguments = {
@@ -322,17 +300,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-09-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-09-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -364,14 +340,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -402,16 +379,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -462,16 +439,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -502,16 +480,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -558,16 +536,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -600,32 +579,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -748,24 +728,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -776,16 +756,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -820,32 +801,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -878,31 +860,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -990,24 +973,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_id=role_id,
             api_version=api_version,
@@ -1017,16 +1000,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1059,31 +1043,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1111,16 +1096,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -1166,16 +1151,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1203,16 +1189,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-09-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -1258,16 +1244,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/aio/_authorization_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -47,22 +47,22 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-09-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/_configuration.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2018-09-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2021-03-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop("api_version", "2018-09-01-preview")
+        api_version: str = kwargs.pop("api_version", "2021-03-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_role_assignments_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -38,40 +38,37 @@
     build_get_request,
     build_list_for_resource_group_request,
     build_list_for_resource_request,
     build_list_for_scope_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_09_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2018_01_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`role_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -96,22 +93,22 @@
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -162,16 +159,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -196,22 +194,22 @@
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -258,16 +256,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -286,46 +285,47 @@
 
         :param scope: The scope of the role assignment to delete. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to delete. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or None or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment or None
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -362,21 +362,21 @@
          for a resource. Required.
         :type scope: str
         :param role_assignment_name: A GUID for the role assignment to create. The name must be unique
          and different for each role assignment. Required.
         :type role_assignment_name: str
         :param parameters: Parameters for the role assignment. Required.
         :type parameters:
-         ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignmentCreateParameters
+         ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignmentCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create(
         self,
         scope: str,
@@ -401,15 +401,15 @@
         :param parameters: Parameters for the role assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create(
         self,
         scope: str,
@@ -428,44 +428,44 @@
         :type scope: str
         :param role_assignment_name: A GUID for the role assignment to create. The name must be unique
          and different for each role assignment. Required.
         :type role_assignment_name: str
         :param parameters: Parameters for the role assignment. Is either a
          RoleAssignmentCreateParameters type or a IO type. Required.
         :type parameters:
-         ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignmentCreateParameters or IO
+         ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignmentCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -476,16 +476,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -506,46 +507,47 @@
 
         :param scope: The scope of the role assignment. Required.
         :type scope: str
         :param role_assignment_name: The name of the role assignment to get. Required.
         :type role_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -564,45 +566,46 @@
     async def delete_by_id(self, role_id: str, **kwargs: Any) -> Optional[_models.RoleAssignment]:
         """Deletes a role assignment.
 
         :param role_id: The ID of the role assignment to delete. Required.
         :type role_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or None or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment or None
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -630,21 +633,21 @@
     ) -> _models.RoleAssignment:
         """Creates a role assignment by ID.
 
         :param role_id: The ID of the role assignment to create. Required.
         :type role_id: str
         :param parameters: Parameters for the role assignment. Required.
         :type parameters:
-         ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignmentCreateParameters
+         ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignmentCreateParameters
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create_by_id(
         self, role_id: str, parameters: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.RoleAssignment:
@@ -655,59 +658,59 @@
         :param parameters: Parameters for the role assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create_by_id(
         self, role_id: str, parameters: Union[_models.RoleAssignmentCreateParameters, IO], **kwargs: Any
     ) -> _models.RoleAssignment:
         """Creates a role assignment by ID.
 
         :param role_id: The ID of the role assignment to create. Required.
         :type role_id: str
         :param parameters: Parameters for the role assignment. Is either a
          RoleAssignmentCreateParameters type or a IO type. Required.
         :type parameters:
-         ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignmentCreateParameters or IO
+         ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignmentCreateParameters or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_id=role_id,
             api_version=api_version,
@@ -717,16 +720,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -745,45 +749,46 @@
     async def get_by_id(self, role_id: str, **kwargs: Any) -> _models.RoleAssignment:
         """Gets a role assignment by ID.
 
         :param role_id: The ID of the role assignment to get. Required.
         :type role_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment
+        :rtype: ~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_id=role_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -805,22 +810,22 @@
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -866,16 +871,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -897,22 +903,22 @@
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignments at or above the scope. Use $filter=principalId eq {id} to return all role
          assignments at, above or below the scope for the specified principal. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignment or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_09_01_preview.models.RoleAssignment]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_01_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-09-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-09-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -958,16 +964,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_09_01_preview/models/_authorization_management_client_enums.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/models/_authorization_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_authorization_management_client.py`

 * *Files 7% similar despite different names*

```diff
@@ -81,46 +81,48 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
+        )
         self.access_review_schedule_definitions = AccessReviewScheduleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_instances = AccessReviewInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_instance = AccessReviewInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_instance_decisions = AccessReviewInstanceDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_default_settings = AccessReviewDefaultSettingsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_schedule_definitions_assigned_for_my_approval = (
             AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations(
-                self._client, self._config, self._serialize, self._deserialize
+                self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
             )
         )
         self.access_review_instances_assigned_for_my_approval = AccessReviewInstancesAssignedForMyApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_instance_my_decisions = AccessReviewInstanceMyDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_configuration.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-03-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2018-01-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop("api_version", "2021-03-01-preview")
+        api_version: str = kwargs.pop("api_version", "2018-01-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_decisions_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,34 +25,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     schedule_definition_id: str, id: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions",
     )  # pylint: disable=line-too-long
@@ -90,14 +83,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewDecision"]:
         """Get access review instance decisions.
 
@@ -116,16 +110,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -173,16 +167,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(schedule_definition_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances",
     )  # pylint: disable=line-too-long
@@ -72,17 +65,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
     )  # pylint: disable=line-too-long
@@ -104,26 +95,27 @@
 
 class AccessReviewInstancesAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_instances_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewInstance"]:
         """Get access review instances assigned for my approval.
 
@@ -134,22 +126,22 @@
          $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
          returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -195,16 +187,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -223,46 +216,47 @@
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance
+        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_default_settings_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_default_settings_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +24,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default",
     )  # pylint: disable=line-too-long
@@ -68,17 +62,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_put_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default",
@@ -114,14 +106,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
@@ -135,31 +128,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         request = build_get_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -236,24 +230,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
 
         request = build_put_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
@@ -263,16 +257,17 @@
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instances_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,34 +25,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     schedule_definition_id: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances",
     )  # pylint: disable=line-too-long
@@ -75,17 +68,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
     )  # pylint: disable=line-too-long
@@ -120,14 +111,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewInstance"]:
         """Get access review instances.
 
@@ -144,16 +136,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -200,16 +192,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -242,16 +235,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -259,16 +252,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_my_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_instance_my_decisions_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,34 +26,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(
     schedule_definition_id: str, id: str, *, filter: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions",
     )  # pylint: disable=line-too-long
@@ -75,17 +69,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, decision_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions/{decisionId}",
     )  # pylint: disable=line-too-long
@@ -106,17 +98,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_patch_request(schedule_definition_id: str, id: str, decision_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions/{decisionId}",
@@ -142,26 +132,27 @@
 
 class AccessReviewInstanceMyDecisionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_instance_my_decisions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.AccessReviewDecision"]:
         """Get my access review instance decisions.
 
@@ -174,22 +165,22 @@
          $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
          returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewDecision or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -236,16 +227,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -268,30 +260,30 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             decision_id=decision_id,
@@ -299,16 +291,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -342,21 +335,21 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :param properties: Access review decision properties to patch. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecisionProperties
+         ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecisionProperties
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def patch(
         self,
         schedule_definition_id: str,
@@ -378,15 +371,15 @@
         :param properties: Access review decision properties to patch. Required.
         :type properties: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def patch(
         self,
         schedule_definition_id: str,
@@ -402,44 +395,44 @@
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :param properties: Access review decision properties to patch. Is either a
          AccessReviewDecisionProperties type or a IO type. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecisionProperties or IO
+         ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecisionProperties or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewDecisionProperties")
 
         request = build_patch_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -451,16 +444,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +23,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_stop_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/stop",
     )  # pylint: disable=line-too-long
@@ -72,17 +65,15 @@
 
 def build_reset_decisions_request(
     schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/resetDecisions",
     )  # pylint: disable=line-too-long
@@ -105,17 +96,15 @@
 
 def build_apply_decisions_request(
     schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/applyDecisions",
     )  # pylint: disable=line-too-long
@@ -138,17 +127,15 @@
 
 def build_send_reminders_request(
     schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/sendReminders",
     )  # pylint: disable=line-too-long
@@ -169,17 +156,15 @@
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_accept_recommendations_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/acceptRecommendations",
     )  # pylint: disable=line-too-long
@@ -201,26 +186,27 @@
 
 class AccessReviewInstanceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_instance` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def stop(  # pylint: disable=inconsistent-return-statements
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> None:
         """An action to stop an access review instance.
 
@@ -240,16 +226,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -257,16 +243,17 @@
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -301,16 +288,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_reset_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -318,16 +305,17 @@
             template_url=self.reset_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -362,16 +350,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_apply_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -379,16 +367,17 @@
             template_url=self.apply_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -423,16 +412,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_send_reminders_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -440,16 +429,17 @@
             template_url=self.send_reminders.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -484,32 +474,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_accept_recommendations_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.accept_recommendations.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(*, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-03-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -78,14 +71,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review instances assigned for my approval.
 
         :param filter: The filter to apply on the operation. Other than standard filters, one custom
          filter option is supported : 'assignedToMeToReview()'. When one specified
@@ -98,16 +92,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -152,16 +146,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_access_review_schedule_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_schedule_definitions_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions",
     )  # pylint: disable=line-too-long
@@ -72,27 +66,25 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -102,27 +94,25 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -134,28 +124,26 @@
 
 def build_create_or_update_by_id_request(
     schedule_definition_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -167,27 +155,25 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_stop_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/stop",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
+        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
@@ -199,48 +185,49 @@
 
 class AccessReviewScheduleDefinitionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_schedule_definitions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review schedule definitions.
 
         :param filter: The filter to apply on the operation. Other than standard filters, one custom
          filter option is supported : 'assignedToMeToReview()'. When one specified
          $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
          returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -286,16 +273,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -312,46 +300,47 @@
     def get_by_id(self, schedule_definition_id: str, **kwargs: Any) -> _models.AccessReviewScheduleDefinition:
         """Get single access review definition.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewScheduleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -388,32 +377,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -437,21 +427,21 @@
     ) -> _models.AccessReviewScheduleDefinition:
         """Create or Update access review schedule definition.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param properties: Access review schedule definition properties. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinitionProperties
+         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinitionProperties
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewScheduleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create_or_update_by_id(
         self, schedule_definition_id: str, properties: IO, *, content_type: str = "application/json", **kwargs: Any
     ) -> _models.AccessReviewScheduleDefinition:
@@ -462,15 +452,15 @@
         :param properties: Access review schedule definition properties. Required.
         :type properties: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewScheduleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create_or_update_by_id(
         self,
         schedule_definition_id: str,
@@ -480,45 +470,45 @@
         """Create or Update access review schedule definition.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param properties: Access review schedule definition properties. Is either a
          AccessReviewScheduleDefinitionProperties type or a IO type. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinitionProperties
+         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinitionProperties
          or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewScheduleDefinition or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleDefinitionProperties")
 
         request = build_create_or_update_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
@@ -529,16 +519,17 @@
             template_url=self.create_or_update_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -575,32 +566,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,95 +25,99 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(**kwargs: Any) -> HttpRequest:
+def build_list_request(*, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-03-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-07-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
-    _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/operations")
+    _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class Operations:
+class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.AuthorizationManagementClient`'s
-        :attr:`operations` attribute.
+        :class:`~azure.mgmt.authorization.v2021_07_01_preview.AuthorizationManagementClient`'s
+        :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
-        """Lists the operations available from this provider.
+    def list(self, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.AccessReviewScheduleDefinition"]:
+        """Get access review instances assigned for my approval.
 
+        :param filter: The filter to apply on the operation. Other than standard filters, one custom
+         filter option is supported : 'assignedToMeToReview()'. When one specified
+         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
+         returned. Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either Operation or the result of cls(response)
+        :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
+         cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.Operation]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_07_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-07-01-preview")
         )
-        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
+                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -134,31 +137,32 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("OperationListResult", pipeline_response)
+            deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.Authorization/operations"}
+    list.metadata = {"url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_authorization_management_client.py`

 * *Files 9% similar despite different names*

```diff
@@ -3,21 +3,21 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
-from typing import Any, Awaitable, TYPE_CHECKING
+from typing import Any, TYPE_CHECKING
 
-from azure.core.rest import AsyncHttpResponse, HttpRequest
-from azure.mgmt.core import AsyncARMPipelineClient
+from azure.core.rest import HttpRequest, HttpResponse
+from azure.mgmt.core import ARMPipelineClient
 
-from .. import models as _models
-from ..._serialization import Deserializer, Serializer
+from . import models as _models
+from .._serialization import Deserializer, Serializer
 from ._configuration import AuthorizationManagementClientConfiguration
 from .operations import (
     AccessReviewDefaultSettingsOperations,
     AccessReviewInstanceDecisionsOperations,
     AccessReviewInstanceMyDecisionsOperations,
     AccessReviewInstanceOperations,
     AccessReviewInstancesAssignedForMyApprovalOperations,
@@ -25,128 +25,130 @@
     AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations,
     AccessReviewScheduleDefinitionsOperations,
     Operations,
 )
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
     """Access reviews service provides the workflow for running access reviews on different kind of
     resources.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.authorization.v2021_03_01_preview.aio.operations.Operations
+    :vartype operations: azure.mgmt.authorization.v2018_05_01_preview.operations.Operations
     :ivar access_review_schedule_definitions: AccessReviewScheduleDefinitionsOperations operations
     :vartype access_review_schedule_definitions:
-     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewScheduleDefinitionsOperations
+     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewScheduleDefinitionsOperations
     :ivar access_review_instances: AccessReviewInstancesOperations operations
     :vartype access_review_instances:
-     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstancesOperations
+     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstancesOperations
     :ivar access_review_instance: AccessReviewInstanceOperations operations
     :vartype access_review_instance:
-     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstanceOperations
+     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstanceOperations
     :ivar access_review_instance_decisions: AccessReviewInstanceDecisionsOperations operations
     :vartype access_review_instance_decisions:
-     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstanceDecisionsOperations
+     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstanceDecisionsOperations
     :ivar access_review_default_settings: AccessReviewDefaultSettingsOperations operations
     :vartype access_review_default_settings:
-     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewDefaultSettingsOperations
+     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewDefaultSettingsOperations
     :ivar access_review_schedule_definitions_assigned_for_my_approval:
      AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations operations
     :vartype access_review_schedule_definitions_assigned_for_my_approval:
-     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations
+     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations
     :ivar access_review_instances_assigned_for_my_approval:
      AccessReviewInstancesAssignedForMyApprovalOperations operations
     :vartype access_review_instances_assigned_for_my_approval:
-     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstancesAssignedForMyApprovalOperations
+     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstancesAssignedForMyApprovalOperations
     :ivar access_review_instance_my_decisions: AccessReviewInstanceMyDecisionsOperations operations
     :vartype access_review_instance_my_decisions:
-     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstanceMyDecisionsOperations
+     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstanceMyDecisionsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2021-03-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2018-05-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(
         self,
-        credential: "AsyncTokenCredential",
+        credential: "TokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
+        )
         self.access_review_schedule_definitions = AccessReviewScheduleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_instances = AccessReviewInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_instance = AccessReviewInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_instance_decisions = AccessReviewInstanceDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_default_settings = AccessReviewDefaultSettingsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_schedule_definitions_assigned_for_my_approval = (
             AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations(
-                self._client, self._config, self._serialize, self._deserialize
+                self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
             )
         )
         self.access_review_instances_assigned_for_my_approval = AccessReviewInstancesAssignedForMyApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
         self.access_review_instance_my_decisions = AccessReviewInstanceMyDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-05-01-preview"
         )
 
-    def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
+    def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
-        >>> response = await client._send_request(request)
-        <AsyncHttpResponse: 200 OK>
+        >>> response = client._send_request(request)
+        <HttpResponse: 200 OK>
 
         For more information on this code flow, see https://aka.ms/azsdk/dpcodegen/python/send_request
 
         :param request: The network request you want to make. Required.
         :type request: ~azure.core.rest.HttpRequest
         :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
         :return: The response of your network call. Does not do error handling on your response.
-        :rtype: ~azure.core.rest.AsyncHttpResponse
+        :rtype: ~azure.core.rest.HttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    async def close(self) -> None:
-        await self._client.close()
+    def close(self) -> None:
+        self._client.close()
 
-    async def __aenter__(self) -> "AuthorizationManagementClient":
-        await self._client.__aenter__()
+    def __enter__(self) -> "AuthorizationManagementClient":
+        self._client.__enter__()
         return self
 
-    async def __aexit__(self, *exc_details: Any) -> None:
-        await self._client.__aexit__(*exc_details)
+    def __exit__(self, *exc_details: Any) -> None:
+        self._client.__exit__(*exc_details)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/_configuration.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2021-03-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2022-05-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop("api_version", "2021-03-01-preview")
+        api_version: str = kwargs.pop("api_version", "2022-05-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_decisions_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,68 +25,60 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_instance_decisions_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceDecisionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`access_review_instance_decisions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
-        self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
+        self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewDecision"]:
         """Get access review instance decisions.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
-        :param filter: The filter to apply on the operation. Other than standard filters, one custom
-         filter option is supported : 'assignedToMeToReview()'. When one specified
-         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
-         returned. Default value is None.
-        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewDecision or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -98,15 +89,14 @@
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     schedule_definition_id=schedule_definition_id,
                     id=id,
                     subscription_id=self._config.subscription_id,
-                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -135,16 +125,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -30,66 +29,56 @@
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_instances_assigned_for_my_approval_operations import (
     build_get_by_id_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstancesAssignedForMyApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`access_review_instances_assigned_for_my_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(
-        self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.AccessReviewInstance"]:
+    def list(self, schedule_definition_id: str, **kwargs: Any) -> AsyncIterable["_models.AccessReviewInstance"]:
         """Get access review instances assigned for my approval.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
-        :param filter: The filter to apply on the operation. Other than standard filters, one custom
-         filter option is supported : 'assignedToMeToReview()'. When one specified
-         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
-         returned. Default value is None.
-        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -98,15 +87,14 @@
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     schedule_definition_id=schedule_definition_id,
-                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -135,16 +123,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -163,46 +152,47 @@
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance
+        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_default_settings_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,225 +2,208 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
+from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._access_review_default_settings_operations import build_get_request, build_put_request
+from ...operations._access_review_instances_operations import build_get_by_id_request, build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AccessReviewDefaultSettingsOperations:
+class AccessReviewInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`access_review_default_settings` attribute.
+        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`access_review_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
-    @distributed_trace_async
-    async def get(self, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
+    @distributed_trace
+    def list(self, schedule_definition_id: str, **kwargs: Any) -> AsyncIterable["_models.AccessReviewInstance"]:
+        """Get access review instances.
 
+        :param schedule_definition_id: The id of the access review schedule definition. Required.
+        :type schedule_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDefaultSettings
+        :return: An iterator like instance of either AccessReviewInstance or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
+        )
+        cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
-        )
-        cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
-
-        request = build_get_request(
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                request = build_list_request(
+                    schedule_definition_id=schedule_definition_id,
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("AccessReviewDefaultSettings", pipeline_response)
+            return pipeline_response
 
-        if cls:
-            return cls(pipeline_response, deserialized, {})
+        return AsyncItemPaged(get_next, extract_data)
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances"
     }
 
-    @overload
-    async def put(
-        self, properties: _models.AccessReviewScheduleSettings, *, content_type: str = "application/json", **kwargs: Any
-    ) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
-
-        :param properties: Access review schedule settings. Required.
-        :type properties:
-         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleSettings
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDefaultSettings
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    async def put(
-        self, properties: IO, *, content_type: str = "application/json", **kwargs: Any
-    ) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
-
-        :param properties: Access review schedule settings. Required.
-        :type properties: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDefaultSettings
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
     @distributed_trace_async
-    async def put(
-        self, properties: Union[_models.AccessReviewScheduleSettings, IO], **kwargs: Any
-    ) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
-
-        :param properties: Access review schedule settings. Is either a AccessReviewScheduleSettings
-         type or a IO type. Required.
-        :type properties:
-         ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleSettings or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
+    async def get_by_id(self, schedule_definition_id: str, id: str, **kwargs: Any) -> _models.AccessReviewInstance:
+        """Get access review instances.
+
+        :param schedule_definition_id: The id of the access review schedule definition. Required.
+        :type schedule_definition_id: str
+        :param id: The id of the access review instance. Required.
+        :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDefaultSettings
+        :return: AccessReviewInstance or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(properties, (IO, bytes)):
-            _content = properties
-        else:
-            _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
+        cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
-        request = build_put_request(
+        request = build_get_by_id_request(
+            schedule_definition_id=schedule_definition_id,
+            id=id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self.put.metadata["url"],
+            template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("AccessReviewDefaultSettings", pipeline_response)
+        deserialized = self._deserialize("AccessReviewInstance", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    put.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"
+    get_by_id.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -25,85 +24,80 @@
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._access_review_instances_operations import build_get_by_id_request, build_list_request
+from ...operations._role_assignment_approval_operations import build_get_by_id_request, build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AccessReviewInstancesOperations:
+class RoleAssignmentApprovalOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`access_review_instances` attribute.
+        :class:`~azure.mgmt.authorization.v2021_01_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`role_assignment_approval` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(
-        self, schedule_definition_id: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.AccessReviewInstance"]:
-        """Get access review instances.
-
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param filter: The filter to apply on the operation. Other than standard filters, one custom
-         filter option is supported : 'assignedToMeToReview()'. When one specified
-         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
-         returned. Default value is None.
+    def list(self, filter: Optional[str] = None, **kwargs: Any) -> AsyncIterable["_models.RoleAssignmentApproval"]:
+        """Get role assignment approvals.
+
+        :param filter: The filter to apply on the operation. Valid values for $filter are:
+         'asApprover()', 'asCreatedBy()' and 'asTarget()'. If $filter is not provided, no filtering is
+         performed. If $filter=asApprover() is provided, the returned list only includes all role
+         assignment approvals that the calling user is assigned as an approver for. If
+         $filter=asCreatedBy() is provided, the returned list only includes all role assignment
+         approvals that the calling user created requests for. If $filter=asTarget() is provided, the
+         returned list only includes all role assignment approvals that the calling user has requests
+         targeted for. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewInstance or the result of
+        :return: An iterator like instance of either RoleAssignmentApproval or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApproval]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
-        cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoleAssignmentApprovalListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
-                    schedule_definition_id=schedule_definition_id,
-                    subscription_id=self._config.subscription_id,
                     filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
@@ -124,96 +118,90 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
+            deserialized = self._deserialize("RoleAssignmentApprovalListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances"
-    }
+    list.metadata = {"url": "/providers/Microsoft.Authorization/roleAssignmentApprovals"}
 
     @distributed_trace_async
-    async def get_by_id(self, schedule_definition_id: str, id: str, **kwargs: Any) -> _models.AccessReviewInstance:
-        """Get access review instances.
+    async def get_by_id(self, approval_id: str, **kwargs: Any) -> _models.RoleAssignmentApproval:
+        """Get role assignment approval.
 
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param id: The id of the access review instance. Required.
-        :type id: str
+        :param approval_id: The id of the role assignment approval. Required.
+        :type approval_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewInstance
+        :return: RoleAssignmentApproval or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApproval
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
-        cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoleAssignmentApproval] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
-            schedule_definition_id=schedule_definition_id,
-            id=id,
-            subscription_id=self._config.subscription_id,
+            approval_id=approval_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("AccessReviewInstance", pipeline_response)
+        deserialized = self._deserialize("RoleAssignmentApproval", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_by_id.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}"
-    }
+    get_by_id.metadata = {"url": "/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -31,18 +31,14 @@
 from ..._vendor import _convert_request
 from ...operations._access_review_instance_my_decisions_operations import (
     build_get_by_id_request,
     build_list_request,
     build_patch_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceMyDecisionsOperations:
     """
     .. warning::
@@ -57,14 +53,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewDecision"]:
         """Get my access review instance decisions.
 
@@ -83,16 +80,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -139,16 +136,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -185,16 +183,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             decision_id=decision_id,
@@ -202,16 +200,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -325,24 +324,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewDecisionProperties")
 
         request = build_patch_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -354,16 +353,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_access_review_instance_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,40 +29,37 @@
     build_accept_recommendations_request,
     build_apply_decisions_request,
     build_reset_decisions_request,
     build_send_reminders_request,
     build_stop_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`access_review_instance` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def stop(  # pylint: disable=inconsistent-return-statements
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> None:
         """An action to stop an access review instance.
 
@@ -83,16 +79,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -100,16 +96,17 @@
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -144,16 +141,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_reset_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -161,16 +158,17 @@
             template_url=self.reset_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -205,16 +203,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_apply_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -222,16 +220,17 @@
             template_url=self.apply_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -266,16 +265,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_send_reminders_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -283,16 +282,17 @@
             template_url=self.send_reminders.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -327,32 +327,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_accept_recommendations_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.accept_recommendations.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_eligible_child_resources_operations.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,106 +2,132 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._access_review_schedule_definitions_assigned_for_my_approval_operations import build_list_request
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .. import models as _models
+from ..._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
+
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_get_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/eligibleChildResources")
+    path_format_arguments = {
+        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
+    }
 
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
-class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
+    # Construct parameters
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class EligibleChildResourcesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.AuthorizationManagementClient`'s
+        :attr:`eligible_child_resources` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(
-        self, filter: Optional[str] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
-        """Get access review instances assigned for my approval.
-
-        :param filter: The filter to apply on the operation. Other than standard filters, one custom
-         filter option is supported : 'assignedToMeToReview()'. When one specified
-         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
-         returned. Default value is None.
+    def get(self, scope: str, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.EligibleChildResource"]:
+        """Get the child resources of a resource on which user has eligible access.
+
+        :param scope: The scope of the role management policy. Required.
+        :type scope: str
+        :param filter: The filter to apply on the operation. Use $filter=resourceType+eq+'Subscription'
+         to filter on only resource of type = 'Subscription'. Use
+         $filter=resourceType+eq+'subscription'+or+resourceType+eq+'resourcegroup' to filter on resource
+         of type = 'Subscription' or 'ResourceGroup'. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
+        :return: An iterator like instance of either EligibleChildResource or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.EligibleChildResource]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
-        cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.EligibleChildResourcesListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                request = build_get_request(
+                    scope=scope,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
+                    template_url=self.get.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -118,32 +144,32 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("EligibleChildResourcesListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
+        return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions"}
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/eligibleChildResources"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_schedule_definitions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,18 +33,14 @@
     build_create_or_update_by_id_request,
     build_delete_by_id_request,
     build_get_by_id_request,
     build_list_request,
     build_stop_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewScheduleDefinitionsOperations:
     """
     .. warning::
@@ -59,14 +55,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review schedule definitions.
 
@@ -81,16 +78,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -136,16 +133,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -176,32 +174,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -238,32 +237,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -351,24 +351,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleDefinitionProperties")
 
         request = build_create_or_update_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
@@ -379,16 +379,17 @@
             template_url=self.create_or_update_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -425,32 +426,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,18 +25,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
@@ -52,30 +47,31 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """Lists the operations available from this provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_03_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-03-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-03-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -119,16 +115,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_03_01_preview/models/_authorization_management_client_enums.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/_authorization_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/_authorization_management_client.py`

 * *Files 19% similar despite different names*

```diff
@@ -3,21 +3,21 @@
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
 from copy import deepcopy
-from typing import Any, TYPE_CHECKING
+from typing import Any, Awaitable, TYPE_CHECKING
 
-from azure.core.rest import HttpRequest, HttpResponse
-from azure.mgmt.core import ARMPipelineClient
+from azure.core.rest import AsyncHttpResponse, HttpRequest
+from azure.mgmt.core import AsyncARMPipelineClient
 
-from . import models as _models
-from .._serialization import Deserializer, Serializer
+from .. import models as _models
+from ..._serialization import Deserializer, Serializer
 from ._configuration import AuthorizationManagementClientConfiguration
 from .operations import (
     AccessReviewDefaultSettingsOperations,
     AccessReviewInstanceDecisionsOperations,
     AccessReviewInstanceMyDecisionsOperations,
     AccessReviewInstanceOperations,
     AccessReviewInstancesAssignedForMyApprovalOperations,
@@ -25,128 +25,130 @@
     AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations,
     AccessReviewScheduleDefinitionsOperations,
     Operations,
 )
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials import TokenCredential
+    from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
     """Access reviews service provides the workflow for running access reviews on different kind of
     resources.
 
     :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.authorization.v2018_05_01_preview.operations.Operations
+    :vartype operations: azure.mgmt.authorization.v2021_03_01_preview.aio.operations.Operations
     :ivar access_review_schedule_definitions: AccessReviewScheduleDefinitionsOperations operations
     :vartype access_review_schedule_definitions:
-     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewScheduleDefinitionsOperations
+     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewScheduleDefinitionsOperations
     :ivar access_review_instances: AccessReviewInstancesOperations operations
     :vartype access_review_instances:
-     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstancesOperations
+     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstancesOperations
     :ivar access_review_instance: AccessReviewInstanceOperations operations
     :vartype access_review_instance:
-     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstanceOperations
+     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstanceOperations
     :ivar access_review_instance_decisions: AccessReviewInstanceDecisionsOperations operations
     :vartype access_review_instance_decisions:
-     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstanceDecisionsOperations
+     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstanceDecisionsOperations
     :ivar access_review_default_settings: AccessReviewDefaultSettingsOperations operations
     :vartype access_review_default_settings:
-     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewDefaultSettingsOperations
+     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewDefaultSettingsOperations
     :ivar access_review_schedule_definitions_assigned_for_my_approval:
      AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations operations
     :vartype access_review_schedule_definitions_assigned_for_my_approval:
-     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations
+     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations
     :ivar access_review_instances_assigned_for_my_approval:
      AccessReviewInstancesAssignedForMyApprovalOperations operations
     :vartype access_review_instances_assigned_for_my_approval:
-     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstancesAssignedForMyApprovalOperations
+     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstancesAssignedForMyApprovalOperations
     :ivar access_review_instance_my_decisions: AccessReviewInstanceMyDecisionsOperations operations
     :vartype access_review_instance_my_decisions:
-     azure.mgmt.authorization.v2018_05_01_preview.operations.AccessReviewInstanceMyDecisionsOperations
+     azure.mgmt.authorization.v2021_03_01_preview.aio.operations.AccessReviewInstanceMyDecisionsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials.TokenCredential
+    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2018-05-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2021-03-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(
         self,
-        credential: "TokenCredential",
+        credential: "AsyncTokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
+        )
         self.access_review_schedule_definitions = AccessReviewScheduleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_instances = AccessReviewInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_instance = AccessReviewInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_instance_decisions = AccessReviewInstanceDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_default_settings = AccessReviewDefaultSettingsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_schedule_definitions_assigned_for_my_approval = (
             AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations(
-                self._client, self._config, self._serialize, self._deserialize
+                self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
             )
         )
         self.access_review_instances_assigned_for_my_approval = AccessReviewInstancesAssignedForMyApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
         self.access_review_instance_my_decisions = AccessReviewInstanceMyDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-03-01-preview"
         )
 
-    def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
+    def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
         <HttpRequest [GET], url: 'https://www.example.org/'>
-        >>> response = client._send_request(request)
-        <HttpResponse: 200 OK>
+        >>> response = await client._send_request(request)
+        <AsyncHttpResponse: 200 OK>
 
         For more information on this code flow, see https://aka.ms/azsdk/dpcodegen/python/send_request
 
         :param request: The network request you want to make. Required.
         :type request: ~azure.core.rest.HttpRequest
         :keyword bool stream: Whether the response payload will be streamed. Defaults to False.
         :return: The response of your network call. Does not do error handling on your response.
-        :rtype: ~azure.core.rest.HttpResponse
+        :rtype: ~azure.core.rest.AsyncHttpResponse
         """
 
         request_copy = deepcopy(request)
         request_copy.url = self._client.format_url(request_copy.url)
         return self._client.send_request(request_copy, **kwargs)
 
-    def close(self) -> None:
-        self._client.close()
+    async def close(self) -> None:
+        await self._client.close()
 
-    def __enter__(self) -> "AuthorizationManagementClient":
-        self._client.__enter__()
+    async def __aenter__(self) -> "AuthorizationManagementClient":
+        await self._client.__aenter__()
         return self
 
-    def __exit__(self, *exc_details: Any) -> None:
-        self._client.__exit__(*exc_details)
+    async def __aexit__(self, *exc_details: Any) -> None:
+        await self._client.__aexit__(*exc_details)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_configuration.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2018-05-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2020-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop("api_version", "2018-05-01-preview")
+        api_version: str = kwargs.pop("api_version", "2020-10-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_decisions_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,95 +25,101 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_list_request(
+    schedule_definition_id: str, id: str, subscription_id: str, *, filter: Optional[str] = None, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
+        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
         "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
         "id": _SERIALIZER.url("id", id, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 class AccessReviewInstanceDecisionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_instance_decisions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(self, schedule_definition_id: str, id: str, **kwargs: Any) -> Iterable["_models.AccessReviewDecision"]:
+    def list(
+        self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> Iterable["_models.AccessReviewDecision"]:
         """Get access review instance decisions.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
+        :param filter: The filter to apply on the operation. Other than standard filters, one custom
+         filter option is supported : 'assignedToMeToReview()'. When one specified
+         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
+         returned. Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewDecision or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -125,14 +130,15 @@
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     schedule_definition_id=schedule_definition_id,
                     id=id,
                     subscription_id=self._config.subscription_id,
+                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -161,16 +167,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_assigned_for_my_approval_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(schedule_definition_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances",
     )  # pylint: disable=line-too-long
@@ -70,17 +63,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
     )  # pylint: disable=line-too-long
@@ -114,14 +105,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, schedule_definition_id: str, **kwargs: Any) -> Iterable["_models.AccessReviewInstance"]:
         """Get access review instances assigned for my approval.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
@@ -131,16 +123,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -185,16 +177,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -227,32 +220,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_default_settings_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,289 +2,267 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_get_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_list_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default",
+        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
+        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_put_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
+def build_get_by_id_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
-    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default",
+        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
     )  # pylint: disable=line-too-long
     path_format_arguments = {
+        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
+        "id": _SERIALIZER.url("id", id, "str"),
         "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
-    if content_type is not None:
-        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
-    return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class AccessReviewDefaultSettingsOperations:
+class AccessReviewInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
-        :attr:`access_review_default_settings` attribute.
+        :attr:`access_review_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def get(self, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
+    def list(self, schedule_definition_id: str, **kwargs: Any) -> Iterable["_models.AccessReviewInstance"]:
+        """Get access review instances.
 
+        :param schedule_definition_id: The id of the access review schedule definition. Required.
+        :type schedule_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDefaultSettings
+        :return: An iterator like instance of either AccessReviewInstance or the result of
+         cls(response)
+        :rtype:
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
+        )
+        cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
-        )
-        cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
-
-        request = build_get_request(
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                request = build_list_request(
+                    schedule_definition_id=schedule_definition_id,
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, iter(list_of_elem)
+
+        def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("AccessReviewDefaultSettings", pipeline_response)
+            return pipeline_response
 
-        if cls:
-            return cls(pipeline_response, deserialized, {})
+        return ItemPaged(get_next, extract_data)
 
-        return deserialized
-
-    get.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"
+    list.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances"
     }
 
-    @overload
-    def put(
-        self, properties: _models.AccessReviewScheduleSettings, *, content_type: str = "application/json", **kwargs: Any
-    ) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
-
-        :param properties: Access review schedule settings. Required.
-        :type properties:
-         ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewScheduleSettings
-        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDefaultSettings
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
-    @overload
-    def put(
-        self, properties: IO, *, content_type: str = "application/json", **kwargs: Any
-    ) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
-
-        :param properties: Access review schedule settings. Required.
-        :type properties: IO
-        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
-         Default value is "application/json".
-        :paramtype content_type: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDefaultSettings
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-
     @distributed_trace
-    def put(
-        self, properties: Union[_models.AccessReviewScheduleSettings, IO], **kwargs: Any
-    ) -> _models.AccessReviewDefaultSettings:
-        """Get access review default settings for the subscription.
-
-        :param properties: Access review schedule settings. Is either a AccessReviewScheduleSettings
-         type or a IO type. Required.
-        :type properties:
-         ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewScheduleSettings or IO
-        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
-         Default value is None.
-        :paramtype content_type: str
+    def get_by_id(self, schedule_definition_id: str, id: str, **kwargs: Any) -> _models.AccessReviewInstance:
+        """Get access review instances.
+
+        :param schedule_definition_id: The id of the access review schedule definition. Required.
+        :type schedule_definition_id: str
+        :param id: The id of the access review instance. Required.
+        :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewDefaultSettings or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDefaultSettings
+        :return: AccessReviewInstance or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
-        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
-        cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
-
-        content_type = content_type or "application/json"
-        _json = None
-        _content = None
-        if isinstance(properties, (IO, bytes)):
-            _content = properties
-        else:
-            _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
+        cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
 
-        request = build_put_request(
+        request = build_get_by_id_request(
+            schedule_definition_id=schedule_definition_id,
+            id=id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
-            content_type=content_type,
-            json=_json,
-            content=_content,
-            template_url=self.put.metadata["url"],
+            template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("AccessReviewDefaultSettings", pipeline_response)
+        deserialized = self._deserialize("AccessReviewInstance", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    put.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"
+    get_by_id.metadata = {
+        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_permissions_operations.py`

 * *Files 17% similar despite different names*

```diff
@@ -2,166 +2,98 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from ..._serialization import Serializer
-from .._vendor import _convert_request, _format_url_section
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_list_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._permissions_operations import build_list_for_resource_group_request, build_list_for_resource_request
 
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_get_by_id_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
-        "id": _SERIALIZER.url("id", id, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+T = TypeVar("T")
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AccessReviewInstancesOperations:
+class PermissionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
-        :attr:`access_review_instances` attribute.
+        :class:`~azure.mgmt.authorization.v2022_05_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`permissions` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(self, schedule_definition_id: str, **kwargs: Any) -> Iterable["_models.AccessReviewInstance"]:
-        """Get access review instances.
+    def list_for_resource_group(self, resource_group_name: str, **kwargs: Any) -> AsyncIterable["_models.Permission"]:
+        """Gets all permissions the caller has for a resource group.
 
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewInstance or the result of
-         cls(response)
+        :return: An iterator like instance of either Permission or the result of cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_05_01_preview.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-05-01-preview")
         )
-        cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
-                    schedule_definition_id=schedule_definition_id,
+                request = build_list_for_resource_group_request(
+                    resource_group_name=resource_group_name,
                     subscription_id=self._config.subscription_id,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
+                    template_url=self.list_for_resource_group.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -178,97 +110,145 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("PermissionGetResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
+        async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances"
+    list_for_resource_group.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.Authorization/permissions"
     }
 
     @distributed_trace
-    def get_by_id(self, schedule_definition_id: str, id: str, **kwargs: Any) -> _models.AccessReviewInstance:
-        """Get access review instances.
-
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param id: The id of the access review instance. Required.
-        :type id: str
+    def list_for_resource(
+        self,
+        resource_group_name: str,
+        resource_provider_namespace: str,
+        parent_resource_path: str,
+        resource_type: str,
+        resource_name: str,
+        **kwargs: Any
+    ) -> AsyncIterable["_models.Permission"]:
+        """Gets all permissions the caller has for a resource.
+
+        :param resource_group_name: The name of the resource group. The name is case insensitive.
+         Required.
+        :type resource_group_name: str
+        :param resource_provider_namespace: The namespace of the resource provider. Required.
+        :type resource_provider_namespace: str
+        :param parent_resource_path: The parent resource identity. Required.
+        :type parent_resource_path: str
+        :param resource_type: The resource type of the resource. Required.
+        :type resource_type: str
+        :param resource_name: The name of the resource to get the permissions for. Required.
+        :type resource_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance
+        :return: An iterator like instance of either Permission or the result of cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_05_01_preview.models.Permission]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-05-01-preview")
+        )
+        cls: ClsType[_models.PermissionGetResult] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
-        )
-        cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
+                request = build_list_for_resource_request(
+                    resource_group_name=resource_group_name,
+                    resource_provider_namespace=resource_provider_namespace,
+                    parent_resource_path=parent_resource_path,
+                    resource_type=resource_type,
+                    resource_name=resource_name,
+                    subscription_id=self._config.subscription_id,
+                    api_version=api_version,
+                    template_url=self.list_for_resource.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
 
-        request = build_get_by_id_request(
-            schedule_definition_id=schedule_definition_id,
-            id=id,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self.get_by_id.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("PermissionGetResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        response = pipeline_response.http_response
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
 
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
 
-        deserialized = self._deserialize("AccessReviewInstance", pipeline_response)
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        if cls:
-            return cls(pipeline_response, deserialized, {})
+            return pipeline_response
 
-        return deserialized
+        return AsyncItemPaged(get_next, extract_data)
 
-    get_by_id.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}"
+    list_for_resource.metadata = {
+        "url": "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/permissions"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_my_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_access_review_instance_my_decisions_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +26,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
+def build_list_request(
+    schedule_definition_id: str, id: str, *, filter: Optional[str] = None, **kwargs: Any
+) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions",
     )  # pylint: disable=line-too-long
@@ -60,28 +56,28 @@
         "id": _SERIALIZER.url("id", id, "str"),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, id: str, decision_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions/{decisionId}",
     )  # pylint: disable=line-too-long
@@ -102,17 +98,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_patch_request(schedule_definition_id: str, id: str, decision_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions/{decisionId}",
@@ -138,47 +132,55 @@
 
 class AccessReviewInstanceMyDecisionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
         :attr:`access_review_instance_my_decisions` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(self, schedule_definition_id: str, id: str, **kwargs: Any) -> Iterable["_models.AccessReviewDecision"]:
+    def list(
+        self, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> Iterable["_models.AccessReviewDecision"]:
         """Get my access review instance decisions.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
+        :param filter: The filter to apply on the operation. Other than standard filters, one custom
+         filter option is supported : 'assignedToMeToReview()'. When one specified
+         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
+         returned. Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewDecision or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -188,14 +190,15 @@
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     schedule_definition_id=schedule_definition_id,
                     id=id,
+                    filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -224,16 +227,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -256,30 +260,30 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             decision_id=decision_id,
@@ -287,16 +291,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -330,21 +335,21 @@
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :param properties: Access review decision properties to patch. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecisionProperties
+         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecisionProperties
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def patch(
         self,
         schedule_definition_id: str,
@@ -366,15 +371,15 @@
         :param properties: Access review decision properties to patch. Required.
         :type properties: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def patch(
         self,
         schedule_definition_id: str,
@@ -390,44 +395,44 @@
         :param id: The id of the access review instance. Required.
         :type id: str
         :param decision_id: The id of the decision record. Required.
         :type decision_id: str
         :param properties: Access review decision properties to patch. Is either a
          AccessReviewDecisionProperties type or a IO type. Required.
         :type properties:
-         ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecisionProperties or IO
+         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecisionProperties or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDecision or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewDecisionProperties")
 
         request = build_patch_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -439,16 +444,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/aio/operations/_role_definitions_operations.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,522 +2,497 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, Optional, TypeVar
+from io import IOBase
+from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
+import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from ..._serialization import Serializer
-from .._vendor import _convert_request, _format_url_section
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_stop_request(schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/stop",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
-        "id": _SERIALIZER.url("id", id, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_reset_decisions_request(
-    schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/resetDecisions",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
-        "id": _SERIALIZER.url("id", id, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_apply_decisions_request(
-    schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/applyDecisions",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
-        "id": _SERIALIZER.url("id", id, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_send_reminders_request(
-    schedule_definition_id: str, id: str, subscription_id: str, **kwargs: Any
-) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/sendReminders",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
-        "id": _SERIALIZER.url("id", id, "str"),
-        "subscriptionId": _SERIALIZER.url("subscription_id", subscription_id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_accept_recommendations_request(schedule_definition_id: str, id: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/acceptRecommendations",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
-        "id": _SERIALIZER.url("id", id, "str"),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._role_definitions_operations import (
+    build_create_or_update_request,
+    build_delete_request,
+    build_get_by_id_request,
+    build_get_request,
+    build_list_request,
+)
 
-    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+T = TypeVar("T")
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AccessReviewInstanceOperations:
+class RoleDefinitionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
-        :attr:`access_review_instance` attribute.
+        :class:`~azure.mgmt.authorization.v2022_05_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`role_definitions` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
-    @distributed_trace
-    def stop(  # pylint: disable=inconsistent-return-statements
-        self, schedule_definition_id: str, id: str, **kwargs: Any
-    ) -> None:
-        """An action to stop an access review instance.
-
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param id: The id of the access review instance. Required.
-        :type id: str
+    @distributed_trace_async
+    async def delete(self, scope: str, role_definition_id: str, **kwargs: Any) -> Optional[_models.RoleDefinition]:
+        """Deletes a role definition.
+
+        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
+         '/subscriptions/{subscriptionId}'), resource group (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
+         Required.
+        :type scope: str
+        :param role_definition_id: The ID of the role definition to delete. Required.
+        :type role_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: RoleDefinition or None or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_05_01_preview.models.RoleDefinition or None
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-05-01-preview")
         )
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[Optional[_models.RoleDefinition]] = kwargs.pop("cls", None)
 
-        request = build_stop_request(
-            schedule_definition_id=schedule_definition_id,
-            id=id,
-            subscription_id=self._config.subscription_id,
+        request = build_delete_request(
+            scope=scope,
+            role_definition_id=role_definition_id,
             api_version=api_version,
-            template_url=self.stop.metadata["url"],
+            template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [204]:
+        if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        deserialized = None
+        if response.status_code == 200:
+            deserialized = self._deserialize("RoleDefinition", pipeline_response)
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, {})
 
-    stop.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/stop"
-    }
+        return deserialized
 
-    @distributed_trace
-    def reset_decisions(  # pylint: disable=inconsistent-return-statements
-        self, schedule_definition_id: str, id: str, **kwargs: Any
-    ) -> None:
-        """An action to reset all decisions for an access review instance.
-
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param id: The id of the access review instance. Required.
-        :type id: str
+    delete.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}"}
+
+    @distributed_trace_async
+    async def get(self, scope: str, role_definition_id: str, **kwargs: Any) -> _models.RoleDefinition:
+        """Get role definition by ID (GUID).
+
+        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
+         '/subscriptions/{subscriptionId}'), resource group (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
+         Required.
+        :type scope: str
+        :param role_definition_id: The ID of the role definition. Required.
+        :type role_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: RoleDefinition or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_05_01_preview.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-05-01-preview")
         )
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
-        request = build_reset_decisions_request(
-            schedule_definition_id=schedule_definition_id,
-            id=id,
-            subscription_id=self._config.subscription_id,
+        request = build_get_request(
+            scope=scope,
+            role_definition_id=role_definition_id,
             api_version=api_version,
-            template_url=self.reset_decisions.metadata["url"],
+            template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [204]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        deserialized = self._deserialize("RoleDefinition", pipeline_response)
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, {})
 
-    reset_decisions.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/resetDecisions"
-    }
+        return deserialized
 
-    @distributed_trace
-    def apply_decisions(  # pylint: disable=inconsistent-return-statements
-        self, schedule_definition_id: str, id: str, **kwargs: Any
-    ) -> None:
-        """An action to apply all decisions for an access review instance.
-
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param id: The id of the access review instance. Required.
-        :type id: str
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}"}
+
+    @overload
+    async def create_or_update(
+        self,
+        scope: str,
+        role_definition_id: str,
+        role_definition: _models.RoleDefinition,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> _models.RoleDefinition:
+        """Creates or updates a role definition.
+
+        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
+         '/subscriptions/{subscriptionId}'), resource group (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
+         Required.
+        :type scope: str
+        :param role_definition_id: The ID of the role definition. Required.
+        :type role_definition_id: str
+        :param role_definition: The values for the role definition. Required.
+        :type role_definition: ~azure.mgmt.authorization.v2022_05_01_preview.models.RoleDefinition
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: RoleDefinition or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_05_01_preview.models.RoleDefinition
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def create_or_update(
+        self,
+        scope: str,
+        role_definition_id: str,
+        role_definition: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> _models.RoleDefinition:
+        """Creates or updates a role definition.
+
+        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
+         '/subscriptions/{subscriptionId}'), resource group (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
+         Required.
+        :type scope: str
+        :param role_definition_id: The ID of the role definition. Required.
+        :type role_definition_id: str
+        :param role_definition: The values for the role definition. Required.
+        :type role_definition: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: RoleDefinition or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_05_01_preview.models.RoleDefinition
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace_async
+    async def create_or_update(
+        self, scope: str, role_definition_id: str, role_definition: Union[_models.RoleDefinition, IO], **kwargs: Any
+    ) -> _models.RoleDefinition:
+        """Creates or updates a role definition.
+
+        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
+         '/subscriptions/{subscriptionId}'), resource group (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
+         Required.
+        :type scope: str
+        :param role_definition_id: The ID of the role definition. Required.
+        :type role_definition_id: str
+        :param role_definition: The values for the role definition. Is either a RoleDefinition type or
+         a IO type. Required.
+        :type role_definition: ~azure.mgmt.authorization.v2022_05_01_preview.models.RoleDefinition or
+         IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: RoleDefinition or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_05_01_preview.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-05-01-preview")
         )
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
-        request = build_apply_decisions_request(
-            schedule_definition_id=schedule_definition_id,
-            id=id,
-            subscription_id=self._config.subscription_id,
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(role_definition, (IOBase, bytes)):
+            _content = role_definition
+        else:
+            _json = self._serialize.body(role_definition, "RoleDefinition")
+
+        request = build_create_or_update_request(
+            scope=scope,
+            role_definition_id=role_definition_id,
             api_version=api_version,
-            template_url=self.apply_decisions.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self.create_or_update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [204]:
+        if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        deserialized = self._deserialize("RoleDefinition", pipeline_response)
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-    apply_decisions.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/applyDecisions"
-    }
+    create_or_update.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId}"}
 
     @distributed_trace
-    def send_reminders(  # pylint: disable=inconsistent-return-statements
-        self, schedule_definition_id: str, id: str, **kwargs: Any
-    ) -> None:
-        """An action to send reminders for an access review instance.
-
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param id: The id of the access review instance. Required.
-        :type id: str
+    def list(self, scope: str, filter: Optional[str] = None, **kwargs: Any) -> AsyncIterable["_models.RoleDefinition"]:
+        """Get all role definitions that are applicable at scope and above.
+
+        :param scope: The scope of the operation or resource. Valid scopes are: subscription (format:
+         '/subscriptions/{subscriptionId}'), resource group (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}', or resource (format:
+         '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/[{parentResourcePath}/]{resourceType}/{resourceName}'.
+         Required.
+        :type scope: str
+        :param filter: The filter to apply on the operation. Use atScopeAndBelow filter to search below
+         the given scope as well. Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: An iterator like instance of either RoleDefinition or the result of cls(response)
+        :rtype:
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2022_05_01_preview.models.RoleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-05-01-preview")
+        )
+        cls: ClsType[_models.RoleDefinitionListResult] = kwargs.pop("cls", None)
+
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+        def prepare_request(next_link=None):
+            if not next_link:
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
-        )
-        cls: ClsType[None] = kwargs.pop("cls", None)
-
-        request = build_send_reminders_request(
-            schedule_definition_id=schedule_definition_id,
-            id=id,
-            subscription_id=self._config.subscription_id,
-            api_version=api_version,
-            template_url=self.send_reminders.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [204]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        if cls:
-            return cls(pipeline_response, None, {})
-
-    send_reminders.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/sendReminders"
-    }
-
-    @distributed_trace
-    def accept_recommendations(  # pylint: disable=inconsistent-return-statements
-        self, schedule_definition_id: str, id: str, **kwargs: Any
-    ) -> None:
-        """An action to accept recommendations for decision in an access review instance.
-
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param id: The id of the access review instance. Required.
-        :type id: str
+                request = build_list_request(
+                    scope=scope,
+                    filter=filter,
+                    api_version=api_version,
+                    template_url=self.list.metadata["url"],
+                    headers=_headers,
+                    params=_params,
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+
+            else:
+                # make call to next link with the client's api-version
+                _parsed_next_link = urllib.parse.urlparse(next_link)
+                _next_request_params = case_insensitive_dict(
+                    {
+                        key: [urllib.parse.quote(v) for v in value]
+                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
+                    }
+                )
+                _next_request_params["api-version"] = self._config.api_version
+                request = HttpRequest(
+                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
+                )
+                request = _convert_request(request)
+                request.url = self._client.format_url(request.url)
+                request.method = "GET"
+            return request
+
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("RoleDefinitionListResult", pipeline_response)
+            list_of_elem = deserialized.value
+            if cls:
+                list_of_elem = cls(list_of_elem)  # type: ignore
+            return deserialized.next_link or None, AsyncList(list_of_elem)
+
+        async def get_next(next_link=None):
+            request = prepare_request(next_link)
+
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
+            )
+            response = pipeline_response.http_response
+
+            if response.status_code not in [200]:
+                map_error(status_code=response.status_code, response=response, error_map=error_map)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+            return pipeline_response
+
+        return AsyncItemPaged(get_next, extract_data)
+
+    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleDefinitions"}
+
+    @distributed_trace_async
+    async def get_by_id(self, role_id: str, **kwargs: Any) -> _models.RoleDefinition:
+        """Gets a role definition by ID.
+
+        :param role_id: The fully qualified role definition ID. Use the format,
+         /subscriptions/{guid}/providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId} for
+         subscription level role definitions, or
+         /providers/Microsoft.Authorization/roleDefinitions/{roleDefinitionId} for tenant level role
+         definitions. Required.
+        :type role_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: None or the result of cls(response)
-        :rtype: None
+        :return: RoleDefinition or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_05_01_preview.models.RoleDefinition
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-05-01-preview")
         )
-        cls: ClsType[None] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoleDefinition] = kwargs.pop("cls", None)
 
-        request = build_accept_recommendations_request(
-            schedule_definition_id=schedule_definition_id,
-            id=id,
+        request = build_get_by_id_request(
+            role_id=role_id,
             api_version=api_version,
-            template_url=self.accept_recommendations.metadata["url"],
+            template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
-        if response.status_code not in [204]:
+        if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
+        deserialized = self._deserialize("RoleDefinition", pipeline_response)
+
         if cls:
-            return cls(pipeline_response, None, {})
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
 
-    accept_recommendations.metadata = {
-        "url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/acceptRecommendations"
-    }
+    get_by_id.metadata = {"url": "/{roleId}"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,83 +25,77 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
-    _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions")
+    _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
+class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
-        :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
+        :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> Iterable["_models.AccessReviewScheduleDefinition"]:
-        """Get access review instances assigned for my approval.
+    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
+        """Lists the operations available from this provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
-         cls(response)
+        :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewScheduleDefinition]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
-        cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -135,31 +128,32 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
+            deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions"}
+    list.metadata = {"url": "/providers/Microsoft.Authorization/operations"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/operations/_access_review_schedule_definitions_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions",
     )  # pylint: disable=line-too-long
@@ -70,17 +64,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
@@ -100,17 +92,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
     )  # pylint: disable=line-too-long
@@ -132,17 +122,15 @@
 
 def build_create_or_update_by_id_request(
     schedule_definition_id: str, subscription_id: str, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}",
@@ -165,17 +153,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_stop_request(schedule_definition_id: str, subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2018-05-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/stop",
     )  # pylint: disable=line-too-long
@@ -209,14 +195,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review schedule definitions.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
@@ -224,16 +211,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -278,16 +265,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -318,32 +306,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -380,32 +369,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -493,24 +483,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleDefinitionProperties")
 
         request = build_create_or_update_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
@@ -521,16 +511,17 @@
             template_url=self.create_or_update_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -567,32 +558,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(**kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2018-05-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/operations")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -64,42 +57,43 @@
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_01_01_preview.AuthorizationManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
         """Lists the operations available from this provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.Operation]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_01_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -143,16 +137,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/_authorization_management_client.py`

 * *Files 18% similar despite different names*

```diff
@@ -12,115 +12,123 @@
 from azure.core.rest import AsyncHttpResponse, HttpRequest
 from azure.mgmt.core import AsyncARMPipelineClient
 
 from .. import models as _models
 from ..._serialization import Deserializer, Serializer
 from ._configuration import AuthorizationManagementClientConfiguration
 from .operations import (
-    AccessReviewDefaultSettingsOperations,
-    AccessReviewInstanceDecisionsOperations,
-    AccessReviewInstanceMyDecisionsOperations,
-    AccessReviewInstanceOperations,
-    AccessReviewInstancesAssignedForMyApprovalOperations,
-    AccessReviewInstancesOperations,
-    AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations,
-    AccessReviewScheduleDefinitionsOperations,
-    Operations,
+    EligibleChildResourcesOperations,
+    RoleAssignmentScheduleInstancesOperations,
+    RoleAssignmentScheduleRequestsOperations,
+    RoleAssignmentSchedulesOperations,
+    RoleAssignmentsOperations,
+    RoleEligibilityScheduleInstancesOperations,
+    RoleEligibilityScheduleRequestsOperations,
+    RoleEligibilitySchedulesOperations,
+    RoleManagementPoliciesOperations,
+    RoleManagementPolicyAssignmentsOperations,
 )
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClient:  # pylint: disable=client-accepts-api-version-keyword,too-many-instance-attributes
-    """Access reviews service provides the workflow for running access reviews on different kind of
-    resources.
-
-    :ivar operations: Operations operations
-    :vartype operations: azure.mgmt.authorization.v2018_05_01_preview.aio.operations.Operations
-    :ivar access_review_schedule_definitions: AccessReviewScheduleDefinitionsOperations operations
-    :vartype access_review_schedule_definitions:
-     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewScheduleDefinitionsOperations
-    :ivar access_review_instances: AccessReviewInstancesOperations operations
-    :vartype access_review_instances:
-     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstancesOperations
-    :ivar access_review_instance: AccessReviewInstanceOperations operations
-    :vartype access_review_instance:
-     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstanceOperations
-    :ivar access_review_instance_decisions: AccessReviewInstanceDecisionsOperations operations
-    :vartype access_review_instance_decisions:
-     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstanceDecisionsOperations
-    :ivar access_review_default_settings: AccessReviewDefaultSettingsOperations operations
-    :vartype access_review_default_settings:
-     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewDefaultSettingsOperations
-    :ivar access_review_schedule_definitions_assigned_for_my_approval:
-     AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations operations
-    :vartype access_review_schedule_definitions_assigned_for_my_approval:
-     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations
-    :ivar access_review_instances_assigned_for_my_approval:
-     AccessReviewInstancesAssignedForMyApprovalOperations operations
-    :vartype access_review_instances_assigned_for_my_approval:
-     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstancesAssignedForMyApprovalOperations
-    :ivar access_review_instance_my_decisions: AccessReviewInstanceMyDecisionsOperations operations
-    :vartype access_review_instance_my_decisions:
-     azure.mgmt.authorization.v2018_05_01_preview.aio.operations.AccessReviewInstanceMyDecisionsOperations
+    """Role based access control provides you a way to apply granular level policy administration down
+    to individual resources or resource groups. These operations enable you to manage role
+    assignments. A role assignment grants access to Azure Active Directory users.
+
+    :ivar role_assignments: RoleAssignmentsOperations operations
+    :vartype role_assignments:
+     azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleAssignmentsOperations
+    :ivar eligible_child_resources: EligibleChildResourcesOperations operations
+    :vartype eligible_child_resources:
+     azure.mgmt.authorization.v2020_10_01_preview.aio.operations.EligibleChildResourcesOperations
+    :ivar role_assignment_schedules: RoleAssignmentSchedulesOperations operations
+    :vartype role_assignment_schedules:
+     azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleAssignmentSchedulesOperations
+    :ivar role_assignment_schedule_instances: RoleAssignmentScheduleInstancesOperations operations
+    :vartype role_assignment_schedule_instances:
+     azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleAssignmentScheduleInstancesOperations
+    :ivar role_assignment_schedule_requests: RoleAssignmentScheduleRequestsOperations operations
+    :vartype role_assignment_schedule_requests:
+     azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleAssignmentScheduleRequestsOperations
+    :ivar role_eligibility_schedules: RoleEligibilitySchedulesOperations operations
+    :vartype role_eligibility_schedules:
+     azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleEligibilitySchedulesOperations
+    :ivar role_eligibility_schedule_instances: RoleEligibilityScheduleInstancesOperations
+     operations
+    :vartype role_eligibility_schedule_instances:
+     azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleEligibilityScheduleInstancesOperations
+    :ivar role_eligibility_schedule_requests: RoleEligibilityScheduleRequestsOperations operations
+    :vartype role_eligibility_schedule_requests:
+     azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleEligibilityScheduleRequestsOperations
+    :ivar role_management_policies: RoleManagementPoliciesOperations operations
+    :vartype role_management_policies:
+     azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleManagementPoliciesOperations
+    :ivar role_management_policy_assignments: RoleManagementPolicyAssignmentsOperations operations
+    :vartype role_management_policy_assignments:
+     azure.mgmt.authorization.v2020_10_01_preview.aio.operations.RoleManagementPolicyAssignmentsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials_async.AsyncTokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2018-05-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2020-10-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(
         self,
         credential: "AsyncTokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
-        self.access_review_schedule_definitions = AccessReviewScheduleDefinitionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+        self.role_assignments = RoleAssignmentsOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
+        )
+        self.eligible_child_resources = EligibleChildResourcesOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
+        )
+        self.role_assignment_schedules = RoleAssignmentSchedulesOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
-        self.access_review_instances = AccessReviewInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+        self.role_assignment_schedule_instances = RoleAssignmentScheduleInstancesOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
-        self.access_review_instance = AccessReviewInstanceOperations(
-            self._client, self._config, self._serialize, self._deserialize
+        self.role_assignment_schedule_requests = RoleAssignmentScheduleRequestsOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
-        self.access_review_instance_decisions = AccessReviewInstanceDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+        self.role_eligibility_schedules = RoleEligibilitySchedulesOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
-        self.access_review_default_settings = AccessReviewDefaultSettingsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+        self.role_eligibility_schedule_instances = RoleEligibilityScheduleInstancesOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
-        self.access_review_schedule_definitions_assigned_for_my_approval = (
-            AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations(
-                self._client, self._config, self._serialize, self._deserialize
-            )
+        self.role_eligibility_schedule_requests = RoleEligibilityScheduleRequestsOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
-        self.access_review_instances_assigned_for_my_approval = AccessReviewInstancesAssignedForMyApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+        self.role_management_policies = RoleManagementPoliciesOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
-        self.access_review_instance_my_decisions = AccessReviewInstanceMyDecisionsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+        self.role_management_policy_assignments = RoleManagementPolicyAssignmentsOperations(
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/_configuration.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :keyword api_version: Api Version. Default value is "2018-05-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop("api_version", "2018-05-01-preview")
+        api_version: str = kwargs.pop("api_version", "2018-05-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_tenant_level_access_review_instance_contacted_reviewers_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -24,67 +23,64 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._access_review_instance_decisions_operations import build_list_request
+from ...operations._tenant_level_access_review_instance_contacted_reviewers_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AccessReviewInstanceDecisionsOperations:
+class TenantLevelAccessReviewInstanceContactedReviewersOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`access_review_instance_decisions` attribute.
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`tenant_level_access_review_instance_contacted_reviewers` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, **kwargs: Any
-    ) -> AsyncIterable["_models.AccessReviewDecision"]:
-        """Get access review instance decisions.
+    ) -> AsyncIterable["_models.AccessReviewContactedReviewer"]:
+        """Get access review instance contacted reviewers.
 
         :param schedule_definition_id: The id of the access review schedule definition. Required.
         :type schedule_definition_id: str
         :param id: The id of the access review instance. Required.
         :type id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewDecision or the result of
+        :return: An iterator like instance of either AccessReviewContactedReviewer or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewContactedReviewer]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
-        cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessReviewContactedReviewerListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -92,15 +88,14 @@
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
                     schedule_definition_id=schedule_definition_id,
                     id=id,
-                    subscription_id=self._config.subscription_id,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
@@ -120,33 +115,34 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewDecisionListResult", pipeline_response)
+            deserialized = self._deserialize("AccessReviewContactedReviewerListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
     list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions"
+        "url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/contactedReviewers"
     }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedules_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -25,82 +24,151 @@
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._access_review_instances_assigned_for_my_approval_operations import (
-    build_get_by_id_request,
-    build_list_request,
-)
+from ...operations._role_assignment_schedules_operations import build_get_request, build_list_for_scope_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AccessReviewInstancesAssignedForMyApprovalOperations:
+class RoleAssignmentSchedulesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`access_review_instances_assigned_for_my_approval` attribute.
+        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`role_assignment_schedules` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
-    @distributed_trace
-    def list(self, schedule_definition_id: str, **kwargs: Any) -> AsyncIterable["_models.AccessReviewInstance"]:
-        """Get access review instances assigned for my approval.
+    @distributed_trace_async
+    async def get(
+        self, scope: str, role_assignment_schedule_name: str, **kwargs: Any
+    ) -> _models.RoleAssignmentSchedule:
+        """Get the specified role assignment schedule for a resource scope.
+
+        :param scope: The scope of the role assignment schedule. Required.
+        :type scope: str
+        :param role_assignment_schedule_name: The name (guid) of the role assignment schedule to get.
+         Required.
+        :type role_assignment_schedule_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: RoleAssignmentSchedule or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentSchedule
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
+        )
+        cls: ClsType[_models.RoleAssignmentSchedule] = kwargs.pop("cls", None)
+
+        request = build_get_request(
+            scope=scope,
+            role_assignment_schedule_name=role_assignment_schedule_name,
+            api_version=api_version,
+            template_url=self.get.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
 
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("RoleAssignmentSchedule", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
+
+    get.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules/{roleAssignmentScheduleName}"
+    }
+
+    @distributed_trace
+    def list_for_scope(
+        self, scope: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> AsyncIterable["_models.RoleAssignmentSchedule"]:
+        """Gets role assignment schedules for a resource scope.
+
+        :param scope: The scope of the role assignments schedules. Required.
+        :type scope: str
+        :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
+         assignment schedules at or above the scope. Use $filter=principalId eq {id} to return all role
+         assignment schedules at, above or below the scope for the specified principal. Use
+         $filter=assignedTo('{userId}') to return all role assignment schedules for the current user.
+         Use $filter=asTarget() to return all role assignment schedules created for the current user.
+         Default value is None.
+        :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewInstance or the result of
+        :return: An iterator like instance of either RoleAssignmentSchedule or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentSchedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
-        cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.RoleAssignmentScheduleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
-                    schedule_definition_id=schedule_definition_id,
+                request = build_list_for_scope_request(
+                    scope=scope,
+                    filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
+                    template_url=self.list_for_scope.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -118,95 +186,31 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
+            deserialized = self._deserialize("RoleAssignmentScheduleListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {
-        "url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances"
-    }
-
-    @distributed_trace_async
-    async def get_by_id(self, schedule_definition_id: str, id: str, **kwargs: Any) -> _models.AccessReviewInstance:
-        """Get single access review instance assigned for my approval.
-
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param id: The id of the access review instance. Required.
-        :type id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
-        )
-        cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
-
-        request = build_get_by_id_request(
-            schedule_definition_id=schedule_definition_id,
-            id=id,
-            api_version=api_version,
-            template_url=self.get_by_id.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("AccessReviewInstance", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    get_by_id.metadata = {
-        "url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}"
-    }
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_default_settings_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_default_settings_operations.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,18 +24,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._access_review_default_settings_operations import build_get_request, build_put_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewDefaultSettingsOperations:
     """
     .. warning::
@@ -50,14 +46,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(self, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
         """Get access review default settings for the subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: AccessReviewDefaultSettings or the result of cls(response)
@@ -71,31 +68,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         request = build_get_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -172,24 +170,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
 
         request = build_put_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
@@ -199,16 +197,17 @@
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_default_settings_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,210 +2,233 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
-import urllib.parse
+from io import IOBase
+from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._access_review_instances_operations import build_get_by_id_request, build_list_request
+from ...operations._scope_access_review_default_settings_operations import build_get_request, build_put_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AccessReviewInstancesOperations:
+class ScopeAccessReviewDefaultSettingsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`access_review_instances` attribute.
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`scope_access_review_default_settings` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
-    @distributed_trace
-    def list(self, schedule_definition_id: str, **kwargs: Any) -> AsyncIterable["_models.AccessReviewInstance"]:
-        """Get access review instances.
+    @distributed_trace_async
+    async def get(self, scope: str, **kwargs: Any) -> _models.AccessReviewDefaultSettings:
+        """Get access review default settings for the subscription.
 
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
+        :param scope: The scope of the resource. Required.
+        :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewInstance or the result of
-         cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance]
+        :return: AccessReviewDefaultSettings or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
-        )
-        cls: ClsType[_models.AccessReviewInstanceListResult] = kwargs.pop("cls", None)
-
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-                request = build_list_request(
-                    schedule_definition_id=schedule_definition_id,
-                    subscription_id=self._config.subscription_id,
-                    api_version=api_version,
-                    template_url=self.list.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
-
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewInstanceListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
-
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
-
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-            return pipeline_response
-
-        return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances"
-    }
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
+        )
+        cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
 
-    @distributed_trace_async
-    async def get_by_id(self, schedule_definition_id: str, id: str, **kwargs: Any) -> _models.AccessReviewInstance:
-        """Get access review instances.
+        request = build_get_request(
+            scope=scope,
+            api_version=api_version,
+            template_url=self.get.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("AccessReviewDefaultSettings", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
+
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"}
 
-        :param schedule_definition_id: The id of the access review schedule definition. Required.
-        :type schedule_definition_id: str
-        :param id: The id of the access review instance. Required.
-        :type id: str
+    @overload
+    async def put(
+        self,
+        scope: str,
+        properties: _models.AccessReviewScheduleSettings,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> _models.AccessReviewDefaultSettings:
+        """Get access review default settings for the subscription.
+
+        :param scope: The scope of the resource. Required.
+        :type scope: str
+        :param properties: Access review schedule settings. Required.
+        :type properties:
+         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleSettings
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: AccessReviewInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewInstance
+        :return: AccessReviewDefaultSettings or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    async def put(
+        self, scope: str, properties: IO, *, content_type: str = "application/json", **kwargs: Any
+    ) -> _models.AccessReviewDefaultSettings:
+        """Get access review default settings for the subscription.
+
+        :param scope: The scope of the resource. Required.
+        :type scope: str
+        :param properties: Access review schedule settings. Required.
+        :type properties: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: AccessReviewDefaultSettings or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace_async
+    async def put(
+        self, scope: str, properties: Union[_models.AccessReviewScheduleSettings, IO], **kwargs: Any
+    ) -> _models.AccessReviewDefaultSettings:
+        """Get access review default settings for the subscription.
+
+        :param scope: The scope of the resource. Required.
+        :type scope: str
+        :param properties: Access review schedule settings. Is either a AccessReviewScheduleSettings
+         type or a IO type. Required.
+        :type properties:
+         ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewScheduleSettings or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: AccessReviewDefaultSettings or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDefaultSettings
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        _headers = kwargs.pop("headers", {}) or {}
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
-        cls: ClsType[_models.AccessReviewInstance] = kwargs.pop("cls", None)
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.AccessReviewDefaultSettings] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(properties, (IOBase, bytes)):
+            _content = properties
+        else:
+            _json = self._serialize.body(properties, "AccessReviewScheduleSettings")
 
-        request = build_get_by_id_request(
-            schedule_definition_id=schedule_definition_id,
-            id=id,
-            subscription_id=self._config.subscription_id,
+        request = build_put_request(
+            scope=scope,
             api_version=api_version,
-            template_url=self.get_by_id.metadata["url"],
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
             raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("AccessReviewInstance", pipeline_response)
+        deserialized = self._deserialize("AccessReviewDefaultSettings", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    get_by_id.metadata = {
-        "url": "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}"
-    }
+    put.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleSettings/default"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_my_decisions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -31,18 +31,14 @@
 from ..._vendor import _convert_request
 from ...operations._access_review_instance_my_decisions_operations import (
     build_get_by_id_request,
     build_list_request,
     build_patch_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceMyDecisionsOperations:
     """
     .. warning::
@@ -57,14 +53,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> AsyncIterable["_models.AccessReviewDecision"]:
         """Get my access review instance decisions.
 
@@ -78,16 +75,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -133,16 +130,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -179,16 +177,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             decision_id=decision_id,
@@ -196,16 +194,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -319,24 +318,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewDecision] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewDecisionProperties")
 
         request = build_patch_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
@@ -348,16 +347,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_instance_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/aio/operations/_access_review_instance_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -30,40 +29,37 @@
     build_accept_recommendations_request,
     build_apply_decisions_request,
     build_reset_decisions_request,
     build_send_reminders_request,
     build_stop_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewInstanceOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_03_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`access_review_instance` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def stop(  # pylint: disable=inconsistent-return-statements
         self, schedule_definition_id: str, id: str, **kwargs: Any
     ) -> None:
         """An action to stop an access review instance.
 
@@ -83,16 +79,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -100,16 +96,17 @@
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -144,16 +141,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_reset_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -161,16 +158,17 @@
             template_url=self.reset_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -205,16 +203,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_apply_decisions_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -222,16 +220,17 @@
             template_url=self.apply_decisions.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -266,16 +265,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_send_reminders_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             subscription_id=self._config.subscription_id,
@@ -283,16 +282,17 @@
             template_url=self.send_reminders.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -327,32 +327,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-03-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_accept_recommendations_request(
             schedule_definition_id=schedule_definition_id,
             id=id,
             api_version=api_version,
             template_url=self.accept_recommendations.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_assigned_for_my_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -24,61 +23,57 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._access_review_schedule_definitions_assigned_for_my_approval_operations import build_list_request
+from ...operations._operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class AccessReviewScheduleDefinitionsAssignedForMyApprovalOperations:
+class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`access_review_schedule_definitions_assigned_for_my_approval` attribute.
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
-        """Get access review instances assigned for my approval.
+    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
+        """Lists the operations available from this provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
-         cls(response)
+        :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewScheduleDefinition]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
-        cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -111,31 +106,32 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("AccessReviewScheduleDefinitionListResult", pipeline_response)
+            deserialized = self._deserialize("OperationListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list.metadata = {"url": "/providers/Microsoft.Authorization/accessReviewScheduleDefinitions"}
+    list.metadata = {"url": "/providers/Microsoft.Authorization/operations"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_access_review_schedule_definitions_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -33,18 +33,14 @@
     build_create_or_update_by_id_request,
     build_delete_by_id_request,
     build_get_by_id_request,
     build_list_request,
     build_stop_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class AccessReviewScheduleDefinitionsOperations:
     """
     .. warning::
@@ -59,14 +55,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.AccessReviewScheduleDefinition"]:
         """Get access review schedule definitions.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either AccessReviewScheduleDefinition or the result of
@@ -74,16 +71,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.AccessReviewScheduleDefinition]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinitionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -128,16 +125,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -168,32 +166,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -230,32 +229,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -343,24 +343,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.AccessReviewScheduleDefinition] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "AccessReviewScheduleDefinitionProperties")
 
         request = build_create_or_update_by_id_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
@@ -371,16 +371,17 @@
             template_url=self.create_or_update_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -417,32 +418,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2018-05-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_stop_request(
             schedule_definition_id=schedule_definition_id,
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.stop.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -26,56 +25,53 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class Operations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2018_05_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2021_01_01_preview.aio.AuthorizationManagementClient`'s
         :attr:`operations` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
         """Lists the operations available from this provider.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either Operation or the result of cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2018_05_01_preview.models.Operation]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_01_01_preview.models.Operation]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2018-05-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2018-05-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -119,16 +115,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2018_05_01_preview/models/_authorization_management_client_enums.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_05_01_preview/models/_authorization_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/_authorization_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -47,22 +47,22 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_assignment_metrics = RoleAssignmentMetricsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2019-08-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_07_01_preview/_configuration.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2019-08-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2021-07-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2019-08-01-preview"] = kwargs.pop("api_version", "2019-08-01-preview")
+        api_version: str = kwargs.pop("api_version", "2021-07-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/operations/_role_assignment_metrics_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/_role_assignment_metrics_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +23,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_metrics_for_subscription_request(subscription_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2019-08-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2019-08-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2019-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/roleAssignmentsUsageMetrics"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -81,14 +74,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get_metrics_for_subscription(self, **kwargs: Any) -> _models.RoleAssignmentMetricsResult:
         """Get role assignment usage metrics for a subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentMetricsResult or the result of cls(response)
@@ -102,31 +96,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2019-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2019-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2019-08-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentMetricsResult] = kwargs.pop("cls", None)
 
         request = build_get_metrics_for_subscription_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_metrics_for_subscription.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/_authorization_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -47,22 +47,22 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_assignment_metrics = RoleAssignmentMetricsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2019-08-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_07_01_preview/_configuration.py`

 * *Files 13% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2019-08-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2018-07-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2019-08-01-preview"] = kwargs.pop("api_version", "2019-08-01-preview")
+        api_version: str = kwargs.pop("api_version", "2018-07-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_role_assignment_metrics_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/aio/operations/_role_assignment_metrics_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,18 +23,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._role_assignment_metrics_operations import build_get_metrics_for_subscription_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentMetricsOperations:
     """
     .. warning::
@@ -50,14 +45,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get_metrics_for_subscription(self, **kwargs: Any) -> _models.RoleAssignmentMetricsResult:
         """Get role assignment usage metrics for a subscription.
 
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentMetricsResult or the result of cls(response)
@@ -71,31 +67,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2019-08-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2019-08-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2019-08-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentMetricsResult] = kwargs.pop("cls", None)
 
         request = build_get_metrics_for_subscription_request(
             subscription_id=self._config.subscription_id,
             api_version=api_version,
             template_url=self.get_metrics_for_subscription.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2019_08_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2019_08_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_authorization_management_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -64,38 +64,40 @@
     :paramtype api_version: str
     """
 
     def __init__(
         self, credential: "TokenCredential", base_url: str = "https://management.azure.com", **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(credential=credential, **kwargs)
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
+        )
         self.role_assignment_approval = RoleAssignmentApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
         self.role_assignment_approval_steps = RoleAssignmentApprovalStepsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
         self.role_assignment_approval_step = RoleAssignmentApprovalStepOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
         self.scope_role_assignment_approval = ScopeRoleAssignmentApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
         self.scope_role_assignment_approval_steps = ScopeRoleAssignmentApprovalStepsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
         self.scope_role_assignment_approval_step = ScopeRoleAssignmentApprovalStepOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -36,15 +30,15 @@
     :keyword api_version: Api Version. Default value is "2021-01-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop("api_version", "2021-01-01-preview")
+        api_version: str = kwargs.pop("api_version", "2021-01-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
 
         self.credential = credential
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_step_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_step_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +24,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_by_id_request(approval_id: str, stage_id: str, scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages/{stageId}",
     )  # pylint: disable=line-too-long
@@ -70,17 +64,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_patch_request(approval_id: str, stage_id: str, scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages/{stageId}",
@@ -104,17 +96,15 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_put_request(approval_id: str, stage_id: str, scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages/{stageId}",
@@ -152,14 +142,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get_by_id(
         self, approval_id: str, stage_id: str, scope: str, **kwargs: Any
     ) -> _models.RoleAssignmentApprovalStep:
         """Get role assignment approval.
 
@@ -181,16 +172,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             approval_id=approval_id,
             stage_id=stage_id,
             scope=scope,
@@ -198,16 +189,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -321,24 +313,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "RoleAssignmentApprovalStepProperties")
 
         request = build_patch_request(
             approval_id=approval_id,
             stage_id=stage_id,
@@ -350,16 +342,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -473,24 +466,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "RoleAssignmentApprovalStepProperties")
 
         request = build_put_request(
             approval_id=approval_id,
             stage_id=stage_id,
@@ -502,16 +495,17 @@
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_step_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_step_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +24,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_by_id_request(approval_id: str, stage_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages/{stageId}"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -68,17 +62,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_patch_request(approval_id: str, stage_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages/{stageId}"
     )  # pylint: disable=line-too-long
@@ -100,17 +92,15 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_put_request(approval_id: str, stage_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages/{stageId}"
     )  # pylint: disable=line-too-long
@@ -146,14 +136,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get_by_id(self, approval_id: str, stage_id: str, **kwargs: Any) -> _models.RoleAssignmentApprovalStep:
         """Get role assignment approval.
 
         :param approval_id: The id of the role assignment approval. Required.
         :type approval_id: str
@@ -171,32 +162,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             approval_id=approval_id,
             stage_id=stage_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -295,24 +287,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "RoleAssignmentApprovalStepProperties")
 
         request = build_patch_request(
             approval_id=approval_id,
             stage_id=stage_id,
@@ -323,16 +315,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -429,24 +422,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "RoleAssignmentApprovalStepProperties")
 
         request = build_put_request(
             approval_id=approval_id,
             stage_id=stage_id,
@@ -457,16 +450,17 @@
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(*, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/roleAssignmentApprovals")
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
@@ -64,17 +57,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(approval_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}")
     path_format_arguments = {
         "approvalId": _SERIALIZER.url("approval_id", approval_id, "str"),
     }
@@ -104,14 +95,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, filter: Optional[str] = None, **kwargs: Any) -> Iterable["_models.RoleAssignmentApproval"]:
         """Get role assignment approvals.
 
         :param filter: The filter to apply on the operation. Valid values for $filter are:
          'asApprover()', 'asCreatedBy()' and 'asTarget()'. If $filter is not provided, no filtering is
@@ -128,16 +120,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApproval]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApprovalListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -182,16 +174,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -220,31 +213,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApproval] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             approval_id=approval_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_steps_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_steps_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +23,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(approval_id: str, scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -82,14 +75,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, approval_id: str, scope: str, **kwargs: Any) -> _models.RoleAssignmentApprovalStepListResult:
         """Get role assignment approval.
 
         :param approval_id: The id of the role assignment approval. Required.
         :type approval_id: str
@@ -108,32 +102,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApprovalStepListResult] = kwargs.pop("cls", None)
 
         request = build_list_request(
             approval_id=approval_id,
             scope=scope,
             api_version=api_version,
             template_url=self.list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_steps_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_role_assignment_approval_steps_operations.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -24,32 +23,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(approval_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages")
     path_format_arguments = {
         "approvalId": _SERIALIZER.url("approval_id", approval_id, "str"),
     }
@@ -79,14 +72,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(self, approval_id: str, **kwargs: Any) -> _models.RoleAssignmentApprovalStepListResult:
         """Get role assignment approval.
 
         :param approval_id: The id of the role assignment approval. Required.
         :type approval_id: str
@@ -103,31 +97,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApprovalStepListResult] = kwargs.pop("cls", None)
 
         request = build_list_request(
             approval_id=approval_id,
             api_version=api_version,
             template_url=self.list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/_scope_role_assignment_approval_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -69,17 +62,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(approval_id: str, scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-01-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}")
     path_format_arguments = {
         "approvalId": _SERIALIZER.url("approval_id", approval_id, "str"),
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -110,14 +101,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleAssignmentApproval"]:
         """Get role assignment approvals.
 
@@ -138,16 +130,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApproval]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApprovalListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -193,16 +185,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -233,32 +226,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApproval] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             approval_id=approval_id,
             scope=scope,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/operations/_alert_operation_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,163 +2,141 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
-import urllib.parse
+from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
-from .._vendor import _convert_request
+from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_request(**kwargs: Any) -> HttpRequest:
+def build_get_request(scope: str, operation_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2021-01-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-08-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
-    _url = kwargs.pop("template_url", "/providers/Microsoft.Authorization/operations")
+    _url = kwargs.pop(
+        "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementAlertOperations/{operationId}"
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
+        "operationId": _SERIALIZER.url("operation_id", operation_id, "str", skip_quote=True),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class Operations:
+class AlertOperationOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_01_01_preview.AuthorizationManagementClient`'s
-        :attr:`operations` attribute.
+        :class:`~azure.mgmt.authorization.v2022_08_01_preview.AuthorizationManagementClient`'s
+        :attr:`alert_operation` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(self, **kwargs: Any) -> Iterable["_models.Operation"]:
-        """Lists the operations available from this provider.
+    def get(self, scope: str, operation_id: str, **kwargs: Any) -> _models.AlertOperationResult:
+        """Get the specified alert operation.
 
+        :param scope: The scope of the alert operation. Required.
+        :type scope: str
+        :param operation_id: The id of the alert operation. Required.
+        :type operation_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_01_01_preview.models.Operation]
+        :return: AlertOperationResult or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
-        )
-        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
-
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
+        )
+        cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
+
+        request = build_get_request(
+            scope=scope,
+            operation_id=operation_id,
+            api_version=api_version,
+            template_url=self.get.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-                request = build_list_request(
-                    api_version=api_version,
-                    template_url=self.list.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
-
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("OperationListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
-
-        def get_next(next_link=None):
-            request = prepare_request(next_link)
-
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        deserialized = self._deserialize("AlertOperationResult", pipeline_response)
 
-            return pipeline_response
+        if cls:
+            return cls(pipeline_response, deserialized, {})
 
-        return ItemPaged(get_next, extract_data)
+        return deserialized
 
-    list.metadata = {"url": "/providers/Microsoft.Authorization/operations"}
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleManagementAlertOperations/{operationId}"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/_authorization_management_client.py`

 * *Files 3% similar despite different names*

```diff
@@ -64,38 +64,40 @@
     :paramtype api_version: str
     """
 
     def __init__(
         self, credential: "AsyncTokenCredential", base_url: str = "https://management.azure.com", **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(credential=credential, **kwargs)
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
-        self.operations = Operations(self._client, self._config, self._serialize, self._deserialize)
+        self.operations = Operations(
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
+        )
         self.role_assignment_approval = RoleAssignmentApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
         self.role_assignment_approval_steps = RoleAssignmentApprovalStepsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
         self.role_assignment_approval_step = RoleAssignmentApprovalStepOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
         self.scope_role_assignment_approval = ScopeRoleAssignmentApprovalOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
         self.scope_role_assignment_approval_steps = ScopeRoleAssignmentApprovalStepsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
         self.scope_role_assignment_approval_step = ScopeRoleAssignmentApprovalStepOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2021-01-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/_configuration.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
 
 from .._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials_async import AsyncTokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -36,15 +30,15 @@
     :keyword api_version: Api Version. Default value is "2021-01-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "AsyncTokenCredential", **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop("api_version", "2021-01-01-preview")
+        api_version: str = kwargs.pop("api_version", "2021-01-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
 
         self.credential = credential
         self.api_version = api_version
         self.credential_scopes = kwargs.pop("credential_scopes", ["https://management.azure.com/.default"])
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_step_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_step_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -28,18 +28,14 @@
 from ..._vendor import _convert_request
 from ...operations._scope_role_assignment_approval_step_operations import (
     build_get_by_id_request,
     build_patch_request,
     build_put_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class ScopeRoleAssignmentApprovalStepOperations:
     """
     .. warning::
@@ -54,14 +50,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get_by_id(
         self, approval_id: str, stage_id: str, scope: str, **kwargs: Any
     ) -> _models.RoleAssignmentApprovalStep:
         """Get role assignment approval.
 
@@ -83,16 +80,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             approval_id=approval_id,
             stage_id=stage_id,
             scope=scope,
@@ -100,16 +97,17 @@
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -223,24 +221,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "RoleAssignmentApprovalStepProperties")
 
         request = build_patch_request(
             approval_id=approval_id,
             stage_id=stage_id,
@@ -252,16 +250,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -375,24 +374,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "RoleAssignmentApprovalStepProperties")
 
         request = build_put_request(
             approval_id=approval_id,
             stage_id=stage_id,
@@ -404,16 +403,17 @@
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_step_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_step_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Optional, TypeVar, Union, overload
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -28,18 +28,14 @@
 from ..._vendor import _convert_request
 from ...operations._role_assignment_approval_step_operations import (
     build_get_by_id_request,
     build_patch_request,
     build_put_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentApprovalStepOperations:
     """
     .. warning::
@@ -54,14 +50,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get_by_id(self, approval_id: str, stage_id: str, **kwargs: Any) -> _models.RoleAssignmentApprovalStep:
         """Get role assignment approval.
 
         :param approval_id: The id of the role assignment approval. Required.
         :type approval_id: str
@@ -79,32 +76,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             approval_id=approval_id,
             stage_id=stage_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -203,24 +201,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "RoleAssignmentApprovalStepProperties")
 
         request = build_patch_request(
             approval_id=approval_id,
             stage_id=stage_id,
@@ -231,16 +229,17 @@
             template_url=self.patch.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -337,24 +336,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentApprovalStep] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(properties, (IO, bytes)):
+        if isinstance(properties, (IOBase, bytes)):
             _content = properties
         else:
             _json = self._serialize.body(properties, "RoleAssignmentApprovalStepProperties")
 
         request = build_put_request(
             approval_id=approval_id,
             stage_id=stage_id,
@@ -365,16 +364,17 @@
             template_url=self.put.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/operations/_scope_access_review_instance_decisions_operations.py`

 * *Files 20% similar despite different names*

```diff
@@ -2,106 +2,144 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._role_assignment_approval_operations import build_get_by_id_request, build_list_request
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .. import models as _models
+from ..._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
+
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_list_request(
+    scope: str, schedule_definition_id: str, id: str, *, filter: Optional[str] = None, **kwargs: Any
+) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2021-12-01-preview"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "scope": _SERIALIZER.url("scope", scope, "str"),
+        "scheduleDefinitionId": _SERIALIZER.url("schedule_definition_id", schedule_definition_id, "str"),
+        "id": _SERIALIZER.url("id", id, "str"),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str", skip_quote=True)
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class RoleAssignmentApprovalOperations:
+class ScopeAccessReviewInstanceDecisionsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_01_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`role_assignment_approval` attribute.
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.AuthorizationManagementClient`'s
+        :attr:`scope_access_review_instance_decisions` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(self, filter: Optional[str] = None, **kwargs: Any) -> AsyncIterable["_models.RoleAssignmentApproval"]:
-        """Get role assignment approvals.
-
-        :param filter: The filter to apply on the operation. Valid values for $filter are:
-         'asApprover()', 'asCreatedBy()' and 'asTarget()'. If $filter is not provided, no filtering is
-         performed. If $filter=asApprover() is provided, the returned list only includes all role
-         assignment approvals that the calling user is assigned as an approver for. If
-         $filter=asCreatedBy() is provided, the returned list only includes all role assignment
-         approvals that the calling user created requests for. If $filter=asTarget() is provided, the
-         returned list only includes all role assignment approvals that the calling user has requests
-         targeted for. Default value is None.
+    def list(
+        self, scope: str, schedule_definition_id: str, id: str, filter: Optional[str] = None, **kwargs: Any
+    ) -> Iterable["_models.AccessReviewDecision"]:
+        """Get access review instance decisions.
+
+        :param scope: The scope of the resource. Required.
+        :type scope: str
+        :param schedule_definition_id: The id of the access review schedule definition. Required.
+        :type schedule_definition_id: str
+        :param id: The id of the access review instance. Required.
+        :type id: str
+        :param filter: The filter to apply on the operation. Other than standard filters, one custom
+         filter option is supported : 'assignedToMeToReview()'. When one specified
+         $filter=assignedToMeToReview(), only items that are assigned to the calling user to review are
+         returned. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either RoleAssignmentApproval or the result of
+        :return: An iterator like instance of either AccessReviewDecision or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApproval]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewDecision]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
-        cls: ClsType[_models.RoleAssignmentApprovalListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessReviewDecisionListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
                 request = build_list_request(
+                    scope=scope,
+                    schedule_definition_id=schedule_definition_id,
+                    id=id,
                     filter=filter,
                     api_version=api_version,
                     template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
@@ -121,89 +159,35 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("RoleAssignmentApprovalListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("AccessReviewDecisionListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {"url": "/providers/Microsoft.Authorization/roleAssignmentApprovals"}
-
-    @distributed_trace_async
-    async def get_by_id(self, approval_id: str, **kwargs: Any) -> _models.RoleAssignmentApproval:
-        """Get role assignment approval.
-
-        :param approval_id: The id of the role assignment approval. Required.
-        :type approval_id: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: RoleAssignmentApproval or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApproval
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
-        )
-        cls: ClsType[_models.RoleAssignmentApproval] = kwargs.pop("cls", None)
-
-        request = build_get_by_id_request(
-            approval_id=approval_id,
-            api_version=api_version,
-            template_url=self.get_by_id.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("RoleAssignmentApproval", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+        return ItemPaged(get_next, extract_data)
 
-    get_by_id.metadata = {"url": "/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}"}
+    list.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/accessReviewScheduleDefinitions/{scheduleDefinitionId}/instances/{id}/decisions"
+    }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_steps_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_steps_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -22,51 +21,46 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._scope_role_assignment_approval_steps_operations import build_list_request
+from ...operations._role_assignment_approval_steps_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class ScopeRoleAssignmentApprovalStepsOperations:
+class RoleAssignmentApprovalStepsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.authorization.v2021_01_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`scope_role_assignment_approval_steps` attribute.
+        :attr:`role_assignment_approval_steps` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
-    async def list(self, approval_id: str, scope: str, **kwargs: Any) -> _models.RoleAssignmentApprovalStepListResult:
+    async def list(self, approval_id: str, **kwargs: Any) -> _models.RoleAssignmentApprovalStepListResult:
         """Get role assignment approval.
 
         :param approval_id: The id of the role assignment approval. Required.
         :type approval_id: str
-        :param scope: The scope of the resource. Required.
-        :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentApprovalStepListResult or the result of cls(response)
         :rtype:
          ~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApprovalStepListResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
@@ -76,32 +70,32 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApprovalStepListResult] = kwargs.pop("cls", None)
 
         request = build_list_request(
             approval_id=approval_id,
-            scope=scope,
             api_version=api_version,
             template_url=self.list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -110,8 +104,8 @@
         deserialized = self._deserialize("RoleAssignmentApprovalStepListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages"}
+    list.metadata = {"url": "/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_role_assignment_approval_steps_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_steps_operations.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Optional, TypeVar
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
@@ -22,49 +21,48 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._role_assignment_approval_steps_operations import build_list_request
+from ...operations._scope_role_assignment_approval_steps_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class RoleAssignmentApprovalStepsOperations:
+class ScopeRoleAssignmentApprovalStepsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
         :class:`~azure.mgmt.authorization.v2021_01_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`role_assignment_approval_steps` attribute.
+        :attr:`scope_role_assignment_approval_steps` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
-    async def list(self, approval_id: str, **kwargs: Any) -> _models.RoleAssignmentApprovalStepListResult:
+    async def list(self, approval_id: str, scope: str, **kwargs: Any) -> _models.RoleAssignmentApprovalStepListResult:
         """Get role assignment approval.
 
         :param approval_id: The id of the role assignment approval. Required.
         :type approval_id: str
+        :param scope: The scope of the resource. Required.
+        :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentApprovalStepListResult or the result of cls(response)
         :rtype:
          ~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApprovalStepListResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
@@ -74,31 +72,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-01-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentApprovalStepListResult] = kwargs.pop("cls", None)
 
         request = build_list_request(
             approval_id=approval_id,
+            scope=scope,
             api_version=api_version,
             template_url=self.list.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
@@ -107,8 +107,8 @@
         deserialized = self._deserialize("RoleAssignmentApprovalStepListResult", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
-    list.metadata = {"url": "/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages"}
+    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}/stages"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_scope_role_assignment_approval_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedules_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,114 +2,225 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
+from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
+from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import AsyncHttpResponse
+from azure.core.pipeline.transport import HttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
-from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from ... import models as _models
-from ..._vendor import _convert_request
-from ...operations._scope_role_assignment_approval_operations import build_get_by_id_request, build_list_request
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from .. import models as _models
+from ..._serialization import Serializer
+from .._vendor import _convert_request, _format_url_section
+
 T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
+
+_SERIALIZER = Serializer()
+_SERIALIZER.client_side_validation = False
+
+
+def build_get_request(scope: str, role_eligibility_schedule_name: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules/{roleEligibilityScheduleName}",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
+        "roleEligibilityScheduleName": _SERIALIZER.url(
+            "role_eligibility_schedule_name", role_eligibility_schedule_name, "str"
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
+    accept = _headers.pop("Accept", "application/json")
 
+    # Construct URL
+    _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules")
+    path_format_arguments = {
+        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
+    }
 
-class ScopeRoleAssignmentApprovalOperations:
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+
+
+class RoleEligibilitySchedulesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_01_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`scope_role_assignment_approval` attribute.
+        :class:`~azure.mgmt.authorization.v2020_10_01.AuthorizationManagementClient`'s
+        :attr:`role_eligibility_schedules` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs) -> None:
+    def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def list(
+    def get(self, scope: str, role_eligibility_schedule_name: str, **kwargs: Any) -> _models.RoleEligibilitySchedule:
+        """Get the specified role eligibility schedule for a resource scope.
+
+        :param scope: The scope of the role eligibility schedule. Required.
+        :type scope: str
+        :param role_eligibility_schedule_name: The name (guid) of the role eligibility schedule to get.
+         Required.
+        :type role_eligibility_schedule_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: RoleEligibilitySchedule or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilitySchedule
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
+        cls: ClsType[_models.RoleEligibilitySchedule] = kwargs.pop("cls", None)
+
+        request = build_get_request(
+            scope=scope,
+            role_eligibility_schedule_name=role_eligibility_schedule_name,
+            api_version=api_version,
+            template_url=self.get.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("RoleEligibilitySchedule", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
+
+    get.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules/{roleEligibilityScheduleName}"
+    }
+
+    @distributed_trace
+    def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.RoleAssignmentApproval"]:
-        """Get role assignment approvals.
+    ) -> Iterable["_models.RoleEligibilitySchedule"]:
+        """Gets role eligibility schedules for a resource scope.
 
-        :param scope: The scope of the resource. Required.
+        :param scope: The scope of the role eligibility schedules. Required.
         :type scope: str
-        :param filter: The filter to apply on the operation. Valid values for $filter are:
-         'asApprover()', 'asCreatedBy()' and 'asTarget()'. If $filter is not provided, no filtering is
-         performed. If $filter=asApprover() is provided, the returned list only includes all role
-         assignment approvals that the calling user is assigned as an approver for. If
-         $filter=asCreatedBy() is provided, the returned list only includes all role assignment
-         approvals that the calling user created requests for. If $filter=asTarget() is provided, the
-         returned list only includes all role assignment approvals that the calling user has requests
-         targeted for. Default value is None.
+        :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
+         eligibility schedules at or above the scope. Use $filter=principalId eq {id} to return all role
+         eligibility schedules at, above or below the scope for the specified principal. Use
+         $filter=assignedTo('{userId}') to return all role eligibility schedules for the user. Use
+         $filter=asTarget() to return all role eligibility schedules created for the current user.
+         Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either RoleAssignmentApproval or the result of
+        :return: An iterator like instance of either RoleEligibilitySchedule or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApproval]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilitySchedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
-        )
-        cls: ClsType[_models.RoleAssignmentApprovalListResult] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
+        cls: ClsType[_models.RoleEligibilityScheduleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_list_request(
+                request = build_list_for_scope_request(
                     scope=scope,
                     filter=filter,
                     api_version=api_version,
-                    template_url=self.list.metadata["url"],
+                    template_url=self.list_for_scope.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -126,92 +237,32 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("RoleAssignmentApprovalListResult", pipeline_response)
+        def extract_data(pipeline_response):
+            deserialized = self._deserialize("RoleEligibilityScheduleListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
+            return deserialized.next_link or None, iter(list_of_elem)
 
-        async def get_next(next_link=None):
+        def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return AsyncItemPaged(get_next, extract_data)
-
-    list.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals"}
-
-    @distributed_trace_async
-    async def get_by_id(self, approval_id: str, scope: str, **kwargs: Any) -> _models.RoleAssignmentApproval:
-        """Get role assignment approval.
-
-        :param approval_id: The id of the role assignment approval. Required.
-        :type approval_id: str
-        :param scope: The scope of the resource. Required.
-        :type scope: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: RoleAssignmentApproval or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2021_01_01_preview.models.RoleAssignmentApproval
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
-        )
-        cls: ClsType[_models.RoleAssignmentApproval] = kwargs.pop("cls", None)
-
-        request = build_get_by_id_request(
-            approval_id=approval_id,
-            scope=scope,
-            api_version=api_version,
-            template_url=self.get_by_id.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-            raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("RoleAssignmentApproval", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
+        return ItemPaged(get_next, extract_data)
 
-    get_by_id.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentApprovals/{approvalId}"}
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_08_01_preview/aio/operations/_alert_operation_operations.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,139 +2,111 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
-import urllib.parse
+from typing import Any, Callable, Dict, Optional, TypeVar
 
-from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
 from azure.core.pipeline import PipelineResponse
 from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
-from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._operations import build_list_request
+from ...operations._alert_operation_operations import build_get_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class Operations:
+class AlertOperationOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2021_01_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`operations` attribute.
+        :class:`~azure.mgmt.authorization.v2022_08_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`alert_operation` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
-    @distributed_trace
-    def list(self, **kwargs: Any) -> AsyncIterable["_models.Operation"]:
-        """Lists the operations available from this provider.
-
+    @distributed_trace_async
+    async def get(self, scope: str, operation_id: str, **kwargs: Any) -> _models.AlertOperationResult:
+        """Get the specified alert operation.
+
+        :param scope: The scope of the alert operation. Required.
+        :type scope: str
+        :param operation_id: The id of the alert operation. Required.
+        :type operation_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either Operation or the result of cls(response)
-        :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_01_01_preview.models.Operation]
+        :return: AlertOperationResult or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_08_01_preview.models.AlertOperationResult
         :raises ~azure.core.exceptions.HttpResponseError:
         """
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2021-01-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2021-01-01-preview")
-        )
-        cls: ClsType[_models.OperationListResult] = kwargs.pop("cls", None)
-
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
-        def prepare_request(next_link=None):
-            if not next_link:
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-08-01-preview")
+        )
+        cls: ClsType[_models.AlertOperationResult] = kwargs.pop("cls", None)
+
+        request = build_get_request(
+            scope=scope,
+            operation_id=operation_id,
+            api_version=api_version,
+            template_url=self.get.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-                request = build_list_request(
-                    api_version=api_version,
-                    template_url=self.list.metadata["url"],
-                    headers=_headers,
-                    params=_params,
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-
-            else:
-                # make call to next link with the client's api-version
-                _parsed_next_link = urllib.parse.urlparse(next_link)
-                _next_request_params = case_insensitive_dict(
-                    {
-                        key: [urllib.parse.quote(v) for v in value]
-                        for key, value in urllib.parse.parse_qs(_parsed_next_link.query).items()
-                    }
-                )
-                _next_request_params["api-version"] = self._config.api_version
-                request = HttpRequest(
-                    "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
-                )
-                request = _convert_request(request)
-                request.url = self._client.format_url(request.url)
-                request.method = "GET"
-            return request
-
-        async def extract_data(pipeline_response):
-            deserialized = self._deserialize("OperationListResult", pipeline_response)
-            list_of_elem = deserialized.value
-            if cls:
-                list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, AsyncList(list_of_elem)
-
-        async def get_next(next_link=None):
-            request = prepare_request(next_link)
-
-            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
-            )
-            response = pipeline_response.http_response
-
-            if response.status_code not in [200]:
-                map_error(status_code=response.status_code, response=response, error_map=error_map)
-                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
-                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
+        deserialized = self._deserialize("AlertOperationResult", pipeline_response)
 
-            return pipeline_response
+        if cls:
+            return cls(pipeline_response, deserialized, {})
 
-        return AsyncItemPaged(get_next, extract_data)
+        return deserialized
 
-    list.metadata = {"url": "/providers/Microsoft.Authorization/operations"}
+    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleManagementAlertOperations/{operationId}"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2021_01_01_preview/models/_authorization_management_client_enums.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_01_01_preview/models/_authorization_management_client_enums.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/_authorization_management_client.py`

 * *Files 4% similar despite different names*

```diff
@@ -86,49 +86,49 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
         self.eligible_child_resources = EligibleChildResourcesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
         self.role_assignment_schedules = RoleAssignmentSchedulesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
         self.role_assignment_schedule_instances = RoleAssignmentScheduleInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
         self.role_assignment_schedule_requests = RoleAssignmentScheduleRequestsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
         self.role_eligibility_schedules = RoleEligibilitySchedulesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
         self.role_eligibility_schedule_instances = RoleEligibilityScheduleInstancesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
         self.role_eligibility_schedule_requests = RoleEligibilityScheduleRequestsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
         self.role_management_policies = RoleManagementPoliciesOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
         self.role_management_policy_assignments = RoleManagementPolicyAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-10-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_configuration.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -31,22 +25,22 @@
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2020-10-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2018-09-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop("api_version", "2020-10-01-preview")
+        api_version: str = kwargs.pop("api_version", "2018-09-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policy_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policy_assignments_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, role_management_policy_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments/{roleManagementPolicyAssignmentName}",
     )  # pylint: disable=line-too-long
@@ -73,17 +67,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_management_policy_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments/{roleManagementPolicyAssignmentName}",
@@ -108,17 +100,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(scope: str, role_management_policy_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments/{roleManagementPolicyAssignmentName}",
     )  # pylint: disable=line-too-long
@@ -140,17 +130,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementPolicyAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -180,14 +168,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(
         self, scope: str, role_management_policy_assignment_name: str, **kwargs: Any
     ) -> _models.RoleManagementPolicyAssignment:
         """Get the specified role management policy assignment for a resource scope.
 
@@ -208,32 +197,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleManagementPolicyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -340,24 +330,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleManagementPolicyAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleManagementPolicyAssignment")
 
         request = build_create_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
@@ -368,16 +358,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -416,32 +407,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -465,16 +457,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleManagementPolicyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -519,16 +511,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_requests_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_requests_operations.py`

 * *Files 7% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(scope: str, role_eligibility_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}",
@@ -76,17 +70,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_eligibility_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}",
     )  # pylint: disable=line-too-long
@@ -108,17 +100,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -136,17 +126,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(scope: str, role_eligibility_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleRequests/{roleEligibilityScheduleRequestName}/cancel",
     )  # pylint: disable=line-too-long
@@ -182,14 +170,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     def create(
         self,
         scope: str,
         role_eligibility_schedule_request_name: str,
         parameters: _models.RoleEligibilityScheduleRequest,
@@ -296,24 +285,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleEligibilityScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleEligibilityScheduleRequest")
 
         request = build_create_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
@@ -324,16 +313,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -372,32 +362,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleEligibilityScheduleRequest] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -435,16 +426,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilityScheduleRequest]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleEligibilityScheduleRequestListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -490,16 +481,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -532,32 +524,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_cancel_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
             api_version=api_version,
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignments_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,34 +26,28 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_for_subscription_request(
     subscription_id: str, *, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/roleAssignments"
     )
     path_format_arguments = {
@@ -82,17 +76,15 @@
     filter: Optional[str] = None,
     tenant_id: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -128,17 +120,15 @@
     filter: Optional[str] = None,
     tenant_id: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -171,17 +161,15 @@
 
 def build_get_request(
     scope: str, role_assignment_name: str, *, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str", skip_quote=True),
@@ -200,17 +188,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -232,17 +218,15 @@
 
 def build_delete_request(
     scope: str, role_assignment_name: str, *, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str", skip_quote=True),
@@ -261,17 +245,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}/validate"
     )  # pylint: disable=line-too-long
@@ -295,17 +277,15 @@
 
 def build_list_for_scope_request(
     scope: str, *, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -325,17 +305,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(role_assignment_id: str, *, tenant_id: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleAssignmentId}")
     path_format_arguments = {
         "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
     }
@@ -353,17 +331,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_by_id_request(role_assignment_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleAssignmentId}")
     path_format_arguments = {
         "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
@@ -384,17 +360,15 @@
 
 def build_delete_by_id_request(
     role_assignment_id: str, *, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleAssignmentId}")
     path_format_arguments = {
         "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
     }
@@ -412,17 +386,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_validate_by_id_request(role_assignment_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleAssignmentId}/validate")
     path_format_arguments = {
         "roleAssignmentId": _SERIALIZER.url("role_assignment_id", role_assignment_id, "str", skip_quote=True),
@@ -455,14 +427,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_subscription(
         self, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleAssignment"]:
         """List all role assignments that apply to a subscription.
 
@@ -477,16 +450,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -533,16 +506,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -575,16 +549,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -632,16 +606,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -688,16 +663,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -748,16 +723,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -799,16 +775,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
@@ -816,16 +792,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -943,24 +920,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -971,16 +948,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1028,16 +1006,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
@@ -1045,16 +1023,17 @@
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1174,24 +1153,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_validate_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -1202,16 +1181,17 @@
             template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1251,16 +1231,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -1307,16 +1287,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1353,32 +1334,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_assignment_id=role_assignment_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1476,24 +1458,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
@@ -1503,16 +1485,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1557,32 +1540,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_assignment_id=role_assignment_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1682,24 +1666,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_validate_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
@@ -1709,16 +1693,17 @@
             template_url=self.validate_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedules_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_eligibility_schedule_instances_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,195 +25,124 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_get_request(scope: str, role_eligibility_schedule_name: str, **kwargs: Any) -> HttpRequest:
+def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules/{roleEligibilityScheduleName}",
-    )  # pylint: disable=line-too-long
+    _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
-        "roleEligibilityScheduleName": _SERIALIZER.url(
-            "role_eligibility_schedule_name", role_eligibility_schedule_name, "str"
-        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
+def build_get_request(scope: str, role_eligibility_schedule_instance_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
-    _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules")
+    _url = kwargs.pop(
+        "template_url",
+        "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances/{roleEligibilityScheduleInstanceName}",
+    )  # pylint: disable=line-too-long
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
+        "roleEligibilityScheduleInstanceName": _SERIALIZER.url(
+            "role_eligibility_schedule_instance_name", role_eligibility_schedule_instance_name, "str"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
-    if filter is not None:
-        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class RoleEligibilitySchedulesOperations:
+class RoleEligibilityScheduleInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01_preview.AuthorizationManagementClient`'s
-        :attr:`role_eligibility_schedules` attribute.
+        :class:`~azure.mgmt.authorization.v2020_10_01.AuthorizationManagementClient`'s
+        :attr:`role_eligibility_schedule_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
-
-    @distributed_trace
-    def get(self, scope: str, role_eligibility_schedule_name: str, **kwargs: Any) -> _models.RoleEligibilitySchedule:
-        """Get the specified role eligibility schedule for a resource scope.
-
-        :param scope: The scope of the role eligibility schedule. Required.
-        :type scope: str
-        :param role_eligibility_schedule_name: The name (guid) of the role eligibility schedule to get.
-         Required.
-        :type role_eligibility_schedule_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: RoleEligibilitySchedule or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilitySchedule
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
-        cls: ClsType[_models.RoleEligibilitySchedule] = kwargs.pop("cls", None)
-
-        request = build_get_request(
-            scope=scope,
-            role_eligibility_schedule_name=role_eligibility_schedule_name,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("RoleEligibilitySchedule", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    get.metadata = {
-        "url": "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules/{roleEligibilityScheduleName}"
-    }
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> Iterable["_models.RoleEligibilitySchedule"]:
-        """Gets role eligibility schedules for a resource scope.
+    ) -> Iterable["_models.RoleEligibilityScheduleInstance"]:
+        """Gets role eligibility schedule instances of a role eligibility schedule.
 
-        :param scope: The scope of the role eligibility schedules. Required.
+        :param scope: The scope of the role eligibility schedule. Required.
         :type scope: str
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
-         eligibility schedules at or above the scope. Use $filter=principalId eq {id} to return all role
-         eligibility schedules at, above or below the scope for the specified principal. Use
+         assignment schedules at or above the scope. Use $filter=principalId eq {id} to return all role
+         assignment schedules at, above or below the scope for the specified principal. Use
          $filter=assignedTo('{userId}') to return all role eligibility schedules for the user. Use
          $filter=asTarget() to return all role eligibility schedules created for the current user.
          Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either RoleEligibilitySchedule or the result of
+        :return: An iterator like instance of either RoleEligibilityScheduleInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilitySchedule]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
-        cls: ClsType[_models.RoleEligibilityScheduleListResult] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
+        cls: ClsType[_models.RoleEligibilityScheduleInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -249,30 +177,94 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("RoleEligibilityScheduleListResult", pipeline_response)
+            deserialized = self._deserialize("RoleEligibilityScheduleInstanceListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules"}
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances"}
+
+    @distributed_trace
+    def get(
+        self, scope: str, role_eligibility_schedule_instance_name: str, **kwargs: Any
+    ) -> _models.RoleEligibilityScheduleInstance:
+        """Gets the specified role eligibility schedule instance.
+
+        :param scope: The scope of the role eligibility schedules. Required.
+        :type scope: str
+        :param role_eligibility_schedule_instance_name: The name (hash of schedule name + time) of the
+         role eligibility schedule to get. Required.
+        :type role_eligibility_schedule_instance_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: RoleEligibilityScheduleInstance or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleInstance
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
+        cls: ClsType[_models.RoleEligibilityScheduleInstance] = kwargs.pop("cls", None)
+
+        request = build_get_request(
+            scope=scope,
+            role_eligibility_schedule_instance_name=role_eligibility_schedule_instance_name,
+            api_version=api_version,
+            template_url=self.get.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("RoleEligibilityScheduleInstance", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
+
+    get.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances/{roleEligibilityScheduleInstanceName}"
+    }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedule_instances_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +25,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleInstances")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -69,17 +62,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_assignment_schedule_instance_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleInstances/{roleAssignmentScheduleInstanceName}",
     )  # pylint: disable=line-too-long
@@ -103,26 +94,27 @@
 
 class RoleAssignmentScheduleInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01.AuthorizationManagementClient`'s
         :attr:`role_assignment_schedule_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> Iterable["_models.RoleAssignmentScheduleInstance"]:
         """Gets role assignment schedule instances of a role assignment schedule.
 
@@ -135,23 +127,21 @@
          Use $filter=asTarget() to return all role assignment schedule instances created for the current
          user. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignmentScheduleInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleInstance]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentScheduleInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleAssignmentScheduleInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -196,16 +186,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -224,46 +215,45 @@
         :param scope: The scope of the role assignments schedules. Required.
         :type scope: str
         :param role_assignment_schedule_instance_name: The name (hash of schedule name + time) of the
          role assignment schedule to get. Required.
         :type role_assignment_schedule_instance_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentScheduleInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleInstance
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentScheduleInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleAssignmentScheduleInstance] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_schedule_instance_name=role_assignment_schedule_instance_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_eligibility_schedule_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/operations/_role_assignment_schedules_operations.py`

 * *Files 12% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,133 +25,185 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
-def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
+def build_get_request(scope: str, role_assignment_schedule_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
-    _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances")
+    _url = kwargs.pop(
+        "template_url",
+        "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules/{roleAssignmentScheduleName}",
+    )  # pylint: disable=line-too-long
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
+        "roleAssignmentScheduleName": _SERIALIZER.url(
+            "role_assignment_schedule_name", role_assignment_schedule_name, "str"
+        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
-    if filter is not None:
-        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-def build_get_request(scope: str, role_eligibility_schedule_instance_name: str, **kwargs: Any) -> HttpRequest:
+def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances/{roleEligibilityScheduleInstanceName}",
-    )  # pylint: disable=line-too-long
+    _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
-        "roleEligibilityScheduleInstanceName": _SERIALIZER.url(
-            "role_eligibility_schedule_instance_name", role_eligibility_schedule_instance_name, "str"
-        ),
     }
 
     _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
 
     # Construct parameters
+    if filter is not None:
+        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
     _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
-class RoleEligibilityScheduleInstancesOperations:
+class RoleAssignmentSchedulesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01_preview.AuthorizationManagementClient`'s
-        :attr:`role_eligibility_schedule_instances` attribute.
+        :class:`~azure.mgmt.authorization.v2020_10_01.AuthorizationManagementClient`'s
+        :attr:`role_assignment_schedules` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
+
+    @distributed_trace
+    def get(self, scope: str, role_assignment_schedule_name: str, **kwargs: Any) -> _models.RoleAssignmentSchedule:
+        """Get the specified role assignment schedule for a resource scope.
+
+        :param scope: The scope of the role assignment schedule. Required.
+        :type scope: str
+        :param role_assignment_schedule_name: The name (guid) of the role assignment schedule to get.
+         Required.
+        :type role_assignment_schedule_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: RoleAssignmentSchedule or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentSchedule
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
+        cls: ClsType[_models.RoleAssignmentSchedule] = kwargs.pop("cls", None)
+
+        request = build_get_request(
+            scope=scope,
+            role_assignment_schedule_name=role_assignment_schedule_name,
+            api_version=api_version,
+            template_url=self.get.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("RoleAssignmentSchedule", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
+
+    get.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules/{roleAssignmentScheduleName}"
+    }
 
     @distributed_trace
     def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> Iterable["_models.RoleEligibilityScheduleInstance"]:
-        """Gets role eligibility schedule instances of a role eligibility schedule.
+    ) -> Iterable["_models.RoleAssignmentSchedule"]:
+        """Gets role assignment schedules for a resource scope.
 
-        :param scope: The scope of the role eligibility schedule. Required.
+        :param scope: The scope of the role assignments schedules. Required.
         :type scope: str
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
          assignment schedules at or above the scope. Use $filter=principalId eq {id} to return all role
          assignment schedules at, above or below the scope for the specified principal. Use
-         $filter=assignedTo('{userId}') to return all role eligibility schedules for the user. Use
-         $filter=asTarget() to return all role eligibility schedules created for the current user.
+         $filter=assignedTo('{userId}') to return all role assignment schedules for the current user.
+         Use $filter=asTarget() to return all role assignment schedules created for the current user.
          Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either RoleEligibilityScheduleInstance or the result of
+        :return: An iterator like instance of either RoleAssignmentSchedule or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilityScheduleInstance]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentSchedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
-        cls: ClsType[_models.RoleEligibilityScheduleInstanceListResult] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
+        cls: ClsType[_models.RoleAssignmentScheduleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -187,94 +238,31 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         def extract_data(pipeline_response):
-            deserialized = self._deserialize("RoleEligibilityScheduleInstanceListResult", pipeline_response)
+            deserialized = self._deserialize("RoleAssignmentScheduleListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return ItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances"}
-
-    @distributed_trace
-    def get(
-        self, scope: str, role_eligibility_schedule_instance_name: str, **kwargs: Any
-    ) -> _models.RoleEligibilityScheduleInstance:
-        """Gets the specified role eligibility schedule instance.
-
-        :param scope: The scope of the role eligibility schedules. Required.
-        :type scope: str
-        :param role_eligibility_schedule_instance_name: The name (hash of schedule name + time) of the
-         role eligibility schedule to get. Required.
-        :type role_eligibility_schedule_instance_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: RoleEligibilityScheduleInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilityScheduleInstance
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
-        cls: ClsType[_models.RoleEligibilityScheduleInstance] = kwargs.pop("cls", None)
-
-        request = build_get_request(
-            scope=scope,
-            role_eligibility_schedule_instance_name=role_eligibility_schedule_instance_name,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("RoleEligibilityScheduleInstance", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    get.metadata = {
-        "url": "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances/{roleEligibilityScheduleInstanceName}"
-    }
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedule_requests_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_04_01_preview/operations/_role_assignment_schedule_requests_operations.py`

 * *Files 11% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_create_request(scope: str, role_assignment_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}",
@@ -76,17 +70,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_request(scope: str, role_assignment_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}",
     )  # pylint: disable=line-too-long
@@ -108,17 +100,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -136,17 +126,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_cancel_request(scope: str, role_assignment_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}/cancel",
     )  # pylint: disable=line-too-long
@@ -164,32 +152,66 @@
 
     # Construct headers
     _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
 
     return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
 
 
+def build_validate_request(scope: str, role_assignment_schedule_request_name: str, **kwargs: Any) -> HttpRequest:
+    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2022-04-01-preview"))
+    content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+    accept = _headers.pop("Accept", "application/json")
+
+    # Construct URL
+    _url = kwargs.pop(
+        "template_url",
+        "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}/validate",
+    )  # pylint: disable=line-too-long
+    path_format_arguments = {
+        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
+        "roleAssignmentScheduleRequestName": _SERIALIZER.url(
+            "role_assignment_schedule_request_name", role_assignment_schedule_request_name, "str"
+        ),
+    }
+
+    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
+
+    # Construct parameters
+    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
+
+    # Construct headers
+    if content_type is not None:
+        _headers["Content-Type"] = _SERIALIZER.header("content_type", content_type, "str")
+    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
+
+    return HttpRequest(method="POST", url=_url, params=_params, headers=_headers, **kwargs)
+
+
 class RoleAssignmentScheduleRequestsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01_preview.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2022_04_01_preview.AuthorizationManagementClient`'s
         :attr:`role_assignment_schedule_requests` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     def create(
         self,
         scope: str,
         role_assignment_schedule_request_name: str,
         parameters: _models.RoleAssignmentScheduleRequest,
@@ -208,21 +230,21 @@
          for a resource. Required.
         :type scope: str
         :param role_assignment_schedule_request_name: A GUID for the role assignment to create. The
          name must be unique and different for each role assignment. Required.
         :type role_assignment_schedule_request_name: str
         :param parameters: Parameters for the role assignment schedule request. Required.
         :type parameters:
-         ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleRequest
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     def create(
         self,
         scope: str,
@@ -248,15 +270,15 @@
         :param parameters: Parameters for the role assignment schedule request. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace
     def create(
         self,
         scope: str,
@@ -276,44 +298,44 @@
         :type scope: str
         :param role_assignment_schedule_request_name: A GUID for the role assignment to create. The
          name must be unique and different for each role assignment. Required.
         :type role_assignment_schedule_request_name: str
         :param parameters: Parameters for the role assignment schedule request. Is either a
          RoleAssignmentScheduleRequest type or a IO type. Required.
         :type parameters:
-         ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleRequest or IO
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentScheduleRequest")
 
         request = build_create_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
@@ -324,16 +346,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -358,46 +381,47 @@
         :param scope: The scope of the role assignment schedule request. Required.
         :type scope: str
         :param role_assignment_schedule_request_name: The name (guid) of the role assignment schedule
          request to get. Required.
         :type role_assignment_schedule_request_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentScheduleRequest or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleRequest
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -429,22 +453,22 @@
          for the current user. Use $filter=asApprover() to return all role assignment schedule requests
          where the current user is an approver. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignmentScheduleRequest or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleRequest]
+         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentScheduleRequestListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -490,16 +514,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -532,39 +557,185 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_cancel_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
             api_version=api_version,
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
         if cls:
             return cls(pipeline_response, None, {})
 
     cancel.metadata = {
         "url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}/cancel"
     }
+
+    @overload
+    def validate(
+        self,
+        scope: str,
+        role_assignment_schedule_request_name: str,
+        parameters: _models.RoleAssignmentScheduleRequest,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> _models.RoleAssignmentScheduleRequest:
+        """Validates a new role assignment schedule request.
+
+        :param scope: The scope of the role assignment request to validate. Required.
+        :type scope: str
+        :param role_assignment_schedule_request_name: The name of the role assignment request to
+         validate. Required.
+        :type role_assignment_schedule_request_name: str
+        :param parameters: Parameters for the role assignment schedule request. Required.
+        :type parameters:
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest
+        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: RoleAssignmentScheduleRequest or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @overload
+    def validate(
+        self,
+        scope: str,
+        role_assignment_schedule_request_name: str,
+        parameters: IO,
+        *,
+        content_type: str = "application/json",
+        **kwargs: Any
+    ) -> _models.RoleAssignmentScheduleRequest:
+        """Validates a new role assignment schedule request.
+
+        :param scope: The scope of the role assignment request to validate. Required.
+        :type scope: str
+        :param role_assignment_schedule_request_name: The name of the role assignment request to
+         validate. Required.
+        :type role_assignment_schedule_request_name: str
+        :param parameters: Parameters for the role assignment schedule request. Required.
+        :type parameters: IO
+        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
+         Default value is "application/json".
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: RoleAssignmentScheduleRequest or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+
+    @distributed_trace
+    def validate(
+        self,
+        scope: str,
+        role_assignment_schedule_request_name: str,
+        parameters: Union[_models.RoleAssignmentScheduleRequest, IO],
+        **kwargs: Any
+    ) -> _models.RoleAssignmentScheduleRequest:
+        """Validates a new role assignment schedule request.
+
+        :param scope: The scope of the role assignment request to validate. Required.
+        :type scope: str
+        :param role_assignment_schedule_request_name: The name of the role assignment request to
+         validate. Required.
+        :type role_assignment_schedule_request_name: str
+        :param parameters: Parameters for the role assignment schedule request. Is either a
+         RoleAssignmentScheduleRequest type or a IO type. Required.
+        :type parameters:
+         ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest or IO
+        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
+         Default value is None.
+        :paramtype content_type: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: RoleAssignmentScheduleRequest or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2022_04_01_preview.models.RoleAssignmentScheduleRequest
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2022-04-01-preview")
+        )
+        content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
+        cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
+
+        content_type = content_type or "application/json"
+        _json = None
+        _content = None
+        if isinstance(parameters, (IOBase, bytes)):
+            _content = parameters
+        else:
+            _json = self._serialize.body(parameters, "RoleAssignmentScheduleRequest")
+
+        request = build_validate_request(
+            scope=scope,
+            role_assignment_schedule_request_name=role_assignment_schedule_request_name,
+            api_version=api_version,
+            content_type=content_type,
+            json=_json,
+            content=_content,
+            template_url=self.validate.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("RoleAssignmentScheduleRequest", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
+
+    validate.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentScheduleRequests/{roleAssignmentScheduleRequestName}/validate"
+    }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_assignment_schedules_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedules_operations.py`

 * *Files 17% similar despite different names*

```diff
@@ -2,219 +2,152 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
-from typing import Any, Callable, Dict, Iterable, Optional, TypeVar
+from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
+from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
     ResourceNotFoundError,
     ResourceNotModifiedError,
     map_error,
 )
-from azure.core.paging import ItemPaged
 from azure.core.pipeline import PipelineResponse
-from azure.core.pipeline.transport import HttpResponse
+from azure.core.pipeline.transport import AsyncHttpResponse
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
+from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
-from .. import models as _models
-from ..._serialization import Serializer
-from .._vendor import _convert_request, _format_url_section
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-T = TypeVar("T")
-ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
-
-_SERIALIZER = Serializer()
-_SERIALIZER.client_side_validation = False
-
-
-def build_get_request(scope: str, role_assignment_schedule_name: str, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop(
-        "template_url",
-        "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules/{roleAssignmentScheduleName}",
-    )  # pylint: disable=line-too-long
-    path_format_arguments = {
-        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
-        "roleAssignmentScheduleName": _SERIALIZER.url(
-            "role_assignment_schedule_name", role_assignment_schedule_name, "str"
-        ),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
-
-
-def build_list_for_scope_request(scope: str, *, filter: Optional[str] = None, **kwargs: Any) -> HttpRequest:
-    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
-    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+from ... import models as _models
+from ..._vendor import _convert_request
+from ...operations._role_eligibility_schedules_operations import build_get_request, build_list_for_scope_request
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
-    accept = _headers.pop("Accept", "application/json")
-
-    # Construct URL
-    _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules")
-    path_format_arguments = {
-        "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
-    }
-
-    _url: str = _format_url_section(_url, **path_format_arguments)  # type: ignore
-
-    # Construct parameters
-    if filter is not None:
-        _params["$filter"] = _SERIALIZER.query("filter", filter, "str")
-    _params["api-version"] = _SERIALIZER.query("api_version", api_version, "str")
-
-    # Construct headers
-    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")
-
-    return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
+T = TypeVar("T")
+ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class RoleAssignmentSchedulesOperations:
+class RoleEligibilitySchedulesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01_preview.AuthorizationManagementClient`'s
-        :attr:`role_assignment_schedules` attribute.
+        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
+        :attr:`role_eligibility_schedules` attribute.
     """
 
     models = _models
 
-    def __init__(self, *args, **kwargs):
+    def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
-    @distributed_trace
-    def get(self, scope: str, role_assignment_schedule_name: str, **kwargs: Any) -> _models.RoleAssignmentSchedule:
-        """Get the specified role assignment schedule for a resource scope.
+    @distributed_trace_async
+    async def get(
+        self, scope: str, role_eligibility_schedule_name: str, **kwargs: Any
+    ) -> _models.RoleEligibilitySchedule:
+        """Get the specified role eligibility schedule for a resource scope.
 
-        :param scope: The scope of the role assignment schedule. Required.
+        :param scope: The scope of the role eligibility schedule. Required.
         :type scope: str
-        :param role_assignment_schedule_name: The name (guid) of the role assignment schedule to get.
+        :param role_eligibility_schedule_name: The name (guid) of the role eligibility schedule to get.
          Required.
-        :type role_assignment_schedule_name: str
+        :type role_eligibility_schedule_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: RoleAssignmentSchedule or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentSchedule
+        :return: RoleEligibilitySchedule or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilitySchedule
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
-        cls: ClsType[_models.RoleAssignmentSchedule] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
+        cls: ClsType[_models.RoleEligibilitySchedule] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
-            role_assignment_schedule_name=role_assignment_schedule_name,
+            role_eligibility_schedule_name=role_eligibility_schedule_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
-        pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
-        deserialized = self._deserialize("RoleAssignmentSchedule", pipeline_response)
+        deserialized = self._deserialize("RoleEligibilitySchedule", pipeline_response)
 
         if cls:
             return cls(pipeline_response, deserialized, {})
 
         return deserialized
 
     get.metadata = {
-        "url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules/{roleAssignmentScheduleName}"
+        "url": "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules/{roleEligibilityScheduleName}"
     }
 
     @distributed_trace
     def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> Iterable["_models.RoleAssignmentSchedule"]:
-        """Gets role assignment schedules for a resource scope.
+    ) -> AsyncIterable["_models.RoleEligibilitySchedule"]:
+        """Gets role eligibility schedules for a resource scope.
 
-        :param scope: The scope of the role assignments schedules. Required.
+        :param scope: The scope of the role eligibility schedules. Required.
         :type scope: str
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
-         assignment schedules at or above the scope. Use $filter=principalId eq {id} to return all role
-         assignment schedules at, above or below the scope for the specified principal. Use
-         $filter=assignedTo('{userId}') to return all role assignment schedules for the current user.
-         Use $filter=asTarget() to return all role assignment schedules created for the current user.
+         eligibility schedules at or above the scope. Use $filter=principalId eq {id} to return all role
+         eligibility schedules at, above or below the scope for the specified principal. Use
+         $filter=assignedTo('{userId}') to return all role eligibility schedules for the user. Use
+         $filter=asTarget() to return all role eligibility schedules created for the current user.
          Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either RoleAssignmentSchedule or the result of
+        :return: An iterator like instance of either RoleEligibilitySchedule or the result of
          cls(response)
         :rtype:
-         ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentSchedule]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilitySchedule]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
-        cls: ClsType[_models.RoleAssignmentScheduleListResult] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
+        cls: ClsType[_models.RoleEligibilityScheduleListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -248,31 +181,32 @@
                     "GET", urllib.parse.urljoin(next_link, _parsed_next_link.path), params=_next_request_params
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
-        def extract_data(pipeline_response):
-            deserialized = self._deserialize("RoleAssignmentScheduleListResult", pipeline_response)
+        async def extract_data(pipeline_response):
+            deserialized = self._deserialize("RoleEligibilityScheduleListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
-            return deserialized.next_link or None, iter(list_of_elem)
+            return deserialized.next_link or None, AsyncList(list_of_elem)
 
-        def get_next(next_link=None):
+        async def get_next(next_link=None):
             request = prepare_request(next_link)
 
-            pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+            _stream = False
+            pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
-        return ItemPaged(get_next, extract_data)
+        return AsyncItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleAssignmentSchedules"}
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules"}
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policies_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/_role_management_policies_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,32 +26,26 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
 def build_get_request(scope: str, role_management_policy_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies/{roleManagementPolicyName}"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -70,17 +64,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_update_request(scope: str, role_management_policy_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies/{roleManagementPolicyName}"
     )  # pylint: disable=line-too-long
@@ -102,17 +94,15 @@
     return HttpRequest(method="PATCH", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_request(scope: str, role_management_policy_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies/{roleManagementPolicyName}"
     )  # pylint: disable=line-too-long
     path_format_arguments = {
@@ -131,17 +121,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_list_for_scope_request(scope: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-10-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-10-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleManagementPolicies")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -171,14 +159,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def get(self, scope: str, role_management_policy_name: str, **kwargs: Any) -> _models.RoleManagementPolicy:
         """Get the specified role management policy for a resource scope.
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
@@ -197,32 +186,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleManagementPolicy] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -328,24 +318,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleManagementPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleManagementPolicy")
 
         request = build_update_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
@@ -356,16 +346,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -404,32 +395,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -453,16 +445,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleManagementPolicyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -507,16 +499,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_03_01_preview/_configuration.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2020-10-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2021-03-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop("api_version", "2020-10-01-preview")
+        api_version: str = kwargs.pop("api_version", "2021-03-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policy_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policy_assignments_operations.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -32,86 +32,82 @@
 from ...operations._role_management_policy_assignments_operations import (
     build_create_request,
     build_delete_request,
     build_get_request,
     build_list_for_scope_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleManagementPolicyAssignmentsOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
         :attr:`role_management_policy_assignments` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(
         self, scope: str, role_management_policy_assignment_name: str, **kwargs: Any
     ) -> _models.RoleManagementPolicyAssignment:
         """Get the specified role management policy assignment for a resource scope.
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
         :param role_management_policy_assignment_name: The name of format {guid_guid} the role
          management policy assignment to get. Required.
         :type role_management_policy_assignment_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicyAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleManagementPolicyAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -141,22 +137,21 @@
 
         :param scope: The scope of the role management policy assignment to upsert. Required.
         :type scope: str
         :param role_management_policy_assignment_name: The name of format {guid_guid} the role
          management policy assignment to upsert. Required.
         :type role_management_policy_assignment_name: str
         :param parameters: Parameters for the role management policy assignment. Required.
-        :type parameters:
-         ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment
+        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicyAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def create(
         self,
         scope: str,
@@ -176,15 +171,15 @@
         :param parameters: Parameters for the role management policy assignment. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicyAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def create(
         self,
         scope: str,
@@ -197,45 +192,43 @@
         :param scope: The scope of the role management policy assignment to upsert. Required.
         :type scope: str
         :param role_management_policy_assignment_name: The name of format {guid_guid} the role
          management policy assignment to upsert. Required.
         :type role_management_policy_assignment_name: str
         :param parameters: Parameters for the role management policy assignment. Is either a
          RoleManagementPolicyAssignment type or a IO type. Required.
-        :type parameters:
-         ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment or IO
+        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
+         or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicyAssignment or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleManagementPolicyAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleManagementPolicyAssignment")
 
         request = build_create_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
@@ -246,16 +239,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -294,32 +288,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_management_policy_assignment_name=role_management_policy_assignment_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -337,23 +330,21 @@
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleManagementPolicyAssignment or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicyAssignment]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicyAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleManagementPolicyAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -397,16 +388,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_requests_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedule_requests_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -32,18 +32,14 @@
 from ...operations._role_eligibility_schedule_requests_operations import (
     build_cancel_request,
     build_create_request,
     build_get_request,
     build_list_for_scope_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleEligibilityScheduleRequestsOperations:
     """
     .. warning::
@@ -58,14 +54,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     async def create(
         self,
         scope: str,
         role_eligibility_schedule_request_name: str,
         parameters: _models.RoleEligibilityScheduleRequest,
@@ -172,24 +169,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleEligibilityScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleEligibilityScheduleRequest")
 
         request = build_create_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
@@ -200,16 +197,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -248,32 +246,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleEligibilityScheduleRequest] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -311,16 +310,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilityScheduleRequest]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleEligibilityScheduleRequestListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -366,16 +365,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -408,32 +408,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_cancel_request(
             scope=scope,
             role_eligibility_schedule_request_name=role_eligibility_schedule_request_name,
             api_version=api_version,
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignments_operations.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -40,18 +40,14 @@
     build_list_for_resource_request,
     build_list_for_scope_request,
     build_list_for_subscription_request,
     build_validate_by_id_request,
     build_validate_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentsOperations:
     """
     .. warning::
@@ -66,14 +62,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_subscription(
         self, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleAssignment"]:
         """List all role assignments that apply to a subscription.
 
@@ -88,16 +85,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -144,16 +141,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -186,16 +184,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -243,16 +241,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -299,16 +298,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -359,16 +358,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -410,16 +410,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
@@ -427,16 +427,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -554,24 +555,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -582,16 +583,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -639,16 +641,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
@@ -656,16 +658,17 @@
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -785,24 +788,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_validate_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -813,16 +816,17 @@
             template_url=self.validate.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -862,16 +866,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -918,16 +922,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -964,32 +969,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_assignment_id=role_assignment_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1087,24 +1093,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
@@ -1114,16 +1120,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1168,32 +1175,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_assignment_id=role_assignment_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1293,24 +1301,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.ValidationResponse] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_validate_by_id_request(
             role_assignment_id=role_assignment_id,
             api_version=api_version,
@@ -1320,16 +1328,17 @@
             template_url=self.validate_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_eligibility_schedules_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_eligibility_schedule_instances_operations.py`

 * *Files 14% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -25,136 +24,70 @@
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.tracing.decorator_async import distributed_trace_async
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._role_eligibility_schedules_operations import build_get_request, build_list_for_scope_request
+from ...operations._role_eligibility_schedule_instances_operations import (
+    build_get_request,
+    build_list_for_scope_request,
+)
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class RoleEligibilitySchedulesOperations:
+class RoleEligibilityScheduleInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`role_eligibility_schedules` attribute.
+        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
+        :attr:`role_eligibility_schedule_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
-
-    @distributed_trace_async
-    async def get(
-        self, scope: str, role_eligibility_schedule_name: str, **kwargs: Any
-    ) -> _models.RoleEligibilitySchedule:
-        """Get the specified role eligibility schedule for a resource scope.
-
-        :param scope: The scope of the role eligibility schedule. Required.
-        :type scope: str
-        :param role_eligibility_schedule_name: The name (guid) of the role eligibility schedule to get.
-         Required.
-        :type role_eligibility_schedule_name: str
-        :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: RoleEligibilitySchedule or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilitySchedule
-        :raises ~azure.core.exceptions.HttpResponseError:
-        """
-        error_map = {
-            401: ClientAuthenticationError,
-            404: ResourceNotFoundError,
-            409: ResourceExistsError,
-            304: ResourceNotModifiedError,
-        }
-        error_map.update(kwargs.pop("error_map", {}) or {})
-
-        _headers = kwargs.pop("headers", {}) or {}
-        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
-
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
-        cls: ClsType[_models.RoleEligibilitySchedule] = kwargs.pop("cls", None)
-
-        request = build_get_request(
-            scope=scope,
-            role_eligibility_schedule_name=role_eligibility_schedule_name,
-            api_version=api_version,
-            template_url=self.get.metadata["url"],
-            headers=_headers,
-            params=_params,
-        )
-        request = _convert_request(request)
-        request.url = self._client.format_url(request.url)
-
-        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
-        )
-
-        response = pipeline_response.http_response
-
-        if response.status_code not in [200]:
-            map_error(status_code=response.status_code, response=response, error_map=error_map)
-            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
-
-        deserialized = self._deserialize("RoleEligibilitySchedule", pipeline_response)
-
-        if cls:
-            return cls(pipeline_response, deserialized, {})
-
-        return deserialized
-
-    get.metadata = {
-        "url": "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules/{roleEligibilityScheduleName}"
-    }
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.RoleEligibilitySchedule"]:
-        """Gets role eligibility schedules for a resource scope.
+    ) -> AsyncIterable["_models.RoleEligibilityScheduleInstance"]:
+        """Gets role eligibility schedule instances of a role eligibility schedule.
 
-        :param scope: The scope of the role eligibility schedules. Required.
+        :param scope: The scope of the role eligibility schedule. Required.
         :type scope: str
         :param filter: The filter to apply on the operation. Use $filter=atScope() to return all role
-         eligibility schedules at or above the scope. Use $filter=principalId eq {id} to return all role
-         eligibility schedules at, above or below the scope for the specified principal. Use
+         assignment schedules at or above the scope. Use $filter=principalId eq {id} to return all role
+         assignment schedules at, above or below the scope for the specified principal. Use
          $filter=assignedTo('{userId}') to return all role eligibility schedules for the user. Use
          $filter=asTarget() to return all role eligibility schedules created for the current user.
          Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either RoleEligibilitySchedule or the result of
+        :return: An iterator like instance of either RoleEligibilityScheduleInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleEligibilitySchedule]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
-        cls: ClsType[_models.RoleEligibilityScheduleListResult] = kwargs.pop("cls", None)
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
+        cls: ClsType[_models.RoleEligibilityScheduleInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
@@ -189,30 +122,94 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("RoleEligibilityScheduleListResult", pipeline_response)
+            deserialized = self._deserialize("RoleEligibilityScheduleInstanceListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleEligibilitySchedules"}
+    list_for_scope.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances"}
+
+    @distributed_trace_async
+    async def get(
+        self, scope: str, role_eligibility_schedule_instance_name: str, **kwargs: Any
+    ) -> _models.RoleEligibilityScheduleInstance:
+        """Gets the specified role eligibility schedule instance.
+
+        :param scope: The scope of the role eligibility schedules. Required.
+        :type scope: str
+        :param role_eligibility_schedule_instance_name: The name (hash of schedule name + time) of the
+         role eligibility schedule to get. Required.
+        :type role_eligibility_schedule_instance_name: str
+        :keyword callable cls: A custom type or function that will be passed the direct response
+        :return: RoleEligibilityScheduleInstance or the result of cls(response)
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleEligibilityScheduleInstance
+        :raises ~azure.core.exceptions.HttpResponseError:
+        """
+        error_map = {
+            401: ClientAuthenticationError,
+            404: ResourceNotFoundError,
+            409: ResourceExistsError,
+            304: ResourceNotModifiedError,
+        }
+        error_map.update(kwargs.pop("error_map", {}) or {})
+
+        _headers = kwargs.pop("headers", {}) or {}
+        _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
+
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
+        cls: ClsType[_models.RoleEligibilityScheduleInstance] = kwargs.pop("cls", None)
+
+        request = build_get_request(
+            scope=scope,
+            role_eligibility_schedule_instance_name=role_eligibility_schedule_instance_name,
+            api_version=api_version,
+            template_url=self.get.metadata["url"],
+            headers=_headers,
+            params=_params,
+        )
+        request = _convert_request(request)
+        request.url = self._client.format_url(request.url)
+
+        _stream = False
+        pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
+            request, stream=_stream, **kwargs
+        )
+
+        response = pipeline_response.http_response
+
+        if response.status_code not in [200]:
+            map_error(status_code=response.status_code, response=response, error_map=error_map)
+            raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+
+        deserialized = self._deserialize("RoleEligibilityScheduleInstance", pipeline_response)
+
+        if cls:
+            return cls(pipeline_response, deserialized, {})
+
+        return deserialized
+
+    get.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/roleEligibilityScheduleInstances/{roleEligibilityScheduleInstanceName}"
+    }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_instances_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_assignment_schedule_instances_operations.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -27,40 +26,37 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
 from ...operations._role_assignment_schedule_instances_operations import build_get_request, build_list_for_scope_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentScheduleInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
         :attr:`role_assignment_schedule_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_scope(
         self, scope: str, filter: Optional[str] = None, **kwargs: Any
     ) -> AsyncIterable["_models.RoleAssignmentScheduleInstance"]:
         """Gets role assignment schedule instances of a role assignment schedule.
 
@@ -73,23 +69,21 @@
          Use $filter=asTarget() to return all role assignment schedule instances created for the current
          user. Default value is None.
         :type filter: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleAssignmentScheduleInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleInstance]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentScheduleInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleAssignmentScheduleInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -134,16 +128,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -162,46 +157,45 @@
         :param scope: The scope of the role assignments schedules. Required.
         :type scope: str
         :param role_assignment_schedule_instance_name: The name (hash of schedule name + time) of the
          role assignment schedule to get. Required.
         :type role_assignment_schedule_instance_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleAssignmentScheduleInstance or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleInstance
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleAssignmentScheduleInstance
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleAssignmentScheduleInstance] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_schedule_instance_name=role_assignment_schedule_instance_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_requests_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_assignment_schedule_requests_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -32,18 +32,14 @@
 from ...operations._role_assignment_schedule_requests_operations import (
     build_cancel_request,
     build_create_request,
     build_get_request,
     build_list_for_scope_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentScheduleRequestsOperations:
     """
     .. warning::
@@ -58,14 +54,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @overload
     async def create(
         self,
         scope: str,
         role_assignment_schedule_request_name: str,
         parameters: _models.RoleAssignmentScheduleRequest,
@@ -172,24 +169,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentScheduleRequest")
 
         request = build_create_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
@@ -200,16 +197,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -248,32 +246,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentScheduleRequest] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -311,16 +310,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleAssignmentScheduleRequest]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentScheduleRequestListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -366,16 +365,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
 
@@ -408,32 +408,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-10-01-preview")
         )
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_cancel_request(
             scope=scope,
             role_assignment_schedule_request_name=role_assignment_schedule_request_name,
             api_version=api_version,
             template_url=self.cancel.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_role_management_policies_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01/aio/operations/_role_management_policies_operations.py`

 * *Files 4% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -32,84 +32,80 @@
 from ...operations._role_management_policies_operations import (
     build_delete_request,
     build_get_request,
     build_list_for_scope_request,
     build_update_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleManagementPoliciesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
+        :class:`~azure.mgmt.authorization.v2020_10_01.aio.AuthorizationManagementClient`'s
         :attr:`role_management_policies` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace_async
     async def get(self, scope: str, role_management_policy_name: str, **kwargs: Any) -> _models.RoleManagementPolicy:
         """Get the specified role management policy for a resource scope.
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
         :param role_management_policy_name: The name (guid) of the role management policy to get.
          Required.
         :type role_management_policy_name: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicy or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleManagementPolicy] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
             api_version=api_version,
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -139,21 +135,21 @@
 
         :param scope: The scope of the role management policy to upsert. Required.
         :type scope: str
         :param role_management_policy_name: The name (guid) of the role management policy to upsert.
          Required.
         :type role_management_policy_name: str
         :param parameters: Parameters for the role management policy. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy
+        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy
         :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicy or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @overload
     async def update(
         self,
         scope: str,
@@ -173,15 +169,15 @@
         :param parameters: Parameters for the role management policy. Required.
         :type parameters: IO
         :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
          Default value is "application/json".
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicy or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
 
     @distributed_trace_async
     async def update(
         self,
         scope: str,
@@ -194,45 +190,42 @@
         :param scope: The scope of the role management policy to upsert. Required.
         :type scope: str
         :param role_management_policy_name: The name (guid) of the role management policy to upsert.
          Required.
         :type role_management_policy_name: str
         :param parameters: Parameters for the role management policy. Is either a RoleManagementPolicy
          type or a IO type. Required.
-        :type parameters: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy or
-         IO
+        :type parameters: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy or IO
         :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
          Default value is None.
         :paramtype content_type: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: RoleManagementPolicy or the result of cls(response)
-        :rtype: ~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy
+        :rtype: ~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleManagementPolicy] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleManagementPolicy")
 
         request = build_update_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
@@ -243,16 +236,17 @@
             template_url=self.update.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -291,32 +285,31 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[None] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_management_policy_name=role_management_policy_name,
             api_version=api_version,
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             raise HttpResponseError(response=response, error_format=ARMErrorFormat)
@@ -334,23 +327,21 @@
 
         :param scope: The scope of the role management policy. Required.
         :type scope: str
         :keyword callable cls: A custom type or function that will be passed the direct response
         :return: An iterator like instance of either RoleManagementPolicy or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.RoleManagementPolicy]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01.models.RoleManagementPolicy]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
-        )
+        api_version: str = kwargs.pop("api_version", _params.pop("api-version", self._api_version or "2020-10-01"))
         cls: ClsType[_models.RoleManagementPolicyListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
@@ -394,16 +385,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 raise HttpResponseError(response=response, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/aio/operations/_eligible_child_resources_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2021_12_01_preview/aio/operations/_scope_access_review_history_definition_instances_operations.py`

 * *Files 27% similar despite different names*

```diff
@@ -2,15 +2,14 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
 from typing import Any, AsyncIterable, Callable, Dict, Optional, TypeVar
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -24,87 +23,81 @@
 from azure.core.rest import HttpRequest
 from azure.core.tracing.decorator import distributed_trace
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from ... import models as _models
 from ..._vendor import _convert_request
-from ...operations._eligible_child_resources_operations import build_get_request
+from ...operations._scope_access_review_history_definition_instances_operations import build_list_request
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
-class EligibleChildResourcesOperations:
+class ScopeAccessReviewHistoryDefinitionInstancesOperations:
     """
     .. warning::
         **DO NOT** instantiate this class directly.
 
         Instead, you should access the following operations through
-        :class:`~azure.mgmt.authorization.v2020_10_01_preview.aio.AuthorizationManagementClient`'s
-        :attr:`eligible_child_resources` attribute.
+        :class:`~azure.mgmt.authorization.v2021_12_01_preview.aio.AuthorizationManagementClient`'s
+        :attr:`scope_access_review_history_definition_instances` attribute.
     """
 
     models = _models
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
-    def get(
-        self, scope: str, filter: Optional[str] = None, **kwargs: Any
-    ) -> AsyncIterable["_models.EligibleChildResource"]:
-        """Get the child resources of a resource on which user has eligible access.
+    def list(
+        self, scope: str, history_definition_id: str, **kwargs: Any
+    ) -> AsyncIterable["_models.AccessReviewHistoryInstance"]:
+        """Get access review history definition instances by definition Id.
 
-        :param scope: The scope of the role management policy. Required.
+        :param scope: The scope of the resource. Required.
         :type scope: str
-        :param filter: The filter to apply on the operation. Use $filter=resourceType+eq+'Subscription'
-         to filter on only resource of type = 'Subscription'. Use
-         $filter=resourceType+eq+'subscription'+or+resourceType+eq+'resourcegroup' to filter on resource
-         of type = 'Subscription' or 'ResourceGroup'. Default value is None.
-        :type filter: str
+        :param history_definition_id: The id of the access review history definition. Required.
+        :type history_definition_id: str
         :keyword callable cls: A custom type or function that will be passed the direct response
-        :return: An iterator like instance of either EligibleChildResource or the result of
+        :return: An iterator like instance of either AccessReviewHistoryInstance or the result of
          cls(response)
         :rtype:
-         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_10_01_preview.models.EligibleChildResource]
+         ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2021_12_01_preview.models.AccessReviewHistoryInstance]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-10-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-10-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2021-12-01-preview")
         )
-        cls: ClsType[_models.EligibleChildResourcesListResult] = kwargs.pop("cls", None)
+        cls: ClsType[_models.AccessReviewHistoryDefinitionInstanceListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         def prepare_request(next_link=None):
             if not next_link:
 
-                request = build_get_request(
+                request = build_list_request(
                     scope=scope,
-                    filter=filter,
+                    history_definition_id=history_definition_id,
                     api_version=api_version,
-                    template_url=self.get.metadata["url"],
+                    template_url=self.list.metadata["url"],
                     headers=_headers,
                     params=_params,
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
 
             else:
@@ -122,30 +115,34 @@
                 )
                 request = _convert_request(request)
                 request.url = self._client.format_url(request.url)
                 request.method = "GET"
             return request
 
         async def extract_data(pipeline_response):
-            deserialized = self._deserialize("EligibleChildResourcesListResult", pipeline_response)
+            deserialized = self._deserialize("AccessReviewHistoryDefinitionInstanceListResult", pipeline_response)
             list_of_elem = deserialized.value
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
-                raise HttpResponseError(response=response, error_format=ARMErrorFormat)
+                error = self._deserialize.failsafe_deserialize(_models.ErrorDefinition, pipeline_response)
+                raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
 
             return pipeline_response
 
         return AsyncItemPaged(get_next, extract_data)
 
-    get.metadata = {"url": "/{scope}/providers/Microsoft.Authorization/eligibleChildResources"}
+    list.metadata = {
+        "url": "/{scope}/providers/Microsoft.Authorization/accessReviewHistoryDefinitions/{historyDefinitionId}/instances"
+    }
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/_models_py3.py`

 * *Files 0% similar despite different names*

```diff
@@ -16,20 +16,21 @@
     # pylint: disable=unused-import,ungrouped-imports
     from .. import models as _models
 
 
 class ApprovalSettings(_serialization.Model):
     """The approval settings.
 
-    :ivar is_approval_required: Determine whether approval is required or not.
+    :ivar is_approval_required: Determines whether approval is required or not.
     :vartype is_approval_required: bool
-    :ivar is_approval_required_for_extension: Determine whether approval is required for assignment
-     extension.
+    :ivar is_approval_required_for_extension: Determines whether approval is required for
+     assignment extension.
     :vartype is_approval_required_for_extension: bool
-    :ivar is_requestor_justification_required: Determine whether requestor justification required.
+    :ivar is_requestor_justification_required: Determine whether requestor justification is
+     required.
     :vartype is_requestor_justification_required: bool
     :ivar approval_mode: The type of rule. Known values are: "SingleStage", "Serial", "Parallel",
      and "NoApproval".
     :vartype approval_mode: str or
      ~azure.mgmt.authorization.v2020_10_01_preview.models.ApprovalMode
     :ivar approval_stages: The approval stages of the request.
     :vartype approval_stages:
@@ -51,20 +52,20 @@
         is_approval_required_for_extension: Optional[bool] = None,
         is_requestor_justification_required: Optional[bool] = None,
         approval_mode: Optional[Union[str, "_models.ApprovalMode"]] = None,
         approval_stages: Optional[List["_models.ApprovalStage"]] = None,
         **kwargs: Any
     ) -> None:
         """
-        :keyword is_approval_required: Determine whether approval is required or not.
+        :keyword is_approval_required: Determines whether approval is required or not.
         :paramtype is_approval_required: bool
-        :keyword is_approval_required_for_extension: Determine whether approval is required for
+        :keyword is_approval_required_for_extension: Determines whether approval is required for
          assignment extension.
         :paramtype is_approval_required_for_extension: bool
-        :keyword is_requestor_justification_required: Determine whether requestor justification
+        :keyword is_requestor_justification_required: Determine whether requestor justification is
          required.
         :paramtype is_requestor_justification_required: bool
         :keyword approval_mode: The type of rule. Known values are: "SingleStage", "Serial",
          "Parallel", and "NoApproval".
         :paramtype approval_mode: str or
          ~azure.mgmt.authorization.v2020_10_01_preview.models.ApprovalMode
         :keyword approval_stages: The approval stages of the request.
@@ -81,19 +82,19 @@
 
 class ApprovalStage(_serialization.Model):
     """The approval stage.
 
     :ivar approval_stage_time_out_in_days: The time in days when approval request would be timed
      out.
     :vartype approval_stage_time_out_in_days: int
-    :ivar is_approver_justification_required: Determine whether approver need to provide
+    :ivar is_approver_justification_required: Determines whether approver need to provide
      justification for his decision.
     :vartype is_approver_justification_required: bool
     :ivar escalation_time_in_minutes: The time in minutes when the approval request would be
-     escalated if the primary approver does not approves.
+     escalated if the primary approver does not approve.
     :vartype escalation_time_in_minutes: int
     :ivar primary_approvers: The primary approver of the request.
     :vartype primary_approvers: list[~azure.mgmt.authorization.v2020_10_01_preview.models.UserSet]
     :ivar is_escalation_enabled: The value determine whether escalation feature is enabled.
     :vartype is_escalation_enabled: bool
     :ivar escalation_approvers: The escalation approver of the request.
     :vartype escalation_approvers:
@@ -120,19 +121,19 @@
         escalation_approvers: Optional[List["_models.UserSet"]] = None,
         **kwargs: Any
     ) -> None:
         """
         :keyword approval_stage_time_out_in_days: The time in days when approval request would be timed
          out.
         :paramtype approval_stage_time_out_in_days: int
-        :keyword is_approver_justification_required: Determine whether approver need to provide
+        :keyword is_approver_justification_required: Determines whether approver need to provide
          justification for his decision.
         :paramtype is_approver_justification_required: bool
         :keyword escalation_time_in_minutes: The time in minutes when the approval request would be
-         escalated if the primary approver does not approves.
+         escalated if the primary approver does not approve.
         :paramtype escalation_time_in_minutes: int
         :keyword primary_approvers: The primary approver of the request.
         :paramtype primary_approvers:
          list[~azure.mgmt.authorization.v2020_10_01_preview.models.UserSet]
         :keyword is_escalation_enabled: The value determine whether escalation feature is enabled.
         :paramtype is_escalation_enabled: bool
         :keyword escalation_approvers: The escalation approver of the request.
@@ -2998,15 +2999,15 @@
         super().__init__(**kwargs)
         self.id = id
         self.rule_type: Optional[str] = None
         self.target = target
 
 
 class RoleManagementPolicyApprovalRule(RoleManagementPolicyRule):
-    """The role management policy rule.
+    """The role management policy approval rule.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar id: The id of the rule.
     :vartype id: str
     :ivar rule_type: The type of rule. Required. Known values are:
      "RoleManagementPolicyApprovalRule", "RoleManagementPolicyAuthenticationContextRule",
@@ -3153,15 +3154,15 @@
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
 class RoleManagementPolicyAuthenticationContextRule(RoleManagementPolicyRule):
-    """The role management policy rule.
+    """The role management policy authentication context rule.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar id: The id of the rule.
     :vartype id: str
     :ivar rule_type: The type of rule. Required. Known values are:
      "RoleManagementPolicyApprovalRule", "RoleManagementPolicyAuthenticationContextRule",
@@ -3268,15 +3269,15 @@
         """
         super().__init__(id=id, target=target, **kwargs)
         self.rule_type: str = "RoleManagementPolicyEnablementRule"
         self.enabled_rules = enabled_rules
 
 
 class RoleManagementPolicyExpirationRule(RoleManagementPolicyRule):
-    """The role management policy rule.
+    """The role management policy expiration rule.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar id: The id of the rule.
     :vartype id: str
     :ivar rule_type: The type of rule. Required. Known values are:
      "RoleManagementPolicyApprovalRule", "RoleManagementPolicyAuthenticationContextRule",
@@ -3361,15 +3362,15 @@
         """
         super().__init__(**kwargs)
         self.value = value
         self.next_link = next_link
 
 
 class RoleManagementPolicyNotificationRule(RoleManagementPolicyRule):
-    """The role management policy rule.
+    """The role management policy notification rule.
 
     All required parameters must be populated in order to send to Azure.
 
     :ivar id: The id of the rule.
     :vartype id: str
     :ivar rule_type: The type of rule. Required. Known values are:
      "RoleManagementPolicyApprovalRule", "RoleManagementPolicyAuthenticationContextRule",
@@ -3387,18 +3388,18 @@
      "All".
     :vartype notification_level: str or
      ~azure.mgmt.authorization.v2020_10_01_preview.models.NotificationLevel
     :ivar recipient_type: The recipient type. Known values are: "Requestor", "Approver", and
      "Admin".
     :vartype recipient_type: str or
      ~azure.mgmt.authorization.v2020_10_01_preview.models.RecipientType
-    :ivar notification_recipients: The list notification recipients.
+    :ivar notification_recipients: The list of notification recipients.
     :vartype notification_recipients: list[str]
-    :ivar is_default_recipients_enabled: Its value determine if the notification need to be sent to
-     the recipient type specified in policy rule.
+    :ivar is_default_recipients_enabled: Determines if the notification will be sent to the
+     recipient type specified in the policy rule.
     :vartype is_default_recipients_enabled: bool
     """
 
     _validation = {
         "rule_type": {"required": True},
     }
 
@@ -3438,18 +3439,18 @@
          "All".
         :paramtype notification_level: str or
          ~azure.mgmt.authorization.v2020_10_01_preview.models.NotificationLevel
         :keyword recipient_type: The recipient type. Known values are: "Requestor", "Approver", and
          "Admin".
         :paramtype recipient_type: str or
          ~azure.mgmt.authorization.v2020_10_01_preview.models.RecipientType
-        :keyword notification_recipients: The list notification recipients.
+        :keyword notification_recipients: The list of notification recipients.
         :paramtype notification_recipients: list[str]
-        :keyword is_default_recipients_enabled: Its value determine if the notification need to be sent
-         to the recipient type specified in policy rule.
+        :keyword is_default_recipients_enabled: Determines if the notification will be sent to the
+         recipient type specified in the policy rule.
         :paramtype is_default_recipients_enabled: bool
         """
         super().__init__(id=id, target=target, **kwargs)
         self.rule_type: str = "RoleManagementPolicyNotificationRule"
         self.notification_type = notification_type
         self.notification_level = notification_level
         self.recipient_type = recipient_type
@@ -3460,15 +3461,15 @@
 class RoleManagementPolicyRuleTarget(_serialization.Model):
     """The role management policy rule target.
 
     :ivar caller: The caller of the setting.
     :vartype caller: str
     :ivar operations: The type of operation.
     :vartype operations: list[str]
-    :ivar level: The assignment level to which it is applied.
+    :ivar level: The assignment level to which rule is applied.
     :vartype level: str
     :ivar target_objects: The list of target objects.
     :vartype target_objects: list[str]
     :ivar inheritable_settings: The list of inheritable settings.
     :vartype inheritable_settings: list[str]
     :ivar enforced_settings: The list of enforced settings.
     :vartype enforced_settings: list[str]
@@ -3495,15 +3496,15 @@
         **kwargs: Any
     ) -> None:
         """
         :keyword caller: The caller of the setting.
         :paramtype caller: str
         :keyword operations: The type of operation.
         :paramtype operations: list[str]
-        :keyword level: The assignment level to which it is applied.
+        :keyword level: The assignment level to which rule is applied.
         :paramtype level: str
         :keyword target_objects: The list of target objects.
         :paramtype target_objects: list[str]
         :keyword inheritable_settings: The list of inheritable settings.
         :paramtype inheritable_settings: list[str]
         :keyword enforced_settings: The list of enforced settings.
         :paramtype enforced_settings: list[str]
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2015_07_01/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_10_01_preview/models/_authorization_management_client_enums.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_10_01_preview/models/_authorization_management_client_enums.py`

 * *Files 2% similar despite different names*

```diff
@@ -23,15 +23,15 @@
     """Assignment type of the role assignment schedule."""
 
     ACTIVATED = "Activated"
     ASSIGNED = "Assigned"
 
 
 class EnablementRules(str, Enum, metaclass=CaseInsensitiveEnumMeta):
-    """The type of enable rules."""
+    """The type of enablement rule."""
 
     MULTI_FACTOR_AUTHENTICATION = "MultiFactorAuthentication"
     JUSTIFICATION = "Justification"
     TICKETING = "Ticketing"
 
 
 class MemberType(str, Enum, metaclass=CaseInsensitiveEnumMeta):
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_vendor.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_vendor.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_09_01_preview/_authorization_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -25,44 +25,44 @@
 class AuthorizationManagementClient:  # pylint: disable=client-accepts-api-version-keyword
     """Role based access control provides you a way to apply granular level policy administration down
     to individual resources or resource groups. These operations enable you to manage role
     assignments. A role assignment grants access to Azure Active Directory users.
 
     :ivar role_assignments: RoleAssignmentsOperations operations
     :vartype role_assignments:
-     azure.mgmt.authorization.v2020_04_01_preview.operations.RoleAssignmentsOperations
+     azure.mgmt.authorization.v2018_09_01_preview.operations.RoleAssignmentsOperations
     :param credential: Credential needed for the client to connect to Azure. Required.
     :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
     :param base_url: Service URL. Default value is "https://management.azure.com".
     :type base_url: str
-    :keyword api_version: Api Version. Default value is "2020-04-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2018-09-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(
         self,
         credential: "TokenCredential",
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: ARMPipelineClient = ARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2018-09-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> HttpResponse:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/_configuration.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,28 +2,22 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
 from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
 from ._version import VERSION
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
-
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
     from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
@@ -38,15 +32,15 @@
     :keyword api_version: Api Version. Default value is "2020-04-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
     def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop("api_version", "2020-04-01-preview")
+        api_version: str = kwargs.pop("api_version", "2020-04-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/_role_assignments_operations.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, Callable, Dict, IO, Iterable, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
     ResourceExistsError,
@@ -26,18 +26,14 @@
 from azure.core.utils import case_insensitive_dict
 from azure.mgmt.core.exceptions import ARMErrorFormat
 
 from .. import models as _models
 from ..._serialization import Serializer
 from .._vendor import _convert_request, _format_url_section
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]
 
 _SERIALIZER = Serializer()
 _SERIALIZER.client_side_validation = False
 
 
@@ -52,17 +48,15 @@
     filter: Optional[str] = None,
     tenant_id: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-04-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{parentResourcePath}/{resourceType}/{resourceName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -101,17 +95,15 @@
     filter: Optional[str] = None,
     tenant_id: Optional[str] = None,
     **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-04-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url",
         "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Authorization/roleAssignments",
     )  # pylint: disable=line-too-long
@@ -139,17 +131,15 @@
 
 def build_delete_request(
     scope: str, role_assignment_name: str, *, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-04-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
@@ -168,17 +158,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_request(scope: str, role_assignment_name: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-04-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
@@ -200,17 +188,15 @@
 
 def build_get_request(
     scope: str, role_assignment_name: str, *, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-04-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments/{roleAssignmentName}")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
         "roleAssignmentName": _SERIALIZER.url("role_assignment_name", role_assignment_name, "str"),
@@ -229,17 +215,15 @@
     return HttpRequest(method="GET", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_delete_by_id_request(role_id: str, *, tenant_id: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-04-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
     }
@@ -257,17 +241,15 @@
     return HttpRequest(method="DELETE", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_create_by_id_request(role_id: str, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-04-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01-preview"))
     content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
@@ -286,17 +268,15 @@
     return HttpRequest(method="PUT", url=_url, params=_params, headers=_headers, **kwargs)
 
 
 def build_get_by_id_request(role_id: str, *, tenant_id: Optional[str] = None, **kwargs: Any) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-04-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{roleId}")
     path_format_arguments = {
         "roleId": _SERIALIZER.url("role_id", role_id, "str", skip_quote=True),
     }
@@ -316,17 +296,15 @@
 
 def build_list_request(
     subscription_id: str, *, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-04-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop(
         "template_url", "/subscriptions/{subscriptionId}/providers/Microsoft.Authorization/roleAssignments"
     )
     path_format_arguments = {
@@ -350,17 +328,15 @@
 
 def build_list_for_scope_request(
     scope: str, *, filter: Optional[str] = None, tenant_id: Optional[str] = None, **kwargs: Any
 ) -> HttpRequest:
     _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
     _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-    api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-        "api_version", _params.pop("api-version", "2020-04-01-preview")
-    )
+    api_version: str = kwargs.pop("api_version", _params.pop("api-version", "2020-04-01-preview"))
     accept = _headers.pop("Accept", "application/json")
 
     # Construct URL
     _url = kwargs.pop("template_url", "/{scope}/providers/Microsoft.Authorization/roleAssignments")
     path_format_arguments = {
         "scope": _SERIALIZER.url("scope", scope, "str", skip_quote=True),
     }
@@ -394,14 +370,15 @@
 
     def __init__(self, *args, **kwargs):
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -435,16 +412,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_04_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -496,16 +473,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -538,16 +516,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_04_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -595,16 +573,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -641,16 +620,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
@@ -658,16 +637,17 @@
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -790,24 +770,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -818,16 +798,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -866,16 +847,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
@@ -883,16 +864,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -929,32 +911,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_id=role_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1042,24 +1025,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_id=role_id,
             api_version=api_version,
@@ -1069,16 +1052,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1113,32 +1097,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_id=role_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -1170,16 +1155,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_04_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -1226,16 +1211,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -1265,16 +1251,16 @@
         :rtype:
          ~azure.core.paging.ItemPaged[~azure.mgmt.authorization.v2020_04_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -1321,16 +1307,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, iter(list_of_elem)
 
         def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/_authorization_management_client.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/_authorization_management_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -47,22 +47,22 @@
         subscription_id: str,
         base_url: str = "https://management.azure.com",
         **kwargs: Any
     ) -> None:
         self._config = AuthorizationManagementClientConfiguration(
             credential=credential, subscription_id=subscription_id, **kwargs
         )
-        self._client = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
+        self._client: AsyncARMPipelineClient = AsyncARMPipelineClient(base_url=base_url, config=self._config, **kwargs)
 
         client_models = {k: v for k, v in _models.__dict__.items() if isinstance(v, type)}
         self._serialize = Serializer(client_models)
         self._deserialize = Deserializer(client_models)
         self._serialize.client_side_validation = False
         self.role_assignments = RoleAssignmentsOperations(
-            self._client, self._config, self._serialize, self._deserialize
+            self._client, self._config, self._serialize, self._deserialize, "2020-04-01-preview"
         )
 
     def _send_request(self, request: HttpRequest, **kwargs: Any) -> Awaitable[AsyncHttpResponse]:
         """Runs the network request through the client's chained policies.
 
         >>> from azure.core.rest import HttpRequest
         >>> request = HttpRequest("GET", "https://www.example.org/")
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/_configuration.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2022_05_01_preview/_configuration.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,51 +2,45 @@
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
 
-import sys
 from typing import Any, TYPE_CHECKING
 
 from azure.core.configuration import Configuration
 from azure.core.pipeline import policies
-from azure.mgmt.core.policies import ARMHttpLoggingPolicy, AsyncARMChallengeAuthenticationPolicy
+from azure.mgmt.core.policies import ARMChallengeAuthenticationPolicy, ARMHttpLoggingPolicy
 
-from .._version import VERSION
-
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
+from ._version import VERSION
 
 if TYPE_CHECKING:
     # pylint: disable=unused-import,ungrouped-imports
-    from azure.core.credentials_async import AsyncTokenCredential
+    from azure.core.credentials import TokenCredential
 
 
 class AuthorizationManagementClientConfiguration(Configuration):  # pylint: disable=too-many-instance-attributes
     """Configuration for AuthorizationManagementClient.
 
     Note that all parameters used to create this instance are saved as instance
     attributes.
 
     :param credential: Credential needed for the client to connect to Azure. Required.
-    :type credential: ~azure.core.credentials_async.AsyncTokenCredential
+    :type credential: ~azure.core.credentials.TokenCredential
     :param subscription_id: The ID of the target subscription. Required.
     :type subscription_id: str
-    :keyword api_version: Api Version. Default value is "2020-04-01-preview". Note that overriding
+    :keyword api_version: Api Version. Default value is "2022-05-01-preview". Note that overriding
      this default value may result in unsupported behavior.
     :paramtype api_version: str
     """
 
-    def __init__(self, credential: "AsyncTokenCredential", subscription_id: str, **kwargs: Any) -> None:
+    def __init__(self, credential: "TokenCredential", subscription_id: str, **kwargs: Any) -> None:
         super(AuthorizationManagementClientConfiguration, self).__init__(**kwargs)
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop("api_version", "2020-04-01-preview")
+        api_version: str = kwargs.pop("api_version", "2022-05-01-preview")
 
         if credential is None:
             raise ValueError("Parameter 'credential' must not be None.")
         if subscription_id is None:
             raise ValueError("Parameter 'subscription_id' must not be None.")
 
         self.credential = credential
@@ -58,15 +52,15 @@
 
     def _configure(self, **kwargs: Any) -> None:
         self.user_agent_policy = kwargs.get("user_agent_policy") or policies.UserAgentPolicy(**kwargs)
         self.headers_policy = kwargs.get("headers_policy") or policies.HeadersPolicy(**kwargs)
         self.proxy_policy = kwargs.get("proxy_policy") or policies.ProxyPolicy(**kwargs)
         self.logging_policy = kwargs.get("logging_policy") or policies.NetworkTraceLoggingPolicy(**kwargs)
         self.http_logging_policy = kwargs.get("http_logging_policy") or ARMHttpLoggingPolicy(**kwargs)
-        self.retry_policy = kwargs.get("retry_policy") or policies.AsyncRetryPolicy(**kwargs)
+        self.retry_policy = kwargs.get("retry_policy") or policies.RetryPolicy(**kwargs)
         self.custom_hook_policy = kwargs.get("custom_hook_policy") or policies.CustomHookPolicy(**kwargs)
-        self.redirect_policy = kwargs.get("redirect_policy") or policies.AsyncRedirectPolicy(**kwargs)
+        self.redirect_policy = kwargs.get("redirect_policy") or policies.RedirectPolicy(**kwargs)
         self.authentication_policy = kwargs.get("authentication_policy")
         if self.credential and not self.authentication_policy:
-            self.authentication_policy = AsyncARMChallengeAuthenticationPolicy(
+            self.authentication_policy = ARMChallengeAuthenticationPolicy(
                 self.credential, *self.credential_scopes, **kwargs
             )
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/aio/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_role_assignments_operations.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_role_assignments_operations.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 # coding=utf-8
 # --------------------------------------------------------------------------
 # Copyright (c) Microsoft Corporation. All rights reserved.
 # Licensed under the MIT License. See License.txt in the project root for license information.
 # Code generated by Microsoft (R) AutoRest Code Generator.
 # Changes may cause incorrect behavior and will be lost if the code is regenerated.
 # --------------------------------------------------------------------------
-import sys
+from io import IOBase
 from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, overload
 import urllib.parse
 
 from azure.core.async_paging import AsyncItemPaged, AsyncList
 from azure.core.exceptions import (
     ClientAuthenticationError,
     HttpResponseError,
@@ -38,18 +38,14 @@
     build_get_request,
     build_list_for_resource_group_request,
     build_list_for_resource_request,
     build_list_for_scope_request,
     build_list_request,
 )
 
-if sys.version_info >= (3, 8):
-    from typing import Literal  # pylint: disable=no-name-in-module, ungrouped-imports
-else:
-    from typing_extensions import Literal  # type: ignore  # pylint: disable=ungrouped-imports
 T = TypeVar("T")
 ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]
 
 
 class RoleAssignmentsOperations:
     """
     .. warning::
@@ -64,14 +60,15 @@
 
     def __init__(self, *args, **kwargs) -> None:
         input_args = list(args)
         self._client = input_args.pop(0) if input_args else kwargs.pop("client")
         self._config = input_args.pop(0) if input_args else kwargs.pop("config")
         self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
         self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")
+        self._api_version = input_args.pop(0) if input_args else kwargs.pop("api_version")
 
     @distributed_trace
     def list_for_resource(
         self,
         resource_group_name: str,
         resource_provider_namespace: str,
         parent_resource_path: str,
@@ -105,16 +102,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_04_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -166,16 +163,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -208,16 +206,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_04_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -265,16 +263,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -311,16 +310,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
@@ -328,16 +327,17 @@
             template_url=self.delete.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -460,24 +460,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
@@ -488,16 +488,17 @@
             template_url=self.create.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -536,16 +537,16 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_request(
             scope=scope,
             role_assignment_name=role_assignment_name,
             tenant_id=tenant_id,
@@ -553,16 +554,17 @@
             template_url=self.get.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -599,32 +601,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[Optional[_models.RoleAssignment]] = kwargs.pop("cls", None)
 
         request = build_delete_by_id_request(
             role_id=role_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.delete_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200, 204]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -712,24 +715,24 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         content_type: Optional[str] = kwargs.pop("content_type", _headers.pop("Content-Type", None))
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         content_type = content_type or "application/json"
         _json = None
         _content = None
-        if isinstance(parameters, (IO, bytes)):
+        if isinstance(parameters, (IOBase, bytes)):
             _content = parameters
         else:
             _json = self._serialize.body(parameters, "RoleAssignmentCreateParameters")
 
         request = build_create_by_id_request(
             role_id=role_id,
             api_version=api_version,
@@ -739,16 +742,17 @@
             template_url=self.create_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [201]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -783,32 +787,33 @@
             304: ResourceNotModifiedError,
         }
         error_map.update(kwargs.pop("error_map", {}) or {})
 
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignment] = kwargs.pop("cls", None)
 
         request = build_get_by_id_request(
             role_id=role_id,
             tenant_id=tenant_id,
             api_version=api_version,
             template_url=self.get_by_id.metadata["url"],
             headers=_headers,
             params=_params,
         )
         request = _convert_request(request)
         request.url = self._client.format_url(request.url)
 
+        _stream = False
         pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-            request, stream=False, **kwargs
+            request, stream=_stream, **kwargs
         )
 
         response = pipeline_response.http_response
 
         if response.status_code not in [200]:
             map_error(status_code=response.status_code, response=response, error_map=error_map)
             error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
@@ -840,16 +845,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_04_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -896,16 +901,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
@@ -935,16 +941,16 @@
         :rtype:
          ~azure.core.async_paging.AsyncItemPaged[~azure.mgmt.authorization.v2020_04_01_preview.models.RoleAssignment]
         :raises ~azure.core.exceptions.HttpResponseError:
         """
         _headers = kwargs.pop("headers", {}) or {}
         _params = case_insensitive_dict(kwargs.pop("params", {}) or {})
 
-        api_version: Literal["2020-04-01-preview"] = kwargs.pop(
-            "api_version", _params.pop("api-version", "2020-04-01-preview")
+        api_version: str = kwargs.pop(
+            "api_version", _params.pop("api-version", self._api_version or "2020-04-01-preview")
         )
         cls: ClsType[_models.RoleAssignmentListResult] = kwargs.pop("cls", None)
 
         error_map = {
             401: ClientAuthenticationError,
             404: ResourceNotFoundError,
             409: ResourceExistsError,
@@ -991,16 +997,17 @@
             if cls:
                 list_of_elem = cls(list_of_elem)  # type: ignore
             return deserialized.next_link or None, AsyncList(list_of_elem)
 
         async def get_next(next_link=None):
             request = prepare_request(next_link)
 
+            _stream = False
             pipeline_response: PipelineResponse = await self._client._pipeline.run(  # pylint: disable=protected-access
-                request, stream=False, **kwargs
+                request, stream=_stream, **kwargs
             )
             response = pipeline_response.http_response
 
             if response.status_code not in [200]:
                 map_error(status_code=response.status_code, response=response, error_map=error_map)
                 error = self._deserialize.failsafe_deserialize(_models.ErrorResponse, pipeline_response)
                 raise HttpResponseError(response=response, model=error, error_format=ARMErrorFormat)
```

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/operations/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/aio/operations/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/operations/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/_models_py3.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/_models_py3.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/__init__.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/__init__.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/_patch.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2018_01_01_preview/models/_patch.py`

 * *Files identical despite different names*

## Comparing `azure-mgmt-authorization-3.1.0b1/azure/mgmt/authorization/v2020_04_01_preview/models/_authorization_management_client_enums.py` & `azure-mgmt-authorization-4.0.0/azure/mgmt/authorization/v2020_04_01_preview/models/_authorization_management_client_enums.py`

 * *Files identical despite different names*

